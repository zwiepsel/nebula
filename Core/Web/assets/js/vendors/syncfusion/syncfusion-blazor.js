/*!
 * filename: syncfusion-blazor.js
 *     version : 19.3.44
 *     Copyright Syncfusion Inc. 2001 - 2021. All rights reserved.
 *     Use of this code is subject to the terms of our license.
 *     A copy of the current license can be obtained at any time by e-mailing
 *     licensing@syncfusion.com. Any infringement will be prosecuted under
 *     applicable laws.
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./crg-resources/19.3.44/crg/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./crg-resources/19.3.44/crg/bundle.js":
/*!*********************************************!*\
  !*** ./crg-resources/19.3.44/crg/bundle.js ***!
  \*********************************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _resources_19_3_44_Scripts_common_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/common/base.js */ "./resources/19.3.44/Scripts/common/base.js");
/* harmony import */ var _resources_19_3_44_Scripts_common_base_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_common_base_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resources_19_3_44_Scripts_common_syncfusion_blazor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/common/syncfusion-blazor.js */ "./resources/19.3.44/Scripts/common/syncfusion-blazor.js");
/* harmony import */ var _resources_19_3_44_Scripts_common_syncfusion_blazor_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_common_syncfusion_blazor_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_textbox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-textbox.js */ "./resources/19.3.44/Scripts/sf-textbox.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_textbox_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_textbox_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_calendarbase_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-calendarbase.js */ "./resources/19.3.44/Scripts/sf-calendarbase.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_calendarbase_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_calendarbase_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _resources_19_3_44_Scripts_popupsbase_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/popupsbase.js */ "./resources/19.3.44/Scripts/popupsbase.js");
/* harmony import */ var _resources_19_3_44_Scripts_popupsbase_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_popupsbase_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _resources_19_3_44_Scripts_popup_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/popup.js */ "./resources/19.3.44/Scripts/popup.js");
/* harmony import */ var _resources_19_3_44_Scripts_popup_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_popup_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_datepicker_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-datepicker.js */ "./resources/19.3.44/Scripts/sf-datepicker.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_datepicker_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_datepicker_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_daterangepicker_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-daterangepicker.js */ "./resources/19.3.44/Scripts/sf-daterangepicker.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_daterangepicker_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_daterangepicker_js__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_timepicker_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-timepicker.js */ "./resources/19.3.44/Scripts/sf-timepicker.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_timepicker_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_timepicker_js__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_spinner_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-spinner.js */ "./resources/19.3.44/Scripts/sf-spinner.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_spinner_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_spinner_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_dropdownlist_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-dropdownlist.js */ "./resources/19.3.44/Scripts/sf-dropdownlist.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_dropdownlist_js__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_dropdownlist_js__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_multiselect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-multiselect.js */ "./resources/19.3.44/Scripts/sf-multiselect.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_multiselect_js__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_multiselect_js__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _resources_19_3_44_Scripts_splitbuttonsbase_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/splitbuttonsbase.js */ "./resources/19.3.44/Scripts/splitbuttonsbase.js");
/* harmony import */ var _resources_19_3_44_Scripts_splitbuttonsbase_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_splitbuttonsbase_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_drop_down_button_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-drop-down-button.js */ "./resources/19.3.44/Scripts/sf-drop-down-button.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_drop_down_button_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_drop_down_button_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_grid_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-grid.js */ "./resources/19.3.44/Scripts/sf-grid.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_grid_js__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_grid_js__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _resources_19_3_44_Scripts_navigationsbase_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/navigationsbase.js */ "./resources/19.3.44/Scripts/navigationsbase.js");
/* harmony import */ var _resources_19_3_44_Scripts_navigationsbase_js__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_navigationsbase_js__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_contextmenu_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-contextmenu.js */ "./resources/19.3.44/Scripts/sf-contextmenu.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_contextmenu_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_contextmenu_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_toolbar_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-toolbar.js */ "./resources/19.3.44/Scripts/sf-toolbar.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_toolbar_js__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_toolbar_js__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_numerictextbox_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-numerictextbox.js */ "./resources/19.3.44/Scripts/sf-numerictextbox.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_numerictextbox_js__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_numerictextbox_js__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_dialog_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-dialog.js */ "./resources/19.3.44/Scripts/sf-dialog.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_dialog_js__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_dialog_js__WEBPACK_IMPORTED_MODULE_19__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_accordion_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-accordion.js */ "./resources/19.3.44/Scripts/sf-accordion.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_accordion_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_accordion_js__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_tab_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-tab.js */ "./resources/19.3.44/Scripts/sf-tab.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_tab_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_tab_js__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _resources_19_3_44_Scripts_svgbase_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/svgbase.js */ "./resources/19.3.44/Scripts/svgbase.js");
/* harmony import */ var _resources_19_3_44_Scripts_svgbase_js__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_svgbase_js__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_svg_export_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-svg-export.js */ "./resources/19.3.44/Scripts/sf-svg-export.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_svg_export_js__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_svg_export_js__WEBPACK_IMPORTED_MODULE_23__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_chart_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-chart.js */ "./resources/19.3.44/Scripts/sf-chart.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_chart_js__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_chart_js__WEBPACK_IMPORTED_MODULE_24__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_accumulation_chart_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-accumulation-chart.js */ "./resources/19.3.44/Scripts/sf-accumulation-chart.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_accumulation_chart_js__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_accumulation_chart_js__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_progressbar_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-progressbar.js */ "./resources/19.3.44/Scripts/sf-progressbar.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_progressbar_js__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_progressbar_js__WEBPACK_IMPORTED_MODULE_26__);
/* harmony import */ var _resources_19_3_44_Scripts_spinner_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/spinner.js */ "./resources/19.3.44/Scripts/spinner.js");
/* harmony import */ var _resources_19_3_44_Scripts_spinner_js__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_spinner_js__WEBPACK_IMPORTED_MODULE_27__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_treeview_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-treeview.js */ "./resources/19.3.44/Scripts/sf-treeview.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_treeview_js__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_treeview_js__WEBPACK_IMPORTED_MODULE_28__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_uploader_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-uploader.js */ "./resources/19.3.44/Scripts/sf-uploader.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_uploader_js__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_uploader_js__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_splitter_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-splitter.js */ "./resources/19.3.44/Scripts/sf-splitter.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_splitter_js__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_splitter_js__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_filemanager_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-filemanager.js */ "./resources/19.3.44/Scripts/sf-filemanager.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_filemanager_js__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_filemanager_js__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_tooltip_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-tooltip.js */ "./resources/19.3.44/Scripts/sf-tooltip.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_tooltip_js__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_tooltip_js__WEBPACK_IMPORTED_MODULE_32__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_colorpicker_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-colorpicker.js */ "./resources/19.3.44/Scripts/sf-colorpicker.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_colorpicker_js__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_colorpicker_js__WEBPACK_IMPORTED_MODULE_33__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_richtexteditor_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-richtexteditor.js */ "./resources/19.3.44/Scripts/sf-richtexteditor.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_richtexteditor_js__WEBPACK_IMPORTED_MODULE_34___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_richtexteditor_js__WEBPACK_IMPORTED_MODULE_34__);
/* harmony import */ var _resources_19_3_44_Scripts_sf_inplaceeditor_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./../../../resources/19.3.44/Scripts/sf-inplaceeditor.js */ "./resources/19.3.44/Scripts/sf-inplaceeditor.js");
/* harmony import */ var _resources_19_3_44_Scripts_sf_inplaceeditor_js__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/__webpack_require__.n(_resources_19_3_44_Scripts_sf_inplaceeditor_js__WEBPACK_IMPORTED_MODULE_35__);






































/***/ }),

/***/ "./resources/19.3.44/Scripts/common/base.js":
/*!**************************************************!*\
  !*** ./resources/19.3.44/Scripts/common/base.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sf = window.sf || {};
window.sf.base = (function (exports) {
'use strict';

var instances = 'ej2_instances';
var uid = 0;
var isBlazorPlatform = false;
/**
 * Function to check whether the platform is blazor or not.
 *
 * @returns {void} result
 * @private
 */
function disableBlazorMode() {
    isBlazorPlatform = false;
}
/**
 * Create Instance from constructor function with desired parameters.
 *
 * @param {Function} classFunction - Class function to which need to create instance
 * @param {any[]} params - Parameters need to passed while creating instance
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function createInstance(classFunction, params) {
    var arrayParam = params;
    arrayParam.unshift(undefined);
    return new (Function.prototype.bind.apply(classFunction, arrayParam));
}
/**
 * To run a callback function immediately after the browser has completed other operations.
 *
 * @param {Function} handler - callback function to be triggered.
 * @returns {Function} ?
 * @private
 */
function setImmediate(handler) {
    var unbind;
    // eslint-disable-next-line
    var num = new Uint16Array(5);
    var intCrypto = window.msCrypto || window.crypto;
    intCrypto.getRandomValues(num);
    var secret = 'ej2' + combineArray(num);
    // eslint-disable-next-line
    var messageHandler = function (event) {
        if (event.source === window && typeof event.data === 'string' && event.data.length <= 32 && event.data === secret) {
            handler();
            unbind();
        }
    };
    window.addEventListener('message', messageHandler, false);
    window.postMessage(secret, '*');
    return unbind = function () {
        window.removeEventListener('message', messageHandler);
        handler = messageHandler = secret = undefined;
    };
}
/**
 * To get nameSpace value from the desired object.
 *
 * @param {string} nameSpace - String value to the get the inner object
 * @param {any} obj - Object to get the inner object value.
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function getValue(nameSpace, obj) {
    // eslint-disable-next-line
    var value = obj;
    var splits = nameSpace.replace(/\[/g, '.').replace(/\]/g, '').split('.');
    for (var i = 0; i < splits.length && !isUndefined(value); i++) {
        value = value[splits[i]];
    }
    return value;
}
/**
 * To set value for the nameSpace in desired object.
 *
 * @param {string} nameSpace - String value to the get the inner object
 * @param {any} value - Value that you need to set.
 * @param {any} obj - Object to get the inner object value.
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function setValue(nameSpace, value, obj) {
    var keys = nameSpace.replace(/\[/g, '.').replace(/\]/g, '').split('.');
    // eslint-disable-next-line
    var start = obj || {};
    // eslint-disable-next-line
    var fromObj = start;
    var i;
    var length = keys.length;
    var key;
    for (i = 0; i < length; i++) {
        key = keys[i];
        if (i + 1 === length) {
            fromObj[key] = value === undefined ? {} : value;
        }
        else if (isNullOrUndefined(fromObj[key])) {
            fromObj[key] = {};
        }
        fromObj = fromObj[key];
    }
    return start;
}
/**
 * Delete an item from Object
 *
 * @param {any} obj - Object in which we need to delete an item.
 * @param {string} key - String value to the get the inner object
 * @returns {void} ?
 * @private
 */
// eslint-disable-next-line
function deleteObject(obj, key) {
    delete obj[key];
}
/**
 * Check weather the given argument is only object.
 *
 * @param {any} obj - Object which is need to check.
 * @returns {boolean} ?
 * @private
 */
// eslint-disable-next-line
function isObject(obj) {
    var objCon = {};
    return (!isNullOrUndefined(obj) && obj.constructor === objCon.constructor);
}
/**
 * To get enum value by giving the string.
 *
 * @param {any} enumObject - Enum object.
 * @param {string} enumValue - Enum value to be searched
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function getEnumValue(enumObject, enumValue) {
    // eslint-disable-next-line
    return enumObject[enumValue];
}
/**
 * Merge the source object into destination object.
 *
 * @param {any} source - source object which is going to merge with destination object
 * @param {any} destination - object need to be merged
 * @returns {void} ?
 * @private
 */
function merge(source, destination) {
    if (!isNullOrUndefined(destination)) {
        var temrObj = source;
        var tempProp = destination;
        var keys = Object.keys(destination);
        var deepmerge = 'deepMerge';
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (!isNullOrUndefined(temrObj[deepmerge]) && (temrObj[deepmerge].indexOf(key) !== -1) &&
                (isObject(tempProp[key]) || Array.isArray(tempProp[key]))) {
                extend(temrObj[key], temrObj[key], tempProp[key], true);
            }
            else {
                temrObj[key] = tempProp[key];
            }
        }
    }
}
/**
 * Extend the two object with newer one.
 *
 * @param {any} copied - Resultant object after merged
 * @param {Object} first - First object need to merge
 * @param {Object} second - Second object need to merge
 * @param {boolean} deep ?
 * @returns {Object} ?
 * @private
 */
function extend(copied, first, second, deep) {
    var result = copied && typeof copied === 'object' ? copied : {};
    var length = arguments.length;
    if (deep) {
        length = length - 1;
    }
    var _loop_1 = function (i) {
        // eslint-disable-next-line
        if (!arguments_1[i]) {
            return "continue";
        }
        // eslint-disable-next-line
        var obj1 = arguments_1[i];
        Object.keys(obj1).forEach(function (key) {
            var src = result[key];
            var copy = obj1[key];
            var clone;
            var isArrayChanged = Array.isArray(copy) && Array.isArray(src) && (copy.length !== src.length);
            // eslint-disable-next-line
            var blazorEventExtend = isBlazor() ? (!(src instanceof Event) && !isArrayChanged) : true;
            if (deep && blazorEventExtend && (isObject(copy) || Array.isArray(copy))) {
                if (isObject(copy)) {
                    clone = src ? src : {};
                    // eslint-disable-next-line
                    if (Array.isArray(clone) && clone.hasOwnProperty('isComplexArray')) {
                        extend(clone, {}, copy, deep);
                    }
                    else {
                        result[key] = extend(clone, {}, copy, deep);
                    }
                }
                else {
                    /* istanbul ignore next */
                    clone = isBlazor() ? src && Object.keys(copy).length : src ? src : [];
                    result[key] = extend([], clone, copy, deep);
                }
            }
            else {
                result[key] = copy;
            }
        });
    };
    var arguments_1 = arguments;
    for (var i = 1; i < length; i++) {
        _loop_1(i);
    }
    return result;
}
/**
 * To check whether the object is null or undefined.
 *
 * @param {Object} value - To check the object is null or undefined
 * @returns {boolean} ?
 * @private
 */
function isNullOrUndefined(value) {
    return value === undefined || value === null;
}
/**
 * To check whether the object is undefined.
 *
 * @param {Object} value - To check the object is undefined
 * @returns {boolean} ?
 * @private
 */
function isUndefined(value) {
    return ('undefined' === typeof value);
}
/**
 * To return the generated unique name
 *
 * @param {string} definedName - To concatenate the unique id to provided name
 * @returns {string} ?
 * @private
 */
function getUniqueID(definedName) {
    return definedName + '_' + uid++;
}
/**
 * It limits the rate at which a function can fire. The function will fire only once every provided second instead of as quickly.
 *
 * @param {Function} eventFunction - Specifies the function to run when the event occurs
 * @param {number} delay - A number that specifies the milliseconds for function delay call option
 * @returns {Function} ?
 * @private
 */
function debounce(eventFunction, delay) {
    // eslint-disable-next-line
    var out;
    return function () {
        var _this = this;
        // eslint-disable-next-line
        var args = arguments;
        var later = function () {
            out = null;
            return eventFunction.apply(_this, args);
        };
        clearTimeout(out);
        out = setTimeout(later, delay);
    };
}
/**
 * To convert the object to string for query url
 *
 * @param  {Object} data ?
 * @returns {string} ?
 * @private
 */
// eslint-disable-next-line
function queryParams(data) {
    var array = [];
    var keys = Object.keys(data);
    for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
        var key = keys_2[_i];
        array.push(encodeURIComponent(key) + '=' + encodeURIComponent('' + data[key]));
    }
    return array.join('&');
}
/**
 * To check whether the given array contains object.
 *
 * @param {any} value - Specifies the T type array to be checked.
 * @returns {boolean} ?
 * @private
 */
function isObjectArray(value) {
    var parser = Object.prototype.toString;
    if (parser.call(value) === '[object Array]') {
        if (parser.call(value[0]) === '[object Object]') {
            return true;
        }
    }
    return false;
}
/**
 * To check whether the  child element is descendant to parent element or parent and child are same element.
 *
 * @param {Element} child - Specifies the child element to compare with parent.
 * @param {Element} parent - Specifies the parent element.
 * @returns {boolean} ?
 * @private
 */
function compareElementParent(child, parent) {
    var node = child;
    if (node === parent) {
        return true;
    }
    else if (node === document || !node) {
        return false;
    }
    else {
        return compareElementParent(node.parentNode, parent);
    }
}
/**
 * To throw custom error message.
 *
 * @param {string} message - Specifies the error message to be thrown.
 * @returns {void} ?
 * @private
 */
function throwError(message) {
    try {
        throw new Error(message);
    }
    catch (e) {
        // eslint-disable-next-line
        throw e.message + '\n' + e.stack;
    }
}
/**
 * This function is used to print given element
 *
 * @param {Element} element - Specifies the print content element.
 * @param {Window} printWindow - Specifies the print window.
 * @returns {Window} ?
 * @private
 */
function print(element, printWindow) {
    var div = document.createElement('div');
    var links = [].slice.call(document.getElementsByTagName('head')[0].querySelectorAll('base, link, style'));
    var reference = '';
    if (isNullOrUndefined(printWindow)) {
        printWindow = window.open('', 'print', 'height=452,width=1024,tabbar=no');
    }
    div.appendChild(element.cloneNode(true));
    for (var i = 0, len = links.length; i < len; i++) {
        reference += links[i].outerHTML;
    }
    printWindow.document.write('<!DOCTYPE html> <html><head>' + reference + '</head><body>' + div.innerHTML +
        '<script> (function() { window.ready = true; })(); </script>' + '</body></html>');
    printWindow.document.close();
    printWindow.focus();
    // eslint-disable-next-line
    var interval = setInterval(function () {
        if (printWindow.ready) {
            printWindow.print();
            printWindow.close();
            clearInterval(interval);
        }
    }, 500);
    return printWindow;
}
/**
 * Function to normalize the units applied to the element.
 *
 * @param {number|string} value ?
 * @returns {string} result
 * @private
 */
function formatUnit(value) {
    var result = value + '';
    if (result === 'auto' || result.indexOf('%') !== -1 || result.indexOf('px') !== -1) {
        return result;
    }
    return result + 'px';
}
/**
 * Function to check whether the platform is blazor or not.
 *
 * @returns {void} result
 * @private
 */
function enableBlazorMode() {
    isBlazorPlatform = true;
}
/**
 * Function to check whether the platform is blazor or not.
 *
 * @returns {boolean} result
 * @private
 */
function isBlazor() {
    return isBlazorPlatform;
}
/**
 * Function to convert xPath to DOM element in blazor platform
 *
 * @returns {HTMLElement} result
 * @param {HTMLElement | object} element ?
 * @private
 */
function getElement(element) {
    var xPath = 'xPath';
    if (!(element instanceof Node) && isBlazor() && !isNullOrUndefined(element[xPath])) {
        return document.evaluate(element[xPath], document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    }
    return element;
}
/**
 * Function to fetch the Instances of a HTML element for the given component.
 *
 * @param {string | HTMLElement} element ?
 * @param {any} component ?
 * @returns {Object} ?
 * @private
 */
// eslint-disable-next-line
function getInstance(element, component) {
    // eslint-disable-next-line
    var elem = (typeof (element) === 'string') ? document.querySelector(element) : element;
    if (elem[instances]) {
        for (var _i = 0, _a = elem[instances]; _i < _a.length; _i++) {
            var inst = _a[_i];
            if (inst instanceof component) {
                return inst;
            }
        }
    }
    return null;
}
/**
 * Function to add instances for the given element.
 *
 * @param {string | HTMLElement} element ?
 * @param {Object} instance ?
 * @returns {void} ?
 * @private
 */
function addInstance(element, instance) {
    // eslint-disable-next-line
    var elem = (typeof (element) === 'string') ? document.querySelector(element) : element;
    if (elem[instances]) {
        elem[instances].push(instance);
    }
    else {
        elem[instances] = [instance];
    }
}
/**
 * Function to generate the unique id.
 *
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function uniqueID() {
    if ((typeof window) === 'undefined') {
        return;
    }
    // eslint-disable-next-line
    var num = new Uint16Array(5);
    var intCrypto = window.msCrypto || window.crypto;
    return intCrypto.getRandomValues(num);
}
/**
 *
 * @param {Int16Array} num ?
 * @returns {string} ?
 */
function combineArray(num) {
    var ret = '';
    for (var i = 0; i < 5; i++) {
        ret += (i ? ',' : '') + num[i];
    }
    return ret;
}

/**
 * Parser
 */
var defaultNumberingSystem = {
    'latn': {
        '_digits': '0123456789',
        '_type': 'numeric'
    }
};
var defaultNumberSymbols = {
    'decimal': '.',
    'group': ',',
    'percentSign': '%',
    'plusSign': '+',
    'minusSign': '-',
    'infinity': '∞',
    'nan': 'NaN',
    'exponential': 'E'
};
var latnNumberSystem = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
/**
 * Interface for parser base
 *
 * @private
 */
var ParserBase = /** @class */ (function () {
    function ParserBase() {
    }
    /**
     * Returns the cldr object for the culture specifies
     *
     * @param {Object} obj - Specifies the object from which culture object to be acquired.
     * @param {string} cName - Specifies the culture name.
     * @returns {Object} ?
     */
    ParserBase.getMainObject = function (obj, cName) {
        var value = isBlazor() ? cName : 'main.' + cName;
        return getValue(value, obj);
    };
    /**
     * Returns the numbering system object from given cldr data.
     *
     * @param {Object} obj - Specifies the object from which number system is acquired.
     * @returns {Object} ?
     */
    ParserBase.getNumberingSystem = function (obj) {
        return getValue('supplemental.numberingSystems', obj) || this.numberingSystems;
    };
    /**
     * Returns the reverse of given object keys or keys specified.
     *
     * @param {Object} prop - Specifies the object to be reversed.
     * @param {number[]} keys - Optional parameter specifies the custom keyList for reversal.
     * @returns {Object} ?
     */
    ParserBase.reverseObject = function (prop, keys) {
        var propKeys = keys || Object.keys(prop);
        var res = {};
        for (var _i = 0, propKeys_1 = propKeys; _i < propKeys_1.length; _i++) {
            var key = propKeys_1[_i];
            // eslint-disable-next-line
            if (!res.hasOwnProperty(prop[key])) {
                // eslint-disable-next-line
                res[prop[key]] = key;
            }
        }
        return res;
    };
    /**
     * Returns the symbol regex by skipping the escape sequence.
     *
     * @param {string[]} props - Specifies the array values to be skipped.
     * @returns {RegExp} ?
     */
    ParserBase.getSymbolRegex = function (props) {
        var regexStr = props.map(function (str) {
            return str.replace(/([.*+?^=!:${}()|[\]/\\])/g, '\\$1');
        }).join('|');
        return new RegExp(regexStr, 'g');
    };
    /**
     *
     * @param {Object} prop ?
     * @returns {Object} ?
     */
    ParserBase.getSymbolMatch = function (prop) {
        var matchKeys = Object.keys(defaultNumberSymbols);
        var ret = {};
        for (var _i = 0, matchKeys_1 = matchKeys; _i < matchKeys_1.length; _i++) {
            var key = matchKeys_1[_i];
            // eslint-disable-next-line
            ret[prop[key]] = defaultNumberSymbols[key];
        }
        return ret;
    };
    /**
     * Returns regex string for provided value
     *
     * @param {string} val ?
     * @returns {string} ?
     */
    ParserBase.constructRegex = function (val) {
        var len = val.length;
        var ret = '';
        for (var i = 0; i < len; i++) {
            if (i !== len - 1) {
                ret += val[i] + '|';
            }
            else {
                ret += val[i];
            }
        }
        return ret;
    };
    /**
     * Returns the replaced value of matching regex and obj mapper.
     *
     * @param {string} value - Specifies the  values to be replaced.
     * @param {RegExp} regex - Specifies the  regex to search.
     * @param {Object} obj - Specifies the  object matcher to be replace value parts.
     * @returns {string} ?
     */
    ParserBase.convertValueParts = function (value, regex, obj) {
        return value.replace(regex, function (str) {
            // eslint-disable-next-line
            return obj[str];
        });
    };
    /**
     * Returns default numbering system object for formatting from cldr data
     *
     * @param {Object} obj ?
     * @returns {NumericObject} ?
     */
    ParserBase.getDefaultNumberingSystem = function (obj) {
        var ret = {};
        ret.obj = getValue('numbers', obj);
        ret.nSystem = getValue('defaultNumberingSystem', ret.obj);
        return ret;
    };
    /**
     * Returns the replaced value of matching regex and obj mapper.
     *
     * @param {Object} curObj ?
     * @param {Object} numberSystem ?
     * @param {boolean} needSymbols ?
     * @param {boolean} blazorMode ?
     * @returns {Object} ?
     */
    ParserBase.getCurrentNumericOptions = function (curObj, numberSystem, needSymbols, blazorMode) {
        var ret = {};
        var cur = this.getDefaultNumberingSystem(curObj);
        if (!isUndefined(cur.nSystem) || blazorMode) {
            var digits = blazorMode ? getValue('obj.mapperDigits', cur) : getValue(cur.nSystem + '._digits', numberSystem);
            if (!isUndefined(digits)) {
                ret.numericPair = this.reverseObject(digits, latnNumberSystem);
                ret.numberParseRegex = new RegExp(this.constructRegex(digits), 'g');
                ret.numericRegex = '[' + digits[0] + '-' + digits[9] + ']';
                if (needSymbols) {
                    ret.numericRegex = digits[0] + '-' + digits[9];
                    ret.symbolNumberSystem = getValue(blazorMode ? 'numberSymbols' : 'symbols-numberSystem-' + cur.nSystem, cur.obj);
                    ret.symbolMatch = this.getSymbolMatch(ret.symbolNumberSystem);
                    ret.numberSystem = cur.nSystem;
                }
            }
        }
        return ret;
    };
    /**
     * Returns number mapper object for the provided cldr data
     *
     * @param {Object} curObj ?
     * @param {Object} numberSystem ?
     * @param {boolean} isNumber ?
     * @returns {NumberMapper} ?
     */
    // eslint-disable-next-line
    ParserBase.getNumberMapper = function (curObj, numberSystem, isNumber) {
        var ret = { mapper: {} };
        var cur = this.getDefaultNumberingSystem(curObj);
        if (!isUndefined(cur.nSystem)) {
            ret.numberSystem = cur.nSystem;
            ret.numberSymbols = getValue('symbols-numberSystem-' + cur.nSystem, cur.obj);
            ret.timeSeparator = getValue('timeSeparator', ret.numberSymbols);
            var digits = getValue(cur.nSystem + '._digits', numberSystem);
            if (!isUndefined(digits)) {
                for (var _i = 0, latnNumberSystem_1 = latnNumberSystem; _i < latnNumberSystem_1.length; _i++) {
                    var i = latnNumberSystem_1[_i];
                    // eslint-disable-next-line
                    ret.mapper[i] = digits[i];
                }
            }
        }
        return ret;
    };
    ParserBase.nPair = 'numericPair';
    ParserBase.nRegex = 'numericRegex';
    ParserBase.numberingSystems = defaultNumberingSystem;
    return ParserBase;
}());
/**
 * @private
 */
var blazorCurrencyData = {
    'DJF': 'Fdj',
    'ERN': 'Nfk',
    'ETB': 'Br',
    'NAD': '$',
    'ZAR': 'R',
    'XAF': 'FCFA',
    'GHS': 'GH₵',
    'XDR': 'XDR',
    'AED': 'د.إ.‏',
    'BHD': 'د.ب.‏',
    'DZD': 'د.ج.‏',
    'EGP': 'ج.م.‏',
    'ILS': '₪',
    'IQD': 'د.ع.‏',
    'JOD': 'د.ا.‏',
    'KMF': 'CF',
    'KWD': 'د.ك.‏',
    'LBP': 'ل.ل.‏',
    'LYD': 'د.ل.‏',
    'MAD': 'د.م.‏',
    'MRU': 'أ.م.',
    'OMR': 'ر.ع.‏',
    'QAR': 'ر.ق.‏',
    'SAR': 'ر.س.‏',
    'SDG': 'ج.س.',
    'SOS': 'S',
    'SSP': '£',
    'SYP': 'ل.س.‏',
    'TND': 'د.ت.‏',
    'YER': 'ر.ي.‏',
    'CLP': '$',
    'INR': '₹',
    'TZS': 'TSh',
    'EUR': '€',
    'AZN': '₼',
    'RUB': '₽',
    'BYN': 'Br',
    'ZMW': 'K',
    'BGN': 'лв.',
    'NGN': '₦',
    'XOF': 'CFA',
    'BDT': '৳',
    'CNY': '¥',
    'BAM': 'КМ',
    'UGX': 'USh',
    'USD': '$',
    'CZK': 'Kč',
    'GBP': '£',
    'DKK': 'kr.',
    'KES': 'Ksh',
    'CHF': 'CHF',
    'MVR': 'ރ.',
    'BTN': 'Nu.',
    'XCD': 'EC$',
    'AUD': '$',
    'BBD': '$',
    'BIF': 'FBu',
    'BMD': '$',
    'BSD': '$',
    'BWP': 'P',
    'BZD': '$',
    'CAD': '$',
    'NZD': '$',
    'FJD': '$',
    'FKP': '£',
    'GIP': '£',
    'GMD': 'D',
    'GYD': '$',
    'HKD': '$',
    'IDR': 'Rp',
    'JMD': '$',
    'KYD': '$',
    'LRD': '$',
    'MGA': 'Ar',
    'MOP': 'MOP$',
    'MUR': 'Rs',
    'MWK': 'MK',
    'MYR': 'RM',
    'PGK': 'K',
    'PHP': '₱',
    'PKR': 'Rs',
    'RWF': 'RF',
    'SBD': '$',
    'SCR': 'SR',
    'SEK': 'kr',
    'SGD': '$',
    'SHP': '£',
    'SLL': 'Le',
    'ANG': 'NAf.',
    'SZL': 'E',
    'TOP': 'T$',
    'TTD': '$',
    'VUV': 'VT',
    'WST': 'WS$',
    'ARS': '$',
    'BOB': 'Bs',
    'BRL': 'R$',
    'COP': '$',
    'CRC': '₡',
    'CUP': '$',
    'DOP': '$',
    'GTQ': 'Q',
    'HNL': 'L',
    'MXN': '$',
    'NIO': 'C$',
    'PAB': 'B/.',
    'PEN': 'S/',
    'PYG': '₲',
    'UYU': '$',
    'VES': 'Bs.S',
    'IRR': 'ريال',
    'GNF': 'FG',
    'CDF': 'FC',
    'HTG': 'G',
    'XPF': 'FCFP',
    'HRK': 'kn',
    'HUF': 'Ft',
    'AMD': '֏',
    'ISK': 'kr',
    'JPY': '¥',
    'GEL': '₾',
    'CVE': '​',
    'KZT': '₸',
    'KHR': '៛',
    'KPW': '₩',
    'KRW': '₩',
    'KGS': 'сом',
    'AOA': 'Kz',
    'LAK': '₭',
    'MZN': 'MTn',
    'MKD': 'ден',
    'MNT': '₮',
    'BND': '$',
    'MMK': 'K',
    'NOK': 'kr',
    'NPR': 'रु',
    'AWG': 'Afl.',
    'SRD': '$',
    'PLN': 'zł',
    'AFN': '؋',
    'STN': 'Db',
    'MDL': 'L',
    'RON': 'lei',
    'UAH': '₴',
    'LKR': 'රු.',
    'ALL': 'Lekë',
    'RSD': 'дин.',
    'TJS': 'смн',
    'THB': '฿',
    'TMT': 'm.',
    'TRY': '₺',
    'UZS': 'сўм',
    'VND': '₫',
    'TWD': 'NT$'
};
/**
 *
 * @param {string} currencyCode ?
 * @returns {string} ?
 */
function getBlazorCurrencySymbol(currencyCode) {
    return getValue(currencyCode || '', blazorCurrencyData);
}

/***
 * Hijri parser
 */
// eslint-disable-next-line

(function (HijriParser) {
    var dateCorrection = [28607, 28636, 28665, 28695, 28724, 28754, 28783, 28813, 28843, 28872, 28901, 28931, 28960, 28990,
        29019, 29049, 29078, 29108, 29137, 29167, 29196, 29226, 29255, 29285, 29315, 29345, 29375, 29404, 29434, 29463, 29492, 29522,
        29551, 29580, 29610, 29640, 29669, 29699, 29729, 29759, 29788, 29818, 29847, 29876, 29906, 29935, 29964, 29994, 30023, 30053,
        30082, 30112, 30141, 30171, 30200, 30230, 30259, 30289, 30318, 30348, 30378, 30408, 30437, 30467, 30496, 30526, 30555, 30585,
        30614, 30644, 30673, 30703, 30732, 30762, 30791, 30821, 30850, 30880, 30909, 30939, 30968, 30998, 31027, 31057, 31086, 31116,
        31145, 31175, 31204, 31234, 31263, 31293, 31322, 31352, 31381, 31411, 31441, 31471, 31500, 31530, 31559, 31589, 31618, 31648,
        31676, 31706, 31736, 31766, 31795, 31825, 31854, 31884, 31913, 31943, 31972, 32002, 32031, 32061, 32090, 32120, 32150, 32180,
        32209, 32239, 32268, 32298, 32327, 32357, 32386, 32416, 32445, 32475, 32504, 32534, 32563, 32593, 32622, 32652, 32681, 32711,
        32740, 32770, 32799, 32829, 32858, 32888, 32917, 32947, 32976, 33006, 33035, 33065, 33094, 33124, 33153, 33183, 33213, 33243,
        33272, 33302, 33331, 33361, 33390, 33420, 33450, 33479, 33509, 33539, 33568, 33598, 33627, 33657, 33686, 33716, 33745, 33775,
        33804, 33834, 33863, 33893, 33922, 33952, 33981, 34011, 34040, 34069, 34099, 34128, 34158, 34187, 34217, 34247, 34277, 34306,
        34336, 34365, 34395, 34424, 34454, 34483, 34512, 34542, 34571, 34601, 34631, 34660, 34690, 34719, 34749, 34778, 34808, 34837,
        34867, 34896, 34926, 34955, 34985, 35015, 35044, 35074, 35103, 35133, 35162, 35192, 35222, 35251, 35280, 35310, 35340, 35370,
        35399, 35429, 35458, 35488, 35517, 35547, 35576, 35605, 35635, 35665, 35694, 35723, 35753, 35782, 35811, 35841, 35871, 35901,
        35930, 35960, 35989, 36019, 36048, 36078, 36107, 36136, 36166, 36195, 36225, 36254, 36284, 36314, 36343, 36373, 36403, 36433,
        36462, 36492, 36521, 36551, 36580, 36610, 36639, 36669, 36698, 36728, 36757, 36786, 36816, 36845, 36875, 36904, 36934, 36963,
        36993, 37022, 37052, 37081, 37111, 37141, 37170, 37200, 37229, 37259, 37288, 37318, 37347, 37377, 37406, 37436, 37465, 37495,
        37524, 37554, 37584, 37613, 37643, 37672, 37701, 37731, 37760, 37790, 37819, 37849, 37878, 37908, 37938, 37967, 37997, 38027,
        38056, 38085, 38115, 38144, 38174, 38203, 38233, 38262, 38292, 38322, 38351, 38381, 38410, 38440, 38469, 38499, 38528, 38558,
        38587, 38617, 38646, 38676, 38705, 38735, 38764, 38794, 38823, 38853, 38882, 38912, 38941, 38971, 39001, 39030, 39059, 39089,
        39118, 39148, 39178, 39208, 39237, 39267, 39297, 39326, 39355, 39385, 39414, 39444, 39473, 39503, 39532, 39562, 39592, 39621,
        39650, 39680, 39709, 39739, 39768, 39798, 39827, 39857, 39886, 39916, 39946, 39975, 40005, 40035, 40064, 40094, 40123, 40153,
        40182, 40212, 40241, 40271, 40300, 40330, 40359, 40389, 40418, 40448, 40477, 40507, 40536, 40566, 40595, 40625, 40655, 40685,
        40714, 40744, 40773, 40803, 40832, 40862, 40892, 40921, 40951, 40980, 41009, 41039, 41068, 41098, 41127, 41157, 41186, 41216,
        41245, 41275, 41304, 41334, 41364, 41393, 41422, 41452, 41481, 41511, 41540, 41570, 41599, 41629, 41658, 41688, 41718, 41748,
        41777, 41807, 41836, 41865, 41894, 41924, 41953, 41983, 42012, 42042, 42072, 42102, 42131, 42161, 42190, 42220, 42249, 42279,
        42308, 42337, 42367, 42397, 42426, 42456, 42485, 42515, 42545, 42574, 42604, 42633, 42662, 42692, 42721, 42751, 42780, 42810,
        42839, 42869, 42899, 42929, 42958, 42988, 43017, 43046, 43076, 43105, 43135, 43164, 43194, 43223, 43253, 43283, 43312, 43342,
        43371, 43401, 43430, 43460, 43489, 43519, 43548, 43578, 43607, 43637, 43666, 43696, 43726, 43755, 43785, 43814, 43844, 43873,
        43903, 43932, 43962, 43991, 44021, 44050, 44080, 44109, 44139, 44169, 44198, 44228, 44258, 44287, 44317, 44346, 44375, 44405,
        44434, 44464, 44493, 44523, 44553, 44582, 44612, 44641, 44671, 44700, 44730, 44759, 44788, 44818, 44847, 44877, 44906, 44936,
        44966, 44996, 45025, 45055, 45084, 45114, 45143, 45172, 45202, 45231, 45261, 45290, 45320, 45350, 45380, 45409, 45439, 45468,
        45498, 45527, 45556, 45586, 45615, 45644, 45674, 45704, 45733, 45763, 45793, 45823, 45852, 45882, 45911, 45940, 45970, 45999,
        46028, 46058, 46088, 46117, 46147, 46177, 46206, 46236, 46265, 46295, 46324, 46354, 46383, 46413, 46442, 46472, 46501, 46531,
        46560, 46590, 46620, 46649, 46679, 46708, 46738, 46767, 46797, 46826, 46856, 46885, 46915, 46944, 46974, 47003, 47033, 47063,
        47092, 47122, 47151, 47181, 47210, 47240, 47269, 47298, 47328, 47357, 47387, 47417, 47446, 47476, 47506, 47535, 47565, 47594,
        47624, 47653, 47682, 47712, 47741, 47771, 47800, 47830, 47860, 47890, 47919, 47949, 47978, 48008, 48037, 48066, 48096, 48125,
        48155, 48184, 48214, 48244, 48273, 48303, 48333, 48362, 48392, 48421, 48450, 48480, 48509, 48538, 48568, 48598, 48627, 48657,
        48687, 48717, 48746, 48776, 48805, 48834, 48864, 48893, 48922, 48952, 48982, 49011, 49041, 49071, 49100, 49130, 49160, 49189,
        49218, 49248, 49277, 49306, 49336, 49365, 49395, 49425, 49455, 49484, 49514, 49543, 49573, 49602, 49632, 49661, 49690, 49720,
        49749, 49779, 49809, 49838, 49868, 49898, 49927, 49957, 49986, 50016, 50045, 50075, 50104, 50133, 50163, 50192, 50222, 50252,
        50281, 50311, 50340, 50370, 50400, 50429, 50459, 50488, 50518, 50547, 50576, 50606, 50635, 50665, 50694, 50724, 50754, 50784,
        50813, 50843, 50872, 50902, 50931, 50960, 50990, 51019, 51049, 51078, 51108, 51138, 51167, 51197, 51227, 51256, 51286, 51315,
        51345, 51374, 51403, 51433, 51462, 51492, 51522, 51552, 51582, 51611, 51641, 51670, 51699, 51729, 51758, 51787, 51816, 51846,
        51876, 51906, 51936, 51965, 51995, 52025, 52054, 52083, 52113, 52142, 52171, 52200, 52230, 52260, 52290, 52319, 52349, 52379,
        52408, 52438, 52467, 52497, 52526, 52555, 52585, 52614, 52644, 52673, 52703, 52733, 52762, 52792, 52822, 52851, 52881, 52910,
        52939, 52969, 52998, 53028, 53057, 53087, 53116, 53146, 53176, 53205, 53235, 53264, 53294, 53324, 53353, 53383, 53412, 53441,
        53471, 53500, 53530, 53559, 53589, 53619, 53648, 53678, 53708, 53737, 53767, 53796, 53825, 53855, 53884, 53913, 53943, 53973,
        54003, 54032, 54062, 54092, 54121, 54151, 54180, 54209, 54239, 54268, 54297, 54327, 54357, 54387, 54416, 54446, 54476, 54505,
        54535, 54564, 54593, 54623, 54652, 54681, 54711, 54741, 54770, 54800, 54830, 54859, 54889, 54919, 54948, 54977, 55007, 55036,
        55066, 55095, 55125, 55154, 55184, 55213, 55243, 55273, 55302, 55332, 55361, 55391, 55420, 55450, 55479, 55508, 55538, 55567,
        55597, 55627, 55657, 55686, 55716, 55745, 55775, 55804, 55834, 55863, 55892, 55922, 55951, 55981, 56011, 56040, 56070, 56100,
        56129, 56159, 56188, 56218, 56247, 56276, 56306, 56335, 56365, 56394, 56424, 56454, 56483, 56513, 56543, 56572, 56601, 56631,
        56660, 56690, 56719, 56749, 56778, 56808, 56837, 56867, 56897, 56926, 56956, 56985, 57015, 57044, 57074, 57103, 57133, 57162,
        57192, 57221, 57251, 57280, 57310, 57340, 57369, 57399, 57429, 57458, 57487, 57517, 57546, 57576, 57605, 57634, 57664, 57694,
        57723, 57753, 57783, 57813, 57842, 57871, 57901, 57930, 57959, 57989, 58018, 58048, 58077, 58107, 58137, 58167, 58196, 58226,
        58255, 58285, 58314, 58343, 58373, 58402, 58432, 58461, 58491, 58521, 58551, 58580, 58610, 58639, 58669, 58698, 58727, 58757,
        58786, 58816, 58845, 58875, 58905, 58934, 58964, 58994, 59023, 59053, 59082, 59111, 59141, 59170, 59200, 59229, 59259, 59288,
        59318, 59348, 59377, 59407, 59436, 59466, 59495, 59525, 59554, 59584, 59613, 59643, 59672, 59702, 59731, 59761, 59791, 59820,
        59850, 59879, 59909, 59939, 59968, 59997, 60027, 60056, 60086, 60115, 60145, 60174, 60204, 60234, 60264, 60293, 60323, 60352,
        60381, 60411, 60440, 60469, 60499, 60528, 60558, 60588, 60618, 60648, 60677, 60707, 60736, 60765, 60795, 60824, 60853, 60883,
        60912, 60942, 60972, 61002, 61031, 61061, 61090, 61120, 61149, 61179, 61208, 61237, 61267, 61296, 61326, 61356, 61385, 61415,
        61445, 61474, 61504, 61533, 61563, 61592, 61621, 61651, 61680, 61710, 61739, 61769, 61799, 61828, 61858, 61888, 61917, 61947,
        61976, 62006, 62035, 62064, 62094, 62123, 62153, 62182, 62212, 62242, 62271, 62301, 62331, 62360, 62390, 62419, 62448, 62478,
        62507, 62537, 62566, 62596, 62625, 62655, 62685, 62715, 62744, 62774, 62803, 62832, 62862, 62891, 62921, 62950, 62980, 63009,
        63039, 63069, 63099, 63128, 63157, 63187, 63216, 63246, 63275, 63305, 63334, 63363, 63393, 63423, 63453, 63482, 63512, 63541,
        63571, 63600, 63630, 63659, 63689, 63718, 63747, 63777, 63807, 63836, 63866, 63895, 63925, 63955, 63984, 64014, 64043, 64073,
        64102, 64131, 64161, 64190, 64220, 64249, 64279, 64309, 64339, 64368, 64398, 64427, 64457, 64486, 64515, 64545, 64574, 64603,
        64633, 64663, 64692, 64722, 64752, 64782, 64811, 64841, 64870, 64899, 64929, 64958, 64987, 65017, 65047, 65076, 65106, 65136,
        65166, 65195, 65225, 65254, 65283, 65313, 65342, 65371, 65401, 65431, 65460, 65490, 65520, 65549, 65579, 65608, 65638, 65667,
        65697, 65726, 65755, 65785, 65815, 65844, 65874, 65903, 65933, 65963, 65992, 66022, 66051, 66081, 66110, 66140, 66169, 66199,
        66228, 66258, 66287, 66317, 66346, 66376, 66405, 66435, 66465, 66494, 66524, 66553, 66583, 66612, 66641, 66671, 66700, 66730,
        66760, 66789, 66819, 66849, 66878, 66908, 66937, 66967, 66996, 67025, 67055, 67084, 67114, 67143, 67173, 67203, 67233, 67262,
        67292, 67321, 67351, 67380, 67409, 67439, 67468, 67497, 67527, 67557, 67587, 67617, 67646, 67676, 67705, 67735, 67764, 67793,
        67823, 67852, 67882, 67911, 67941, 67971, 68000, 68030, 68060, 68089, 68119, 68148, 68177, 68207, 68236, 68266, 68295, 68325,
        68354, 68384, 68414, 68443, 68473, 68502, 68532, 68561, 68591, 68620, 68650, 68679, 68708, 68738, 68768, 68797, 68827, 68857,
        68886, 68916, 68946, 68975, 69004, 69034, 69063, 69092, 69122, 69152, 69181, 69211, 69240, 69270, 69300, 69330, 69359, 69388,
        69418, 69447, 69476, 69506, 69535, 69565, 69595, 69624, 69654, 69684, 69713, 69743, 69772, 69802, 69831, 69861, 69890, 69919,
        69949, 69978, 70008, 70038, 70067, 70097, 70126, 70156, 70186, 70215, 70245, 70274, 70303, 70333, 70362, 70392, 70421, 70451,
        70481, 70510, 70540, 70570, 70599, 70629, 70658, 70687, 70717, 70746, 70776, 70805, 70835, 70864, 70894, 70924, 70954, 70983,
        71013, 71042, 71071, 71101, 71130, 71159, 71189, 71218, 71248, 71278, 71308, 71337, 71367, 71397, 71426, 71455, 71485, 71514,
        71543, 71573, 71602, 71632, 71662, 71691, 71721, 71751, 71781, 71810, 71839, 71869, 71898, 71927, 71957, 71986, 72016, 72046,
        72075, 72105, 72135, 72164, 72194, 72223, 72253, 72282, 72311, 72341, 72370, 72400, 72429, 72459, 72489, 72518, 72548, 72577,
        72607, 72637, 72666, 72695, 72725, 72754, 72784, 72813, 72843, 72872, 72902, 72931, 72961, 72991, 73020, 73050, 73080, 73109,
        73139, 73168, 73197, 73227, 73256, 73286, 73315, 73345, 73375, 73404, 73434, 73464, 73493, 73523, 73552, 73581, 73611, 73640,
        73669, 73699, 73729, 73758, 73788, 73818, 73848, 73877, 73907, 73936, 73965, 73995, 74024, 74053, 74083, 74113, 74142, 74172,
        74202, 74231, 74261, 74291, 74320, 74349, 74379, 74408, 74437, 74467, 74497, 74526, 74556, 74586, 74615, 74645, 74675, 74704,
        74733, 74763, 74792, 74822, 74851, 74881, 74910, 74940, 74969, 74999, 75029, 75058, 75088, 75117, 75147, 75176, 75206, 75235,
        75264, 75294, 75323, 75353, 75383, 75412, 75442, 75472, 75501, 75531, 75560, 75590, 75619, 75648, 75678, 75707, 75737, 75766,
        75796, 75826, 75856, 75885, 75915, 75944, 75974, 76003, 76032, 76062, 76091, 76121, 76150, 76180, 76210, 76239, 76269, 76299,
        76328, 76358, 76387, 76416, 76446, 76475, 76505, 76534, 76564, 76593, 76623, 76653, 76682, 76712, 76741, 76771, 76801, 76830,
        76859, 76889, 76918, 76948, 76977, 77007, 77036, 77066, 77096, 77125, 77155, 77185, 77214, 77243, 77273, 77302, 77332, 77361,
        77390, 77420, 77450, 77479, 77509, 77539, 77569, 77598, 77627, 77657, 77686, 77715, 77745, 77774, 77804, 77833, 77863, 77893,
        77923, 77952, 77982, 78011, 78041, 78070, 78099, 78129, 78158, 78188, 78217, 78247, 78277, 78307, 78336, 78366, 78395, 78425,
        78454, 78483, 78513, 78542, 78572, 78601, 78631, 78661, 78690, 78720, 78750, 78779, 78808, 78838, 78867, 78897, 78926, 78956,
        78985, 79015, 79044, 79074, 79104, 79133, 79163, 79192, 79222, 79251, 79281, 79310, 79340, 79369, 79399, 79428, 79458, 79487,
        79517, 79546, 79576, 79606, 79635, 79665, 79695, 79724, 79753, 79783, 79812, 79841, 79871, 79900, 79930, 79960, 79990
    ];
    /**
     *
     * @param {Date} gDate ?
     * @returns {Object} ?
     */
    function getHijriDate(gDate) {
        var day = gDate.getDate();
        var month = gDate.getMonth();
        var year = gDate.getFullYear();
        var tMonth = month + 1;
        var tYear = year;
        if (tMonth < 3) {
            tYear -= 1;
            tMonth += 12;
        }
        var yPrefix = Math.floor(tYear / 100.);
        var julilanOffset = yPrefix - Math.floor(yPrefix / 4.) - 2;
        var julianNumber = Math.floor(365.25 * (tYear + 4716)) + Math.floor(30.6001 * (tMonth + 1)) + day - julilanOffset - 1524;
        yPrefix = Math.floor((julianNumber - 1867216.25) / 36524.25);
        julilanOffset = yPrefix - Math.floor(yPrefix / 4.) + 1;
        var b = julianNumber + julilanOffset + 1524;
        var c = Math.floor((b - 122.1) / 365.25);
        var d = Math.floor(365.25 * c);
        var tempMonth = Math.floor((b - d) / 30.6001);
        day = (b - d) - Math.floor(30.6001 * tempMonth);
        month = Math.floor((b - d) / 20.6001);
        if (month > 13) {
            c += 1;
            month -= 12;
        }
        month -= 1;
        year = c - 4716;
        var modifiedJulianDate = julianNumber - 2400000;
        // date calculation for year after 2077
        var iyear = 10631. / 30.;
        var z = julianNumber - 1948084;
        var cyc = Math.floor(z / 10631.);
        z = z - 10631 * cyc;
        var j = Math.floor((z - 0.1335) / iyear);
        var iy = 30 * cyc + j;
        z = z - Math.floor(j * iyear + 0.1335);
        var im = Math.floor((z + 28.5001) / 29.5);
        /* istanbul ignore next */
        if (im === 13) {
            im = 12;
        }
        var tempDay = z - Math.floor(29.5001 * im - 29);
        var i = 0;
        for (; i < dateCorrection.length; i++) {
            if (dateCorrection[i] > modifiedJulianDate) {
                break;
            }
        }
        var iln = i + 16260;
        var ii = Math.floor((iln - 1) / 12);
        var hYear = ii + 1;
        var hmonth = iln - 12 * ii;
        var hDate = modifiedJulianDate - dateCorrection[i - 1] + 1;
        if ((hDate + '').length > 2) {
            hDate = tempDay;
            hmonth = im;
            hYear = iy;
        }
        return { year: hYear, month: hmonth, date: hDate };
    }
    HijriParser.getHijriDate = getHijriDate;
    /**
     *
     * @param {number} year ?
     * @param {number} month ?
     * @param {number} day ?
     * @returns {Date} ?
     */
    function toGregorian(year, month, day) {
        var iy = year;
        var im = month;
        var id = day;
        var ii = iy - 1;
        var iln = (ii * 12) + 1 + (im - 1);
        var i = iln - 16260;
        var mcjdn = id + dateCorrection[i - 1] - 1;
        var julianDate = mcjdn + 2400000;
        var z = Math.floor(julianDate + 0.5);
        var a = Math.floor((z - 1867216.25) / 36524.25);
        a = z + 1 + a - Math.floor(a / 4);
        var b = a + 1524;
        var c = Math.floor((b - 122.1) / 365.25);
        var d = Math.floor(365.25 * c);
        var e = Math.floor((b - d) / 30.6001);
        var gDay = b - d - Math.floor(e * 30.6001);
        var gMonth = e - (e > 13.5 ? 13 : 1);
        var gYear = c - (gMonth > 2.5 ? 4716 : 4715);
        /* istanbul ignore next */
        if (gYear <= 0) {
            gMonth--;
        } // No year zero
        return new Date(gYear + '/' + (gMonth) + '/' + gDay);
    }
    HijriParser.toGregorian = toGregorian;
})(exports.HijriParser || (exports.HijriParser = {}));

var abbreviateRegexGlobal = /\/MMMMM|MMMM|MMM|a|LLLL|LLL|EEEEE|EEEE|E|K|cccc|ccc|WW|W|G+|z+/gi;
var standalone = 'stand-alone';
var weekdayKey = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];

var timeSetter = {
    m: 'getMinutes',
    h: 'getHours',
    H: 'getHours',
    s: 'getSeconds',
    d: 'getDate',
    f: 'getMilliseconds'
};
var datePartMatcher = {
    'M': 'month',
    'd': 'day',
    'E': 'weekday',
    'c': 'weekday',
    'y': 'year',
    'm': 'minute',
    'h': 'hour',
    'H': 'hour',
    's': 'second',
    'L': 'month',
    'a': 'designator',
    'z': 'timeZone',
    'Z': 'timeZone',
    'G': 'era',
    'f': 'milliseconds'
};
var timeSeparator = 'timeSeparator';
/* tslint:disable no-any */
/**
 * Date Format is a framework provides support for date formatting.
 *
 * @private
 */
var DateFormat = /** @class */ (function () {
    function DateFormat() {
    }
    /**
     * Returns the formatter function for given skeleton.
     *
     * @param {string} culture -  Specifies the culture name to be which formatting.
     * @param {DateFormatOptions} option - Specific the format in which date  will format.
     * @param {Object} cldr - Specifies the global cldr data collection.
     * @returns {Function} ?
     */
    DateFormat.dateFormat = function (culture, option, cldr) {
        var _this = this;
        var dependable = exports.IntlBase.getDependables(cldr, culture, option.calendar);
        var numObject = getValue('parserObject.numbers', dependable);
        var dateObject = dependable.dateObject;
        var formatOptions = { isIslamic: exports.IntlBase.islamicRegex.test(option.calendar) };
        if (isBlazor() && option.isServerRendered) {
            option = exports.IntlBase.compareBlazorDateFormats(option, culture);
        }
        var resPattern = option.format ||
            exports.IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, isBlazor() ? culture : '');
        formatOptions.dateSeperator = isBlazor() ? getValue('dateSeperator', dateObject) : exports.IntlBase.getDateSeparator(dependable.dateObject);
        if (isUndefined(resPattern)) {
            throwError('Format options or type given must be invalid');
        }
        else {
            resPattern = exports.IntlBase.ConvertDateToWeekFormat(resPattern);
            if (isBlazor()) {
                resPattern = resPattern.replace(/tt/, 'a');
            }
            formatOptions.pattern = resPattern;
            formatOptions.numMapper = isBlazor() ?
                extend({}, numObject) : ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
            var patternMatch = resPattern.match(abbreviateRegexGlobal) || [];
            for (var _i = 0, patternMatch_1 = patternMatch; _i < patternMatch_1.length; _i++) {
                var str = patternMatch_1[_i];
                var len = str.length;
                var char = str[0];
                if (char === 'K') {
                    char = 'h';
                }
                switch (char) {
                    case 'E':
                    case 'c':
                        if (isBlazor()) {
                            // eslint-disable-next-line
                            formatOptions.weekday = getValue('days.' + exports.IntlBase.monthIndex[len], dateObject);
                        }
                        else {
                            // eslint-disable-next-line
                            formatOptions.weekday = dependable.dateObject[exports.IntlBase.days][standalone][exports.IntlBase.monthIndex[len]];
                        }
                        break;
                    case 'M':
                    case 'L':
                        if (isBlazor()) {
                            // eslint-disable-next-line
                            formatOptions.month = getValue('months.' + exports.IntlBase.monthIndex[len], dateObject);
                        }
                        else {
                            // eslint-disable-next-line
                            formatOptions.month = dependable.dateObject[exports.IntlBase.month][standalone][exports.IntlBase.monthIndex[len]];
                        }
                        break;
                    case 'a':
                        formatOptions.designator = isBlazor() ?
                            getValue('dayPeriods', dateObject) : getValue('dayPeriods.format.wide', dateObject);
                        break;
                    case 'G':
                        // eslint-disable-next-line
                        var eText = (len <= 3) ? 'eraAbbr' : (len === 4) ? 'eraNames' : 'eraNarrow';
                        formatOptions.era = isBlazor() ? getValue('eras', dateObject) : getValue('eras.' + eText, dependable.dateObject);
                        break;
                    case 'z':
                        formatOptions.timeZone = getValue('dates.timeZoneNames', dependable.parserObject);
                        break;
                }
            }
        }
        return function (value) {
            if (isNaN(value.getDate())) {
                return null;
            }
            return _this.intDateFormatter(value, formatOptions);
        };
    };
    /**
     * Returns formatted date string based on options passed.
     *
     * @param {Date} value ?
     * @param {FormatOptions} options ?
     * @returns {string} ?
     */
    DateFormat.intDateFormatter = function (value, options) {
        var pattern = options.pattern;
        var ret = '';
        var matches = pattern.match(exports.IntlBase.dateParseRegex);
        var dObject = this.getCurrentDateValue(value, options.isIslamic);
        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
            var match = matches_1[_i];
            var length_1 = match.length;
            var char = match[0];
            if (char === 'K') {
                char = 'h';
            }
            var curval = void 0;
            var curvalstr = '';
            var isNumber = void 0;
            var processNumber = void 0;
            var curstr = '';
            switch (char) {
                case 'M':
                case 'L':
                    curval = dObject.month;
                    if (length_1 > 2) {
                        // eslint-disable-next-line
                        ret += options.month[curval];
                    }
                    else {
                        isNumber = true;
                    }
                    break;
                case 'E':
                case 'c':
                    // eslint-disable-next-line
                    ret += options.weekday[weekdayKey[value.getDay()]];
                    break;
                case 'H':
                case 'h':
                case 'm':
                case 's':
                case 'd':
                case 'f':
                    isNumber = true;
                    if (char === 'd') {
                        curval = dObject.date;
                    }
                    else if (char === 'f') {
                        isNumber = false;
                        processNumber = true;
                        // eslint-disable-next-line
                        curvalstr = value[timeSetter[char]]().toString();
                        curvalstr = curvalstr.substring(0, length_1);
                        var curlength = curvalstr.length;
                        if (length_1 !== curlength) {
                            if (length_1 > 3) {
                                continue;
                            }
                            for (var i = 0; i < length_1 - curlength; i++) {
                                curvalstr = '0' + curvalstr.toString();
                            }
                        }
                        curstr += curvalstr;
                    }
                    else {
                        // eslint-disable-next-line
                        curval = value[timeSetter[char]]();
                    }
                    if (char === 'h') {
                        curval = curval % 12 || 12;
                    }
                    break;
                case 'y':
                    processNumber = true;
                    curstr += dObject.year;
                    if (length_1 === 2) {
                        curstr = curstr.substr(curstr.length - 2);
                    }
                    break;
                case 'a':
                    // eslint-disable-next-line
                    var desig = value.getHours() < 12 ? 'am' : 'pm';
                    // eslint-disable-next-line
                    ret += options.designator[desig];
                    break;
                case 'G':
                    // eslint-disable-next-line
                    var dec = value.getFullYear() < 0 ? 0 : 1;
                    // eslint-disable-next-line
                    var retu = options.era[dec];
                    if (isNullOrUndefined(retu)) {
                        // eslint-disable-next-line
                        retu = options.era[dec ? 0 : 1];
                    }
                    ret += retu || '';
                    break;
                case '\'':
                    ret += (match === '\'\'') ? '\'' : match.replace(/'/g, '');
                    break;
                case 'z':
                    // eslint-disable-next-line
                    var timezone = value.getTimezoneOffset();
                    // eslint-disable-next-line
                    var pattern_1 = (length_1 < 4) ? '+H;-H' : options.timeZone.hourFormat;
                    pattern_1 = pattern_1.replace(/:/g, options.numMapper.timeSeparator);
                    if (timezone === 0) {
                        ret += options.timeZone.gmtZeroFormat;
                    }
                    else {
                        processNumber = true;
                        curstr = this.getTimeZoneValue(timezone, pattern_1);
                    }
                    curstr = options.timeZone.gmtFormat.replace(/\{0\}/, curstr);
                    break;
                case ':':
                    // eslint-disable-next-line
                    ret += options.numMapper.numberSymbols[timeSeparator];
                    break;
                case '/':
                    ret += options.dateSeperator;
                    break;
                case 'W':
                    isNumber = true;
                    curval = exports.IntlBase.getWeekOfYear(value);
                    break;
                default:
                    ret += match;
            }
            if (isNumber) {
                processNumber = true;
                curstr = this.checkTwodigitNumber(curval, length_1);
            }
            if (processNumber) {
                ret += ParserBase.convertValueParts(curstr, exports.IntlBase.latnParseRegex, options.numMapper.mapper);
            }
        }
        return ret;
    };
    DateFormat.getCurrentDateValue = function (value, isIslamic) {
        if (isIslamic) {
            return exports.HijriParser.getHijriDate(value);
        }
        return { year: value.getFullYear(), month: value.getMonth() + 1, date: value.getDate() };
    };
    /**
     * Returns two digit numbers for given value and length
     *
     * @param {number} val ?
     * @param {number} len ?
     * @returns {string} ?
     */
    DateFormat.checkTwodigitNumber = function (val, len) {
        var ret = val + '';
        if (len === 2 && ret.length !== 2) {
            return '0' + ret;
        }
        return ret;
    };
    /**
     * Returns the value of the Time Zone.
     *
     * @param {number} tVal ?
     * @param {string} pattern ?
     * @returns {string} ?
     * @private
     */
    DateFormat.getTimeZoneValue = function (tVal, pattern) {
        var _this = this;
        var splt = pattern.split(';');
        var curPattern = splt[tVal > 0 ? 1 : 0];
        var no = Math.abs(tVal);
        return curPattern = curPattern.replace(/HH?|mm/g, function (str) {
            var len = str.length;
            var ishour = str.indexOf('H') !== -1;
            return _this.checkTwodigitNumber(Math.floor(ishour ? (no / 60) : (no % 60)), len);
        });
    };
    return DateFormat;
}());

var errorText = {
    'ms': 'minimumSignificantDigits',
    'ls': 'maximumSignificantDigits',
    'mf': 'minimumFractionDigits',
    'lf': 'maximumFractionDigits',
};
var percentSign = 'percentSign';
var minusSign = 'minusSign';
var mapper$1 = ['infinity', 'nan', 'group', 'decimal', 'exponential'];
/**
 * Module for number formatting.
 *
 * @private
 */
var NumberFormat = /** @class */ (function () {
    function NumberFormat() {
    }
    /**
     * Returns the formatter function for given skeleton.
     *
     * @param {string} culture -  Specifies the culture name to be which formatting.
     * @param {NumberFormatOptions} option - Specific the format in which number  will format.
     * @param {Object} cldr - Specifies the global cldr data collection.
     * @returns {Function} ?
     */
    NumberFormat.numberFormatter = function (culture, option, cldr) {
        var _this = this;
        var fOptions = extend({}, option);
        var cOptions = {};
        var dOptions = {};
        var symbolPattern;
        var dependable = exports.IntlBase.getDependables(cldr, culture, '', true);
        var numObject = dependable.numericObject;
        dOptions.numberMapper = isBlazor() ? extend({}, numObject) :
            ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
        dOptions.currencySymbol = isBlazor() ? getValue('currencySymbol', numObject) : exports.IntlBase.getCurrencySymbol(dependable.numericObject, fOptions.currency || exports.defaultCurrencyCode, option.altSymbol);
        /* eslint-disable  @typescript-eslint/no-explicit-any */
        dOptions.percentSymbol = isBlazor() ? getValue('numberSymbols.percentSign', numObject) :
            dOptions.numberMapper.numberSymbols[percentSign];
        dOptions.minusSymbol = isBlazor() ? getValue('numberSymbols.minusSign', numObject) :
            dOptions.numberMapper.numberSymbols[minusSign];
        var symbols = dOptions.numberMapper.numberSymbols;
        if ((option.format) && !(exports.IntlBase.formatRegex.test(option.format))) {
            cOptions = exports.IntlBase.customFormat(option.format, dOptions, dependable.numericObject);
        }
        else {
            extend(fOptions, exports.IntlBase.getProperNumericSkeleton(option.format || 'N'));
            fOptions.isCurrency = fOptions.type === 'currency';
            fOptions.isPercent = fOptions.type === 'percent';
            if (!isBlazor()) {
                symbolPattern = exports.IntlBase.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);
            }
            fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);
            this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);
            if (!isUndefined(fOptions.fractionDigits)) {
                fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;
            }
            if (isUndefined(fOptions.useGrouping)) {
                fOptions.useGrouping = true;
            }
            if (fOptions.isCurrency && !isBlazor()) {
                symbolPattern = symbolPattern.replace(/\u00A4/g, exports.IntlBase.defaultCurrency);
            }
            if (!isBlazor()) {
                var split = symbolPattern.split(';');
                cOptions.nData = exports.IntlBase.getFormatData(split[1] || '-' + split[0], true, dOptions.currencySymbol);
                cOptions.pData = exports.IntlBase.getFormatData(split[0], false, dOptions.currencySymbol);
                if (fOptions.useGrouping) {
                    fOptions.groupSeparator = symbols[mapper$1[2]];
                    fOptions.groupData = this.getGroupingDetails(split[0]);
                }
            }
            else {
                cOptions.nData = extend({}, {}, getValue(fOptions.type + 'nData', numObject));
                cOptions.pData = extend({}, {}, getValue(fOptions.type + 'pData', numObject));
                if (fOptions.type === 'currency' && option.currency) {
                    exports.IntlBase.replaceBlazorCurrency([cOptions.pData, cOptions.nData], dOptions.currencySymbol, option.currency);
                }
            }
            var minFrac = isUndefined(fOptions.minimumFractionDigits);
            if (minFrac) {
                fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;
            }
            if (isUndefined(fOptions.maximumFractionDigits)) {
                var mval = cOptions.nData.maximumFraction;
                fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;
            }
            var mfrac = fOptions.minimumFractionDigits;
            var lfrac = fOptions.maximumFractionDigits;
            if (!isUndefined(mfrac) && !isUndefined(lfrac)) {
                if (mfrac > lfrac) {
                    fOptions.maximumFractionDigits = mfrac;
                }
            }
        }
        extend(cOptions.nData, fOptions);
        extend(cOptions.pData, fOptions);
        return function (value) {
            if (isNaN(value)) {
                return symbols[mapper$1[1]];
            }
            else if (!isFinite(value)) {
                return symbols[mapper$1[0]];
            }
            return _this.intNumberFormatter(value, cOptions, dOptions);
        };
    };
    /**
     * Returns grouping details for the pattern provided
     *
     * @param {string} pattern ?
     * @returns {GroupDetails} ?
     */
    NumberFormat.getGroupingDetails = function (pattern) {
        var ret = {};
        var match = pattern.match(exports.IntlBase.negativeDataRegex);
        if (match && match[4]) {
            var pattern_1 = match[4];
            var p = pattern_1.lastIndexOf(',');
            if (p !== -1) {
                var temp = pattern_1.split('.')[0];
                ret.primary = (temp.length - p) - 1;
                var s = pattern_1.lastIndexOf(',', p - 1);
                if (s !== -1) {
                    ret.secondary = p - 1 - s;
                }
            }
        }
        return ret;
    };
    /**
     * Returns if the provided integer range is valid.
     *
     * @param {number} val1 ?
     * @param {number} val2 ?
     * @param {boolean} checkbothExist ?
     * @param {boolean} isFraction ?
     * @returns {boolean} ?
     */
    NumberFormat.checkValueRange = function (val1, val2, checkbothExist, isFraction) {
        var decide = isFraction ? 'f' : 's';
        var dint = 0;
        var str1 = errorText['l' + decide];
        // eslint-disable-next-line
        var str2 = errorText['m' + decide];
        if (!isUndefined(val1)) {
            this.checkRange(val1, str1, isFraction);
            dint++;
        }
        if (!isUndefined(val2)) {
            this.checkRange(val2, str2, isFraction);
            dint++;
        }
        if (dint === 2) {
            if (val1 < val2) {
                throwError(str2 + 'specified must be less than the' + str1);
            }
            else {
                return true;
            }
        }
        else if (checkbothExist && dint === 1) {
            throwError('Both' + str2 + 'and' + str2 + 'must be present');
        }
        return false;
    };
    /**
     * Check if the provided fraction range is valid
     *
     * @param {number} val ?
     * @param {string} text ?
     * @param {boolean} isFraction ?
     * @returns {void} ?
     */
    NumberFormat.checkRange = function (val, text, isFraction) {
        var range = isFraction ? [0, 20] : [1, 21];
        if (val < range[0] || val > range[1]) {
            throwError(text + 'value must be within the range' + range[0] + 'to' + range[1]);
        }
    };
    /**
     * Returns formatted numeric string for provided formatting options
     *
     * @param {number} value ?
     * @param {base.GenericFormatOptions} fOptions ?
     * @param {CommonOptions} dOptions ?
     * @returns {string} ?
     */
    NumberFormat.intNumberFormatter = function (value, fOptions, dOptions) {
        var curData;
        if (isUndefined(fOptions.nData.type)) {
            return undefined;
        }
        else {
            if (value < 0) {
                value = value * -1;
                curData = fOptions.nData;
            }
            else if (value === 0) {
                curData = fOptions.zeroData || fOptions.pData;
            }
            else {
                curData = fOptions.pData;
            }
            var fValue = '';
            if (curData.isPercent) {
                value = value * 100;
            }
            if (curData.groupOne) {
                fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);
            }
            else {
                fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits);
                if (curData.minimumIntegerDigits) {
                    fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);
                }
            }
            if (curData.type === 'scientific') {
                fValue = value.toExponential(curData.maximumFractionDigits);
                fValue = fValue.replace('e', dOptions.numberMapper.numberSymbols[mapper$1[4]]);
            }
            fValue = fValue.replace('.', dOptions.numberMapper.numberSymbols[mapper$1[3]]);
            if (curData.useGrouping) {
                /* eslint-disable  @typescript-eslint/no-explicit-any */
                fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ',', dOptions.numberMapper.numberSymbols[mapper$1[3]] || '.', curData.groupData.secondary);
            }
            fValue = ParserBase.convertValueParts(fValue, exports.IntlBase.latnParseRegex, dOptions.numberMapper.mapper);
            if (curData.nlead === 'N/A') {
                return curData.nlead;
            }
            else {
                return curData.nlead + fValue + curData.nend;
            }
        }
    };
    /**
     * Returns significant digits processed numeric string
     *
     * @param {number} value ?
     * @param {number} min ?
     * @param {number} max ?
     * @returns {string} ?
     */
    NumberFormat.processSignificantDigits = function (value, min, max) {
        var temp = value + '';
        var tn;
        var length = temp.length;
        if (length < min) {
            return value.toPrecision(min);
        }
        else {
            temp = value.toPrecision(max);
            tn = +temp;
            return tn + '';
        }
    };
    /**
     * Returns grouped numeric string
     *
     * @param {string} val ?
     * @param {number} level1 ?
     * @param {string} sep ?
     * @param {string} decimalSymbol ?
     * @param {number} level2 ?
     * @returns {string} ?
     */
    NumberFormat.groupNumbers = function (val, level1, sep, decimalSymbol, level2) {
        var flag = !isNullOrUndefined(level2) && level2 !== 0;
        var split = val.split(decimalSymbol);
        var prefix = split[0];
        var length = prefix.length;
        var str = '';
        while (length > level1) {
            str = prefix.slice(length - level1, length) + (str.length ?
                (sep + str) : '');
            length -= level1;
            if (flag) {
                level1 = level2;
                flag = false;
            }
        }
        split[0] = prefix.slice(0, length) + (str.length ? sep : '') + str;
        return split.join(decimalSymbol);
    };
    /**
     * Returns fraction processed numeric string
     *
     * @param {number} value ?
     * @param {number} min ?
     * @param {number} max ?
     * @returns {string} ?
     */
    NumberFormat.processFraction = function (value, min, max) {
        var temp = (value + '').split('.')[1];
        var length = temp ? temp.length : 0;
        if (min && length < min) {
            var ret = '';
            if (length === 0) {
                ret = value.toFixed(min);
            }
            else {
                ret += value;
                for (var j = 0; j < min - length; j++) {
                    ret += '0';
                }
                return ret;
            }
            return value.toFixed(min);
        }
        else if (!isNullOrUndefined(max) && (length > max || max === 0)) {
            return value.toFixed(max);
        }
        return value + '';
    };
    /**
     * Returns integer processed numeric string
     *
     * @param {string} value ?
     * @param {number} min ?
     * @returns {string} ?
     */
    NumberFormat.processMinimumIntegers = function (value, min) {
        var temp = value.split('.');
        var lead = temp[0];
        var len = lead.length;
        if (len < min) {
            for (var i = 0; i < min - len; i++) {
                lead = '0' + lead;
            }
            temp[0] = lead;
        }
        return temp.join('.');
    };
    return NumberFormat;
}());

var standalone$1 = 'stand-alone';
var latnRegex = /^[0-9]*$/;
var timeSetter$1 = {
    minute: 'setMinutes',
    hour: 'setHours',
    second: 'setSeconds',
    day: 'setDate',
    month: 'setMonth',
    milliseconds: 'setMilliseconds'
};
var month = 'months';
/* tslint:disable no-any */
/**
 * Date Parser.
 *
 * @private
 */
var DateParser = /** @class */ (function () {
    function DateParser() {
    }
    /**
     * Returns the parser function for given skeleton.
     *
     * @param {string} culture -  Specifies the culture name to be which formatting.
     * @param {DateFormatOptions} option - Specific the format in which string date  will be parsed.
     * @param {Object} cldr - Specifies the global cldr data collection.
     * @returns {Function} ?
     */
    DateParser.dateParser = function (culture, option, cldr) {
        var _this = this;
        var dependable = exports.IntlBase.getDependables(cldr, culture, option.calendar);
        var numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), false, isBlazor());
        var parseOptions = {};
        if (isBlazor() && option.isServerRendered) {
            option = exports.IntlBase.compareBlazorDateFormats(option, culture);
        }
        var resPattern = option.format ||
            exports.IntlBase.getResultantPattern(option.skeleton, dependable.dateObject, option.type, false, isBlazor() ? culture : '');
        var regexString = '';
        var hourOnly;
        if (isUndefined(resPattern)) {
            throwError('Format options or type given must be invalid');
        }
        else {
            resPattern = exports.IntlBase.ConvertDateToWeekFormat(resPattern);
            parseOptions = { isIslamic: exports.IntlBase.islamicRegex.test(option.calendar), pattern: resPattern, evalposition: {}, culture: culture };
            var patternMatch = resPattern.match(exports.IntlBase.dateParseRegex) || [];
            var length_1 = patternMatch.length;
            var gmtCorrection = 0;
            var zCorrectTemp = 0;
            var isgmtTraversed = false;
            var nRegx = numOptions.numericRegex;
            // eslint-disable-next-line
            var numMapper = isBlazor() ? dependable.parserObject.numbers :
                ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
            for (var i = 0; i < length_1; i++) {
                var str = patternMatch[i];
                var len = str.length;
                var char = (str[0] === 'K') ? 'h' : str[0];
                var isNumber = void 0;
                var canUpdate = void 0;
                // eslint-disable-next-line
                var charKey = datePartMatcher[char];
                var optional = (len === 2) ? '' : '?';
                if (isgmtTraversed) {
                    gmtCorrection = zCorrectTemp;
                    isgmtTraversed = false;
                }
                switch (char) {
                    case 'E':
                    case 'c':
                        // eslint-disable-next-line
                        var weekData = void 0;
                        if (isBlazor()) {
                            // eslint-disable-next-line
                            weekData = getValue('days.' + exports.IntlBase.monthIndex[len], dependable.dateObject);
                        }
                        else {
                            // eslint-disable-next-line
                            weekData = dependable.dateObject[exports.IntlBase.days][standalone$1][exports.IntlBase.monthIndex[len]];
                        }
                        // eslint-disable-next-line
                        var weekObject = ParserBase.reverseObject(weekData);
                        // tslint:enable
                        regexString += '(' + Object.keys(weekObject).join('|') + ')';
                        break;
                    case 'M':
                    case 'L':
                    case 'd':
                    case 'm':
                    case 's':
                    case 'h':
                    case 'H':
                    case 'f':
                        canUpdate = true;
                        if ((char === 'M' || char === 'L') && len > 2) {
                            var monthData = void 0;
                            if (isBlazor()) {
                                // eslint-disable-next-line
                                monthData = getValue('months.' + exports.IntlBase.monthIndex[len], dependable.dateObject);
                            }
                            else {
                                // eslint-disable-next-line
                                monthData = dependable.dateObject[month][standalone$1][exports.IntlBase.monthIndex[len]];
                            }
                            // eslint-disable-next-line
                            parseOptions[charKey] = ParserBase.reverseObject(monthData);
                            // eslint-disable-next-line
                            regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';
                        }
                        else if (char === 'f') {
                            if (len > 3) {
                                continue;
                            }
                            isNumber = true;
                            regexString += '(' + nRegx + nRegx + '?' + nRegx + '?' + ')';
                        }
                        else {
                            isNumber = true;
                            regexString += '(' + nRegx + nRegx + optional + ')';
                        }
                        if (char === 'h') {
                            parseOptions.hour12 = true;
                        }
                        break;
                    case 'W':
                        // eslint-disable-next-line
                        var opt = len === 1 ? '?' : '';
                        regexString += '(' + nRegx + opt + nRegx + ')';
                        break;
                    case 'y':
                        canUpdate = isNumber = true;
                        if (len === 2) {
                            regexString += '(' + nRegx + nRegx + ')';
                        }
                        else {
                            regexString += '(' + nRegx + '{' + len + ',})';
                        }
                        break;
                    case 'a':
                        canUpdate = true;
                        // eslint-disable-next-line
                        var periodValur = isBlazor() ?
                            getValue('dayPeriods', dependable.dateObject) :
                            getValue('dayPeriods.format.wide', dependable.dateObject);
                        // eslint-disable-next-line
                        parseOptions[charKey] = ParserBase.reverseObject(periodValur);
                        // eslint-disable-next-line
                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + ')';
                        break;
                    case 'G':
                        canUpdate = true;
                        // eslint-disable-next-line
                        var eText = (len <= 3) ? 'eraAbbr' : (len === 4) ? 'eraNames' : 'eraNarrow';
                        // eslint-disable-next-line
                        parseOptions[charKey] = ParserBase.reverseObject(isBlazor() ?
                            getValue('eras', dependable.dateObject) : getValue('eras.' + eText, dependable.dateObject));
                        // eslint-disable-next-line
                        regexString += '(' + Object.keys(parseOptions[charKey]).join('|') + '?)';
                        break;
                    case 'z':
                        // eslint-disable-next-line
                        var tval = new Date().getTimezoneOffset();
                        canUpdate = (tval !== 0);
                        // eslint-disable-next-line
                        parseOptions[charKey] = getValue('dates.timeZoneNames', dependable.parserObject);
                        // eslint-disable-next-line
                        var tzone = parseOptions[charKey];
                        hourOnly = (len < 4);
                        // eslint-disable-next-line
                        var hpattern = hourOnly ? '+H;-H' : tzone.hourFormat;
                        hpattern = hpattern.replace(/:/g, numMapper.timeSeparator);
                        regexString += '(' + this.parseTimeZoneRegx(hpattern, tzone, nRegx) + ')?';
                        isgmtTraversed = true;
                        zCorrectTemp = hourOnly ? 6 : 12;
                        break;
                    case '\'':
                        // eslint-disable-next-line
                        var iString = str.replace(/'/g, '');
                        regexString += '(' + iString + ')?';
                        break;
                    default:
                        regexString += '([\\D])';
                        break;
                }
                if (canUpdate) {
                    parseOptions.evalposition[charKey] = { isNumber: isNumber, pos: i + 1 + gmtCorrection, hourOnly: hourOnly };
                }
                if (i === length_1 - 1 && !isNullOrUndefined(regexString)) {
                    parseOptions.parserRegex = new RegExp('^' + regexString + '$', 'i');
                }
            }
        }
        return function (value) {
            var parsedDateParts = _this.internalDateParse(value, parseOptions, numOptions);
            if (isNullOrUndefined(parsedDateParts) || !Object.keys(parsedDateParts).length) {
                return null;
            }
            if (parseOptions.isIslamic) {
                var dobj = {};
                var tYear = parsedDateParts.year;
                var tDate = parsedDateParts.day;
                var tMonth = parsedDateParts.month;
                var ystrig = tYear ? (tYear + '') : '';
                var is2DigitYear = (ystrig.length === 2);
                if (!tYear || !tMonth || !tDate || is2DigitYear) {
                    dobj = exports.HijriParser.getHijriDate(new Date());
                }
                if (is2DigitYear) {
                    tYear = parseInt((dobj.year + '').slice(0, 2) + ystrig, 10);
                }
                // tslint:disable-next-line
                var dateObject = exports.HijriParser.toGregorian(tYear || dobj.year, tMonth || dobj.month, tDate || dobj.date);
                parsedDateParts.year = dateObject.getFullYear();
                parsedDateParts.month = dateObject.getMonth() + 1;
                parsedDateParts.day = dateObject.getDate();
            }
            return _this.getDateObject(parsedDateParts);
        };
    };
    /* tslint:disable */
    /**
     * Returns date object for provided date options
     *
     * @param {DateParts} options ?
     * @param {Date} value ?
     * @returns {Date} ?
     */
    DateParser.getDateObject = function (options, value) {
        var res = value || new Date();
        res.setMilliseconds(0);
        var tKeys = ['hour', 'minute', 'second', 'milliseconds', 'month', 'day'];
        var y = options.year;
        var desig = options.designator;
        var tzone = options.timeZone;
        if (!isUndefined(y)) {
            var len = (y + '').length;
            if (len <= 2) {
                var century = Math.floor(res.getFullYear() / 100) * 100;
                y += century;
            }
            res.setFullYear(y);
        }
        for (var _i = 0, tKeys_1 = tKeys; _i < tKeys_1.length; _i++) {
            var key = tKeys_1[_i];
            // eslint-disable-next-line
            var tValue = options[key];
            if (isUndefined(tValue) && key === 'day') {
                res.setDate(1);
            }
            if (!isUndefined(tValue)) {
                if (key === 'month') {
                    tValue -= 1;
                    if (tValue < 0 || tValue > 11) {
                        return new Date('invalid');
                    }
                    var pDate = res.getDate();
                    res.setDate(1);
                    // eslint-disable-next-line
                    res[timeSetter$1[key]](tValue);
                    var lDate = new Date(res.getFullYear(), tValue + 1, 0).getDate();
                    res.setDate(pDate < lDate ? pDate : lDate);
                }
                else {
                    if (key === 'day') {
                        var lastDay = new Date(res.getFullYear(), res.getMonth() + 1, 0).getDate();
                        if ((tValue < 1 || tValue > lastDay)) {
                            return null;
                        }
                    }
                    // eslint-disable-next-line
                    res[timeSetter$1[key]](tValue);
                }
            }
        }
        if (!isUndefined(desig)) {
            var hour = res.getHours();
            if (desig === 'pm') {
                res.setHours(hour + (hour === 12 ? 0 : 12));
            }
            else if (hour === 12) {
                res.setHours(0);
            }
        }
        if (!isUndefined(tzone)) {
            var tzValue = tzone - res.getTimezoneOffset();
            if (tzValue !== 0) {
                res.setMinutes(res.getMinutes() + tzValue);
            }
        }
        return res;
    };
    /**
     * Returns date parsing options for provided value along with parse and numeric options
     *
     * @param {string} value ?
     * @param {ParseOptions} parseOptions ?
     * @param {NumericOptions} num ?
     * @returns {DateParts} ?
     */
    DateParser.internalDateParse = function (value, parseOptions, num) {
        var matches = value.match(parseOptions.parserRegex);
        var retOptions = { 'hour': 0, 'minute': 0, 'second': 0 };
        if (isNullOrUndefined(matches)) {
            return null;
        }
        else {
            var props = Object.keys(parseOptions.evalposition);
            for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
                var prop = props_1[_i];
                var curObject = parseOptions.evalposition[prop];
                var matchString = matches[curObject.pos];
                if (curObject.isNumber) {
                    // eslint-disable-next-line
                    retOptions[prop] = this.internalNumberParser(matchString, num);
                }
                else {
                    if (prop === 'timeZone' && !isUndefined(matchString)) {
                        var pos = curObject.pos;
                        var val = void 0;
                        var tmatch = matches[pos + 1];
                        var flag = !isUndefined(tmatch);
                        if (curObject.hourOnly) {
                            val = this.getZoneValue(flag, tmatch, matches[pos + 4], num) * 60;
                        }
                        else {
                            val = this.getZoneValue(flag, tmatch, matches[pos + 7], num) * 60;
                            val += this.getZoneValue(flag, matches[pos + 4], matches[pos + 10], num);
                        }
                        if (!isNullOrUndefined(val)) {
                            retOptions[prop] = val;
                        }
                    }
                    else {
                        // eslint-disable-next-line
                        matchString = ((prop === 'month') && (!parseOptions.isIslamic) && (parseOptions.culture === 'en' || parseOptions.culture === 'en-GB' || parseOptions.culture === 'en-US'))
                            ? matchString[0].toUpperCase() + matchString.substring(1).toLowerCase() : matchString;
                        // eslint-disable-next-line
                        retOptions[prop] = parseOptions[prop][matchString];
                    }
                }
            }
            if (parseOptions.hour12) {
                retOptions.hour12 = true;
            }
        }
        return retOptions;
    };
    /**
     * Returns parsed number for provided Numeric string and Numeric Options
     *
     * @param {string} value ?
     * @param {NumericOptions} option ?
     * @returns {number} ?
     */
    DateParser.internalNumberParser = function (value, option) {
        value = ParserBase.convertValueParts(value, option.numberParseRegex, option.numericPair);
        if (latnRegex.test(value)) {
            return +value;
        }
        return null;
    };
    /**
     * Returns parsed time zone RegExp for provided hour format and time zone
     *
     * @param {string} hourFormat ?
     * @param {base.TimeZoneOptions} tZone ?
     * @param {string} nRegex ?
     * @returns {string} ?
     */
    DateParser.parseTimeZoneRegx = function (hourFormat, tZone, nRegex) {
        var pattern = tZone.gmtFormat;
        var ret;
        var cRegex = '(' + nRegex + ')' + '(' + nRegex + ')';
        var splitStr;
        ret = hourFormat.replace('+', '\\+');
        if (hourFormat.indexOf('HH') !== -1) {
            ret = ret.replace(/HH|mm/g, '(' + cRegex + ')');
        }
        else {
            ret = ret.replace(/H|m/g, '(' + cRegex + '?)');
        }
        // eslint-disable-next-line
        splitStr = (ret.split(';').map(function (str) {
            return pattern.replace('{0}', str);
        }));
        ret = splitStr.join('|') + '|' + tZone.gmtZeroFormat;
        return ret;
    };
    /**
     * Returns zone based value.
     *
     * @param {boolean} flag ?
     * @param {string} val1 ?
     * @param {string} val2 ?
     * @param {NumericOptions} num ?
     * @returns {number} ?
     */
    DateParser.getZoneValue = function (flag, val1, val2, num) {
        var ival = flag ? val1 : val2;
        if (!ival) {
            return 0;
        }
        var value = this.internalNumberParser(ival, num);
        if (flag) {
            return -value;
        }
        return value;
    };
    return DateParser;
}());

var parseRegex = /^([^0-9]*)(([0-9,]*[0-9]+)(\.[0-9]+)?)([Ee][+-]?[0-9]+)?([^0-9]*)$/;
var groupRegex = /,/g;
var keys = ['minusSign', 'infinity'];
/**
 * Module for Number Parser.
 *
 * @private
 */
var NumberParser = /** @class */ (function () {
    function NumberParser() {
    }
    /**
     * Returns the parser function for given skeleton.
     *
     * @param {string} culture -  Specifies the culture name to be which formatting.
     * @param {NumberFormatOptions} option - Specific the format in which number  will parsed.
     * @param {Object} cldr - Specifies the global cldr data collection.
     * @returns {Function} ?
     */
    NumberParser.numberParser = function (culture, option, cldr) {
        var _this = this;
        var dependable = exports.IntlBase.getDependables(cldr, culture, '', true);
        var parseOptions = { custom: true };
        var numOptions;
        if ((exports.IntlBase.formatRegex.test(option.format)) || !(option.format)) {
            extend(parseOptions, exports.IntlBase.getProperNumericSkeleton(option.format || 'N'));
            parseOptions.custom = false;
            if (!parseOptions.fractionDigits) {
                if (option.maximumFractionDigits) {
                    parseOptions.maximumFractionDigits = option.maximumFractionDigits;
                }
            }
        }
        else {
            extend(parseOptions, exports.IntlBase.customFormat(option.format, null, null));
        }
        var numbers = getValue('numbers', dependable.parserObject);
        // eslint-disable-next-line
        numOptions = ParserBase.getCurrentNumericOptions(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true, isBlazor());
        parseOptions.symbolRegex = ParserBase.getSymbolRegex(Object.keys(numOptions.symbolMatch));
        // eslint-disable-next-line
        parseOptions.infinity = numOptions.symbolNumberSystem[keys[1]];
        var symbolpattern;
        if (!isBlazor()) {
            symbolpattern = exports.IntlBase.getSymbolPattern(parseOptions.type, numOptions.numberSystem, dependable.numericObject, parseOptions.isAccount);
            if (symbolpattern) {
                symbolpattern = symbolpattern.replace(/\u00A4/g, exports.IntlBase.defaultCurrency);
                var split = symbolpattern.split(';');
                parseOptions.nData = exports.IntlBase.getFormatData(split[1] || '-' + split[0], true, '');
                parseOptions.pData = exports.IntlBase.getFormatData(split[0], true, '');
            }
        }
        else {
            parseOptions.nData = extend({}, {}, getValue(parseOptions.type + 'nData', numbers));
            parseOptions.pData = extend({}, {}, getValue(parseOptions.type + 'pData', numbers));
            if (parseOptions.type === 'currency' && option.currency) {
                exports.IntlBase.replaceBlazorCurrency([parseOptions.pData, parseOptions.nData], getValue('currencySymbol', numbers), option.currency);
            }
        }
        return function (value) {
            return _this.getParsedNumber(value, parseOptions, numOptions);
        };
    };
    /**
     * Returns parsed number for the provided formatting options
     *
     * @param {string} value ?
     * @param {NumericParts} options ?
     * @param {NumericOptions} numOptions ?
     * @returns {number} ?
     */
    NumberParser.getParsedNumber = function (value, options, numOptions) {
        var isNegative;
        var isPercent;
        var tempValue;
        var lead;
        var end;
        var ret;
        if (value.indexOf(options.infinity) !== -1) {
            return Infinity;
        }
        else {
            value = ParserBase.convertValueParts(value, options.symbolRegex, numOptions.symbolMatch);
            value = ParserBase.convertValueParts(value, numOptions.numberParseRegex, numOptions.numericPair);
            value = value.indexOf('-') !== -1 ? value.replace('-.', '-0.') : value;
            if (value.indexOf('.') === 0) {
                value = '0' + value;
            }
            var matches = value.match(parseRegex);
            if (isNullOrUndefined(matches)) {
                return NaN;
            }
            lead = matches[1];
            tempValue = matches[2];
            var exponent = matches[5];
            end = matches[6];
            isNegative = options.custom ? ((lead === options.nData.nlead) && (end === options.nData.nend)) :
                ((lead.indexOf(options.nData.nlead) !== -1) && (end.indexOf(options.nData.nend) !== -1));
            isPercent = isNegative ?
                options.nData.isPercent :
                options.pData.isPercent;
            tempValue = tempValue.replace(groupRegex, '');
            if (exponent) {
                tempValue += exponent;
            }
            ret = +tempValue;
            if (options.type === 'percent' || isPercent) {
                ret = ret / 100;
            }
            if (options.custom || options.fractionDigits) {
                ret = parseFloat(ret.toFixed(options.custom ?
                    (isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits) : options.fractionDigits));
            }
            if (options.maximumFractionDigits) {
                ret = this.convertMaxFracDigits(tempValue, options, ret, isNegative);
            }
            if (isNegative) {
                ret *= -1;
            }
            return ret;
        }
    };
    NumberParser.convertMaxFracDigits = function (value, options, ret, isNegative) {
        var decimalSplitValue = value.split('.');
        if (decimalSplitValue[1] && decimalSplitValue[1].length > options.maximumFractionDigits) {
            ret = +(ret.toFixed(options.custom ?
                (isNegative ? options.nData.maximumFractionDigits : options.pData.maximumFractionDigits) : options.maximumFractionDigits));
        }
        return ret;
    };
    return NumberParser;
}());

var Observer = /** @class */ (function () {
    function Observer(context) {
        this.ranArray = [];
        this.boundedEvents = {};
        if (isNullOrUndefined(context)) {
            return;
        }
        this.context = context;
    }
    /**
     * To attach handler for given property in current context.
     *
     * @param {string} property - specifies the name of the event.
     * @param {Function} handler - Specifies the handler function to be called while event notified.
     * @param {Object} context - Specifies the context binded to the handler.
     * @param {string} id - specifies the random generated id.
     * @returns {void}
     */
    Observer.prototype.on = function (property, handler, context, id) {
        if (isNullOrUndefined(handler)) {
            return;
        }
        var cntxt = context || this.context;
        if (this.notExist(property)) {
            this.boundedEvents[property] = [{ handler: handler, context: cntxt }];
            return;
        }
        if (!isNullOrUndefined(id)) {
            if (this.ranArray.indexOf(id) === -1) {
                this.ranArray.push(id);
                this.boundedEvents[property].push({ handler: handler, context: cntxt, id: id });
            }
        }
        else if (!this.isHandlerPresent(this.boundedEvents[property], handler)) {
            this.boundedEvents[property].push({ handler: handler, context: cntxt });
        }
    };
    /**
     * To remove handlers from a event attached using on() function.
     *
     * @param {string} property - specifies the name of the event.
     * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.
     * @param {string} id - specifies the random generated id.
     * @returns {void} ?
     */
    Observer.prototype.off = function (property, handler, id) {
        if (this.notExist(property)) {
            return;
        }
        var curObject = getValue(property, this.boundedEvents);
        if (handler) {
            for (var i = 0; i < curObject.length; i++) {
                if (id) {
                    if (curObject[i].id === id) {
                        curObject.splice(i, 1);
                        var indexLocation = this.ranArray.indexOf(id);
                        if (indexLocation !== -1) {
                            this.ranArray.splice(indexLocation, 1);
                        }
                        break;
                    }
                }
                else if (handler === curObject[i].handler) {
                    curObject.splice(i, 1);
                    break;
                }
            }
        }
        else {
            delete this.boundedEvents[property];
        }
    };
    /**
     * To notify the handlers in the specified event.
     *
     * @param {string} property - Specifies the event to be notify.
     * @param {Object} argument - Additional parameters to pass while calling the handler.
     * @param {Function} successHandler - this function will invoke after event successfully triggered
     * @param {Function} errorHandler - this function will invoke after event if it was failure to call.
     * @returns {void} ?
     */
    Observer.prototype.notify = function (property, argument, successHandler, errorHandler) {
        if (this.notExist(property)) {
            if (successHandler) {
                successHandler.call(this, argument);
            }
            return;
        }
        if (argument) {
            argument.name = property;
        }
        var blazor = 'Blazor';
        var curObject = getValue(property, this.boundedEvents).slice(0);
        if (window[blazor]) {
            return this.blazorCallback(curObject, argument, successHandler, errorHandler, 0);
        }
        else {
            for (var _i = 0, curObject_1 = curObject; _i < curObject_1.length; _i++) {
                var cur = curObject_1[_i];
                cur.handler.call(cur.context, argument);
            }
            if (successHandler) {
                successHandler.call(this, argument);
            }
        }
    };
    Observer.prototype.blazorCallback = function (objs, argument, successHandler, errorHandler, index) {
        var _this = this;
        var isTrigger = index === objs.length - 1;
        if (index < objs.length) {
            var obj_1 = objs[index];
            var promise = obj_1.handler.call(obj_1.context, argument);
            if (promise && typeof promise.then === 'function') {
                if (!successHandler) {
                    return promise;
                }
                promise.then(function (data) {
                    data = typeof data === 'string' && _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data;
                    extend(argument, argument, data, true);
                    if (successHandler && isTrigger) {
                        successHandler.call(obj_1.context, argument);
                    }
                    else {
                        return _this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
                    }
                }).catch(function (data) {
                    if (errorHandler) {
                        errorHandler.call(obj_1.context, typeof data === 'string' &&
                            _this.isJson(data) ? JSON.parse(data, _this.dateReviver) : data);
                    }
                });
            }
            else if (successHandler && isTrigger) {
                successHandler.call(obj_1.context, argument);
            }
            else {
                return this.blazorCallback(objs, argument, successHandler, errorHandler, index + 1);
            }
        }
    };
    // eslint-disable-next-line
    Observer.prototype.dateReviver = function (key, value) {
        var dPattern = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/;
        if (isBlazor && typeof value === 'string' && value.match(dPattern) !== null) {
            return (new Date(value));
        }
        return (value);
    };
    Observer.prototype.isJson = function (value) {
        try {
            JSON.parse(value);
        }
        catch (e) {
            return false;
        }
        return true;
    };
    /**
     * To destroy handlers in the event
     *
     * @returns {void} ?
     */
    Observer.prototype.destroy = function () {
        this.boundedEvents = this.context = undefined;
    };
    /**
     * Returns if the property exists.
     *
     * @param {string} prop ?
     * @returns {boolean} ?
     */
    Observer.prototype.notExist = function (prop) {
        // eslint-disable-next-line
        return this.boundedEvents.hasOwnProperty(prop) === false || this.boundedEvents[prop].length <= 0;
    };
    /**
     * Returns if the handler is present.
     *
     * @param {BoundOptions[]} boundedEvents ?
     * @param {Function} handler ?
     * @returns {boolean} ?
     */
    Observer.prototype.isHandlerPresent = function (boundedEvents, handler) {
        for (var _i = 0, boundedEvents_1 = boundedEvents; _i < boundedEvents_1.length; _i++) {
            var cur = boundedEvents_1[_i];
            if (cur.handler === handler) {
                return true;
            }
        }
        return false;
    };
    return Observer;
}());

/**
 * Specifies the observer used for external change detection.
 */
var onIntlChange = new Observer();
/**
 * Specifies the default rtl status for EJ2 components.
 */
exports.rightToLeft = false;
/**
 * Specifies the CLDR data loaded for internationalization functionalities.
 *
 * @private
 */
var cldrData = {};
/**
 * Specifies the default culture value to be considered.
 *
 * @private
 */
exports.defaultCulture = 'en-US';
/**
 * Specifies default currency code to be considered
 *
 * @private
 */
exports.defaultCurrencyCode = 'USD';
var mapper = ['numericObject', 'dateObject'];
/**
 * Internationalization class provides support to parse and format the number and date object to the desired format.
 * ```typescript
 * // To set the culture globally
 * setCulture('en-GB');
 *
 * // To set currency code globally
 * setCurrencyCode('EUR');
 *
 * //Load cldr data
 * loadCldr(gregorainData);
 * loadCldr(timeZoneData);
 * loadCldr(numbersData);
 * loadCldr(numberSystemData);
 *
 * // To use formatter in component side
 * let Intl:Internationalization = new Internationalization();
 *
 * // Date formatting
 * let dateFormatter: Function = Intl.getDateFormat({skeleton:'long',type:'dateTime'});
 * dateFormatter(new Date('11/2/2016'));
 * dateFormatter(new Date('25/2/2030'));
 * Intl.formatDate(new Date(),{skeleton:'E'});
 *
 * //Number formatting
 * let numberFormatter: Function = Intl.getNumberFormat({skeleton:'C5'})
 * numberFormatter(24563334);
 * Intl.formatNumber(123123,{skeleton:'p2'});
 *
 * // Date parser
 * let dateParser: Function = Intl.getDateParser({skeleton:'short',type:'time'});
 * dateParser('10:30 PM');
 * Intl.parseDate('10',{skeleton:'H'});
 * ```
 */
var Internationalization = /** @class */ (function () {
    function Internationalization(cultureName) {
        if (cultureName) {
            this.culture = cultureName;
        }
    }
    /**
     * Returns the format function for given options.
     *
     * @param {DateFormatOptions} options - Specifies the format options in which the format function will return.
     * @returns {Function} ?
     */
    Internationalization.prototype.getDateFormat = function (options) {
        return DateFormat.dateFormat(this.getCulture(), options || { type: 'date', skeleton: 'short' }, cldrData);
    };
    /**
     * Returns the format function for given options.
     *
     * @param {NumberFormatOptions} options - Specifies the format options in which the format function will return.
     * @returns {Function} ?
     */
    Internationalization.prototype.getNumberFormat = function (options) {
        if (options && !options.currency) {
            options.currency = exports.defaultCurrencyCode;
        }
        if (isBlazor() && options && !options.format) {
            options.minimumFractionDigits = 0;
        }
        return NumberFormat.numberFormatter(this.getCulture(), options || {}, cldrData);
    };
    /**
     * Returns the parser function for given options.
     *
     * @param {DateFormatOptions} options - Specifies the format options in which the parser function will return.
     * @returns {Function} ?
     */
    Internationalization.prototype.getDateParser = function (options) {
        return DateParser.dateParser(this.getCulture(), options || { skeleton: 'short', type: 'date' }, cldrData);
    };
    /**
     * Returns the parser function for given options.
     *
     * @param {NumberFormatOptions} options - Specifies the format options in which the parser function will return.
     * @returns {Function} ?
     */
    Internationalization.prototype.getNumberParser = function (options) {
        if (isBlazor() && options && !options.format) {
            options.minimumFractionDigits = 0;
        }
        return NumberParser.numberParser(this.getCulture(), options || { format: 'N' }, cldrData);
    };
    /**
     * Returns the formatted string based on format options.
     *
     * @param {number} value - Specifies the number to format.
     * @param {NumberFormatOptions} option - Specifies the format options in which the number will be formatted.
     * @returns {string} ?
     */
    Internationalization.prototype.formatNumber = function (value, option) {
        return this.getNumberFormat(option)(value);
    };
    /**
     * Returns the formatted date string based on format options.
     *
     * @param {Date} value - Specifies the number to format.
     * @param {DateFormatOptions} option - Specifies the format options in which the number will be formatted.
     * @returns {string} ?
     */
    Internationalization.prototype.formatDate = function (value, option) {
        return this.getDateFormat(option)(value);
    };
    /**
     * Returns the date object for given date string and options.
     *
     * @param {string} value - Specifies the string to parse.
     * @param {DateFormatOptions} option - Specifies the parse options in which the date string will be parsed.
     * @returns {Date} ?
     */
    Internationalization.prototype.parseDate = function (value, option) {
        return this.getDateParser(option)(value);
    };
    /**
     * Returns the number object from the given string value and options.
     *
     * @param {string} value - Specifies the string to parse.
     * @param {NumberFormatOptions} option - Specifies the parse options in which the  string number  will be parsed.
     * @returns {number} ?
     */
    Internationalization.prototype.parseNumber = function (value, option) {
        return this.getNumberParser(option)(value);
    };
    /**
     * Returns Native Date Time Pattern
     *
     * @param {DateFormatOptions} option - Specifies the parse options for resultant date time pattern.
     * @param {boolean} isExcelFormat - Specifies format value to be converted to excel pattern.
     * @returns {string} ?
     * @private
     */
    Internationalization.prototype.getDatePattern = function (option, isExcelFormat) {
        return exports.IntlBase.getActualDateTimeFormat(this.getCulture(), option, cldrData, isExcelFormat);
    };
    /**
     * Returns Native Number Pattern
     *
     * @param {NumberFormatOptions} option - Specifies the parse options for resultant number pattern.
     * @param {boolean} isExcel ?
     * @returns {string} ?
     * @private
     */
    Internationalization.prototype.getNumberPattern = function (option, isExcel) {
        return exports.IntlBase.getActualNumberFormat(this.getCulture(), option, cldrData, isExcel);
    };
    /**
     * Returns the First Day of the Week
     *
     * @returns {number} ?
     */
    Internationalization.prototype.getFirstDayOfWeek = function () {
        return exports.IntlBase.getWeekData(this.getCulture(), cldrData);
    };
    /**
     * Returns the culture
     *
     * @returns {string} ?
     */
    Internationalization.prototype.getCulture = function () {
        return this.culture || exports.defaultCulture;
    };
    return Internationalization;
}());
/**
 * Set the default culture to all EJ2 components
 *
 * @param {string} cultureName - Specifies the culture name to be set as default culture.
 * @returns {void} ?
 */
function setCulture(cultureName) {
    exports.defaultCulture = cultureName;
    onIntlChange.notify('notifyExternalChange', { 'locale': exports.defaultCulture });
}
/**
 * Set the default currency code to all EJ2 components
 *
 * @param {string} currencyCode Specifies the culture name to be set as default culture.
 * @returns {void} ?
 */
function setCurrencyCode(currencyCode) {
    exports.defaultCurrencyCode = currencyCode;
    onIntlChange.notify('notifyExternalChange', { 'currencyCode': exports.defaultCurrencyCode });
}
/**
 * Load the CLDR data into context
 *
 * @param {Object[]} data Specifies the CLDR data's to be used for formatting and parser.
 * @returns {void} ?
 */
function loadCldr() {
    var data = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        data[_i] = arguments[_i];
    }
    for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
        var obj = data_1[_a];
        extend(cldrData, obj, {}, true);
    }
}
/**
 * To enable or disable RTL functionality for all components globally.
 *
 * @param {boolean} status - Optional argument Specifies the status value to enable or disable rtl option.
 * @returns {void} ?
 */
function enableRtl(status) {
    if (status === void 0) { status = true; }
    exports.rightToLeft = status;
    onIntlChange.notify('notifyExternalChange', { enableRtl: exports.rightToLeft });
}
/**
 * To get the numeric CLDR object for given culture
 *
 * @param {string} locale - Specifies the locale for which numericObject to be returned.
 * @param {string} type ?
 * @returns {Object} ?
 * @ignore
 * @private
 */
function getNumericObject(locale, type) {
    // eslint-disable-next-line
    var numObject = exports.IntlBase.getDependables(cldrData, locale, '', true)[mapper[0]];
    // eslint-disable-next-line
    var dateObject = exports.IntlBase.getDependables(cldrData, locale, '')[mapper[1]];
    var numSystem = getValue('defaultNumberingSystem', numObject);
    var symbPattern = isBlazor() ? getValue('numberSymbols', numObject) : getValue('symbols-numberSystem-' + numSystem, numObject);
    var pattern = exports.IntlBase.getSymbolPattern(type || 'decimal', numSystem, numObject, false);
    return extend(symbPattern, exports.IntlBase.getFormatData(pattern, true, '', true), { 'dateSeparator': exports.IntlBase.getDateSeparator(dateObject) });
}
/**
 * To get the numeric CLDR  number base object for given culture
 *
 * @param {string} locale - Specifies the locale for which numericObject to be returned.
 * @param {string} currency - Specifies the currency for which numericObject to be returned.
 * @returns {string} ?
 * @ignore
 * @private
 */
function getNumberDependable(locale, currency) {
    // eslint-disable-next-line
    var numObject = exports.IntlBase.getDependables(cldrData, locale, '', true);
    // eslint-disable-next-line
    return exports.IntlBase.getCurrencySymbol(numObject.numericObject, currency);
}
/**
 * To get the default date CLDR object.
 *
 * @param {string} mode ?
 * @returns {Object} ?
 * @ignore
 * @private
 */
function getDefaultDateObject(mode) {
    // eslint-disable-next-line
    return exports.IntlBase.getDependables(cldrData, '', mode, false)[mapper[1]];
}

var blazorCultureFormats = {
    'en-US': {
        'd': 'M/d/y',
        'D': 'EEEE, MMMM d, y',
        'f': 'EEEE, MMMM d, y h:mm a',
        'F': 'EEEE, MMMM d, y h:mm:s a',
        'g': 'M/d/y h:mm a',
        'G': 'M/d/yyyy h:mm:ss tt',
        'm': 'MMMM d',
        'M': 'MMMM d',
        'r': 'ddd, dd MMM yyyy HH\':\'mm\':\'ss \'GMT\'',
        'R': 'ddd, dd MMM yyyy HH\':\'mm\':\'ss \'GMT\'',
        's': 'yyyy\'-\'MM\'-\'dd\'T\'HH\':\'mm\':\'ss',
        't': 'h:mm tt',
        'T': 'h:m:s tt',
        'u': 'yyyy\'-\'MM\'-\'dd HH\':\'mm\':\'ss\'Z\'',
        'U': 'dddd, MMMM d, yyyy h:mm:ss tt',
        'y': 'MMMM yyyy',
        'Y': 'MMMM yyyy'
    }
};
/**
 * Date base common constants and function for date parser and formatter.
 */
// eslint-disable-next-line

(function (IntlBase) {
    // tslint:disable-next-line:max-line-length
    IntlBase.negativeDataRegex = /^(('[^']+'|''|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
    IntlBase.customRegex = /^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
    IntlBase.latnParseRegex = /0|1|2|3|4|5|6|7|8|9/g;
    var fractionRegex = /[0-9]/g;
    IntlBase.defaultCurrency = '$';
    var mapper = ['infinity', 'nan', 'group', 'decimal'];
    var patternRegex = /G|M|L|H|c|'| a|yy|y|EEEE|E/g;
    var patternMatch = {
        'G': '',
        'M': 'm',
        'L': 'm',
        'H': 'h',
        'c': 'd',
        '\'': '"',
        ' a': ' AM/PM',
        'yy': 'yy',
        'y': 'yyyy',
        'EEEE': 'dddd',
        'E': 'ddd'
    };
    IntlBase.dateConverterMapper = /dddd|ddd/ig;
    var defaultFirstDay = 'sun';
    IntlBase.islamicRegex = /^islamic/;
    var firstDayMapper = {
        'sun': 0,
        'mon': 1,
        'tue': 2,
        'wed': 3,
        'thu': 4,
        'fri': 5,
        'sat': 6
    };
    IntlBase.formatRegex = /(^[ncpae]{1})([0-1]?[0-9]|20)?$/i;
    IntlBase.currencyFormatRegex = /(^[ca]{1})([0-1]?[0-9]|20)?$/i;
    IntlBase.curWithoutNumberRegex = /(c|a)$/ig;
    var typeMapper = {
        '$': 'isCurrency',
        '%': 'isPercent',
        '-': 'isNegative',
        0: 'nlead',
        1: 'nend'
    };
    IntlBase.dateParseRegex = /([a-z])\1*|'([^']|'')+'|''|./gi;
    IntlBase.basicPatterns = ['short', 'medium', 'long', 'full'];
    /* tslint:disable:quotemark */
    IntlBase.defaultObject = {
        'dates': {
            'calendars': {
                'gregorian': {
                    'months': {
                        'stand-alone': {
                            'abbreviated': {
                                '1': 'Jan',
                                '2': 'Feb',
                                '3': 'Mar',
                                '4': 'Apr',
                                '5': 'May',
                                '6': 'Jun',
                                '7': 'Jul',
                                '8': 'Aug',
                                '9': 'Sep',
                                '10': 'Oct',
                                '11': 'Nov',
                                '12': 'Dec'
                            },
                            'narrow': {
                                '1': 'J',
                                '2': 'F',
                                '3': 'M',
                                '4': 'A',
                                '5': 'M',
                                '6': 'J',
                                '7': 'J',
                                '8': 'A',
                                '9': 'S',
                                '10': 'O',
                                '11': 'N',
                                '12': 'D'
                            },
                            'wide': {
                                '1': 'January',
                                '2': 'February',
                                '3': 'March',
                                '4': 'April',
                                '5': 'May',
                                '6': 'June',
                                '7': 'July',
                                '8': 'August',
                                '9': 'September',
                                '10': 'October',
                                '11': 'November',
                                '12': 'December'
                            }
                        }
                    },
                    'days': {
                        'stand-alone': {
                            'abbreviated': {
                                'sun': 'Sun',
                                'mon': 'Mon',
                                'tue': 'Tue',
                                'wed': 'Wed',
                                'thu': 'Thu',
                                'fri': 'Fri',
                                'sat': 'Sat'
                            },
                            'narrow': {
                                'sun': 'S',
                                'mon': 'M',
                                'tue': 'T',
                                'wed': 'W',
                                'thu': 'T',
                                'fri': 'F',
                                'sat': 'S'
                            },
                            'short': {
                                'sun': 'Su',
                                'mon': 'Mo',
                                'tue': 'Tu',
                                'wed': 'We',
                                'thu': 'Th',
                                'fri': 'Fr',
                                'sat': 'Sa'
                            },
                            'wide': {
                                'sun': 'Sunday',
                                'mon': 'Monday',
                                'tue': 'Tuesday',
                                'wed': 'Wednesday',
                                'thu': 'Thursday',
                                'fri': 'Friday',
                                'sat': 'Saturday'
                            }
                        }
                    },
                    'dayPeriods': {
                        'format': {
                            'wide': {
                                'am': 'AM',
                                'pm': 'PM'
                            }
                        }
                    },
                    'eras': {
                        'eraNames': {
                            '0': 'Before Christ',
                            '0-alt-variant': 'Before Common Era',
                            '1': 'Anno Domini',
                            '1-alt-variant': 'Common Era'
                        },
                        'eraAbbr': {
                            '0': 'BC',
                            '0-alt-variant': 'BCE',
                            '1': 'AD',
                            '1-alt-variant': 'CE'
                        },
                        'eraNarrow': {
                            '0': 'B',
                            '0-alt-variant': 'BCE',
                            '1': 'A',
                            '1-alt-variant': 'CE'
                        }
                    },
                    'dateFormats': {
                        'full': 'EEEE, MMMM d, y',
                        'long': 'MMMM d, y',
                        'medium': 'MMM d, y',
                        'short': 'M/d/yy'
                    },
                    'timeFormats': {
                        'full': 'h:mm:ss a zzzz',
                        'long': 'h:mm:ss a z',
                        'medium': 'h:mm:ss a',
                        'short': 'h:mm a'
                    },
                    'dateTimeFormats': {
                        'full': '{1} \'at\' {0}',
                        'long': '{1} \'at\' {0}',
                        'medium': '{1}, {0}',
                        'short': '{1}, {0}',
                        'availableFormats': {
                            'd': 'd',
                            'E': 'ccc',
                            'Ed': 'd E',
                            'Ehm': 'E h:mm a',
                            'EHm': 'E HH:mm',
                            'Ehms': 'E h:mm:ss a',
                            'EHms': 'E HH:mm:ss',
                            'Gy': 'y G',
                            'GyMMM': 'MMM y G',
                            'GyMMMd': 'MMM d, y G',
                            'GyMMMEd': 'E, MMM d, y G',
                            'h': 'h a',
                            'H': 'HH',
                            'hm': 'h:mm a',
                            'Hm': 'HH:mm',
                            'hms': 'h:mm:ss a',
                            'Hms': 'HH:mm:ss',
                            'hmsv': 'h:mm:ss a v',
                            'Hmsv': 'HH:mm:ss v',
                            'hmv': 'h:mm a v',
                            'Hmv': 'HH:mm v',
                            'M': 'L',
                            'Md': 'M/d',
                            'MEd': 'E, M/d',
                            'MMM': 'LLL',
                            'MMMd': 'MMM d',
                            'MMMEd': 'E, MMM d',
                            'MMMMd': 'MMMM d',
                            'ms': 'mm:ss',
                            'y': 'y',
                            'yM': 'M/y',
                            'yMd': 'M/d/y',
                            'yMEd': 'E, M/d/y',
                            'yMMM': 'MMM y',
                            'yMMMd': 'MMM d, y',
                            'yMMMEd': 'E, MMM d, y',
                            'yMMMM': 'MMMM y'
                        }
                    }
                },
                'islamic': {
                    'months': {
                        'stand-alone': {
                            'abbreviated': {
                                '1': 'Muh.',
                                '2': 'Saf.',
                                '3': 'Rab. I',
                                '4': 'Rab. II',
                                '5': 'Jum. I',
                                '6': 'Jum. II',
                                '7': 'Raj.',
                                '8': 'Sha.',
                                '9': 'Ram.',
                                '10': 'Shaw.',
                                '11': 'Dhuʻl-Q.',
                                '12': 'Dhuʻl-H.'
                            },
                            'narrow': {
                                '1': '1',
                                '2': '2',
                                '3': '3',
                                '4': '4',
                                '5': '5',
                                '6': '6',
                                '7': '7',
                                '8': '8',
                                '9': '9',
                                '10': '10',
                                '11': '11',
                                '12': '12'
                            },
                            'wide': {
                                '1': 'Muharram',
                                '2': 'Safar',
                                '3': 'Rabiʻ I',
                                '4': 'Rabiʻ II',
                                '5': 'Jumada I',
                                '6': 'Jumada II',
                                '7': 'Rajab',
                                '8': 'Shaʻban',
                                '9': 'Ramadan',
                                '10': 'Shawwal',
                                '11': 'Dhuʻl-Qiʻdah',
                                '12': 'Dhuʻl-Hijjah'
                            }
                        }
                    },
                    'days': {
                        'stand-alone': {
                            'abbreviated': {
                                'sun': 'Sun',
                                'mon': 'Mon',
                                'tue': 'Tue',
                                'wed': 'Wed',
                                'thu': 'Thu',
                                'fri': 'Fri',
                                'sat': 'Sat'
                            },
                            'narrow': {
                                'sun': 'S',
                                'mon': 'M',
                                'tue': 'T',
                                'wed': 'W',
                                'thu': 'T',
                                'fri': 'F',
                                'sat': 'S'
                            },
                            'short': {
                                'sun': 'Su',
                                'mon': 'Mo',
                                'tue': 'Tu',
                                'wed': 'We',
                                'thu': 'Th',
                                'fri': 'Fr',
                                'sat': 'Sa'
                            },
                            'wide': {
                                'sun': 'Sunday',
                                'mon': 'Monday',
                                'tue': 'Tuesday',
                                'wed': 'Wednesday',
                                'thu': 'Thursday',
                                'fri': 'Friday',
                                'sat': 'Saturday'
                            }
                        }
                    },
                    'dayPeriods': {
                        'format': {
                            'wide': {
                                'am': 'AM',
                                'pm': 'PM'
                            }
                        }
                    },
                    'eras': {
                        'eraNames': {
                            '0': 'AH'
                        },
                        'eraAbbr': {
                            '0': 'AH'
                        },
                        'eraNarrow': {
                            '0': 'AH'
                        }
                    },
                    'dateFormats': {
                        'full': 'EEEE, MMMM d, y G',
                        'long': 'MMMM d, y G',
                        'medium': 'MMM d, y G',
                        'short': 'M/d/y GGGGG'
                    },
                    'timeFormats': {
                        'full': 'h:mm:ss a zzzz',
                        'long': 'h:mm:ss a z',
                        'medium': 'h:mm:ss a',
                        'short': 'h:mm a'
                    },
                    'dateTimeFormats': {
                        'full': '{1} \'at\' {0}',
                        'long': '{1} \'at\' {0}',
                        'medium': '{1}, {0}',
                        'short': '{1}, {0}',
                        'availableFormats': {
                            'd': 'd',
                            'E': 'ccc',
                            'Ed': 'd E',
                            'Ehm': 'E h:mm a',
                            'EHm': 'E HH:mm',
                            'Ehms': 'E h:mm:ss a',
                            'EHms': 'E HH:mm:ss',
                            'Gy': 'y G',
                            'GyMMM': 'MMM y G',
                            'GyMMMd': 'MMM d, y G',
                            'GyMMMEd': 'E, MMM d, y G',
                            'h': 'h a',
                            'H': 'HH',
                            'hm': 'h:mm a',
                            'Hm': 'HH:mm',
                            'hms': 'h:mm:ss a',
                            'Hms': 'HH:mm:ss',
                            'M': 'L',
                            'Md': 'M/d',
                            'MEd': 'E, M/d',
                            'MMM': 'LLL',
                            'MMMd': 'MMM d',
                            'MMMEd': 'E, MMM d',
                            'MMMMd': 'MMMM d',
                            'ms': 'mm:ss',
                            'y': 'y G',
                            'yyyy': 'y G',
                            'yyyyM': 'M/y GGGGG',
                            'yyyyMd': 'M/d/y GGGGG',
                            'yyyyMEd': 'E, M/d/y GGGGG',
                            'yyyyMMM': 'MMM y G',
                            'yyyyMMMd': 'MMM d, y G',
                            'yyyyMMMEd': 'E, MMM d, y G',
                            'yyyyMMMM': 'MMMM y G',
                            'yyyyQQQ': 'QQQ y G',
                            'yyyyQQQQ': 'QQQQ y G'
                        }
                    }
                }
            },
            'timeZoneNames': {
                'hourFormat': '+HH:mm;-HH:mm',
                'gmtFormat': 'GMT{0}',
                'gmtZeroFormat': 'GMT'
            }
        },
        'numbers': {
            'currencies': {
                'USD': {
                    'displayName': 'US Dollar',
                    'symbol': '$',
                    'symbol-alt-narrow': '$'
                },
                'EUR': {
                    'displayName': 'Euro',
                    'symbol': '€',
                    'symbol-alt-narrow': '€'
                },
                'GBP': {
                    'displayName': 'British Pound',
                    'symbol-alt-narrow': '£'
                }
            },
            'defaultNumberingSystem': 'latn',
            'minimumGroupingDigits': '1',
            'symbols-numberSystem-latn': {
                'decimal': '.',
                'group': ',',
                'list': ';',
                'percentSign': '%',
                'plusSign': '+',
                'minusSign': '-',
                'exponential': 'E',
                'superscriptingExponent': '×',
                'perMille': '‰',
                'infinity': '∞',
                'nan': 'NaN',
                'timeSeparator': ':'
            },
            'decimalFormats-numberSystem-latn': {
                'standard': '#,##0.###'
            },
            'percentFormats-numberSystem-latn': {
                'standard': '#,##0%'
            },
            'currencyFormats-numberSystem-latn': {
                'standard': '¤#,##0.00',
                'accounting': '¤#,##0.00;(¤#,##0.00)'
            },
            'scientificFormats-numberSystem-latn': {
                'standard': '#E0'
            }
        }
    };
    IntlBase.blazorDefaultObject = {
        'numbers': {
            'mapper': {
                '0': '0',
                '1': '1',
                '2': '2',
                '3': '3',
                '4': '4',
                '5': '5',
                '6': '6',
                '7': '7',
                '8': '8',
                '9': '9'
            },
            'mapperDigits': '0123456789',
            'numberSymbols': {
                'decimal': '.',
                'group': ',',
                'plusSign': '+',
                'minusSign': '-',
                'percentSign': '%',
                'nan': 'NaN',
                'timeSeparator': ':',
                'infinity': '∞'
            },
            'timeSeparator': ':',
            'currencySymbol': '$',
            'currencypData': {
                'nlead': '$',
                'nend': '',
                'groupSeparator': ',',
                'groupData': {
                    'primary': 3
                },
                'maximumFraction': 2,
                'minimumFraction': 2
            },
            'percentpData': {
                'nlead': '',
                'nend': '%',
                'groupSeparator': ',',
                'groupData': {
                    'primary': 3
                },
                'maximumFraction': 2,
                'minimumFraction': 2
            },
            'percentnData': {
                'nlead': '-',
                'nend': '%',
                'groupSeparator': ',',
                'groupData': {
                    'primary': 3
                },
                'maximumFraction': 2,
                'minimumFraction': 2
            },
            'currencynData': {
                'nlead': '($',
                'nend': ')',
                'groupSeparator': ',',
                'groupData': {
                    'primary': 3
                },
                'maximumFraction': 2,
                'minimumFraction': 2
            },
            'decimalnData': {
                'nlead': '-',
                'nend': '',
                'groupData': {
                    'primary': 3
                },
                'maximumFraction': 2,
                'minimumFraction': 2
            },
            'decimalpData': {
                'nlead': '',
                'nend': '',
                'groupData': {
                    'primary': 3
                },
                'maximumFraction': 2,
                'minimumFraction': 2
            }
        },
        'dates': {
            'dayPeriods': {
                'am': 'AM',
                'pm': 'PM'
            },
            'dateSeperator': '/',
            'days': {
                'abbreviated': {
                    'sun': 'Sun',
                    'mon': 'Mon',
                    'tue': 'Tue',
                    'wed': 'Wed',
                    'thu': 'Thu',
                    'fri': 'Fri',
                    'sat': 'Sat'
                },
                'short': {
                    'sun': 'Su',
                    'mon': 'Mo',
                    'tue': 'Tu',
                    'wed': 'We',
                    'thu': 'Th',
                    'fri': 'Fr',
                    'sat': 'Sa'
                },
                'wide': {
                    'sun': 'Sunday',
                    'mon': 'Monday',
                    'tue': 'Tuesday',
                    'wed': 'Wednesday',
                    'thu': 'Thursday',
                    'fri': 'Friday',
                    'sat': 'Saturday'
                }
            },
            'months': {
                'abbreviated': {
                    '1': 'Jan',
                    '2': 'Feb',
                    '3': 'Mar',
                    '4': 'Apr',
                    '5': 'May',
                    '6': 'Jun',
                    '7': 'Jul',
                    '8': 'Aug',
                    '9': 'Sep',
                    '10': 'Oct',
                    '11': 'Nov',
                    '12': 'Dec'
                },
                'wide': {
                    '1': 'January',
                    '2': 'February',
                    '3': 'March',
                    '4': 'April',
                    '5': 'May',
                    '6': 'June',
                    '7': 'July',
                    '8': 'August',
                    '9': 'September',
                    '10': 'October',
                    '11': 'November',
                    '12': 'December'
                }
            },
            'eras': {
                '1': 'AD'
            }
        }
    };
    /* tslint:enable:quotemark */
    IntlBase.monthIndex = {
        3: 'abbreviated',
        4: 'wide',
        5: 'narrow',
        1: 'abbreviated'
    };
    /**
     *
     */
    IntlBase.month = 'months';
    IntlBase.days = 'days';
    /**
     * Default numerber Object
     */
    IntlBase.patternMatcher = {
        C: 'currency',
        P: 'percent',
        N: 'decimal',
        A: 'currency',
        E: 'scientific'
    };
    /**
     * Returns the resultant pattern based on the skeleton, dateObject and the type provided
     *
     * @private
     * @param {string} skeleton ?
     * @param {Object} dateObject ?
     * @param {string} type ?
     * @param {boolean} isIslamic ?
     * @param {string} blazorCulture ?
     * @returns {string} ?
     */
    function getResultantPattern(skeleton, dateObject, type, isIslamic, blazorCulture) {
        var resPattern;
        var iType = type || 'date';
        if (blazorCulture) {
            resPattern = compareBlazorDateFormats({ skeleton: skeleton }, blazorCulture).format ||
                compareBlazorDateFormats({ skeleton: 'd' }, 'en-US').format;
        }
        else {
            if (IntlBase.basicPatterns.indexOf(skeleton) !== -1) {
                resPattern = getValue(iType + 'Formats.' + skeleton, dateObject);
                if (iType === 'dateTime') {
                    var dPattern = getValue('dateFormats.' + skeleton, dateObject);
                    var tPattern = getValue('timeFormats.' + skeleton, dateObject);
                    resPattern = resPattern.replace('{1}', dPattern).replace('{0}', tPattern);
                }
            }
            else {
                resPattern = getValue('dateTimeFormats.availableFormats.' + skeleton, dateObject);
            }
            if (isUndefined(resPattern) && skeleton === 'yMd') {
                resPattern = 'M/d/y';
            }
        }
        return resPattern;
    }
    IntlBase.getResultantPattern = getResultantPattern;
    /**
     * Returns the dependable object for provided cldr data and culture
     *
     * @private
     * @param {Object} cldr ?
     * @param {string} culture ?
     * @param {string} mode ?
     * @param {boolean} isNumber ?
     * @returns {any} ?
     */
    function getDependables(cldr, culture, mode, isNumber) {
        var ret = {};
        var calendartype = mode || 'gregorian';
        ret.parserObject = ParserBase.getMainObject(cldr, culture) || (isBlazor() ? IntlBase.blazorDefaultObject : IntlBase.defaultObject);
        if (isNumber) {
            ret.numericObject = getValue('numbers', ret.parserObject);
        }
        else {
            var dateString = isBlazor() ? 'dates' : ('dates.calendars.' + calendartype);
            ret.dateObject = getValue(dateString, ret.parserObject);
        }
        return ret;
    }
    IntlBase.getDependables = getDependables;
    /**
     * Returns the symbol pattern for provided parameters
     *
     * @private
     * @param {string} type ?
     * @param {string} numSystem ?
     * @param {Object} obj ?
     * @param {boolean} isAccount ?
     * @returns {string} ?
     */
    function getSymbolPattern(type, numSystem, obj, isAccount) {
        return getValue(type + 'Formats-numberSystem-' +
            numSystem + (isAccount ? '.accounting' : '.standard'), obj) || (isAccount ? getValue(type + 'Formats-numberSystem-' +
            numSystem + '.standard', obj) : '');
    }
    IntlBase.getSymbolPattern = getSymbolPattern;
    /**
     *
     * @param {string} format ?
     * @returns {string} ?
     */
    function ConvertDateToWeekFormat(format) {
        var convertMapper = format.match(IntlBase.dateConverterMapper);
        if (convertMapper && isBlazor()) {
            var tempString = convertMapper[0].length === 3 ? 'EEE' : 'EEEE';
            return format.replace(IntlBase.dateConverterMapper, tempString);
        }
        return format;
    }
    IntlBase.ConvertDateToWeekFormat = ConvertDateToWeekFormat;
    /**
     *
     * @param {DateFormatOptions} formatOptions ?
     * @param {string} culture ?
     * @returns {DateFormatOptions} ?
     */
    function compareBlazorDateFormats(formatOptions, culture) {
        var format = formatOptions.format || formatOptions.skeleton;
        var curFormatMapper = getValue((culture || 'en-US') + '.' + format, blazorCultureFormats);
        if (!curFormatMapper) {
            curFormatMapper = getValue('en-US.' + format, blazorCultureFormats);
        }
        if (curFormatMapper) {
            curFormatMapper = ConvertDateToWeekFormat(curFormatMapper);
            formatOptions.format = curFormatMapper.replace(/tt/, 'a');
        }
        return formatOptions;
    }
    IntlBase.compareBlazorDateFormats = compareBlazorDateFormats;
    /**
     * Returns proper numeric skeleton
     *
     * @private
     * @param {string} skeleton ?
     * @returns {any} ?
     */
    function getProperNumericSkeleton(skeleton) {
        var matches = skeleton.match(IntlBase.formatRegex);
        var ret = {};
        var pattern = matches[1].toUpperCase();
        ret.isAccount = (pattern === 'A');
        // eslint-disable-next-line
        ret.type = IntlBase.patternMatcher[pattern];
        if (skeleton.length > 1) {
            ret.fractionDigits = parseInt(matches[2], 10);
        }
        return ret;
    }
    IntlBase.getProperNumericSkeleton = getProperNumericSkeleton;
    /**
     * Returns format data for number formatting like minimum fraction, maximum fraction, etc..,
     *
     * @private
     * @param {string} pattern ?
     * @param {boolean} needFraction ?
     * @param {string} cSymbol ?
     * @param {boolean} fractionOnly ?
     * @returns {any} ?
     */
    function getFormatData(pattern, needFraction, cSymbol, fractionOnly) {
        var nData = fractionOnly ? {} : { nlead: '', nend: '' };
        var match = pattern.match(IntlBase.customRegex);
        if (match) {
            if (!fractionOnly) {
                nData.nlead = changeCurrencySymbol(match[1], cSymbol);
                nData.nend = changeCurrencySymbol(match[10], cSymbol);
                nData.groupPattern = match[4];
            }
            var fraction = match[7];
            if (fraction && needFraction) {
                var fmatch = fraction.match(fractionRegex);
                if (!isNullOrUndefined(fmatch)) {
                    nData.minimumFraction = fmatch.length;
                }
                else {
                    nData.minimumFraction = 0;
                }
                nData.maximumFraction = fraction.length - 1;
            }
        }
        return nData;
    }
    IntlBase.getFormatData = getFormatData;
    /**
     * Changes currency symbol
     *
     * @private
     * @param {string} val ?
     * @param {string} sym ?
     * @returns {string} ?
     */
    function changeCurrencySymbol(val, sym) {
        if (val) {
            return val.replace(IntlBase.defaultCurrency, sym);
        }
        return '';
    }
    IntlBase.changeCurrencySymbol = changeCurrencySymbol;
    /**
     * Returns currency symbol based on currency code ?
     *
     * @private
     * @param {Object} numericObject ?
     * @param {string} currencyCode ?
     * @param {string} altSymbol ?
     * @returns {string} ?
     */
    function getCurrencySymbol(numericObject, currencyCode, altSymbol) {
        var symbol = altSymbol ? ('.' + altSymbol) : '.symbol';
        var getCurrency = getValue('currencies.' + currencyCode + symbol, numericObject) ||
            getValue('currencies.' + currencyCode + '.symbol-alt-narrow', numericObject) || '$';
        return getCurrency;
    }
    IntlBase.getCurrencySymbol = getCurrencySymbol;
    /**
     * Returns formatting options for custom number format
     *
     * @private
     * @param {string} format ?
     * @param {CommonOptions} dOptions ?
     * @param {any} obj ?
     * @returns {any} ?
     */
    function customFormat(format, dOptions, obj) {
        var options = {};
        var formatSplit = format.split(';');
        var data = ['pData', 'nData', 'zeroData'];
        for (var i = 0; i < formatSplit.length; i++) {
            // eslint-disable-next-line
            options[data[i]] = customNumberFormat(formatSplit[i], dOptions, obj);
        }
        if (isNullOrUndefined(options.nData)) {
            options.nData = extend({}, options.pData);
            options.nData.nlead = isNullOrUndefined(dOptions) ? '-' + options.nData.nlead : dOptions.minusSymbol + options.nData.nlead;
        }
        return options;
    }
    IntlBase.customFormat = customFormat;
    /**
     * Returns custom formatting options
     *
     * @private
     * @param {string} format ?
     * @param {CommonOptions} dOptions ?
     * @param {Object} numObject ?
     * @returns {any} ?
     */
    function customNumberFormat(format, dOptions, numObject) {
        var cOptions = { type: 'decimal', minimumFractionDigits: 0, maximumFractionDigits: 0 };
        var pattern = format.match(IntlBase.customRegex);
        if (isNullOrUndefined(pattern) || (pattern[5] === '' && format !== 'N/A')) {
            cOptions.type = undefined;
            return cOptions;
        }
        cOptions.nlead = pattern[1];
        cOptions.nend = pattern[10];
        var integerPart = pattern[6];
        cOptions.useGrouping = integerPart.indexOf(',') !== -1;
        integerPart = integerPart.replace(/,/g, '');
        var fractionPart = pattern[7];
        if (integerPart.indexOf('0') !== -1) {
            cOptions.minimumIntegerDigits = integerPart.length - integerPart.indexOf('0');
        }
        if (!isNullOrUndefined(fractionPart)) {
            cOptions.minimumFractionDigits = fractionPart.lastIndexOf('0');
            cOptions.maximumFractionDigits = fractionPart.lastIndexOf('#');
            if (cOptions.minimumFractionDigits === -1) {
                cOptions.minimumFractionDigits = 0;
            }
            if (cOptions.maximumFractionDigits === -1 || cOptions.maximumFractionDigits < cOptions.minimumFractionDigits) {
                cOptions.maximumFractionDigits = cOptions.minimumFractionDigits;
            }
        }
        if (!isNullOrUndefined(dOptions)) {
            extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], '$', dOptions.currencySymbol));
            if (!cOptions.isCurrency) {
                extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], '%', dOptions.percentSymbol));
            }
        }
        else {
            extend(cOptions, isCurrencyPercent([cOptions.nlead, cOptions.nend], '%', '%'));
        }
        if (!isNullOrUndefined(numObject)) {
            var symbolPattern = getSymbolPattern(cOptions.type, dOptions.numberMapper.numberSystem, numObject, false);
            if (cOptions.useGrouping) {
                // eslint-disable-next-line
                cOptions.groupSeparator = dOptions.numberMapper.numberSymbols[mapper[2]];
                cOptions.groupData = NumberFormat.getGroupingDetails(symbolPattern.split(';')[0]);
            }
            cOptions.nlead = cOptions.nlead.replace(/'/g, '');
            cOptions.nend = cOptions.nend.replace(/'/g, '');
        }
        return cOptions;
    }
    IntlBase.customNumberFormat = customNumberFormat;
    /**
     * Returns formatting options for currency or percent type
     *
     * @private
     * @param {string[]} parts ?
     * @param {string} actual ?
     * @param {string} symbol ?
     * @returns {any} ?
     */
    function isCurrencyPercent(parts, actual, symbol) {
        var options = { nlead: parts[0], nend: parts[1] };
        for (var i = 0; i < 2; i++) {
            var part = parts[i];
            var loc = part.indexOf(actual);
            if ((loc !== -1) && ((loc < part.indexOf('\'')) || (loc > part.lastIndexOf('\'')))) {
                // eslint-disable-next-line
                options[typeMapper[i]] = part.substr(0, loc) + symbol + part.substr(loc + 1);
                // eslint-disable-next-line
                options[typeMapper[actual]] = true;
                options.type = options.isCurrency ? 'currency' : 'percent';
                break;
            }
        }
        return options;
    }
    IntlBase.isCurrencyPercent = isCurrencyPercent;
    /**
     * Returns culture based date separator
     *
     * @private
     * @param {Object} dateObj ?
     * @returns {string} ?
     */
    function getDateSeparator(dateObj) {
        var value = (getValue('dateFormats.short', dateObj) || '').match(/[d‏M‏]([^d‏M])[d‏M‏]/i);
        return value ? value[1] : '/';
    }
    IntlBase.getDateSeparator = getDateSeparator;
    /**
     * Returns Native Date Time pattern
     *
     * @private
     * @param {string} culture ?
     * @param {DateFormatOptions} options ?
     * @param {Object} cldr ?
     * @param {boolean} isExcelFormat ?
     * @returns {string} ?
     */
    function getActualDateTimeFormat(culture, options, cldr, isExcelFormat) {
        var dependable = getDependables(cldr, culture, options.calendar);
        if (isBlazor()) {
            options = compareBlazorDateFormats(options, culture);
        }
        var actualPattern = options.format || getResultantPattern(options.skeleton, dependable.dateObject, options.type);
        if (isExcelFormat) {
            actualPattern = actualPattern.replace(patternRegex, function (pattern) {
                // eslint-disable-next-line
                return patternMatch[pattern];
            });
            if (actualPattern.indexOf('z') !== -1) {
                var tLength = actualPattern.match(/z/g).length;
                var timeZonePattern = void 0;
                var options_1 = { 'timeZone': {} };
                options_1.numMapper = ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr));
                options_1.timeZone = getValue('dates.timeZoneNames', dependable.parserObject);
                var value = new Date();
                var timezone = value.getTimezoneOffset();
                var pattern = (tLength < 4) ? '+H;-H' : options_1.timeZone.hourFormat;
                pattern = pattern.replace(/:/g, options_1.numMapper.timeSeparator);
                if (timezone === 0) {
                    timeZonePattern = options_1.timeZone.gmtZeroFormat;
                }
                else {
                    timeZonePattern = DateFormat.getTimeZoneValue(timezone, pattern);
                    timeZonePattern = options_1.timeZone.gmtFormat.replace(/\{0\}/, timeZonePattern);
                }
                actualPattern = actualPattern.replace(/[z]+/, '"' + timeZonePattern + '"');
            }
            actualPattern = actualPattern.replace(/ $/, '');
        }
        return actualPattern;
    }
    IntlBase.getActualDateTimeFormat = getActualDateTimeFormat;
    /**
     *
     * @param {string} actual ?
     * @param {any} option ?
     * @returns {any} ?
     */
    // eslint-disable-next-line
    function processSymbol(actual, option) {
        if (actual.indexOf(',') !== -1) {
            // eslint-disable-next-line
            var split = actual.split(',');
            actual = (split[0] + getValue('numberMapper.numberSymbols.group', option) +
                split[1].replace('.', getValue('numberMapper.numberSymbols.decimal', option)));
        }
        else {
            actual = actual.replace('.', getValue('numberMapper.numberSymbols.decimal', option));
        }
        return actual;
    }
    /**
     * Returns Native Number pattern
     *
     * @private
     * @param {string} culture ?
     * @param {NumberFormatOptions} options ?
     * @param {Object} cldr ?
     * @param {boolean} isExcel ?
     * @returns {string} ?
     */
    function getActualNumberFormat(culture, options, cldr, isExcel) {
        var dependable = getDependables(cldr, culture, '', true);
        var parseOptions = { custom: true };
        var numrericObject = dependable.numericObject;
        var minFrac;
        var curObj = {};
        var curMatch = (options.format || '').match(IntlBase.currencyFormatRegex);
        var type = IntlBase.formatRegex.test(options.format) ? getProperNumericSkeleton(options.format || 'N') : {};
        var dOptions = {};
        if (curMatch) {
            dOptions.numberMapper = isBlazor() ?
                extend({}, dependable.numericObject) :
                ParserBase.getNumberMapper(dependable.parserObject, ParserBase.getNumberingSystem(cldr), true);
            var curCode = isBlazor() ? getValue('currencySymbol', dependable.numericObject) :
                getCurrencySymbol(dependable.numericObject, options.currency || exports.defaultCurrencyCode, options.altSymbol);
            var symbolPattern = getSymbolPattern('currency', dOptions.numberMapper.numberSystem, dependable.numericObject, (/a/i).test(options.format));
            symbolPattern = symbolPattern.replace(/\u00A4/g, curCode);
            var split = symbolPattern.split(';');
            curObj.hasNegativePattern = isBlazor() ? true : (split.length > 1);
            curObj.nData = isBlazor() ? getValue(type.type + 'nData', numrericObject) :
                getFormatData(split[1] || '-' + split[0], true, curCode);
            curObj.pData = isBlazor() ? getValue(type.type + 'pData', numrericObject) :
                getFormatData(split[0], false, curCode);
            if (!curMatch[2] && !options.minimumFractionDigits && !options.maximumFractionDigits) {
                minFrac = getFormatData(symbolPattern.split(';')[0], true, '', true).minimumFraction;
            }
        }
        var actualPattern;
        if ((IntlBase.formatRegex.test(options.format)) || !(options.format)) {
            extend(parseOptions, getProperNumericSkeleton(options.format || 'N'));
            parseOptions.custom = false;
            actualPattern = '###0';
            if (parseOptions.fractionDigits || options.minimumFractionDigits || options.maximumFractionDigits || minFrac) {
                var defaultMinimum = 0;
                if (parseOptions.fractionDigits) {
                    options.minimumFractionDigits = options.maximumFractionDigits = parseOptions.fractionDigits;
                }
                actualPattern = fractionDigitsPattern(actualPattern, minFrac || parseOptions.fractionDigits ||
                    options.minimumFractionDigits || defaultMinimum, options.maximumFractionDigits || defaultMinimum);
            }
            if (options.minimumIntegerDigits) {
                actualPattern = minimumIntegerPattern(actualPattern, options.minimumIntegerDigits);
            }
            if (options.useGrouping) {
                actualPattern = groupingPattern(actualPattern);
            }
            if (parseOptions.type === 'currency' || (parseOptions.type && isBlazor())) {
                if (isBlazor() && parseOptions.type !== 'currency') {
                    curObj.pData = getValue(parseOptions.type + 'pData', numrericObject);
                    curObj.nData = getValue(parseOptions.type + 'nData', numrericObject);
                }
                var cPattern = actualPattern;
                actualPattern = curObj.pData.nlead + cPattern + curObj.pData.nend;
                if (curObj.hasNegativePattern || isBlazor()) {
                    actualPattern += ';' + curObj.nData.nlead + cPattern + curObj.nData.nend;
                }
            }
            if (parseOptions.type === 'percent' && !isBlazor()) {
                actualPattern += ' %';
            }
        }
        else {
            actualPattern = options.format.replace(/'/g, '"');
        }
        if (Object.keys(dOptions).length > 0) {
            actualPattern = !isExcel ? processSymbol(actualPattern, dOptions) : actualPattern;
        }
        return actualPattern;
    }
    IntlBase.getActualNumberFormat = getActualNumberFormat;
    /**
     *
     * @param {string} pattern ?
     * @param {number} minDigits ?
     * @param {number} maxDigits ?
     * @returns {string} ?
     */
    function fractionDigitsPattern(pattern, minDigits, maxDigits) {
        pattern += '.';
        for (var a = 0; a < minDigits; a++) {
            pattern += '0';
        }
        if (minDigits < maxDigits) {
            var diff = maxDigits - minDigits;
            for (var b = 0; b < diff; b++) {
                pattern += '#';
            }
        }
        return pattern;
    }
    IntlBase.fractionDigitsPattern = fractionDigitsPattern;
    /**
     *
     * @param {string} pattern ?
     * @param {number} digits ?
     * @returns {string} ?
     */
    function minimumIntegerPattern(pattern, digits) {
        var temp = pattern.split('.');
        var integer = '';
        for (var x = 0; x < digits; x++) {
            integer += '0';
        }
        return temp[1] ? (integer + '.' + temp[1]) : integer;
    }
    IntlBase.minimumIntegerPattern = minimumIntegerPattern;
    /**
     *
     * @param {string} pattern ?
     * @returns {string} ?
     */
    function groupingPattern(pattern) {
        var temp = pattern.split('.');
        var integer = temp[0];
        var no = 3 - integer.length % 3;
        var hash = (no && no === 1) ? '#' : (no === 2 ? '##' : '');
        integer = hash + integer;
        pattern = '';
        for (var x = integer.length - 1; x > 0; x = x - 3) {
            pattern = ',' + integer[x - 2] + integer[x - 1] + integer[x] + pattern;
        }
        pattern = pattern.slice(1);
        return temp[1] ? (pattern + '.' + temp[1]) : pattern;
    }
    IntlBase.groupingPattern = groupingPattern;
    /**
     *
     * @param {string} culture ?
     * @param {Object} cldr ?
     * @returns {number} ?
     */
    function getWeekData(culture, cldr) {
        var firstDay = defaultFirstDay;
        var mapper = getValue('supplemental.weekData.firstDay', cldr);
        var iCulture = culture;
        if ((/en-/).test(iCulture)) {
            iCulture = iCulture.slice(3);
        }
        iCulture = iCulture.slice(0, 2).toUpperCase() + iCulture.substr(2);
        if (mapper) {
            firstDay = mapper[iCulture] || defaultFirstDay;
        }
        return firstDayMapper[firstDay];
    }
    IntlBase.getWeekData = getWeekData;
    /**
     * @private
     * @param {any} pData ?
     * @param {string} aCurrency ?
     * @param {string} rCurrency ?
     * @returns {void} ?
     */
    function replaceBlazorCurrency(pData, aCurrency, rCurrency) {
        var iCurrency = getBlazorCurrencySymbol(rCurrency);
        if (aCurrency !== iCurrency) {
            for (var _i = 0, pData_1 = pData; _i < pData_1.length; _i++) {
                var data = pData_1[_i];
                data.nend = data.nend.replace(aCurrency, iCurrency);
                data.nlead = data.nlead.replace(aCurrency, iCurrency);
            }
        }
    }
    IntlBase.replaceBlazorCurrency = replaceBlazorCurrency;
    /**
     * @private
     * @param {Date} date ?
     * @returns {number} ?
     */
    function getWeekOfYear(date) {
        var newYear = new Date(date.getFullYear(), 0, 1);
        var day = newYear.getDay();
        var weeknum;
        day = (day >= 0 ? day : day + 7);
        var daynum = Math.floor((date.getTime() - newYear.getTime() -
            (date.getTimezoneOffset() - newYear.getTimezoneOffset()) * 60000) / 86400000) + 1;
        if (day < 4) {
            weeknum = Math.floor((daynum + day - 1) / 7) + 1;
            if (weeknum > 52) {
                var nYear = new Date(this.getFullYear() + 1, 0, 1);
                var nday = nYear.getDay();
                nday = nday >= 0 ? nday : nday + 7;
                weeknum = nday < 4 ? 1 : 53;
            }
        }
        else {
            weeknum = Math.floor((daynum + day - 1) / 7);
        }
        return weeknum;
    }
    IntlBase.getWeekOfYear = getWeekOfYear;
})(exports.IntlBase || (exports.IntlBase = {}));

var headerRegex = /^(.*?):[ \t]*([^\r\n]*)$/gm;
var defaultType = 'GET';
/**
 * Ajax class provides ability to make asynchronous HTTP request to the server
 * ```typescript
 *   var ajax = new Ajax("index.html", "GET", true);
 *   ajax.send().then(
 *               function (value) {
 *                   console.log(value);
 *               },
 *               function (reason) {
 *                   console.log(reason);
 *               });
 * ```
 */
var Ajax = /** @class */ (function () {
    /**
     * Constructor for Ajax class
     *
     * @param  {string|Object} options ?
     * @param  {string} type ?
     * @param  {boolean} async ?
     * @returns defaultType any
     */
    function Ajax(options, type, async, contentType) {
        /**
         * A boolean value indicating whether the request should be sent asynchronous or not.
         *
         * @default true
         */
        this.mode = true;
        /**
         * A boolean value indicating whether to ignore the promise reject.
         *
         * @private
         * @default true
         */
        this.emitError = true;
        this.options = {};
        if (typeof options === 'string') {
            this.url = options;
            this.type = type ? type.toUpperCase() : defaultType;
            this.mode = !isNullOrUndefined(async) ? async : true;
        }
        else if (typeof options === 'object') {
            this.options = options;
            merge(this, this.options);
        }
        this.type = this.type ? this.type.toUpperCase() : defaultType;
        this.contentType = (this.contentType !== undefined) ? this.contentType : contentType;
    }
    /**
     *
     * Send the request to server.
     *
     * @param {any} data - To send the user data
     * @return {Promise} ?
     */
    Ajax.prototype.send = function (data) {
        var _this = this;
        this.data = isNullOrUndefined(data) ? this.data : data;
        var eventArgs = {
            cancel: false,
            httpRequest: null
        };
        var promise = new Promise(function (resolve, reject) {
            _this.httpRequest = new XMLHttpRequest();
            _this.httpRequest.onreadystatechange = function () { _this.stateChange(resolve, reject); };
            if (!isNullOrUndefined(_this.onLoad)) {
                _this.httpRequest.onload = _this.onLoad;
            }
            if (!isNullOrUndefined(_this.onProgress)) {
                _this.httpRequest.onprogress = _this.onProgress;
            }
            /* istanbul ignore next */
            if (!isNullOrUndefined(_this.onAbort)) {
                _this.httpRequest.onabort = _this.onAbort;
            }
            /* istanbul ignore next */
            if (!isNullOrUndefined(_this.onError)) {
                _this.httpRequest.onerror = _this.onError;
            }
            //** Upload Events **/
            /* istanbul ignore next */
            if (!isNullOrUndefined(_this.onUploadProgress)) {
                _this.httpRequest.upload.onprogress = _this.onUploadProgress;
            }
            _this.httpRequest.open(_this.type, _this.url, _this.mode);
            // Set default headers
            if (!isNullOrUndefined(_this.data) && _this.contentType !== null) {
                _this.httpRequest.setRequestHeader('Content-Type', _this.contentType || 'application/json; charset=utf-8');
            }
            if (_this.beforeSend) {
                eventArgs.httpRequest = _this.httpRequest;
                _this.beforeSend(eventArgs);
            }
            if (!eventArgs.cancel) {
                _this.httpRequest.send(!isNullOrUndefined(_this.data) ? _this.data : null);
            }
        });
        return promise;
    };
    Ajax.prototype.successHandler = function (data) {
        if (this.onSuccess) {
            this.onSuccess(data, this);
        }
        return data;
    };
    Ajax.prototype.failureHandler = function (reason) {
        if (this.onFailure) {
            this.onFailure(this.httpRequest);
        }
        return reason;
    };
    Ajax.prototype.stateChange = function (resolve, reject) {
        var data = this.httpRequest.responseText;
        if (this.dataType && this.dataType.toLowerCase() === 'json') {
            if (data === '') {
                data = undefined;
            }
            else {
                try {
                    data = JSON.parse(data);
                }
                catch (error) {
                    // no exception handle
                }
            }
        }
        if (this.httpRequest.readyState === 4) {
            //success range should be 200 to 299
            if ((this.httpRequest.status >= 200 && this.httpRequest.status <= 299) || this.httpRequest.status === 304) {
                resolve(this.successHandler(data));
            }
            else {
                if (this.emitError) {
                    reject(new Error(this.failureHandler(this.httpRequest.statusText)));
                }
                else {
                    resolve();
                }
            }
        }
    };
    /**
     * To get the response header from XMLHttpRequest
     *
     * @param  {string} key Key to search in the response header
     * @returns {string} ?
     */
    Ajax.prototype.getResponseHeader = function (key) {
        var responseHeaders;
        var header;
        // eslint-disable-next-line
        responseHeaders = {};
        var headers = headerRegex.exec(this.httpRequest.getAllResponseHeaders());
        while (headers) {
            responseHeaders[headers[1].toLowerCase()] = headers[2];
            headers = headerRegex.exec(this.httpRequest.getAllResponseHeaders());
        }
        // eslint-disable-next-line
        header = responseHeaders[key.toLowerCase()];
        return isNullOrUndefined(header) ? null : header;
    };
    return Ajax;
}());

var REGX_MOBILE = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini|mobile/i;
var REGX_IE = /msie|trident/i;
var REGX_IE11 = /Trident\/7\./;
var REGX_IOS = /(ipad|iphone|ipod touch)/i;
var REGX_IOS7 = /(ipad|iphone|ipod touch);.*os 7_\d|(ipad|iphone|ipod touch);.*os 8_\d/i;
var REGX_ANDROID = /android/i;
var REGX_WINDOWS = /trident|windows phone|edge/i;
var REGX_VERSION = /(version)[ /]([\w.]+)/i;
var REGX_BROWSER = {
    OPERA: /(opera|opr)(?:.*version|)[ /]([\w.]+)/i,
    EDGE: /(edge)(?:.*version|)[ /]([\w.]+)/i,
    CHROME: /(chrome|crios)[ /]([\w.]+)/i,
    PANTHOMEJS: /(phantomjs)[ /]([\w.]+)/i,
    SAFARI: /(safari)[ /]([\w.]+)/i,
    WEBKIT: /(webkit)[ /]([\w.]+)/i,
    MSIE: /(msie|trident) ([\w.]+)/i,
    MOZILLA: /(mozilla)(?:.*? rv:([\w.]+)|)/i
};
/* istanbul ignore else  */
if (typeof window !== 'undefined') {
    window.browserDetails = window.browserDetails || {};
}
/**
 * Get configuration details for Browser
 *
 * @private
 */
var Browser = /** @class */ (function () {
    function Browser() {
    }
    Browser.extractBrowserDetail = function () {
        var browserInfo = { culture: {} };
        var keys = Object.keys(REGX_BROWSER);
        var clientInfo = [];
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            clientInfo = Browser.userAgent.match(REGX_BROWSER[key]);
            if (clientInfo) {
                browserInfo.name = (clientInfo[1].toLowerCase() === 'opr' ? 'opera' : clientInfo[1].toLowerCase());
                browserInfo.name = (clientInfo[1].toLowerCase() === 'crios' ? 'chrome' : browserInfo.name);
                browserInfo.version = clientInfo[2];
                browserInfo.culture.name = browserInfo.culture.language = navigator.language;
                // eslint-disable-next-line
                if (!!Browser.userAgent.match(REGX_IE11)) {
                    browserInfo.name = 'msie';
                    break;
                }
                var version = Browser.userAgent.match(REGX_VERSION);
                if (browserInfo.name === 'safari' && version) {
                    browserInfo.version = version[2];
                }
                break;
            }
        }
        return browserInfo;
    };
    /**
     * To get events from the browser
     *
     * @param {string} event - type of event triggered.
     * @returns {boolean}
     */
    Browser.getEvent = function (event) {
        // eslint-disable-next-line
        var events = {
            start: {
                isPointer: 'pointerdown', isTouch: 'touchstart', isDevice: 'mousedown'
            },
            move: {
                isPointer: 'pointermove', isTouch: 'touchmove', isDevice: 'mousemove'
            },
            end: {
                isPointer: 'pointerup', isTouch: 'touchend', isDevice: 'mouseup'
            },
            cancel: {
                isPointer: 'pointercancel', isTouch: 'touchcancel', isDevice: 'mouseleave'
            }
        };
        return (Browser.isPointer ? events[event].isPointer :
            (Browser.isTouch ? events[event].isTouch + (!Browser.isDevice ? ' ' + events[event].isDevice : '')
                : events[event].isDevice));
    };
    /**
     * To get the Touch start event from browser
     *
     * @returns {string}
     */
    Browser.getTouchStartEvent = function () {
        return Browser.getEvent('start');
    };
    /**
     * To get the Touch end event from browser
     *
     * @returns {string}
     */
    Browser.getTouchEndEvent = function () {
        return Browser.getEvent('end');
    };
    /**
     * To get the Touch move event from browser
     *
     * @returns {string}
     */
    Browser.getTouchMoveEvent = function () {
        return Browser.getEvent('move');
    };
    /**
     * To cancel the touch event from browser
     *
     * @returns {string}
     */
    Browser.getTouchCancelEvent = function () {
        return Browser.getEvent('cancel');
    };
    /**
     * To get the value based on provided key and regX
     *
     * @param {string} key ?
     * @param {RegExp} regX ?
     * @returns {Object} ?
     */
    Browser.getValue = function (key, regX) {
        var browserDetails = window.browserDetails;
        if ('undefined' === typeof browserDetails[key]) {
            return browserDetails[key] = regX.test(Browser.userAgent);
        }
        return browserDetails[key];
    };
    Object.defineProperty(Browser, "userAgent", {
        get: function () {
            return Browser.uA;
        },
        //Properties
        /**
         * Property specifies the userAgent of the browser. Default userAgent value is based on the browser.
         * Also we can set our own userAgent.
         *
         * @param {string} uA ?
         */
        set: function (uA) {
            Browser.uA = uA;
            window.browserDetails = {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "info", {
        //Read Only Properties
        /**
         * Property is to get the browser information like Name, Version and Language
         *
         * @returns {BrowserInfo} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.info)) {
                return window.browserDetails.info = Browser.extractBrowserDetail();
            }
            return window.browserDetails.info;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isIE", {
        /**
         * Property is to get whether the userAgent is based IE.
         *
         * @returns {boolean} ?
         */
        get: function () {
            return Browser.getValue('isIE', REGX_IE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isTouch", {
        /**
         * Property is to get whether the browser has touch support.
         *
         * @returns {boolean} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.isTouch)) {
                return (window.browserDetails.isTouch =
                    ('ontouchstart' in window.navigator) ||
                        (window &&
                            window.navigator &&
                            (window.navigator.maxTouchPoints > 0)) || ('ontouchstart' in window));
            }
            return window.browserDetails.isTouch;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isPointer", {
        /**
         * Property is to get whether the browser has Pointer support.
         *
         * @returns {boolean} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.isPointer)) {
                return window.browserDetails.isPointer = ('pointerEnabled' in window.navigator);
            }
            return window.browserDetails.isPointer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isMSPointer", {
        /**
         * Property is to get whether the browser has MSPointer support.
         *
         * @returns {boolean} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.isMSPointer)) {
                return window.browserDetails.isMSPointer = ('msPointerEnabled' in window.navigator);
            }
            return window.browserDetails.isMSPointer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isDevice", {
        /**
         * Property is to get whether the userAgent is device based.
         *
         * @returns {boolean} ?
         */
        get: function () {
            return Browser.getValue('isDevice', REGX_MOBILE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isIos", {
        /**
         * Property is to get whether the userAgent is IOS.
         *
         * @returns {boolean} ?
         */
        get: function () {
            return Browser.getValue('isIos', REGX_IOS);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isIos7", {
        /**
         * Property is to get whether the userAgent is Ios7.
         *
         * @returns {boolean} ?
         */
        get: function () {
            return Browser.getValue('isIos7', REGX_IOS7);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isAndroid", {
        /**
         * Property is to get whether the userAgent is Android.
         *
         * @returns {boolean} ?
         */
        get: function () {
            return Browser.getValue('isAndroid', REGX_ANDROID);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isWebView", {
        /**
         * Property is to identify whether application ran in web view.
         *
         * @returns {boolean} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.isWebView)) {
                window.browserDetails.isWebView = !(isUndefined(window.cordova) && isUndefined(window.PhoneGap)
                    && isUndefined(window.phonegap) && window.forge !== 'object');
                return window.browserDetails.isWebView;
            }
            return window.browserDetails.isWebView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "isWindows", {
        /**
         * Property is to get whether the userAgent is Windows.
         *
         * @returns {boolean} ?
         */
        get: function () {
            return Browser.getValue('isWindows', REGX_WINDOWS);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "touchStartEvent", {
        /**
         * Property is to get the touch start event. It returns event name based on browser.
         *
         * @returns {string} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.touchStartEvent)) {
                return window.browserDetails.touchStartEvent = Browser.getTouchStartEvent();
            }
            return window.browserDetails.touchStartEvent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "touchMoveEvent", {
        /**
         * Property is to get the touch move event. It returns event name based on browser.
         *
         * @returns {string} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.touchMoveEvent)) {
                return window.browserDetails.touchMoveEvent = Browser.getTouchMoveEvent();
            }
            return window.browserDetails.touchMoveEvent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "touchEndEvent", {
        /**
         * Property is to get the touch end event. It returns event name based on browser.
         *
         * @returns {string} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.touchEndEvent)) {
                return window.browserDetails.touchEndEvent = Browser.getTouchEndEvent();
            }
            return window.browserDetails.touchEndEvent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Browser, "touchCancelEvent", {
        /**
         * Property is to cancel the touch end event.
         *
         * @returns {string} ?
         */
        get: function () {
            if (isUndefined(window.browserDetails.touchCancelEvent)) {
                return window.browserDetails.touchCancelEvent = Browser.getTouchCancelEvent();
            }
            return window.browserDetails.touchCancelEvent;
        },
        enumerable: true,
        configurable: true
    });
    /* istanbul ignore next */
    Browser.uA = typeof navigator !== 'undefined' ? navigator.userAgent : '';
    return Browser;
}());

/**
 * EventHandler class provides option to add, remove, clear and trigger events to a HTML DOM element
 * ```html
 * <div id="Eventdiv">  </div>
 * <script>
 *   let node: HTMLElement = document.querySelector("#Eventdiv");
 *   EventHandler.addEventListener(node, "click", function(){
 *       // click handler function code
 *   });
 *   EventHandler.addEventListener(node, "onmouseover", function(){
 *       // mouseover handler function code
 *   });
 *   EventHandler.removeEventListener(node, "click", function(){
 *       // click handler function code
 *   });
 *   eventObj.clearEvents();
 * </script>
 * ```
 */
var EventHandler = /** @class */ (function () {
    function EventHandler() {
    }
    // to get the event data based on element
    EventHandler.addOrGetEventData = function (element) {
        if ('__eventList' in element) {
            return element.__eventList.events;
        }
        else {
            element.__eventList = {};
            return element.__eventList.events = [];
        }
    };
    /**
     * Add an event to the specified DOM element.
     *
     * @param {any} element - Target HTML DOM element
     * @param {string} eventName - A string that specifies the name of the event
     * @param {Function} listener - Specifies the function to run when the event occurs
     * @param {Object} bindTo - A object that binds 'this' variable in the event handler
     * @param {number} intDebounce - Specifies at what interval given event listener should be triggered.
     * @returns {Function} ?
     */
    EventHandler.add = function (element, eventName, listener, bindTo, intDebounce) {
        var eventData = EventHandler.addOrGetEventData(element);
        var debounceListener;
        if (intDebounce) {
            debounceListener = debounce(listener, intDebounce);
        }
        else {
            debounceListener = listener;
        }
        if (bindTo) {
            debounceListener = debounceListener.bind(bindTo);
        }
        var event = eventName.split(' ');
        for (var i = 0; i < event.length; i++) {
            eventData.push({
                name: event[i],
                listener: listener,
                debounce: debounceListener
            });
            if (Browser.isIE) {
                element.addEventListener(event[i], debounceListener);
            }
            else {
                element.addEventListener(event[i], debounceListener, { passive: false });
            }
        }
        return debounceListener;
    };
    /**
     * Remove an event listener that has been attached before.
     *
     * @param {any} element - Specifies the target html element to remove the event
     * @param {string} eventName - A string that specifies the name of the event to remove
     * @param {Function} listener - Specifies the function to remove
     * @returns {void} ?
     */
    EventHandler.remove = function (element, eventName, listener) {
        var eventData = EventHandler.addOrGetEventData(element);
        var event = eventName.split(' ');
        var _loop_1 = function (j) {
            var index = -1;
            var debounceListener;
            if (eventData && eventData.length !== 0) {
                eventData.some(function (x, i) {
                    return x.name === event[j] && x.listener === listener ?
                        (index = i, debounceListener = x.debounce, true) : false;
                });
            }
            if (index !== -1) {
                eventData.splice(index, 1);
            }
            if (debounceListener) {
                element.removeEventListener(event[j], debounceListener);
            }
        };
        for (var j = 0; j < event.length; j++) {
            _loop_1(j);
        }
    };
    /**
     * Clear all the event listeners that has been previously attached to the element.
     *
     * @param {any} element - Specifies the target html element to clear the events
     * @returns {void} ?
     */
    EventHandler.clearEvents = function (element) {
        var eventData;
        var copyData;
        // eslint-disable-next-line
        eventData = EventHandler.addOrGetEventData(element);
        // eslint-disable-next-line
        copyData = extend([], copyData, eventData);
        for (var i = 0; i < copyData.length; i++) {
            element.removeEventListener(copyData[i].name, copyData[i].debounce);
            eventData.shift();
        }
    };
    /**
     * Trigger particular event of the element.
     *
     * @param {any} element - Specifies the target html element to trigger the events
     * @param {string} eventName - Specifies the event to trigger for the specified element.
     * Can be a custom event, or any of the standard events.
     * @param {any} eventProp - Additional parameters to pass on to the event properties
     * @returns {void} ?
     */
    EventHandler.trigger = function (element, eventName, eventProp) {
        var eventData = EventHandler.addOrGetEventData(element);
        for (var _i = 0, eventData_1 = eventData; _i < eventData_1.length; _i++) {
            var event_1 = eventData_1[_i];
            if (event_1.name === eventName) {
                event_1.debounce.call(this, eventProp);
            }
        }
    };
    return EventHandler;
}());

/**
 * Functions related to dom operations.
 */
var SVG_REG = /^svg|^path|^g/;
/**
 * Function to create Html element.
 *
 * @param {string} tagName - Name of the tag, id and class names.
 * @param {ElementProperties} properties - Object to set properties in the element.
 * @param {ElementProperties} properties.id - To set the id to the created element.
 * @param {ElementProperties} properties.className - To add classes to the element.
 * @param {ElementProperties} properties.innerHTML - To set the innerHTML to element.
 * @param {ElementProperties} properties.styles - To set the some custom styles to element.
 * @param {ElementProperties} properties.attrs - To set the attributes to element.
 * @returns {any} ?
 * @private
 */
function createElement(tagName, properties) {
    var element = (SVG_REG.test(tagName) ? document.createElementNS('http://www.w3.org/2000/svg', tagName) : document.createElement(tagName));
    if (typeof (properties) === 'undefined') {
        return element;
    }
    element.innerHTML = (properties.innerHTML ? properties.innerHTML : '');
    if (properties.className !== undefined) {
        element.className = properties.className;
    }
    if (properties.id !== undefined) {
        element.id = properties.id;
    }
    if (properties.styles !== undefined) {
        element.setAttribute('style', properties.styles);
    }
    if (properties.attrs !== undefined) {
        attributes(element, properties.attrs);
    }
    return element;
}
/**
 * The function used to add the classes to array of elements
 *
 * @param  {Element[]|NodeList} elements - An array of elements that need to add a list of classes
 * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
 * @returns {any} .
 * @private
 */
function addClass(elements, classes) {
    var classList = getClassList(classes);
    for (var _i = 0, _a = elements; _i < _a.length; _i++) {
        var ele = _a[_i];
        for (var _b = 0, classList_1 = classList; _b < classList_1.length; _b++) {
            var className = classList_1[_b];
            if (isObject(ele)) {
                var curClass = getValue('attributes.className', ele);
                if (isNullOrUndefined(curClass)) {
                    setValue('attributes.className', className, ele);
                }
                else if (!new RegExp('\\b' + className + '\\b', 'i').test(curClass)) {
                    setValue('attributes.className', curClass + ' ' + className, ele);
                }
            }
            else {
                if (!ele.classList.contains(className)) {
                    ele.classList.add(className);
                }
            }
        }
    }
    return elements;
}
/**
 * The function used to add the classes to array of elements
 *
 * @param  {Element[]|NodeList} elements - An array of elements that need to remove a list of classes
 * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
 * @returns {any} .
 * @private
 */
function removeClass(elements, classes) {
    var classList = getClassList(classes);
    for (var _i = 0, _a = elements; _i < _a.length; _i++) {
        var ele = _a[_i];
        var flag = isObject(ele);
        var canRemove = flag ? getValue('attributes.className', ele) : ele.className !== '';
        if (canRemove) {
            for (var _b = 0, classList_2 = classList; _b < classList_2.length; _b++) {
                var className = classList_2[_b];
                if (flag) {
                    var classes_1 = getValue('attributes.className', ele);
                    var classArr = classes_1.split(' ');
                    var index = classArr.indexOf(className);
                    if (index !== -1) {
                        classArr.splice(index, 1);
                    }
                    setValue('attributes.className', classArr.join(' '), ele);
                }
                else {
                    ele.classList.remove(className);
                }
            }
        }
    }
    return elements;
}
/**
 * The function used to get classlist.
 *
 * @param  {string | string[]} classes - An element the need to check visibility
 * @returns {string[]} ?
 * @private
 */
function getClassList(classes) {
    var classList = [];
    if (typeof classes === 'string') {
        classList.push(classes);
    }
    else {
        classList = classes;
    }
    return classList;
}
/**
 * The function used to check element is visible or not.
 *
 * @param  {Element|Node} element - An element the need to check visibility
 * @returns {boolean} ?
 * @private
 */
function isVisible(element) {
    var ele = element;
    return (ele.style.visibility === '' && ele.offsetWidth > 0);
}
/**
 * The function used to insert an array of elements into a first of the element.
 *
 * @param  {Element[]|NodeList} fromElements - An array of elements that need to prepend.
 * @param  {Element} toElement - An element that is going to prepend.
 * @param {boolean} isEval - ?
 * @returns {Element[] | NodeList} ?
 * @private
 */
function prepend(fromElements, toElement, isEval) {
    var docFrag = document.createDocumentFragment();
    for (var _i = 0, _a = fromElements; _i < _a.length; _i++) {
        var ele = _a[_i];
        docFrag.appendChild(ele);
    }
    toElement.insertBefore(docFrag, toElement.firstElementChild);
    if (isEval) {
        executeScript(toElement);
    }
    return fromElements;
}
/**
 * The function used to insert an array of elements into last of the element.
 *
 * @param  {Element[]|NodeList} fromElements - An array of elements that need to append.
 * @param  {Element} toElement - An element that is going to prepend.
 * @param {boolean} isEval - ?
 * @returns {Element[] | NodeList} ?
 * @private
 */
function append(fromElements, toElement, isEval) {
    var docFrag = document.createDocumentFragment();
    for (var _i = 0, _a = fromElements; _i < _a.length; _i++) {
        var ele = _a[_i];
        docFrag.appendChild(ele);
    }
    toElement.appendChild(docFrag);
    if (isEval) {
        executeScript(toElement);
    }
    return fromElements;
}
/**
 * The function is used to evaluate script from Ajax request
 *
 * @param {Element} ele - An element is going to evaluate the script
 * @returns {void} ?
 */
function executeScript(ele) {
    var eleArray = ele.querySelectorAll('script');
    eleArray.forEach(function (element) {
        var script = document.createElement('script');
        script.text = element.innerHTML;
        document.head.appendChild(script);
        detach(script);
    });
}
/**
 * The function used to remove the element from parentnode
 *
 * @param  {Element|Node|HTMLElement} element - An element that is going to detach from the Dom
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function detach(element) {
    var parentNode = element.parentNode;
    if (parentNode) {
        return parentNode.removeChild(element);
    }
}
/**
 * The function used to remove the element from Dom also clear the bounded events
 *
 * @param  {Element|Node|HTMLElement} element - An element remove from the Dom
 * @returns {void} ?
 * @private
 */
function remove(element) {
    var parentNode = element.parentNode;
    EventHandler.clearEvents(element);
    parentNode.removeChild(element);
}
/**
 * The function helps to set multiple attributes to an element
 *
 * @param  {Element|Node} element - An element that need to set attributes.
 * @param  {string} attributes - JSON Object that is going to as attributes.
 * @returns {Element} ?
 * @private
 */
// eslint-disable-next-line
function attributes(element, attributes) {
    var keys = Object.keys(attributes);
    var ele = element;
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (isObject(ele)) {
            var iKey = key;
            if (key === 'tabindex') {
                iKey = 'tabIndex';
            }
            ele.attributes[iKey] = attributes[key];
        }
        else {
            ele.setAttribute(key, attributes[key]);
        }
    }
    return ele;
}
/**
 * The function selects the element from giving context.
 *
 * @param  {string} selector - Selector string need fetch element
 * @param  {Document|Element} context - It is an optional type, That specifies a Dom context.
 * @param {boolean} needsVDOM ?
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function select(selector, context, needsVDOM) {
    if (context === void 0) { context = document; }
    selector = querySelectId(selector);
    return context.querySelector(selector);
}
/**
 * The function selects an array of element from the given context.
 *
 * @param  {string} selector - Selector string need fetch element
 * @param  {Document|Element} context - It is an optional type, That specifies a Dom context.
 * @param {boolean} needsVDOM ?
 * @returns {HTMLElement[]} ?
 * @private
 */
// eslint-disable-next-line
function selectAll(selector, context, needsVDOM) {
    if (context === void 0) { context = document; }
    selector = querySelectId(selector);
    var nodeList = context.querySelectorAll(selector);
    return nodeList;
}
/**
 * The function selects an id of element from the given context.
 *
 * @param  {string} selector - Selector string need fetch element
 * @returns {string} ?
 * @private
 */
function querySelectId(selector) {
    if (selector.match(/#[0-9]/g)) {
        var idList = selector.split(',');
        for (var i = 0; i < idList.length; i++) {
            var list = idList[i].split(' ');
            for (var j = 0; j < list.length; j++) {
                if (list[j].indexOf('#') > -1) {
                    if (!list[j].match(/\[.*\]/)) {
                        var splitId = list[j].split('#');
                        if (splitId[1].match(/^\d/)) {
                            var setId = list[j].split('.');
                            setId[0] = setId[0].replace(/#/, '[id=\'') + '\']';
                            list[j] = setId.join('.');
                        }
                    }
                }
            }
            idList[i] = list.join(' ');
        }
        return idList.join(',');
    }
    return selector;
}
/**
 * Returns single closest parent element based on class selector.
 *
 * @param  {Element} element - An element that need to find the closest element.
 * @param  {string} selector - A classSelector of closest element.
 * @returns {Element} ?
 * @private
 */
function closest(element, selector) {
    var el = element;
    if (typeof el.closest === 'function') {
        return el.closest(selector);
    }
    while (el && el.nodeType === 1) {
        if (matches(el, selector)) {
            return el;
        }
        el = el.parentNode;
    }
    return null;
}
/**
 * Returns all sibling elements of the given element.
 *
 * @param  {Element|Node} element - An element that need to get siblings.
 * @returns {Element[]} ?
 * @private
 */
function siblings(element) {
    var siblings = [];
    var childNodes = Array.prototype.slice.call(element.parentNode.childNodes);
    for (var _i = 0, childNodes_1 = childNodes; _i < childNodes_1.length; _i++) {
        var curNode = childNodes_1[_i];
        if (curNode.nodeType === Node.ELEMENT_NODE && element !== curNode) {
            siblings.push(curNode);
        }
    }
    return siblings;
}
/**
 * set the value if not exist. Otherwise set the existing value
 *
 * @param  {HTMLElement} element - An element to which we need to set value.
 * @param  {string} property - Property need to get or set.
 * @param  {string} value - value need to set.
 * @returns {string} ?
 * @private
 */
function getAttributeOrDefault(element, property, value) {
    var attrVal;
    var isObj = isObject(element);
    if (isObj) {
        attrVal = getValue('attributes.' + property, element);
    }
    else {
        attrVal = element.getAttribute(property);
    }
    if (isNullOrUndefined(attrVal) && value) {
        if (!isObj) {
            element.setAttribute(property, value.toString());
        }
        else {
            element.attributes[property] = value;
        }
        attrVal = value;
    }
    return attrVal;
}
/**
 * Set the style attributes to Html element.
 *
 * @param {HTMLElement} element - Element which we want to set attributes
 * @param {any} attrs - Set the given attributes to element
 * @returns {void} ?
 * @private
 */
function setStyleAttribute(element, attrs) {
    if (attrs !== undefined) {
        Object.keys(attrs).forEach(function (key) {
            // eslint-disable-next-line
            element.style[key] = attrs[key];
        });
    }
}
/**
 * Method for add and remove classes to a dom element.
 *
 * @param {Element} element - Element for add and remove classes
 * @param {string[]} addClasses - List of classes need to be add to the element
 * @param {string[]} removeClasses - List of classes need to be remove from the element
 * @returns {void} ?
 * @private
 */
function classList(element, addClasses, removeClasses) {
    addClass([element], addClasses);
    removeClass([element], removeClasses);
}
/**
 * Method to check whether the element matches the given selector.
 *
 * @param {Element} element - Element to compare with the selector.
 * @param {string} selector - String selector which element will satisfy.
 * @returns {void} ?
 * @private
 */
function matches(element, selector) {
    // eslint-disable-next-line
    var matches = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
    if (matches) {
        return matches.call(element, selector);
    }
    else {
        return [].indexOf.call(document.querySelectorAll(selector), element) !== -1;
    }
}
/**
 * Method to get the html text from DOM.
 *
 * @param {HTMLElement} ele - Element to compare with the selector.
 * @param {string} innerHTML - String selector which element will satisfy.
 * @returns {void} ?
 * @private
 */
function includeInnerHTML(ele, innerHTML) {
    ele.innerHTML = innerHTML;
}
/**
 * Method to get the containsclass.
 *
 * @param {HTMLElement} ele - Element to compare with the selector.
 * @param {string} className - String selector which element will satisfy.
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function containsClass(ele, className) {
    if (isObject(ele)) {
        // eslint-disable-next-line
        return new RegExp('\\b' + className + '\\b', 'i').test(ele.attributes.className);
    }
    else {
        return ele.classList.contains(className);
    }
}
/**
 * Method to check whether the element matches the given selector.
 *
 * @param {Object} element - Element to compare with the selector.
 * @param {boolean} deep ?
 * @returns {any} ?
 * @private
 */
// eslint-disable-next-line
function cloneNode(element, deep) {
    if (isObject(element)) {
        if (deep) {
            return extend({}, {}, element, true);
        }
    }
    else {
        return element.cloneNode(deep);
    }
}

var isColEName = new RegExp(']');
/* tslint:enable:no-any */
/**
 * Base library module is common module for Framework modules like touch,keyboard and etc.,
 *
 * @private
 */
var Base = /** @class */ (function () {
    /**
     * Base constructor accept options and element
     *
     * @param {Object} options ?
     * @param {string} element ?
     */
    function Base(options, element) {
        this.isRendered = false;
        this.isComplexArraySetter = false;
        this.isServerRendered = false;
        this.allowServerDataBinding = true;
        this.isProtectedOnChange = true;
        this.properties = {};
        this.changedProperties = {};
        this.oldProperties = {};
        this.bulkChanges = {};
        this.refreshing = false;
        this.ignoreCollectionWatch = false;
        // eslint-disable-next-line
        this.finalUpdate = function () { };
        this.childChangedProperties = {};
        this.modelObserver = new Observer(this);
        if (!isUndefined(element)) {
            if ('string' === typeof (element)) {
                this.element = document.querySelector(element);
            }
            else {
                this.element = element;
            }
            if (!isNullOrUndefined(this.element)) {
                this.isProtectedOnChange = false;
                this.addInstance();
            }
        }
        if (!isUndefined(options)) {
            this.setProperties(options, true);
        }
        this.isDestroyed = false;
    }
    /** Property base section */
    /**
     * Function used to set bunch of property at a time.
     *
     * @private
     * @param  {Object} prop - JSON object which holds components properties.
     * @param  {boolean} muteOnChange ? - Specifies to true when we set properties.
     * @returns {void} ?
     */
    Base.prototype.setProperties = function (prop, muteOnChange) {
        var prevDetection = this.isProtectedOnChange;
        this.isProtectedOnChange = !!muteOnChange;
        merge(this, prop);
        if (muteOnChange !== true) {
            merge(this.changedProperties, prop);
            this.dataBind();
        }
        else if (isBlazor() && this.isRendered) {
            this.serverDataBind(prop);
        }
        this.finalUpdate();
        this.changedProperties = {};
        this.oldProperties = {};
        this.isProtectedOnChange = prevDetection;
    };
    /**
     * Calls for child element data bind
     *
     * @param {Object} obj ?
     * @param {Object} parent ?
     * @returns {void} ?
     */
    // tslint:disable-next-line:no-any
    Base.callChildDataBind = function (obj, parent) {
        var keys = Object.keys(obj);
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (parent[key] instanceof Array) {
                for (var _a = 0, _b = parent[key]; _a < _b.length; _a++) {
                    var obj_1 = _b[_a];
                    if (obj_1.dataBind !== undefined) {
                        obj_1.dataBind();
                    }
                }
            }
            else {
                parent[key].dataBind();
            }
        }
    };
    Base.prototype.clearChanges = function () {
        this.finalUpdate();
        this.changedProperties = {};
        this.oldProperties = {};
        this.childChangedProperties = {};
    };
    /**
     * Bind property changes immediately to components
     *
     * @returns {void} ?
     */
    Base.prototype.dataBind = function () {
        Base.callChildDataBind(this.childChangedProperties, this);
        if (Object.getOwnPropertyNames(this.changedProperties).length) {
            var prevDetection = this.isProtectedOnChange;
            var newChanges = this.changedProperties;
            var oldChanges = this.oldProperties;
            this.clearChanges();
            this.isProtectedOnChange = true;
            this.onPropertyChanged(newChanges, oldChanges);
            this.isProtectedOnChange = prevDetection;
        }
    };
    /* tslint:disable:no-any */
    Base.prototype.serverDataBind = function (newChanges) {
        if (!isBlazor()) {
            return;
        }
        newChanges = newChanges ? newChanges : {};
        extend(this.bulkChanges, {}, newChanges, true);
        var sfBlazor = 'sfBlazor';
        if (this.allowServerDataBinding && window[sfBlazor].updateModel) {
            window[sfBlazor].updateModel(this);
            this.bulkChanges = {};
        }
    };
    /* tslint:enable:no-any */
    Base.prototype.saveChanges = function (key, newValue, oldValue) {
        if (isBlazor()) {
            // tslint:disable-next-line:no-any
            var newChanges = {};
            newChanges[key] = newValue;
            this.serverDataBind(newChanges);
        }
        if (this.isProtectedOnChange) {
            return;
        }
        this.oldProperties[key] = oldValue;
        this.changedProperties[key] = newValue;
        this.finalUpdate();
        this.finalUpdate = setImmediate(this.dataBind.bind(this));
    };
    /** Event Base Section */
    /**
     * Adds the handler to the given event listener.
     *
     * @param {string} eventName - A String that specifies the name of the event
     * @param {Function} handler - Specifies the call to run when the event occurs.
     * @returns {void} ?
     */
    Base.prototype.addEventListener = function (eventName, handler) {
        this.modelObserver.on(eventName, handler);
    };
    /**
     * Removes the handler from the given event listener.
     *
     * @param {string} eventName - A String that specifies the name of the event to remove
     * @param {Function} handler - Specifies the function to remove
     * @returns {void} ?
     */
    Base.prototype.removeEventListener = function (eventName, handler) {
        this.modelObserver.off(eventName, handler);
    };
    /**
     * Triggers the handlers in the specified event.
     *
     * @private
     * @param {string} eventName - Specifies the event to trigger for the specified component properties.
     * Can be a custom event, or any of the standard events.
     * @param {Event} eventProp - Additional parameters to pass on to the event properties
     * @param {Function} successHandler - this function will invoke after event successfully triggered
     * @param {Function} errorHandler - this function will invoke after event if it failured to call.
     * @returns {void} ?
     */
    Base.prototype.trigger = function (eventName, eventProp, successHandler, errorHandler) {
        var _this = this;
        if (this.isDestroyed !== true) {
            var prevDetection = this.isProtectedOnChange;
            this.isProtectedOnChange = false;
            var data = this.modelObserver.notify(eventName, eventProp, successHandler, errorHandler);
            if (isColEName.test(eventName)) {
                var handler = getValue(eventName, this);
                if (handler) {
                    var blazor = 'Blazor';
                    if (window[blazor]) {
                        var promise = handler.call(this, eventProp);
                        if (promise && typeof promise.then === 'function') {
                            if (!successHandler) {
                                data = promise;
                            }
                            else {
                                promise.then(function (data) {
                                    if (successHandler) {
                                        data = typeof data === 'string' && _this.modelObserver.isJson(data) ?
                                            JSON.parse(data) : data;
                                        successHandler.call(_this, data);
                                    }
                                }).catch(function (data) {
                                    if (errorHandler) {
                                        data = typeof data === 'string' && _this.modelObserver.isJson(data) ? JSON.parse(data) : data;
                                        errorHandler.call(_this, data);
                                    }
                                });
                            }
                        }
                        else if (successHandler) {
                            successHandler.call(this, eventProp);
                        }
                    }
                    else {
                        handler.call(this, eventProp);
                        if (successHandler) {
                            successHandler.call(this, eventProp);
                        }
                    }
                }
                else if (successHandler) {
                    successHandler.call(this, eventProp);
                }
            }
            this.isProtectedOnChange = prevDetection;
            return data;
        }
    };
    /**
     * To maintain instance in base class
     *
     * @returns {void} ?
     */
    Base.prototype.addInstance = function () {
        // Add module class to the root element
        var moduleClass = 'e-' + this.getModuleName().toLowerCase();
        addClass([this.element], ['e-lib', moduleClass]);
        if (!isNullOrUndefined(this.element.ej2_instances)) {
            this.element.ej2_instances.push(this);
        }
        else {
            setValue('ej2_instances', [this], this.element);
        }
    };
    /**
     * To remove the instance from the element
     *
     * @returns {void} ?
     */
    Base.prototype.destroy = function () {
        var _this = this;
        // eslint-disable-next-line
        this.element.ej2_instances =
            this.element.ej2_instances.filter(function (i) { return i !== _this; });
        removeClass([this.element], ['e-' + this.getModuleName()]);
        if (this.element.ej2_instances.length === 0) {
            // Remove module class from the root element
            removeClass([this.element], ['e-lib']);
        }
        this.clearChanges();
        this.modelObserver.destroy();
        this.isDestroyed = true;
    };
    return Base;
}());
/**
 * Global function to get the component instance from the rendered element.
 *
 * @param {HTMLElement} elem Specifies the HTMLElement or element id string.
 * @param {string} comp Specifies the component module name or Component.
 * @returns {any} ?
 */
// tslint:disable-next-line:no-any
function getComponent(elem, comp) {
    var instance;
    var i;
    var ele = typeof elem === 'string' ? document.getElementById(elem) : elem;
    for (i = 0; i < ele.ej2_instances.length; i++) {
        instance = ele.ej2_instances[i];
        if (typeof comp === 'string') {
            var compName = instance.getModuleName();
            if (comp === compName) {
                return instance;
            }
        }
        else {
            // tslint:disable-next-line:no-any
            if (instance instanceof comp) {
                return instance;
            }
        }
    }
    return undefined;
}
/**
 * Function to remove the child instances.
 *
 * @param {HTMLElement} element ?
 * @return {void}
 * @private
 */
// tslint:disable-next-line:no-any
function removeChildInstance(element) {
    // tslint:disable-next-line:no-any
    var childEle = [].slice.call(element.getElementsByClassName('e-control'));
    for (var i = 0; i < childEle.length; i++) {
        var compName = childEle[i].classList[1].split('e-')[1];
        // tslint:disable-next-line:no-any
        var compInstance = getComponent(childEle[i], compName);
        if (!isUndefined(compInstance)) {
            compInstance.destroy();
        }
    }
}

/**
 * Returns the Class Object
 *
 * @param {ClassObject} instance - instance of ClassObject
 * @param {string} curKey - key of the current instance
 * @param {Object} defaultValue - default Value
 * @param {Object[]} type ?
 * @returns {ClassObject} ?
 */
// eslint-disable-next-line
function getObject(instance, curKey, defaultValue, type) {
    // eslint-disable-next-line
    if (!instance.properties.hasOwnProperty(curKey) || !(instance.properties[curKey] instanceof type)) {
        instance.properties[curKey] = createInstance(type, [instance, curKey, defaultValue]);
    }
    return instance.properties[curKey];
}
/**
 * Returns object array
 *
 * @param {ClassObject} instance ?
 * @param {string} curKey ?
 * @param {Object[]} defaultValue ?
 * @param {Object} type ?
 * @param {boolean} isSetter ?
 * @param {boolean} isFactory ?
 * @returns {Object[]} ?
 */
// eslint-disable-next-line
function getObjectArray(instance, curKey, defaultValue, type, isSetter, isFactory) {
    var result = [];
    var len = defaultValue ? defaultValue.length : 0;
    for (var i = 0; i < len; i++) {
        var curType = type;
        if (isFactory) {
            curType = type(defaultValue[i], instance);
        }
        if (isSetter) {
            var inst = createInstance(curType, [instance, curKey, {}, true]);
            inst.setProperties(defaultValue[i], true);
            result.push(inst);
        }
        else {
            result.push(createInstance(curType, [instance, curKey, defaultValue[i], false]));
        }
    }
    return result;
}
/**
 * Returns the properties of the object
 *
 * @param {Object} defaultValue ?
 * @param {string} curKey ?
 * @returns {void} ?
 */
function propertyGetter(defaultValue, curKey) {
    return function () {
        // eslint-disable-next-line
        if (!this.properties.hasOwnProperty(curKey)) {
            this.properties[curKey] = defaultValue;
        }
        return this.properties[curKey];
    };
}
/**
 * Set the properties for the object
 *
 * @param {Object} defaultValue ?
 * @param {string} curKey ?
 * @returns {void} ?
 */
function propertySetter(defaultValue, curKey) {
    return function (newValue) {
        if (this.properties[curKey] !== newValue) {
            // eslint-disable-next-line
            var oldVal = this.properties.hasOwnProperty(curKey) ? this.properties[curKey] : defaultValue;
            this.saveChanges(curKey, newValue, oldVal);
            this.properties[curKey] = newValue;
        }
    };
}
/**
 * Returns complex objects
 *
 * @param {Object} defaultValue ?
 * @param {string} curKey ?
 * @param {Object[]} type ?
 * @returns {void} ?
 */
// eslint-disable-next-line
function complexGetter(defaultValue, curKey, type) {
    return function () {
        return getObject(this, curKey, defaultValue, type);
    };
}
/**
 * Sets complex objects
 *
 * @param {Object} defaultValue ?
 * @param {string} curKey ?
 * @param {Object[]} type ?
 * @returns {void} ?
 */
function complexSetter(defaultValue, curKey, type) {
    return function (newValue) {
        getObject(this, curKey, defaultValue, type).setProperties(newValue);
    };
}
/**
 *
 * @param {Object} defaultValue ?
 * @param {string} curKey ?
 * @param {FunctionConstructor} type ?
 * @returns {void} ?
 */
// eslint-disable-next-line
function complexFactoryGetter(defaultValue, curKey, type) {
    return function () {
        var curType = type({});
        // eslint-disable-next-line
        if (this.properties.hasOwnProperty(curKey)) {
            return this.properties[curKey];
        }
        else {
            return getObject(this, curKey, defaultValue, curType);
        }
    };
}
/**
 *
 * @param {Object} defaultValue ?
 * @param {string} curKey ?
 * @param {Object[]} type ?
 * @returns {void} ?
 */
function complexFactorySetter(defaultValue, curKey, type) {
    return function (newValue) {
        var curType = type(newValue, this);
        getObject(this, curKey, defaultValue, curType).setProperties(newValue);
    };
}
/**
 *
 * @param {Object[]} defaultValue ?
 * @param {string} curKey ?
 * @param {Object[]} type ?
 * @returns {void} ?
 */
function complexArrayGetter(defaultValue, curKey, type) {
    return function () {
        var _this = this;
        // eslint-disable-next-line
        if (!this.properties.hasOwnProperty(curKey)) {
            var defCollection = getObjectArray(this, curKey, defaultValue, type, false);
            this.properties[curKey] = defCollection;
        }
        var ignore = ((this.controlParent !== undefined && this.controlParent.ignoreCollectionWatch)
            || this.ignoreCollectionWatch);
        // eslint-disable-next-line
        if (!this.properties[curKey].hasOwnProperty('push') && !ignore) {
            ['push', 'pop'].forEach(function (extendFunc) {
                var descriptor = {
                    value: complexArrayDefinedCallback(extendFunc, curKey, type, _this.properties[curKey]).bind(_this),
                    configurable: true
                };
                Object.defineProperty(_this.properties[curKey], extendFunc, descriptor);
            });
        }
        // eslint-disable-next-line
        if (!this.properties[curKey].hasOwnProperty('isComplexArray')) {
            Object.defineProperty(this.properties[curKey], 'isComplexArray', { value: true });
        }
        return this.properties[curKey];
    };
}
/**
 *
 * @param {Object[]} defaultValue ?
 * @param {string} curKey ?
 * @param {Object[]} type ?
 * @returns {void} ?
 */
function complexArraySetter(defaultValue, curKey, type) {
    return function (newValue) {
        this.isComplexArraySetter = true;
        var oldValueCollection = getObjectArray(this, curKey, defaultValue, type, false);
        var newValCollection = getObjectArray(this, curKey, newValue, type, true);
        this.isComplexArraySetter = false;
        this.saveChanges(curKey, newValCollection, oldValueCollection);
        this.properties[curKey] = newValCollection;
    };
}
/**
 *
 * @param {Object[]} defaultValue ?
 * @param {string} curKey ?
 * @param {Object[]} type ?
 * @returns {void} ?
 */
function complexArrayFactorySetter(defaultValue, curKey, type) {
    return function (newValue) {
        // eslint-disable-next-line
        var oldValueCollection = this.properties.hasOwnProperty(curKey) ? this.properties[curKey] : defaultValue;
        var newValCollection = getObjectArray(this, curKey, newValue, type, true, true);
        this.saveChanges(curKey, newValCollection, oldValueCollection);
        this.properties[curKey] = newValCollection;
    };
}
/**
 *
 * @param {Object[]} defaultValue ?
 * @param {string} curKey ?
 * @param {FunctionConstructor} type ?
 * @returns {void} ?
 */
function complexArrayFactoryGetter(defaultValue, curKey, type) {
    return function () {
        var curType = type({});
        // eslint-disable-next-line
        if (!this.properties.hasOwnProperty(curKey)) {
            var defCollection = getObjectArray(this, curKey, defaultValue, curType, false);
            this.properties[curKey] = defCollection;
        }
        return this.properties[curKey];
    };
}
/**
 *
 * @param {string} dFunc ?
 * @param {string} curKey ?
 * @param {Object} type ?
 * @param {Object} prop ?
 * @returns {Object} ?
 */
function complexArrayDefinedCallback(dFunc, curKey, type, prop) {
    /* tslint:disable no-function-expression */
    return function () {
        var newValue = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            newValue[_i] = arguments[_i];
        }
        var keyString = this.propName ? this.getParentKey() + '.' + curKey + '-' : curKey + '-';
        switch (dFunc) {
            case 'push':
                for (var i = 0; i < newValue.length; i++) {
                    Array.prototype[dFunc].apply(prop, [newValue[i]]);
                    var model_1 = getArrayModel(keyString + (prop.length - 1), newValue[i], !this.controlParent, dFunc);
                    this.serverDataBind(model_1, newValue[i], false, dFunc);
                }
                break;
            case 'pop':
                Array.prototype[dFunc].apply(prop);
                // eslint-disable-next-line
                var model = getArrayModel(keyString + prop.length, null, !this.controlParent, dFunc);
                this.serverDataBind(model, { ejsAction: 'pop' }, false, dFunc);
                break;
        }
        return prop;
    };
}
/**
 *
 * @param {string} keyString ?
 * @param {Object} value ?
 * @param {boolean} isControlParent ?
 * @param {string} arrayFunction ?
 * @returns {Object} ?
 */
function getArrayModel(keyString, value, isControlParent, arrayFunction) {
    var modelObject = keyString;
    if (isControlParent) {
        modelObject = {};
        modelObject[keyString] = value;
        if (value && typeof value === 'object') {
            var action = 'ejsAction';
            modelObject[keyString][action] = arrayFunction;
        }
    }
    return modelObject;
}
// eslint-disable-next-line
/**
 * Method used to create property. General syntax below.
 *
 * @param {Object} defaultValue - Specifies the default value of property.
 * @returns {PropertyDecorator} ?
 * ```
 * @Property('TypeScript')
 * propertyName: Type;
 * ```
 * @private
 */
function Property(defaultValue) {
    return function (target, key) {
        var propertyDescriptor = {
            set: propertySetter(defaultValue, key),
            get: propertyGetter(defaultValue, key),
            enumerable: true,
            configurable: true
        };
        //new property creation
        Object.defineProperty(target, key, propertyDescriptor);
        addPropertyCollection(target, key, 'prop', defaultValue);
    };
}
/**
 * Method used to create complex property. General syntax below.
 *
 * @param  {any} defaultValue - Specifies the default value of property.
 * @param  {Function} type - Specifies the class type of complex object.
 * @returns {PropertyDecorator} ?
 * ```
 * @Complex<Type>({},Type)
 * propertyName: Type;
 * ```
 * @private
 */
function Complex(defaultValue, type) {
    return function (target, key) {
        var propertyDescriptor = {
            set: complexSetter(defaultValue, key, type),
            get: complexGetter(defaultValue, key, type),
            enumerable: true,
            configurable: true
        };
        //new property creation
        Object.defineProperty(target, key, propertyDescriptor);
        addPropertyCollection(target, key, 'complexProp', defaultValue, type);
    };
}
/**
 * Method used to create complex Factory property. General syntax below.
 *
 * @param  {Function} type - Specifies the class factory type of complex object.
 * @returns {PropertyDecorator} ?
 * ```
 * @ComplexFactory(defaultType, factoryFunction)
 * propertyName: Type1 | Type2;
 * ```
 * @private
 */
function ComplexFactory(type) {
    return function (target, key) {
        var propertyDescriptor = {
            set: complexFactorySetter({}, key, type),
            get: complexFactoryGetter({}, key, type),
            enumerable: true,
            configurable: true
        };
        //new property creation
        Object.defineProperty(target, key, propertyDescriptor);
        addPropertyCollection(target, key, 'complexProp', {}, type);
    };
}
/**
 * Method used to create complex array property. General syntax below.
 *
 * @param  {any} defaultValue - Specifies the default value of property.
 * @param  {Function} type - Specifies the class type of complex object.
 * @returns {PropertyDecorator} ?
 * ```
 * @Collection([], Type);
 * propertyName: Type;
 * ```
 * @private
 */
function Collection(defaultValue, type) {
    return function (target, key) {
        var propertyDescriptor = {
            set: complexArraySetter(defaultValue, key, type),
            get: complexArrayGetter(defaultValue, key, type),
            enumerable: true,
            configurable: true
        };
        //new property creation
        Object.defineProperty(target, key, propertyDescriptor);
        addPropertyCollection(target, key, 'colProp', defaultValue, type);
    };
}
/**
 * Method used to create complex factory array property. General syntax below.
 *
 * @param  {Function} type - Specifies the class type of complex object.
 * @returns {PropertyCollectionInfo} ?
 * ```
 * @Collection([], Type);
 * propertyName: Type;
 * ```
 * @private
 */
function CollectionFactory(type) {
    return function (target, key) {
        var propertyDescriptor = {
            set: complexArrayFactorySetter([], key, type),
            get: complexArrayFactoryGetter([], key, type),
            enumerable: true,
            configurable: true
        };
        //new property creation
        Object.defineProperty(target, key, propertyDescriptor);
        addPropertyCollection(target, key, 'colProp', {}, type);
    };
}
/**
 * Method used to create event property. General syntax below.
 *
 * @returns {PropertyDecorator} ?
 * ```
 * @Event(()=>{return true;})
 * ```
 * @private
 */
function Event$1() {
    return function (target, key) {
        var eventDescriptor = {
            set: function (newValue) {
                var oldValue = this.properties[key];
                if (oldValue !== newValue) {
                    var finalContext = getParentContext(this, key);
                    if (isUndefined(oldValue) === false) {
                        finalContext.context.removeEventListener(finalContext.prefix, oldValue);
                    }
                    finalContext.context.addEventListener(finalContext.prefix, newValue);
                    this.properties[key] = newValue;
                }
            },
            get: propertyGetter(undefined, key),
            enumerable: true,
            configurable: true
        };
        Object.defineProperty(target, key, eventDescriptor);
        addPropertyCollection(target, key, 'event');
    };
}
/**
 * NotifyPropertyChanges is triggers the call back when the property has been changed.
 *
 * @param {Function} classConstructor ?
 * @returns {void} ?
 * ```
 *  @NotifyPropertyChanges
 * class DemoClass implements INotifyPropertyChanged {
 *
 *     @Property()
 *     property1: string;
 *
 *     dataBind: () => void;
 *
 *     constructor() { }
 *
 *     onPropertyChanged(newProp: any, oldProp: any) {
 *         // Called when property changed
 *     }
 * }
 * ```
 * @private
 */
// eslint-disable-next-line
function NotifyPropertyChanges(classConstructor) {
    /** Need to code */
}
/**
 * Method  used to create the builderObject for the target component.
 *
 * @param {BuildInfo} target ?
 * @param {string} key ?
 * @param {string} propertyType ?
 * @param {Object} defaultValue ?
 * @param {Function} type ?
 * @returns {void} ?
 * @private
 */
function addPropertyCollection(target, key, propertyType, defaultValue, type) {
    if (isUndefined(target.propList)) {
        target.propList = {
            props: [],
            complexProps: [],
            colProps: [],
            events: [],
            propNames: [],
            complexPropNames: [],
            colPropNames: [],
            eventNames: []
        };
    }
    // eslint-disable-next-line
    target.propList[propertyType + 's'].push({
        propertyName: key,
        defaultValue: defaultValue,
        type: type
    });
    // eslint-disable-next-line
    target.propList[propertyType + 'Names'].push(key);
}
/**
 * Returns an object containing the builder properties
 *
 * @param {Function} component ?
 * @returns {Object} ?
 * @private
 */
function getBuilderProperties(component) {
    if (isUndefined(component.prototype.builderObject)) {
        component.prototype.builderObject = {
            properties: {}, propCollections: [], add: function () {
                this.isPropertyArray = true;
                this.propCollections.push(extend({}, this.properties, {}));
            }
        };
        var rex = /complex/;
        for (var _i = 0, _a = Object.keys(component.prototype.propList); _i < _a.length; _i++) {
            var key = _a[_i];
            var _loop_1 = function (prop) {
                if (rex.test(key)) {
                    component.prototype.builderObject[prop.propertyName] = function (value) {
                        var childType = {};
                        merge(childType, getBuilderProperties(prop.type));
                        value(childType);
                        var tempValue;
                        if (!childType.isPropertyArray) {
                            tempValue = extend({}, childType.properties, {});
                        }
                        else {
                            tempValue = childType.propCollections;
                        }
                        this.properties[prop.propertyName] = tempValue;
                        childType.properties = {};
                        childType.propCollections = [];
                        childType.isPropertyArray = false;
                        return this;
                    };
                }
                else {
                    component.prototype.builderObject[prop.propertyName] = function (value) {
                        this.properties[prop.propertyName] = value;
                        return this;
                    };
                }
            };
            for (var _b = 0, _c = component.prototype.propList[key]; _b < _c.length; _b++) {
                var prop = _c[_b];
                _loop_1(prop);
            }
        }
    }
    return component.prototype.builderObject;
}
/**
 * Method used to create builder for the components
 *
 * @param {any} component -specifies the target component for which builder to be created.
 * @returns {Object} ?
 * @private
 */
function CreateBuilder(component) {
    var builderFunction = function (element) {
        this.element = element;
        return this;
    };
    var instanceFunction = function (element) {
        // eslint-disable-next-line
        if (!builderFunction.prototype.hasOwnProperty('create')) {
            builderFunction.prototype = getBuilderProperties(component);
            builderFunction.prototype.create = function () {
                var temp = extend({}, {}, this.properties);
                this.properties = {};
                return new component(temp, this.element);
            };
        }
        return new builderFunction(element);
    };
    return instanceFunction;
}
/**
 * Returns parent options for the object
 *
 * @param {Object} context ?
 * @param {string} prefix ?
 * @returns {ParentOption} ?
 * @private
 */
function getParentContext(context, prefix) {
    // eslint-disable-next-line
    if (context.hasOwnProperty('parentObj') === false) {
        return { context: context, prefix: prefix };
    }
    else {
        var curText = getValue('propName', context);
        if (curText) {
            prefix = curText + '-' + prefix;
        }
        return getParentContext(getValue('parentObj', context), prefix);
    }
}

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * The Animation framework provide options to animate the html DOM elements
 * ```typescript
 *   let animeObject = new Animation({
 *      name: 'SlideLeftIn',
 *      duration: 1000
 *   });
 *   animeObject.animate('#anime1');
 *   animeObject.animate('#anime2', { duration: 500 });
 * ```
 */
var Animation = /** @class */ (function (_super) {
    __extends(Animation, _super);
    function Animation(options) {
        var _this = _super.call(this, options, undefined) || this;
        /**
         * @private
         */
        _this.easing = {
            ease: 'cubic-bezier(0.250, 0.100, 0.250, 1.000)',
            linear: 'cubic-bezier(0.250, 0.250, 0.750, 0.750)',
            easeIn: 'cubic-bezier(0.420, 0.000, 1.000, 1.000)',
            easeOut: 'cubic-bezier(0.000, 0.000, 0.580, 1.000)',
            easeInOut: 'cubic-bezier(0.420, 0.000, 0.580, 1.000)',
            elasticInOut: 'cubic-bezier(0.5,-0.58,0.38,1.81)',
            elasticIn: 'cubic-bezier(0.17,0.67,0.59,1.81)',
            elasticOut: 'cubic-bezier(0.7,-0.75,0.99,1.01)'
        };
        return _this;
    }
    Animation_1 = Animation;
    /**
     * Applies animation to the current element.
     *
     * @param {string | HTMLElement} element - Element which needs to be animated.
     * @param {AnimationModel} options - Overriding default animation settings.
     * @returns {void} ?
     */
    Animation.prototype.animate = function (element, options) {
        options = !options ? {} : options;
        var model = this.getModel(options);
        if (typeof element === 'string') {
            var elements = Array.prototype.slice.call(selectAll(element, document));
            for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                var element_1 = elements_1[_i];
                model.element = element_1;
                Animation_1.delayAnimation(model);
            }
        }
        else {
            model.element = element;
            Animation_1.delayAnimation(model);
        }
    };
    /**
     * Stop the animation effect on animated element.
     *
     * @param {HTMLElement} element - Element which needs to be stop the animation.
     * @param {AnimationOptions} model - Handling the animation model at stop function.
     * @return {void}
     */
    Animation.stop = function (element, model) {
        element.style.animation = '';
        element.removeAttribute('e-animate');
        var animationId = element.getAttribute('e-animation-id');
        if (animationId) {
            var frameId = parseInt(animationId, 10);
            cancelAnimationFrame(frameId);
            element.removeAttribute('e-animation-id');
        }
        if (model && model.end) {
            model.end.call(this, model);
        }
    };
    /**
     * Set delay to animation element
     *
     * @param {AnimationModel} model ?
     * @returns {void}
     */
    Animation.delayAnimation = function (model) {
        if (model.delay) {
            setTimeout(function () { Animation_1.applyAnimation(model); }, model.delay);
        }
        else {
            Animation_1.applyAnimation(model);
        }
    };
    /**
     * Triggers animation
     *
     * @param {AnimationModel} model ?
     * @returns {void}
     */
    Animation.applyAnimation = function (model) {
        var _this = this;
        model.timeStamp = 0;
        var step = 0;
        var timerId = 0;
        var prevTimeStamp = 0;
        var duration = model.duration;
        model.element.setAttribute('e-animate', 'true');
        var startAnimation = function (timeStamp) {
            try {
                if (timeStamp) {
                    // let step: number = model.timeStamp = timeStamp - startTime;
                    /** phantomjs workaround for timestamp fix */
                    prevTimeStamp = prevTimeStamp === 0 ? timeStamp : prevTimeStamp;
                    model.timeStamp = (timeStamp + model.timeStamp) - prevTimeStamp;
                    prevTimeStamp = timeStamp;
                    /** phantomjs workaround end */
                    // trigger animation begin event
                    if (!step && model.begin) {
                        model.begin.call(_this, model);
                    }
                    step = step + 1;
                    var avg = model.timeStamp / step;
                    if (model.timeStamp < duration && model.timeStamp + avg < duration && model.element.getAttribute('e-animate')) {
                        // apply animation effect to the current element
                        model.element.style.animation = model.name + ' ' + model.duration + 'ms ' + model.timingFunction;
                        if (model.progress) {
                            model.progress.call(_this, model);
                        }
                        // repeat requestAnimationFrame
                        requestAnimationFrame(startAnimation);
                    }
                    else {
                        // clear requestAnimationFrame
                        cancelAnimationFrame(timerId);
                        model.element.removeAttribute('e-animation-id');
                        model.element.removeAttribute('e-animate');
                        model.element.style.animation = '';
                        if (model.end) {
                            model.end.call(_this, model);
                        }
                    }
                }
                else {
                    //startTime = performance.now();
                    // set initial requestAnimationFrame
                    timerId = requestAnimationFrame(startAnimation);
                    model.element.setAttribute('e-animation-id', timerId.toString());
                }
            }
            catch (e) {
                cancelAnimationFrame(timerId);
                model.element.removeAttribute('e-animation-id');
                if (model.fail) {
                    model.fail.call(_this, e);
                }
            }
        };
        startAnimation();
    };
    /**
     * Returns Animation Model
     *
     * @param {AnimationModel} options ?
     * @returns {AnimationModel} ?
     */
    Animation.prototype.getModel = function (options) {
        return {
            name: options.name || this.name,
            delay: options.delay || this.delay,
            duration: (options.duration !== undefined ? options.duration : this.duration),
            begin: options.begin || this.begin,
            end: options.end || this.end,
            fail: options.fail || this.fail,
            progress: options.progress || this.progress,
            timingFunction: this.easing[options.timingFunction] ? this.easing[options.timingFunction] :
                (options.timingFunction || this.easing[this.timingFunction])
        };
    };
    /**
     * @private
     * @param {AnimationModel} newProp ?
     * @param {AnimationModel} oldProp ?
     * @returns {void} ?
     */
    // eslint-disable-next-line
    Animation.prototype.onPropertyChanged = function (newProp, oldProp) {
        // no code needed
    };
    /**
     * Returns module name as animation
     *
     * @private
     * @returns {void} ?
     */
    Animation.prototype.getModuleName = function () {
        return 'animation';
    };
    /**
     *
     * @private
     * @returns {void} ?
     */
    Animation.prototype.destroy = function () {
        //Override base destroy;
    };
    var Animation_1;
    __decorate([
        Property('FadeIn')
    ], Animation.prototype, "name", void 0);
    __decorate([
        Property(400)
    ], Animation.prototype, "duration", void 0);
    __decorate([
        Property('ease')
    ], Animation.prototype, "timingFunction", void 0);
    __decorate([
        Property(0)
    ], Animation.prototype, "delay", void 0);
    __decorate([
        Event$1()
    ], Animation.prototype, "progress", void 0);
    __decorate([
        Event$1()
    ], Animation.prototype, "begin", void 0);
    __decorate([
        Event$1()
    ], Animation.prototype, "end", void 0);
    __decorate([
        Event$1()
    ], Animation.prototype, "fail", void 0);
    Animation = Animation_1 = __decorate([
        NotifyPropertyChanges
    ], Animation);
    return Animation;
}(Base));
/**
 * Ripple provides material theme's wave effect when an element is clicked
 * ```html
 * <div id='ripple'></div>
 * <script>
 *   rippleEffect(document.getElementById('ripple'));
 * </script>
 * ```
 *
 * @private
 * @param {HTMLElement} element - Target element
 * @param {RippleOptions} rippleOptions - Ripple options .
 * @param {Function} done .
 * @returns {void} .
 */
function rippleEffect(element, rippleOptions, done) {
    var rippleModel = getRippleModel(rippleOptions);
    if (rippleModel.rippleFlag === false || (rippleModel.rippleFlag === undefined && !exports.isRippleEnabled)) {
        return Function;
    }
    element.setAttribute('data-ripple', 'true');
    EventHandler.add(element, 'mousedown', rippleHandler, { parent: element, rippleOptions: rippleModel });
    EventHandler.add(element, 'mouseup', rippleUpHandler, { parent: element, rippleOptions: rippleModel, done: done });
    EventHandler.add(element, 'mouseleave', rippleLeaveHandler, { parent: element, rippleOptions: rippleModel });
    if (Browser.isPointer) {
        EventHandler.add(element, 'transitionend', rippleLeaveHandler, { parent: element, rippleOptions: rippleModel });
    }
    return (function () {
        element.removeAttribute('data-ripple');
        EventHandler.remove(element, 'mousedown', rippleHandler);
        EventHandler.remove(element, 'mouseup', rippleUpHandler);
        EventHandler.remove(element, 'mouseleave', rippleLeaveHandler);
        EventHandler.remove(element, 'transitionend', rippleLeaveHandler);
    });
}
/**
 * Handler for ripple model
 *
 * @param {RippleOptions} rippleOptions ?
 * @returns {RippleOptions} ?
 */
function getRippleModel(rippleOptions) {
    var rippleModel = {
        selector: rippleOptions && rippleOptions.selector ? rippleOptions.selector : null,
        ignore: rippleOptions && rippleOptions.ignore ? rippleOptions.ignore : null,
        rippleFlag: rippleOptions && rippleOptions.rippleFlag,
        isCenterRipple: rippleOptions && rippleOptions.isCenterRipple,
        duration: rippleOptions && rippleOptions.duration ? rippleOptions.duration : 350
    };
    return rippleModel;
}
/**
 * Handler for ripple event
 *
 * @param {MouseEvent} e ?
 * @returns {void} ?
 * @private
 */
function rippleHandler(e) {
    var target = (e.target);
    var selector = this.rippleOptions.selector;
    var element = selector ? closest(target, selector) : target;
    if (!element || (this.rippleOptions && closest(target, this.rippleOptions.ignore))) {
        return;
    }
    var offset = element.getBoundingClientRect();
    var offsetX = e.pageX - document.body.scrollLeft;
    var offsetY = e.pageY - ((!document.body.scrollTop && document.documentElement) ?
        document.documentElement.scrollTop : document.body.scrollTop);
    var pageX = Math.max(Math.abs(offsetX - offset.left), Math.abs(offsetX - offset.right));
    var pageY = Math.max(Math.abs(offsetY - offset.top), Math.abs(offsetY - offset.bottom));
    var radius = Math.sqrt(pageX * pageX + pageY * pageY);
    var diameter = radius * 2 + 'px';
    var x = offsetX - offset.left - radius;
    var y = offsetY - offset.top - radius;
    if (this.rippleOptions && this.rippleOptions.isCenterRipple) {
        x = 0;
        y = 0;
        diameter = '100%';
    }
    element.classList.add('e-ripple');
    var duration = this.rippleOptions.duration.toString();
    var styles = 'width: ' + diameter + ';height: ' + diameter + ';left: ' + x + 'px;top: ' + y + 'px;' +
        'transition-duration: ' + duration + 'ms;';
    var rippleElement = createElement('div', { className: 'e-ripple-element', styles: styles });
    element.appendChild(rippleElement);
    window.getComputedStyle(rippleElement).getPropertyValue('opacity');
    rippleElement.style.transform = 'scale(1)';
    if (element !== this.parent) {
        EventHandler.add(element, 'mouseleave', rippleLeaveHandler, { parent: this.parent, rippleOptions: this.rippleOptions });
    }
}
/**
 * Handler for ripple element mouse up event
 *
 * @param {MouseEvent} e ?
 * @returns {void} ?
 * @private
 */
function rippleUpHandler(e) {
    removeRipple(e, this);
}
/**
 * Handler for ripple element mouse move event
 *
 * @param {MouseEvent} e ?
 * @returns {void} ?
 * @private
 */
function rippleLeaveHandler(e) {
    removeRipple(e, this);
}
/**
 * Handler for removing ripple element
 *
 * @param {MouseEvent} e ?
 * @param {RippleArgs} eventArgs ?
 * @returns {void} ?
 * @private
 */
function removeRipple(e, eventArgs) {
    var duration = eventArgs.rippleOptions.duration;
    var target = (e.target);
    var selector = eventArgs.rippleOptions.selector;
    var element = selector ? closest(target, selector) : target;
    if (!element || (element && element.className.indexOf('e-ripple') === -1)) {
        return;
    }
    var rippleElements = selectAll('.e-ripple-element', element);
    var rippleElement = rippleElements[rippleElements.length - 1];
    if (rippleElement) {
        rippleElement.style.opacity = '0.5';
    }
    if (eventArgs.parent !== element) {
        EventHandler.remove(element, 'mouseleave', rippleLeaveHandler);
    }
    /* tslint:disable:align */
    setTimeout(function () {
        if (rippleElement && rippleElement.parentNode) {
            rippleElement.parentNode.removeChild(rippleElement);
        }
        if (!element.getElementsByClassName('e-ripple-element').length) {
            element.classList.remove('e-ripple');
        }
        if (eventArgs.done) {
            eventArgs.done(e);
        }
    }, duration);
}
exports.isRippleEnabled = false;
/**
 * Animation Module provides support to enable ripple effect functionality to Essential JS 2 components.
 *
 * @param {boolean} isRipple Specifies the boolean value to enable or disable ripple effect.
 * @returns {boolean} ?
 */
function enableRipple(isRipple) {
    exports.isRippleEnabled = isRipple;
    return exports.isRippleEnabled;
}

/**
 * Module loading operations
 */
var MODULE_SUFFIX = 'Module';
var ModuleLoader = /** @class */ (function () {
    function ModuleLoader(parent) {
        this.loadedModules = [];
        this.parent = parent;
    }
    /**
     * Inject required modules in component library
     *
     * @returns {void} ?
     * @param {ModuleDeclaration[]} requiredModules - Array of modules to be required
     * @param {Function[]} moduleList - Array of modules to be injected from sample side
     */
    ModuleLoader.prototype.inject = function (requiredModules, moduleList) {
        var reqLength = requiredModules.length;
        if (reqLength === 0) {
            this.clean();
            return;
        }
        if (this.loadedModules.length) {
            this.clearUnusedModule(requiredModules);
        }
        for (var i = 0; i < reqLength; i++) {
            var modl = requiredModules[i];
            for (var _i = 0, moduleList_1 = moduleList; _i < moduleList_1.length; _i++) {
                var module = moduleList_1[_i];
                var modName = modl.member;
                if (module.prototype.getModuleName() === modl.member && !this.isModuleLoaded(modName)) {
                    var moduleObject = createInstance(module, modl.args);
                    var memberName = this.getMemberName(modName);
                    if (modl.isProperty) {
                        setValue(memberName, module, this.parent);
                    }
                    else {
                        setValue(memberName, moduleObject, this.parent);
                    }
                    var loadedModule = modl;
                    loadedModule.member = memberName;
                    this.loadedModules.push(loadedModule);
                }
            }
        }
    };
    /**
     * To remove the created object while destroying the control
     *
     * @returns {void}
     */
    ModuleLoader.prototype.clean = function () {
        for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
            var modules = _a[_i];
            if (!modules.isProperty) {
                getValue(modules.member, this.parent).destroy();
            }
        }
        this.loadedModules = [];
    };
    /**
     * Removes all unused modules
     *
     * @param {ModuleDeclaration[]} moduleList ?
     * @returns {void} ?
     */
    ModuleLoader.prototype.clearUnusedModule = function (moduleList) {
        var _this = this;
        var usedModules = moduleList.map(function (arg) { return _this.getMemberName(arg.member); });
        var removableModule = this.loadedModules.filter(function (module) {
            return usedModules.indexOf(module.member) === -1;
        });
        for (var _i = 0, removableModule_1 = removableModule; _i < removableModule_1.length; _i++) {
            var mod = removableModule_1[_i];
            if (!mod.isProperty) {
                getValue(mod.member, this.parent).destroy();
            }
            this.loadedModules.splice(this.loadedModules.indexOf(mod), 1);
            deleteObject(this.parent, mod.member);
        }
    };
    /**
     * To get the name of the member.
     *
     * @param {string} name ?
     * @returns {string} ?
     */
    ModuleLoader.prototype.getMemberName = function (name) {
        return name[0].toLowerCase() + name.substring(1) + MODULE_SUFFIX;
    };
    /**
     * Returns boolean based on whether the module specified is loaded or not
     *
     * @param {string} modName ?
     * @returns {boolean} ?
     */
    ModuleLoader.prototype.isModuleLoaded = function (modName) {
        for (var _i = 0, _a = this.loadedModules; _i < _a.length; _i++) {
            var mod = _a[_i];
            if (mod.member === this.getMemberName(modName)) {
                return true;
            }
        }
        return false;
    };
    return ModuleLoader;
}());

/**
 * To detect the changes for inner properties.
 *
 * @private
 */
var ChildProperty = /** @class */ (function () {
    function ChildProperty(parent, propName, defaultValue, isArray) {
        this.isComplexArraySetter = false;
        this.properties = {};
        this.changedProperties = {};
        this.childChangedProperties = {};
        this.oldProperties = {};
        // eslint-disable-next-line
        this.finalUpdate = function () { };
        this.callChildDataBind = getValue('callChildDataBind', Base);
        this.parentObj = parent;
        this.controlParent = this.parentObj.controlParent || this.parentObj;
        this.propName = propName;
        this.isParentArray = isArray;
        this.setProperties(defaultValue, true);
    }
    /**
     * Updates the property changes
     *
     * @param {boolean} val ?
     * @param {string} propName ?
     * @returns {void} ?
     */
    ChildProperty.prototype.updateChange = function (val, propName) {
        if (val === true) {
            this.parentObj.childChangedProperties[propName] = val;
        }
        else {
            delete this.parentObj.childChangedProperties[propName];
        }
        if (this.parentObj.updateChange) {
            this.parentObj.updateChange(val, this.parentObj.propName);
        }
    };
    /**
     * Updates time out duration
     *
     * @returns {void} ?
     */
    ChildProperty.prototype.updateTimeOut = function () {
        if (this.parentObj.updateTimeOut) {
            this.parentObj.finalUpdate();
            this.parentObj.updateTimeOut();
        }
        else {
            var changeTime_1 = setTimeout(this.parentObj.dataBind.bind(this.parentObj));
            var clearUpdate = function () {
                clearTimeout(changeTime_1);
            };
            this.finalUpdate = clearUpdate;
        }
    };
    /**
     * Clears changed properties
     *
     * @returns {void} ?
     */
    ChildProperty.prototype.clearChanges = function () {
        this.finalUpdate();
        this.updateChange(false, this.propName);
        this.oldProperties = {};
        this.changedProperties = {};
    };
    /**
     * Set property changes
     *
     * @param {Object} prop ?
     * @param {boolean} muteOnChange ?
     * @returns {void} ?
     */
    ChildProperty.prototype.setProperties = function (prop, muteOnChange) {
        if (muteOnChange === true) {
            merge(this, prop);
            this.updateChange(false, this.propName);
            this.clearChanges();
        }
        else {
            merge(this, prop);
        }
    };
    /**
     * Binds data
     *
     * @returns {void} ?
     */
    ChildProperty.prototype.dataBind = function () {
        this.callChildDataBind(this.childChangedProperties, this);
        if (this.isParentArray) {
            var curIndex = this.parentObj[this.propName].indexOf(this);
            if (Object.keys(this.changedProperties).length) {
                setValue(this.propName + '.' + curIndex, this.changedProperties, this.parentObj.changedProperties);
                setValue(this.propName + '.' + curIndex, this.oldProperties, this.parentObj.oldProperties);
            }
        }
        else {
            this.parentObj.changedProperties[this.propName] = this.changedProperties;
            this.parentObj.oldProperties[this.propName] = this.oldProperties;
        }
        this.clearChanges();
    };
    /**
     * Saves changes to newer values
     *
     * @param {string} key ?
     * @param {Object} newValue ?
     * @param {Object} oldValue ?
     * @param {boolean} restrictServerDataBind ?
     * @returns {void} ?
     */
    ChildProperty.prototype.saveChanges = function (key, newValue, oldValue, restrictServerDataBind) {
        if (this.controlParent.isProtectedOnChange) {
            return;
        }
        if (!restrictServerDataBind) {
            this.serverDataBind(key, newValue, true);
        }
        this.oldProperties[key] = oldValue;
        this.changedProperties[key] = newValue;
        this.updateChange(true, this.propName);
        this.finalUpdate();
        this.updateTimeOut();
    };
    ChildProperty.prototype.serverDataBind = function (key, value, isSaveChanges, action) {
        if (isBlazor() && !this.parentObj.isComplexArraySetter) {
            var parent_1;
            var newChanges = {};
            var parentKey = isSaveChanges ? this.getParentKey(true) + '.' + key : key;
            /* istanbul ignore else  */
            if (parentKey.indexOf('.') !== -1) {
                var complexKeys = parentKey.split('.');
                parent_1 = newChanges;
                for (var i = 0; i < complexKeys.length; i++) {
                    var isFinal = i === complexKeys.length - 1;
                    parent_1[complexKeys[i]] = isFinal ? value : {};
                    parent_1 = isFinal ? parent_1 : parent_1[complexKeys[i]];
                }
            }
            else {
                newChanges[parentKey] = {};
                parent_1 = newChanges[parentKey];
                newChanges[parentKey][key] = value;
            }
            /* istanbul ignore next */
            if (this.isParentArray) {
                var actionProperty = 'ejsAction';
                parent_1[actionProperty] = action ? action : 'none';
            }
            this.controlParent.serverDataBind(newChanges);
        }
    };
    ChildProperty.prototype.getParentKey = function (isSaveChanges) {
        // eslint-disable-next-line
        var index = '';
        var propName = this.propName;
        /* istanbul ignore next */
        if (this.isParentArray) {
            index = this.parentObj[this.propName].indexOf(this);
            var valueLength = this.parentObj[this.propName].length;
            valueLength = isSaveChanges ? valueLength : (valueLength > 0 ? valueLength - 1 : 0);
            index = index !== -1 ? '-' + index : '-' + valueLength;
            propName = propName + index;
        }
        if (this.controlParent !== this.parentObj) {
            propName = this.parentObj.getParentKey() + '.' + this.propName + index;
        }
        return propName;
    };
    return ChildProperty;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var componentCount = 0;
var lastPageID;
var lastHistoryLen = 0;
exports.versionBasedStatePersistence = false;
/**
 * To enable or disable version based statePersistence functionality for all components globally.
 *
 * @param {boolean} status - Optional argument Specifies the status value to enable or disable versionBasedStatePersistence option.
 * @returns {void}
 */
function enableVersionBasedPersistence(status) {
    exports.versionBasedStatePersistence = status;
}
/**
 * Base class for all Essential JavaScript components
 */
var Component = /** @class */ (function (_super) {
    __extends$1(Component, _super);
    /**
     * Initialize the constructor for component base
     *
     * @param {Object} options ?
     * @param {string} selector ?
     */
    function Component(options, selector) {
        var _this = _super.call(this, options, selector) || this;
        _this.randomId = uniqueID();
        /**
         * string template option for Blazor template rendering
         *
         * @private
         */
        _this.isStringTemplate = false;
        _this.needsID = false;
        _this.isReactHybrid = false;
        if (isNullOrUndefined(_this.enableRtl)) {
            _this.setProperties({ 'enableRtl': exports.rightToLeft }, true);
        }
        if (isNullOrUndefined(_this.locale)) {
            _this.setProperties({ 'locale': exports.defaultCulture }, true);
        }
        _this.moduleLoader = new ModuleLoader(_this);
        _this.localObserver = new Observer(_this);
        // tslint:disable-next-line:no-function-constructor-with-string-args
        onIntlChange.on('notifyExternalChange', _this.detectFunction, _this, _this.randomId);
        if (!isUndefined(selector)) {
            _this.appendTo();
        }
        return _this;
    }
    Component.prototype.requiredModules = function () {
        return [];
    };
    /**
     * Destroys the sub modules while destroying the widget
     *
     * @returns {void} ?
     */
    Component.prototype.destroy = function () {
        if (this.isDestroyed) {
            return;
        }
        if (this.enablePersistence) {
            this.setPersistData();
        }
        this.localObserver.destroy();
        if (this.refreshing) {
            return;
        }
        removeClass([this.element], ['e-control']);
        this.trigger('destroyed', { cancel: false });
        _super.prototype.destroy.call(this);
        this.moduleLoader.clean();
        onIntlChange.off('notifyExternalChange', this.detectFunction, this.randomId);
    };
    /**
     * Applies all the pending property changes and render the component again.
     *
     * @returns {void} ?
     */
    Component.prototype.refresh = function () {
        this.refreshing = true;
        this.moduleLoader.clean();
        this.destroy();
        this.clearChanges();
        this.localObserver = new Observer(this);
        this.preRender();
        this.injectModules();
        this.render();
        this.refreshing = false;
    };
    Component.prototype.accessMount = function () {
        if (this.mount && !this.isReactHybrid) {
            this.mount();
        }
    };
    /**
     * Returns the route element of the component
     *
     * @returns {HTMLElement} ?
     */
    Component.prototype.getRootElement = function () {
        if (this.isReactHybrid) {
            // eslint-disable-next-line
            return this.actualElement;
        }
        else {
            return this.element;
        }
    };
    /**
     * Returns the persistence data for component
     *
     * @returns {any} ?
     */
    // eslint-disable-next-line
    Component.prototype.getLocalData = function () {
        var eleId = this.getModuleName() + this.element.id;
        if (exports.versionBasedStatePersistence) {
            return window.localStorage.getItem(eleId + this.ej2StatePersistenceVersion);
        }
        else {
            return window.localStorage.getItem(eleId);
        }
    };
    /**
     * Appends the control within the given HTML element
     *
     * @param {string | HTMLElement} selector - Target element where control needs to be appended
     * @returns {void} ?
     */
    Component.prototype.appendTo = function (selector) {
        if (!isNullOrUndefined(selector) && typeof (selector) === 'string') {
            this.element = select(selector, document);
        }
        else if (!isNullOrUndefined(selector)) {
            this.element = selector;
        }
        if (!isNullOrUndefined(this.element)) {
            var moduleClass = 'e-' + this.getModuleName().toLowerCase();
            addClass([this.element], ['e-control', moduleClass]);
            this.isProtectedOnChange = false;
            if (this.needsID && !this.element.id) {
                this.element.id = this.getUniqueID(this.getModuleName());
            }
            if (this.enablePersistence) {
                this.mergePersistData();
                window.addEventListener('unload', this.setPersistData.bind(this));
            }
            var inst = getValue('ej2_instances', this.element);
            if (!inst || inst.indexOf(this) === -1) {
                _super.prototype.addInstance.call(this);
            }
            this.preRender();
            this.injectModules();
            this.render();
            if (!this.mount) {
                this.trigger('created');
            }
            else {
                this.accessMount();
            }
        }
    };
    /**
     * It is used to process the post rendering functionalities to a component.
     *
     * @param {Node} wrapperElement ?
     * @returns {void} ?
     */
    Component.prototype.renderComplete = function (wrapperElement) {
        if (isBlazor()) {
            var sfBlazor = 'sfBlazor';
            // eslint-disable-next-line
            window[sfBlazor].renderComplete(this.element, wrapperElement);
        }
        this.isRendered = true;
    };
    /**
     * When invoked, applies the pending property changes immediately to the component.
     *
     * @returns {void} ?
     */
    Component.prototype.dataBind = function () {
        this.injectModules();
        _super.prototype.dataBind.call(this);
    };
    /**
     * Attach one or more  event handler to the current component context.
     * It is used for internal handling event internally within the component only.
     *
     * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
     * @param {Function} handler - optional parameter Specifies the handler to run when the event occurs
     * @param {Object} context - optional parameter Specifies the context to be bind in the handler.
     * @returns {void} ?
     * @private
     */
    Component.prototype.on = function (event, handler, context) {
        if (typeof event === 'string') {
            this.localObserver.on(event, handler, context);
        }
        else {
            for (var _i = 0, event_1 = event; _i < event_1.length; _i++) {
                var arg = event_1[_i];
                this.localObserver.on(arg.event, arg.handler, arg.context);
            }
        }
    };
    /**
     * To remove one or more event handler that has been attached with the on() method.
     *
     * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
     * @param {Function} handler - optional parameter Specifies the function to run when the event occurs
     * @returns {void} ?
     * @private
     */
    Component.prototype.off = function (event, handler) {
        if (typeof event === 'string') {
            this.localObserver.off(event, handler);
        }
        else {
            for (var _i = 0, event_2 = event; _i < event_2.length; _i++) {
                var arg = event_2[_i];
                this.localObserver.off(arg.event, arg.handler);
            }
        }
    };
    /**
     * To notify the handlers in the specified event.
     *
     * @param {string} property - Specifies the event to be notify.
     * @param {Object} argument - Additional parameters to pass while calling the handler.
     * @returns {void} ?
     * @private
     */
    Component.prototype.notify = function (property, argument) {
        if (this.isDestroyed !== true) {
            this.localObserver.notify(property, argument);
        }
    };
    /**
     * Get injected modules
     *
     * @returns {Function} ?
     * @private
     */
    Component.prototype.getInjectedModules = function () {
        return this.injectedModules;
    };
    /**
     * Dynamically injects the required modules to the component.
     *
     * @param {Function} moduleList ?
     * @returns {void} ?
     */
    Component.Inject = function () {
        var moduleList = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            moduleList[_i] = arguments[_i];
        }
        if (!this.prototype.injectedModules) {
            this.prototype.injectedModules = [];
        }
        for (var i = 0; i < moduleList.length; i++) {
            if (this.prototype.injectedModules.indexOf(moduleList[i]) === -1) {
                this.prototype.injectedModules.push(moduleList[i]);
            }
        }
    };
    /**
     * This is a instance method to create an element.
     *
     * @param {string} tagName ?
     * @param {ElementProperties} prop ?
     * @param {boolean} isVDOM ?
     * @returns {any} ?
     * @private
     */
    // eslint-disable-next-line
    Component.prototype.createElement = function (tagName, prop, isVDOM) {
        return createElement(tagName, prop);
    };
    /**
     *
     * @param {Function} handler - handler to be triggered after state Updated.
     * @param {any} argument - Arguments to be passed to caller.
     * @returns {void} .
     * @private
     */
    // eslint-disable-next-line
    Component.prototype.triggerStateChange = function (handler, argument) {
        if (this.isReactHybrid) {
            // eslint-disable-next-line
            this.setState();
            this.currentContext = { calls: handler, args: argument };
        }
    };
    // tslint: enable: no-any
    Component.prototype.injectModules = function () {
        if (this.injectedModules && this.injectedModules.length) {
            this.moduleLoader.inject(this.requiredModules(), this.injectedModules);
        }
    };
    Component.prototype.detectFunction = function (args) {
        var prop = Object.keys(args);
        if (prop.length) {
            this[prop[0]] = args[prop[0]];
        }
    };
    Component.prototype.mergePersistData = function () {
        var data;
        if (exports.versionBasedStatePersistence) {
            data = window.localStorage.getItem(this.getModuleName() + this.element.id + this.ej2StatePersistenceVersion);
        }
        else {
            data = window.localStorage.getItem(this.getModuleName() + this.element.id);
        }
        if (!(isNullOrUndefined(data) || (data === ''))) {
            this.setProperties(JSON.parse(data), true);
        }
    };
    Component.prototype.setPersistData = function () {
        if (!this.isDestroyed) {
            if (exports.versionBasedStatePersistence) {
                window.localStorage.setItem(this.getModuleName() +
                    this.element.id + this.ej2StatePersistenceVersion, this.getPersistData());
            }
            else {
                window.localStorage.setItem(this.getModuleName() + this.element.id, this.getPersistData());
            }
        }
    };
    //tslint:disable-next-line
    Component.prototype.renderReactTemplates = function () {
        //No Code
    };
    // eslint-disable-next-line
    Component.prototype.clearTemplate = function (templateName, index) {
        //No Code
    };
    Component.prototype.getUniqueID = function (definedName) {
        if (this.isHistoryChanged()) {
            componentCount = 0;
        }
        lastPageID = this.pageID(location.href);
        lastHistoryLen = history.length;
        return definedName + '_' + lastPageID + '_' + componentCount++;
    };
    Component.prototype.pageID = function (url) {
        var hash = 0;
        if (url.length === 0) {
            return hash;
        }
        for (var i = 0; i < url.length; i++) {
            var char = url.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return Math.abs(hash);
    };
    Component.prototype.isHistoryChanged = function () {
        return lastPageID !== this.pageID(location.href) || lastHistoryLen !== history.length;
    };
    Component.prototype.addOnPersist = function (options) {
        var _this = this;
        var persistObj = {};
        for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
            var key = options_1[_i];
            var objValue = void 0;
            // eslint-disable-next-line
            objValue = getValue(key, this);
            if (!isUndefined(objValue)) {
                setValue(key, this.getActualProperties(objValue), persistObj);
            }
        }
        return JSON.stringify(persistObj, function (key, value) {
            return _this.getActualProperties(value);
        });
    };
    Component.prototype.getActualProperties = function (obj) {
        if (obj instanceof ChildProperty) {
            return getValue('properties', obj);
        }
        else {
            return obj;
        }
    };
    Component.prototype.ignoreOnPersist = function (options) {
        return JSON.stringify(this.iterateJsonProperties(this.properties, options));
    };
    Component.prototype.iterateJsonProperties = function (obj, ignoreList) {
        var newObj = {};
        var _loop_1 = function (key) {
            if (ignoreList.indexOf(key) === -1) {
                // eslint-disable-next-line
                var value = obj[key];
                if (typeof value === 'object' && !(value instanceof Array)) {
                    var newList = ignoreList.filter(function (str) {
                        return new RegExp(key + '.').test(str);
                    }).map(function (str) {
                        return str.replace(key + '.', '');
                    });
                    newObj[key] = this_1.iterateJsonProperties(this_1.getActualProperties(value), newList);
                }
                else {
                    newObj[key] = value;
                }
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
            var key = _a[_i];
            _loop_1(key);
        }
        return newObj;
    };
    __decorate$1([
        Property(false)
    ], Component.prototype, "enablePersistence", void 0);
    __decorate$1([
        Property()
    ], Component.prototype, "enableRtl", void 0);
    __decorate$1([
        Property()
    ], Component.prototype, "locale", void 0);
    Component = __decorate$1([
        NotifyPropertyChanges
    ], Component);
    return Component;
}(Base));
//Function handling for page navigation detection
/* istanbul ignore next */
(function () {
    if (typeof window !== 'undefined') {
        window.addEventListener('popstate', 
        /* istanbul ignore next */
        function () {
            componentCount = 0;
        });
    }
})();

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var defaultPosition = { left: 0, top: 0, bottom: 0, right: 0 };
var isDraggedObject = { isDragged: false };
/**
 * Specifies the position coordinates
 */
var Position = /** @class */ (function (_super) {
    __extends$2(Position, _super);
    function Position() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$2([
        Property(0)
    ], Position.prototype, "left", void 0);
    __decorate$2([
        Property(0)
    ], Position.prototype, "top", void 0);
    return Position;
}(ChildProperty));
/**
 * Draggable Module provides support to enable draggable functionality in Dom Elements.
 * ```html
 * <div id='drag'>Draggable</div>
 * <script>
 * var ele = document.getElementById('drag');
 * var drag:Draggable = new Draggable(ele,{
 *     clone:false,
 *     drag: function(e) {
 *      //drag handler code.
 *      },
 *     handle:'.class'
 * });
 * </script>
 * ```
 */
var Draggable = /** @class */ (function (_super) {
    __extends$2(Draggable, _super);
    function Draggable(element, options) {
        var _this = _super.call(this, options, element) || this;
        _this.dragLimit = Draggable_1.getDefaultPosition();
        _this.borderWidth = Draggable_1.getDefaultPosition();
        _this.padding = Draggable_1.getDefaultPosition();
        _this.diffX = 0;
        _this.prevLeft = 0;
        _this.prevTop = 0;
        _this.dragProcessStarted = false;
        /* tslint:disable no-any */
        _this.tapHoldTimer = 0;
        _this.externalInitialize = false;
        _this.diffY = 0;
        _this.parentScrollX = 0;
        _this.parentScrollY = 0;
        _this.droppables = {};
        _this.bind();
        return _this;
    }
    Draggable_1 = Draggable;
    Draggable.prototype.bind = function () {
        this.toggleEvents();
        if (Browser.isIE) {
            addClass([this.element], 'e-block-touch');
        }
        this.droppables[this.scope] = {};
    };
    Draggable.getDefaultPosition = function () {
        return extend({}, defaultPosition);
    };
    Draggable.prototype.toggleEvents = function (isUnWire) {
        var ele;
        if (!isUndefined(this.handle)) {
            ele = select(this.handle, this.element);
        }
        var handler = (this.enableTapHold && Browser.isDevice && Browser.isTouch) ? this.mobileInitialize : this.initialize;
        if (isUnWire) {
            EventHandler.remove(ele || this.element, Browser.touchStartEvent, handler);
        }
        else {
            EventHandler.add(ele || this.element, Browser.touchStartEvent, handler, this);
        }
    };
    /* istanbul ignore next */
    Draggable.prototype.mobileInitialize = function (evt) {
        var _this = this;
        var target = evt.currentTarget;
        this.tapHoldTimer = setTimeout(function () {
            _this.externalInitialize = true;
            _this.removeTapholdTimer();
            _this.initialize(evt, target);
        }, this.tapHoldThreshold);
        EventHandler.add(document, Browser.touchMoveEvent, this.removeTapholdTimer, this);
        EventHandler.add(document, Browser.touchEndEvent, this.removeTapholdTimer, this);
    };
    /* istanbul ignore next */
    Draggable.prototype.removeTapholdTimer = function () {
        clearTimeout(this.tapHoldTimer);
        EventHandler.remove(document, Browser.touchMoveEvent, this.removeTapholdTimer);
        EventHandler.remove(document, Browser.touchEndEvent, this.removeTapholdTimer);
    };
    /* istanbul ignore next */
    Draggable.prototype.getScrollableParent = function (element, axis) {
        var scroll = { 'vertical': 'scrollHeight', 'horizontal': 'scrollWidth' };
        var client = { 'vertical': 'clientHeight', 'horizontal': 'clientWidth' };
        if (isNullOrUndefined(element)) {
            return null;
        }
        if (element[scroll[axis]] > element[client[axis]]) {
            if (axis === 'vertical' ? element.scrollTop > 0 : element.scrollLeft > 0) {
                if (axis === 'vertical') {
                    this.parentScrollY = this.parentScrollY +
                        (this.parentScrollY === 0 ? element.scrollTop : element.scrollTop - this.parentScrollY);
                    this.tempScrollHeight = element.scrollHeight;
                }
                else {
                    this.parentScrollX = this.parentScrollX +
                        (this.parentScrollX === 0 ? element.scrollLeft : element.scrollLeft - this.parentScrollX);
                    this.tempScrollWidth = element.scrollWidth;
                }
                if (!isNullOrUndefined(element)) {
                    return this.getScrollableParent(element.parentNode, axis);
                }
                else {
                    return element;
                }
            }
            else {
                return this.getScrollableParent(element.parentNode, axis);
            }
        }
        else {
            return this.getScrollableParent(element.parentNode, axis);
        }
    };
    Draggable.prototype.getScrollableValues = function () {
        this.parentScrollX = 0;
        this.parentScrollY = 0;
        var isModalDialog = this.element.classList.contains('e-dialog') && this.element.classList.contains('e-dlg-modal');
        var verticalScrollParent = this.getScrollableParent(this.element.parentNode, 'vertical');
        var horizontalScrollParent = this.getScrollableParent(this.element.parentNode, 'horizontal');
    };
    Draggable.prototype.initialize = function (evt, curTarget) {
        this.currentStateTarget = evt.target;
        if (this.isDragStarted()) {
            return;
        }
        else {
            this.isDragStarted(true);
            this.externalInitialize = false;
        }
        this.target = (evt.currentTarget || curTarget);
        this.dragProcessStarted = false;
        if (this.abort) {
            /* tslint:disable no-any */
            var abortSelectors = this.abort;
            if (typeof abortSelectors === 'string') {
                abortSelectors = [abortSelectors];
            }
            for (var i = 0; i < abortSelectors.length; i++) {
                if (!isNullOrUndefined(closest(evt.target, abortSelectors[i]))) {
                    /* istanbul ignore next */
                    if (this.isDragStarted()) {
                        this.isDragStarted(true);
                    }
                    return;
                }
            }
        }
        if (this.preventDefault && !isUndefined(evt.changedTouches) && evt.type !== 'touchstart') {
            evt.preventDefault();
        }
        this.element.setAttribute('aria-grabbed', 'true');
        var intCoord = this.getCoordinates(evt);
        this.initialPosition = { x: intCoord.pageX, y: intCoord.pageY };
        if (!this.clone) {
            var pos = this.element.getBoundingClientRect();
            this.getScrollableValues();
            if (evt.clientX === evt.pageX) {
                this.parentScrollX = 0;
            }
            if (evt.clientY === evt.pageY) {
                this.parentScrollY = 0;
            }
            this.relativeXPosition = intCoord.pageX - (pos.left + this.parentScrollX);
            this.relativeYPosition = intCoord.pageY - (pos.top + this.parentScrollY);
        }
        if (this.externalInitialize) {
            this.intDragStart(evt);
        }
        else {
            EventHandler.add(document, Browser.touchMoveEvent, this.intDragStart, this);
            EventHandler.add(document, Browser.touchEndEvent, this.intDestroy, this);
        }
        this.toggleEvents(true);
        if (evt.type !== 'touchstart' && this.isPreventSelect) {
            document.body.classList.add('e-prevent-select');
        }
        this.externalInitialize = false;
        EventHandler.trigger(document.documentElement, Browser.touchStartEvent, evt);
    };
    Draggable.prototype.intDragStart = function (evt) {
        this.removeTapholdTimer();
        var isChangeTouch = !isUndefined(evt.changedTouches);
        if (isChangeTouch && (evt.changedTouches.length !== 1)) {
            return;
        }
        if (isChangeTouch) {
            evt.preventDefault();
        }
        var intCordinate = this.getCoordinates(evt);
        var pos;
        var styleProp = getComputedStyle(this.element);
        this.margin = {
            left: parseInt(styleProp.marginLeft, 10),
            top: parseInt(styleProp.marginTop, 10),
            right: parseInt(styleProp.marginRight, 10),
            bottom: parseInt(styleProp.marginBottom, 10),
        };
        var element = this.element;
        if (this.clone && this.dragTarget) {
            var intClosest = closest(evt.target, this.dragTarget);
            if (!isNullOrUndefined(intClosest)) {
                element = intClosest;
            }
        }
        /* istanbul ignore next */
        if (this.isReplaceDragEle) {
            element = this.currentStateCheck(evt.target, element);
        }
        this.offset = this.calculateParentPosition(element);
        this.position = this.getMousePosition(evt, this.isDragScroll);
        var x = this.initialPosition.x - intCordinate.pageX;
        var y = this.initialPosition.y - intCordinate.pageY;
        var distance = Math.sqrt((x * x) + (y * y));
        if ((distance >= this.distance || this.externalInitialize)) {
            var ele = this.getHelperElement(evt);
            if (!ele || isNullOrUndefined(ele)) {
                return;
            }
            var dragTargetElement = this.helperElement = ele;
            this.parentClientRect = this.calculateParentPosition(dragTargetElement.offsetParent);
            if (this.dragStart) {
                var curTarget = this.getProperTargetElement(evt);
                var args = {
                    event: evt,
                    element: element,
                    target: curTarget,
                    bindEvents: isBlazor() ? this.bindDragEvents.bind(this) : null,
                    dragElement: dragTargetElement
                };
                this.trigger('dragStart', args);
            }
            if (this.dragArea) {
                this.setDragArea();
            }
            else {
                this.dragLimit = { left: 0, right: 0, bottom: 0, top: 0 };
                this.borderWidth = { top: 0, left: 0 };
            }
            pos = { left: this.position.left - this.parentClientRect.left, top: this.position.top - this.parentClientRect.top };
            if (this.clone && !this.enableTailMode) {
                this.diffX = this.position.left - this.offset.left;
                this.diffY = this.position.top - this.offset.top;
            }
            this.getScrollableValues();
            // when drag element has margin-top
            var styles = getComputedStyle(element);
            var marginTop = parseFloat(styles.marginTop);
            /* istanbul ignore next */
            if (this.clone && marginTop !== 0) {
                pos.top += marginTop;
            }
            if (this.enableScrollHandler && !this.clone) {
                pos.top -= this.parentScrollY;
                pos.left -= this.parentScrollX;
            }
            var posValue = this.getProcessedPositionValue({
                top: (pos.top - this.diffY) + 'px',
                left: (pos.left - this.diffX) + 'px'
            });
            this.dragElePosition = { top: pos.top, left: pos.left };
            setStyleAttribute(dragTargetElement, this.getDragPosition({ position: 'absolute', left: posValue.left, top: posValue.top }));
            EventHandler.remove(document, Browser.touchMoveEvent, this.intDragStart);
            EventHandler.remove(document, Browser.touchEndEvent, this.intDestroy);
            if (!isBlazor()) {
                this.bindDragEvents(dragTargetElement);
            }
        }
    };
    Draggable.prototype.bindDragEvents = function (dragTargetElement) {
        if (isVisible(dragTargetElement)) {
            EventHandler.add(document, Browser.touchMoveEvent, this.intDrag, this);
            EventHandler.add(document, Browser.touchEndEvent, this.intDragStop, this);
            this.setGlobalDroppables(false, this.element, dragTargetElement);
        }
        else {
            this.toggleEvents();
            document.body.classList.remove('e-prevent-select');
        }
    };
    Draggable.prototype.elementInViewport = function (el) {
        this.top = el.offsetTop;
        this.left = el.offsetLeft;
        this.width = el.offsetWidth;
        this.height = el.offsetHeight;
        while (el.offsetParent) {
            el = el.offsetParent;
            this.top += el.offsetTop;
            this.left += el.offsetLeft;
        }
        return (this.top >= window.pageYOffset &&
            this.left >= window.pageXOffset &&
            (this.top + this.height) <= (window.pageYOffset + window.innerHeight) &&
            (this.left + this.width) <= (window.pageXOffset + window.innerWidth));
    };
    Draggable.prototype.getProcessedPositionValue = function (value) {
        if (this.queryPositionInfo) {
            return this.queryPositionInfo(value);
        }
        return value;
    };
    Draggable.prototype.calculateParentPosition = function (ele) {
        if (isNullOrUndefined(ele)) {
            return { left: 0, top: 0 };
        }
        var rect = ele.getBoundingClientRect();
        var style = getComputedStyle(ele);
        return {
            left: (rect.left + window.pageXOffset) - parseInt(style.marginLeft, 10),
            top: (rect.top + window.pageYOffset) - parseInt(style.marginTop, 10)
        };
    };
    // tslint:disable-next-line:max-func-body-length
    Draggable.prototype.intDrag = function (evt) {
        if (!isUndefined(evt.changedTouches) && (evt.changedTouches.length !== 1)) {
            return;
        }
        var left;
        var top;
        this.position = this.getMousePosition(evt, this.isDragScroll);
        var docHeight = this.getDocumentWidthHeight('Height');
        if (docHeight < this.position.top) {
            this.position.top = docHeight;
        }
        var docWidth = this.getDocumentWidthHeight('Width');
        if (docWidth < this.position.left) {
            this.position.left = docWidth;
        }
        if (this.drag) {
            var curTarget = this.getProperTargetElement(evt);
            this.trigger('drag', { event: evt, element: this.element, target: curTarget });
        }
        var eleObj = this.checkTargetElement(evt);
        if (eleObj.target && eleObj.instance) {
            /* tslint:disable no-any */
            var flag = true;
            if (this.hoverObject) {
                if (this.hoverObject.instance !== eleObj.instance) {
                    this.triggerOutFunction(evt, eleObj);
                }
                else {
                    flag = false;
                }
            }
            if (flag) {
                eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
                eleObj.instance.intOver(evt, eleObj.target);
                this.hoverObject = eleObj;
            }
        }
        else if (this.hoverObject) {
            this.triggerOutFunction(evt, eleObj);
        }
        var helperElement = this.droppables[this.scope].helper;
        this.parentClientRect = this.calculateParentPosition(this.helperElement.offsetParent);
        var tLeft = this.parentClientRect.left;
        var tTop = this.parentClientRect.top;
        var intCoord = this.getCoordinates(evt);
        var pagex = intCoord.pageX;
        var pagey = intCoord.pageY;
        var dLeft = this.position.left - this.diffX;
        var dTop = this.position.top - this.diffY;
        var styles = getComputedStyle(helperElement);
        var marginTop = parseFloat(styles.marginTop);
        if (this.dragArea) {
            if (this.pageX !== pagex || this.skipDistanceCheck) {
                var helperWidth = helperElement.offsetWidth + (parseFloat(styles.marginLeft)
                    + parseFloat(styles.marginRight));
                if (this.dragLimit.left > dLeft && dLeft > 0) {
                    left = this.dragLimit.left;
                }
                else if (this.dragLimit.right + window.pageXOffset < dLeft + helperWidth && dLeft > 0) {
                    left = dLeft - (dLeft - this.dragLimit.right) + window.pageXOffset - helperWidth;
                }
                else {
                    left = dLeft < 0 ? this.dragLimit.left : dLeft;
                }
            }
            if (this.pageY !== pagey || this.skipDistanceCheck) {
                var helperHeight = helperElement.offsetHeight + (parseFloat(styles.marginTop)
                    + parseFloat(styles.marginBottom));
                if (this.dragLimit.top > dTop && dTop > 0) {
                    top = this.dragLimit.top;
                }
                else if (this.dragLimit.bottom + window.pageYOffset < dTop + helperHeight && dTop > 0) {
                    top = dTop - (dTop - this.dragLimit.bottom) + window.pageYOffset - helperHeight;
                }
                else {
                    top = dTop < 0 ? this.dragLimit.top : dTop;
                }
            }
        }
        else {
            left = dLeft;
            top = dTop;
        }
        var iTop = tTop + this.borderWidth.top;
        var iLeft = tLeft + this.borderWidth.left;
        if (this.dragProcessStarted) {
            if (isNullOrUndefined(top)) {
                top = this.prevTop;
            }
            if (isNullOrUndefined(left)) {
                left = this.prevLeft;
            }
        }
        var draEleTop;
        var draEleLeft;
        if (this.dragArea) {
            this.dragLimit.top = this.clone ? this.dragLimit.top : 0;
            draEleTop = (top - iTop) < 0 ? this.dragLimit.top : (top - iTop);
            draEleLeft = (left - iLeft) < 0 ? this.dragElePosition.left : (left - iLeft);
            // when drag-element has margin-top
            /* istanbul ignore next */
            if (marginTop > 0) {
                if (this.clone) {
                    draEleTop += this.element.offsetTop;
                    if (dTop < 0) {
                        if ((this.element.offsetTop + dTop) >= 0) {
                            draEleTop = this.element.offsetTop + dTop;
                        }
                        else {
                            draEleTop -= this.element.offsetTop;
                        }
                    }
                    draEleTop = (this.dragLimit.bottom < draEleTop) ? this.dragLimit.bottom : draEleTop;
                }
                if ((top - iTop) < 0) {
                    if (dTop + marginTop + (helperElement.offsetHeight - iTop) >= 0) {
                        var tempDraEleTop = this.dragLimit.top + dTop - iTop;
                        if ((tempDraEleTop + marginTop + iTop) < 0) {
                            draEleTop -= marginTop + iTop;
                        }
                        else {
                            draEleTop = tempDraEleTop;
                        }
                    }
                    else {
                        draEleTop -= marginTop + iTop;
                    }
                }
            }
        }
        else {
            draEleTop = top - iTop;
            draEleLeft = left - iLeft;
        }
        if (this.enableScrollHandler && !this.clone) {
            draEleTop -= this.parentScrollY;
            draEleLeft -= this.parentScrollX;
        }
        var dragValue = this.getProcessedPositionValue({ top: draEleTop + 'px', left: draEleLeft + 'px' });
        setStyleAttribute(helperElement, this.getDragPosition(dragValue));
        if (!this.elementInViewport(helperElement) && this.enableAutoScroll) {
            this.helperElement.scrollIntoView();
        }
        this.dragProcessStarted = true;
        this.prevLeft = left;
        this.prevTop = top;
        this.position.left = left;
        this.position.top = top;
        this.pageX = pagex;
        this.pageY = pagey;
    };
    Draggable.prototype.triggerOutFunction = function (evt, eleObj) {
        this.hoverObject.instance.intOut(evt, eleObj.target);
        this.hoverObject.instance.dragData[this.scope] = null;
        this.hoverObject = null;
    };
    Draggable.prototype.getDragPosition = function (dragValue) {
        var temp = extend({}, dragValue);
        if (this.axis) {
            if (this.axis === 'x') {
                delete temp.top;
            }
            else if (this.axis === 'y') {
                delete temp.left;
            }
        }
        return temp;
    };
    Draggable.prototype.getDocumentWidthHeight = function (str) {
        var docBody = document.body;
        var docEle = document.documentElement;
        var returnValue = Math.max(docBody['scroll' + str], docEle['scroll' + str], docBody['offset' + str], docEle['offset' + str], docEle['client' + str]);
        return returnValue;
    };
    Draggable.prototype.intDragStop = function (evt) {
        this.dragProcessStarted = false;
        if (!isUndefined(evt.changedTouches) && (evt.changedTouches.length !== 1)) {
            return;
        }
        var type = ['touchend', 'pointerup', 'mouseup'];
        if (type.indexOf(evt.type) !== -1) {
            if (this.dragStop) {
                var curTarget = this.getProperTargetElement(evt);
                this.trigger('dragStop', { event: evt, element: this.element, target: curTarget, helper: this.helperElement });
            }
            this.intDestroy(evt);
        }
        else {
            this.element.setAttribute('aria-grabbed', 'false');
        }
        var eleObj = this.checkTargetElement(evt);
        if (eleObj.target && eleObj.instance) {
            eleObj.instance.dragStopCalled = true;
            eleObj.instance.dragData[this.scope] = this.droppables[this.scope];
            eleObj.instance.intDrop(evt, eleObj.target);
        }
        this.setGlobalDroppables(true);
        document.body.classList.remove('e-prevent-select');
    };
    /**
     * @private
     */
    Draggable.prototype.intDestroy = function (evt) {
        this.dragProcessStarted = false;
        this.toggleEvents();
        document.body.classList.remove('e-prevent-select');
        this.element.setAttribute('aria-grabbed', 'false');
        EventHandler.remove(document, Browser.touchMoveEvent, this.intDragStart);
        EventHandler.remove(document, Browser.touchEndEvent, this.intDragStop);
        EventHandler.remove(document, Browser.touchEndEvent, this.intDestroy);
        EventHandler.remove(document, Browser.touchMoveEvent, this.intDrag);
        if (this.isDragStarted()) {
            this.isDragStarted(true);
        }
    };
    // triggers when property changed
    Draggable.prototype.onPropertyChanged = function (newProp, oldProp) {
        //No Code to handle
    };
    Draggable.prototype.getModuleName = function () {
        return 'draggable';
    };
    Draggable.prototype.isDragStarted = function (change) {
        if (change) {
            isDraggedObject.isDragged = !isDraggedObject.isDragged;
        }
        return isDraggedObject.isDragged;
    };
    Draggable.prototype.setDragArea = function () {
        var eleWidthBound;
        var eleHeightBound;
        var top = 0;
        var left = 0;
        var ele;
        var type = typeof this.dragArea;
        if (type === 'string') {
            ele = select(this.dragArea);
        }
        else {
            ele = this.dragArea;
        }
        if (ele) {
            var elementArea = ele.getBoundingClientRect();
            eleWidthBound = ele.scrollWidth ? ele.scrollWidth : elementArea.right - elementArea.left;
            eleHeightBound = ele.scrollHeight ? ele.scrollHeight : elementArea.bottom - elementArea.top;
            var keys = ['Top', 'Left', 'Bottom', 'Right'];
            var styles = getComputedStyle(ele);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var tborder = styles['border' + key + 'Width'];
                var tpadding = styles['padding' + key];
                var lowerKey = key.toLowerCase();
                this.borderWidth[lowerKey] = isNaN(parseFloat(tborder)) ? 0 : parseFloat(tborder);
                this.padding[lowerKey] = isNaN(parseFloat(tpadding)) ? 0 : parseFloat(tpadding);
            }
            top = elementArea.top;
            left = elementArea.left;
            this.dragLimit.left = left + this.borderWidth.left + this.padding.left;
            this.dragLimit.top = ele.offsetTop + this.borderWidth.top + this.padding.top;
            this.dragLimit.right = left + eleWidthBound - (this.borderWidth.right + this.padding.right);
            this.dragLimit.bottom = top + eleHeightBound - (this.borderWidth.bottom + this.padding.bottom);
        }
    };
    Draggable.prototype.getProperTargetElement = function (evt) {
        var intCoord = this.getCoordinates(evt);
        var ele;
        var prevStyle = this.helperElement.style.pointerEvents || '';
        if (compareElementParent(evt.target, this.helperElement) || evt.type.indexOf('touch') !== -1) {
            this.helperElement.style.pointerEvents = 'none';
            ele = document.elementFromPoint(intCoord.clientX, intCoord.clientY);
            this.helperElement.style.pointerEvents = prevStyle;
        }
        else {
            ele = evt.target;
        }
        return ele;
    };
    /* istanbul ignore next */
    Draggable.prototype.currentStateCheck = function (ele, oldEle) {
        var elem;
        if (!isNullOrUndefined(this.currentStateTarget) && this.currentStateTarget !== ele) {
            elem = this.currentStateTarget;
        }
        else {
            elem = !isNullOrUndefined(oldEle) ? oldEle : ele;
        }
        return elem;
    };
    Draggable.prototype.getMousePosition = function (evt, isdragscroll) {
        /* tslint:disable no-any */
        var dragEle = evt.srcElement !== undefined ? evt.srcElement : evt.target;
        var intCoord = this.getCoordinates(evt);
        var pageX;
        var pageY;
        var isOffsetParent = isNullOrUndefined(dragEle.offsetParent);
        /* istanbul ignore next */
        if (isdragscroll) {
            pageX = this.clone ? intCoord.pageX :
                (intCoord.pageX + (isOffsetParent ? 0 : dragEle.offsetParent.scrollLeft)) - this.relativeXPosition;
            pageY = this.clone ? intCoord.pageY :
                (intCoord.pageY + (isOffsetParent ? 0 : dragEle.offsetParent.scrollTop)) - this.relativeYPosition;
        }
        else {
            pageX = this.clone ? intCoord.pageX : (intCoord.pageX + window.pageXOffset) - this.relativeXPosition;
            pageY = this.clone ? intCoord.pageY : (intCoord.pageY + window.pageYOffset) - this.relativeYPosition;
        }
        if (!this.clone && this.dragArea && !isdragscroll) {
            this.getScrollableValues();
            pageY -= this.tempScrollHeight ? this.parentScrollY : 0;
            pageX -= this.tempScrollWidth ? this.parentScrollX : 0;
        }
        return {
            left: pageX - (this.margin.left + this.cursorAt.left),
            top: pageY - (this.margin.top + this.cursorAt.top)
        };
    };
    Draggable.prototype.getCoordinates = function (evt) {
        if (evt.type.indexOf('touch') > -1) {
            return evt.changedTouches[0];
        }
        return evt;
    };
    Draggable.prototype.getHelperElement = function (evt) {
        var element;
        if (this.clone) {
            if (this.helper) {
                element = this.helper({ sender: evt, element: this.target });
            }
            else {
                element = createElement('div', { className: 'e-drag-helper e-block-touch', innerHTML: 'Draggable' });
                document.body.appendChild(element);
            }
        }
        else {
            element = this.element;
        }
        return element;
    };
    Draggable.prototype.setGlobalDroppables = function (reset, drag, helper) {
        this.droppables[this.scope] = reset ? null : {
            draggable: drag,
            helper: helper,
            draggedElement: this.element
        };
    };
    Draggable.prototype.checkTargetElement = function (evt) {
        var target = this.getProperTargetElement(evt);
        var dropIns = this.getDropInstance(target);
        if (!dropIns && target && !isNullOrUndefined(target.parentNode)) {
            var parent_1 = closest(target.parentNode, '.e-droppable') || target.parentElement;
            if (parent_1) {
                dropIns = this.getDropInstance(parent_1);
            }
        }
        return { target: target, instance: dropIns };
    };
    Draggable.prototype.getDropInstance = function (ele) {
        var name = 'getModuleName';
        var drop;
        var eleInst = ele && ele.ej2_instances;
        if (eleInst) {
            for (var _i = 0, eleInst_1 = eleInst; _i < eleInst_1.length; _i++) {
                var inst = eleInst_1[_i];
                if (inst[name]() === 'droppable') {
                    drop = inst;
                    break;
                }
            }
        }
        return drop;
    };
    Draggable.prototype.destroy = function () {
        this.toggleEvents(true);
        _super.prototype.destroy.call(this);
    };
    var Draggable_1;
    __decorate$2([
        Complex({}, Position)
    ], Draggable.prototype, "cursorAt", void 0);
    __decorate$2([
        Property(true)
    ], Draggable.prototype, "clone", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "dragArea", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "isDragScroll", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "isReplaceDragEle", void 0);
    __decorate$2([
        Property(true)
    ], Draggable.prototype, "isPreventSelect", void 0);
    __decorate$2([
        Event$1()
    ], Draggable.prototype, "drag", void 0);
    __decorate$2([
        Event$1()
    ], Draggable.prototype, "dragStart", void 0);
    __decorate$2([
        Event$1()
    ], Draggable.prototype, "dragStop", void 0);
    __decorate$2([
        Property(1)
    ], Draggable.prototype, "distance", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "handle", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "abort", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "helper", void 0);
    __decorate$2([
        Property('default')
    ], Draggable.prototype, "scope", void 0);
    __decorate$2([
        Property('')
    ], Draggable.prototype, "dragTarget", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "axis", void 0);
    __decorate$2([
        Property()
    ], Draggable.prototype, "queryPositionInfo", void 0);
    __decorate$2([
        Property(false)
    ], Draggable.prototype, "enableTailMode", void 0);
    __decorate$2([
        Property(false)
    ], Draggable.prototype, "skipDistanceCheck", void 0);
    __decorate$2([
        Property(true)
    ], Draggable.prototype, "preventDefault", void 0);
    __decorate$2([
        Property(false)
    ], Draggable.prototype, "enableAutoScroll", void 0);
    __decorate$2([
        Property(false)
    ], Draggable.prototype, "enableTapHold", void 0);
    __decorate$2([
        Property(750)
    ], Draggable.prototype, "tapHoldThreshold", void 0);
    __decorate$2([
        Property(false)
    ], Draggable.prototype, "enableScrollHandler", void 0);
    Draggable = Draggable_1 = __decorate$2([
        NotifyPropertyChanges
    ], Draggable);
    return Draggable;
}(Base));

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Droppable Module provides support to enable droppable functionality in Dom Elements.
 * ```html
 * <div id='drop'>Droppable</div>
 * <script>
 * let ele:HTMLElement = document.getElementById('drop');
 * var drag:Droppable = new Droppable(ele,{
 *     accept:'.drop',
 *     drop: function(e) {
 *      //drop handler code.
 *     }
 * });
 * </script>
 * ```
 */
var Droppable = /** @class */ (function (_super) {
    __extends$3(Droppable, _super);
    function Droppable(element, options) {
        var _this = _super.call(this, options, element) || this;
        _this.mouseOver = false;
        _this.dragData = {};
        _this.dragStopCalled = false;
        _this.bind();
        return _this;
    }
    Droppable.prototype.bind = function () {
        this.wireEvents();
    };
    Droppable.prototype.wireEvents = function () {
        EventHandler.add(this.element, Browser.touchEndEvent, this.intDrop, this);
    };
    // triggers when property changed
    // eslint-disable-next-line
    Droppable.prototype.onPropertyChanged = function (newProp, oldProp) {
        //No Code to handle
    };
    Droppable.prototype.getModuleName = function () {
        return 'droppable';
    };
    Droppable.prototype.intOver = function (event, element) {
        if (!this.mouseOver) {
            var drag = this.dragData[this.scope];
            this.trigger('over', { event: event, target: element, dragData: drag });
            this.mouseOver = true;
        }
    };
    Droppable.prototype.intOut = function (event, element) {
        if (this.mouseOver) {
            this.trigger('out', { evt: event, target: element });
            this.mouseOver = false;
        }
    };
    Droppable.prototype.intDrop = function (evt, element) {
        if (!this.dragStopCalled) {
            return;
        }
        else {
            this.dragStopCalled = false;
        }
        var accept = true;
        var drag = this.dragData[this.scope];
        var isDrag = drag ? (drag.helper && isVisible(drag.helper)) : false;
        var area;
        if (isDrag) {
            area = this.isDropArea(evt, drag.helper, element);
            if (this.accept) {
                accept = matches(drag.helper, this.accept);
            }
        }
        if (isDrag && this.drop && area.canDrop && accept) {
            this.trigger('drop', { event: evt, target: area.target, droppedElement: drag.helper, dragData: drag });
        }
        this.mouseOver = false;
    };
    Droppable.prototype.isDropArea = function (evt, helper, element) {
        var area = { canDrop: true, target: element || evt.target };
        var isTouch = evt.type === 'touchend';
        if (isTouch || area.target === helper) {
            helper.style.display = 'none';
            var coord = isTouch ? (evt.changedTouches[0]) : evt;
            var ele = document.elementFromPoint(coord.clientX, coord.clientY);
            area.canDrop = false;
            area.canDrop = compareElementParent(ele, this.element);
            if (area.canDrop) {
                area.target = ele;
            }
            helper.style.display = '';
        }
        return area;
    };
    Droppable.prototype.destroy = function () {
        EventHandler.remove(this.element, Browser.touchEndEvent, this.intDrop);
        _super.prototype.destroy.call(this);
    };
    __decorate$3([
        Property()
    ], Droppable.prototype, "accept", void 0);
    __decorate$3([
        Property('default')
    ], Droppable.prototype, "scope", void 0);
    __decorate$3([
        Event$1()
    ], Droppable.prototype, "drop", void 0);
    __decorate$3([
        Event$1()
    ], Droppable.prototype, "over", void 0);
    __decorate$3([
        Event$1()
    ], Droppable.prototype, "out", void 0);
    Droppable = __decorate$3([
        NotifyPropertyChanges
    ], Droppable);
    return Droppable;
}(Base));

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var keyCode = {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'control': 17,
    'alt': 18,
    'pause': 19,
    'capslock': 20,
    'space': 32,
    'escape': 27,
    'pageup': 33,
    'pagedown': 34,
    'end': 35,
    'home': 36,
    'leftarrow': 37,
    'uparrow': 38,
    'rightarrow': 39,
    'downarrow': 40,
    'insert': 45,
    'delete': 46,
    'f1': 112,
    'f2': 113,
    'f3': 114,
    'f4': 115,
    'f5': 116,
    'f6': 117,
    'f7': 118,
    'f8': 119,
    'f9': 120,
    'f10': 121,
    'f11': 122,
    'f12': 123,
    'semicolon': 186,
    'plus': 187,
    'comma': 188,
    'minus': 189,
    'dot': 190,
    'forwardslash': 191,
    'graveaccent': 192,
    'openbracket': 219,
    'backslash': 220,
    'closebracket': 221,
    'singlequote': 222
};
/**
 * KeyboardEvents class enables you to bind key action desired key combinations for ex., Ctrl+A, Delete, Alt+Space etc.
 * ```html
 * <div id='testEle'>  </div>;
 * <script>
 *   let node: HTMLElement = document.querySelector('#testEle');
 *   let kbInstance = new KeyboardEvents({
 *       element: node,
 *       keyConfigs:{ selectAll : 'ctrl+a' },
 *       keyAction: function (e:KeyboardEvent, action:string) {
 *           // handler function code
 *       }
 *   });
 * </script>
 * ```
 */
var KeyboardEvents = /** @class */ (function (_super) {
    __extends$4(KeyboardEvents, _super);
    /**
     * Initializes the KeyboardEvents
     *
     * @param {HTMLElement} element ?
     * @param {KeyboardEventsModel} options ?
     */
    function KeyboardEvents(element, options) {
        var _this = _super.call(this, options, element) || this;
        /**
         * To handle a key press event returns null
         *
         * @param {KeyboardEventArgs} e ?
         * @returns {void} ?
         */
        _this.keyPressHandler = function (e) {
            var isAltKey = e.altKey;
            var isCtrlKey = e.ctrlKey;
            var isShiftKey = e.shiftKey;
            var curkeyCode = e.which;
            var keys = Object.keys(_this.keyConfigs);
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                var configCollection = _this.keyConfigs[key].split(',');
                for (var _a = 0, configCollection_1 = configCollection; _a < configCollection_1.length; _a++) {
                    var rconfig = configCollection_1[_a];
                    var rKeyObj = KeyboardEvents_1.getKeyConfigData(rconfig.trim());
                    if (isAltKey === rKeyObj.altKey && isCtrlKey === rKeyObj.ctrlKey &&
                        isShiftKey === rKeyObj.shiftKey && curkeyCode === rKeyObj.keyCode) {
                        e.action = key;
                        if (_this.keyAction) {
                            _this.keyAction(e);
                        }
                    }
                }
            }
        };
        _this.bind();
        return _this;
    }
    KeyboardEvents_1 = KeyboardEvents;
    /**
     * Unwire bound events and destroy the instance.
     *
     * @returns {void} ?
     */
    KeyboardEvents.prototype.destroy = function () {
        this.unwireEvents();
        _super.prototype.destroy.call(this);
    };
    /**
     * Function can be used to specify certain action if a property is changed
     *
     * @param {KeyboardEventsModel} newProp ?
     * @param {KeyboardEventsModel} oldProp ?
     * @returns {void} ?
     * @private
     */
    // eslint-disable-next-line
    KeyboardEvents.prototype.onPropertyChanged = function (newProp, oldProp) {
        // No code are needed
    };
    KeyboardEvents.prototype.bind = function () {
        this.wireEvents();
    };
    /**
     * To get the module name, returns 'keyboard'.
     *
     * @returns {string} ?
     * @private
     */
    KeyboardEvents.prototype.getModuleName = function () {
        return 'keyboard';
    };
    /**
     * Wiring event handlers to events
     *
     * @returns {void} ?
     * @private
     */
    KeyboardEvents.prototype.wireEvents = function () {
        this.element.addEventListener(this.eventName, this.keyPressHandler);
    };
    /**
     * Unwiring event handlers to events
     *
     * @returns {void} ?
     * @private
     */
    KeyboardEvents.prototype.unwireEvents = function () {
        this.element.removeEventListener(this.eventName, this.keyPressHandler);
    };
    /**
     * To get the key configuration data
     *
     * @param {string} config - configuration data
     * @returns {KeyData} ?
     */
    KeyboardEvents.getKeyConfigData = function (config) {
        if (config in this.configCache) {
            return this.configCache[config];
        }
        var keys = config.toLowerCase().split('+');
        var keyData = {
            altKey: (keys.indexOf('alt') !== -1 ? true : false),
            ctrlKey: (keys.indexOf('ctrl') !== -1 ? true : false),
            shiftKey: (keys.indexOf('shift') !== -1 ? true : false),
            keyCode: null
        };
        if (keys[keys.length - 1].length > 1 && !!Number(keys[keys.length - 1])) {
            keyData.keyCode = Number(keys[keys.length - 1]);
        }
        else {
            keyData.keyCode = KeyboardEvents_1.getKeyCode(keys[keys.length - 1]);
        }
        KeyboardEvents_1.configCache[config] = keyData;
        return keyData;
    };
    // Return the keycode value as string
    KeyboardEvents.getKeyCode = function (keyVal) {
        return keyCode[keyVal] || keyVal.toUpperCase().charCodeAt(0);
    };
    var KeyboardEvents_1;
    KeyboardEvents.configCache = {};
    __decorate$4([
        Property({})
    ], KeyboardEvents.prototype, "keyConfigs", void 0);
    __decorate$4([
        Property('keyup')
    ], KeyboardEvents.prototype, "eventName", void 0);
    __decorate$4([
        Event$1()
    ], KeyboardEvents.prototype, "keyAction", void 0);
    KeyboardEvents = KeyboardEvents_1 = __decorate$4([
        NotifyPropertyChanges
    ], KeyboardEvents);
    return KeyboardEvents;
}(Base));

/**
 * L10n modules provides localized text for different culture.
 * ```typescript
 * import {setCulture} from '@syncfusion/ts-base-library';
 * //load global locale object common for all components.
 * L10n.load({
 *    'fr-BE': {
 *       'button': {
 *            'check': 'vérifié'
 *        }
 *    }
 * });
 * //set globale default locale culture.
 * setCulture('fr-BE');
 * let instance: L10n = new L10n('button', {
 *    check: 'checked'
 * });
 * //Get locale text for current property.
 * instance.getConstant('check');
 * //Change locale culture in a component.
 * instance.setLocale('en-US');
 * ```
 */
var L10n = /** @class */ (function () {
    /**
     * Constructor
     *
     * @param {string} controlName ?
     * @param {Object} localeStrings ?
     * @param {string} locale ?
     */
    function L10n(controlName, localeStrings, locale) {
        this.controlName = controlName;
        this.localeStrings = localeStrings;
        this.setLocale(locale || exports.defaultCulture);
    }
    /**
     * Sets the locale text
     *
     * @param {string} locale ?
     * @returns {void} ?
     */
    L10n.prototype.setLocale = function (locale) {
        var intLocale = this.intGetControlConstant(L10n.locale, locale);
        this.currentLocale = intLocale || this.localeStrings;
    };
    /**
     * Sets the global locale for all components.
     *
     * @param {Object} localeObject - specifies the localeObject to be set as global locale.
     * @returns {void} ?
     */
    L10n.load = function (localeObject) {
        this.locale = extend(this.locale, localeObject, {}, true);
    };
    /**
     * Returns current locale text for the property based on the culture name and control name.
     *
     * @param {string} prop - specifies the property for which localize text to be returned.
     * @returns {string} ?
     */
    L10n.prototype.getConstant = function (prop) {
        // Removed conditional operator because this method does not return correct value when passing 0 as value in localization
        if (!isNullOrUndefined(this.currentLocale[prop])) {
            return this.currentLocale[prop];
        }
        else {
            return this.localeStrings[prop] || '';
        }
    };
    /**
     * Returns the control constant object for current object and the locale specified.
     *
     * @param {Object} curObject ?
     * @param {string} locale ?
     * @returns {Object} ?
     */
    L10n.prototype.intGetControlConstant = function (curObject, locale) {
        if ((curObject)[locale]) {
            return (curObject)[locale][this.controlName];
        }
        return null;
    };
    L10n.locale = {};
    return L10n;
}());

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * SwipeSettings is a framework module that provides support to handle swipe event like swipe up, swipe right, etc..,
 */
var SwipeSettings = /** @class */ (function (_super) {
    __extends$5(SwipeSettings, _super);
    function SwipeSettings() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate$5([
        Property(50)
    ], SwipeSettings.prototype, "swipeThresholdDistance", void 0);
    return SwipeSettings;
}(ChildProperty));
var swipeRegex = /(Up|Down)/;
/**
 * Touch class provides support to handle the touch event like tap, double tap, tap hold, etc..,
 * ```typescript
 *    let node: HTMLElement;
 * let touchObj: Touch = new Touch({
 *    element: node,
 *    tap: function (e) {
 *        // tap handler function code
 *    }
 *    tapHold: function (e) {
 *        // tap hold handler function code
 *    }
 *    scroll: function (e) {
 *        // scroll handler function code
 *    }
 *    swipe: function (e) {
 *        // swipe handler function code
 *    }
 * });
 * ```
 */
var Touch = /** @class */ (function (_super) {
    __extends$5(Touch, _super);
    /* End-Properties */
    function Touch(element, options) {
        var _this = _super.call(this, options, element) || this;
        _this.touchAction = true;
        _this.tapCount = 0;
        /**
         *
         * @param {MouseEventArgs | TouchEventArgs} evt ?
         * @returns {void} ?
         */
        _this.startEvent = function (evt) {
            if (_this.touchAction === true) {
                var point = _this.updateChangeTouches(evt);
                if (evt.changedTouches !== undefined) {
                    _this.touchAction = false;
                }
                _this.isTouchMoved = false;
                _this.movedDirection = '';
                _this.startPoint = _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
                _this.startEventData = point;
                _this.hScrollLocked = _this.vScrollLocked = false;
                _this.tStampStart = Date.now();
                _this.timeOutTapHold = setTimeout(function () { _this.tapHoldEvent(evt); }, _this.tapHoldThreshold);
                EventHandler.add(_this.element, Browser.touchMoveEvent, _this.moveEvent, _this);
                EventHandler.add(_this.element, Browser.touchEndEvent, _this.endEvent, _this);
                EventHandler.add(_this.element, Browser.touchCancelEvent, _this.cancelEvent, _this);
            }
        };
        /**
         *
         * @param {MouseEventArgs | TouchEventArgs} evt ?
         * @returns {void} ?
         */
        _this.moveEvent = function (evt) {
            var point = _this.updateChangeTouches(evt);
            _this.movedPoint = point;
            _this.isTouchMoved = !(point.clientX === _this.startPoint.clientX && point.clientY === _this.startPoint.clientY);
            var eScrollArgs = {};
            if (_this.isTouchMoved) {
                clearTimeout(_this.timeOutTapHold);
                _this.calcScrollPoints(evt);
                var scrollArg = {
                    startEvents: _this.startEventData,
                    originalEvent: evt, startX: _this.startPoint.clientX,
                    startY: _this.startPoint.clientY, distanceX: _this.distanceX,
                    distanceY: _this.distanceY, scrollDirection: _this.scrollDirection,
                    velocity: _this.getVelocity(point)
                };
                eScrollArgs = extend(eScrollArgs, {}, scrollArg);
                _this.trigger('scroll', eScrollArgs);
                _this.lastMovedPoint = { clientX: point.clientX, clientY: point.clientY };
            }
        };
        /**
         *
         * @param {MouseEventArgs | TouchEventArgs} evt ?
         * @returns {void} ?
         */
        _this.cancelEvent = function (evt) {
            clearTimeout(_this.timeOutTapHold);
            clearTimeout(_this.timeOutTap);
            _this.tapCount = 0;
            _this.swipeFn(evt);
            EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
        };
        /**
         *
         * @param {MouseEventArgs | TouchEventArgs} evt ?
         * @returns {void} ?
         */
        _this.endEvent = function (evt) {
            _this.swipeFn(evt);
            if (!_this.isTouchMoved) {
                if (typeof _this.tap === 'function') {
                    _this.trigger('tap', { originalEvent: evt, tapCount: ++_this.tapCount });
                    _this.timeOutTap = setTimeout(function () {
                        _this.tapCount = 0;
                    }, _this.tapThreshold);
                }
            }
            _this.modeclear();
        };
        /**
         *
         * @param {MouseEventArgs | TouchEventArgs} evt ?
         * @returns {void} ?
         */
        _this.swipeFn = function (evt) {
            clearTimeout(_this.timeOutTapHold);
            clearTimeout(_this.timeOutTap);
            var point = _this.updateChangeTouches(evt);
            var diffX = point.clientX - _this.startPoint.clientX;
            var diffY = point.clientY - _this.startPoint.clientY;
            diffX = Math.floor(diffX < 0 ? -1 * diffX : diffX);
            diffY = Math.floor(diffY < 0 ? -1 * diffY : diffX);
            _this.isTouchMoved = diffX > 1 || diffY > 1;
            _this.endPoint = point;
            _this.calcPoints(evt);
            var swipeArgs = {
                originalEvent: evt,
                startEvents: _this.startEventData,
                startX: _this.startPoint.clientX,
                startY: _this.startPoint.clientY,
                distanceX: _this.distanceX, distanceY: _this.distanceY, swipeDirection: _this.movedDirection,
                velocity: _this.getVelocity(point)
            };
            if (_this.isTouchMoved) {
                var eSwipeArgs = void 0;
                var tDistance = _this.swipeSettings.swipeThresholdDistance;
                // eslint-disable-next-line
                eSwipeArgs = extend(eSwipeArgs, _this.defaultArgs, swipeArgs);
                var canTrigger = false;
                var ele = _this.element;
                var scrollBool = _this.isScrollable(ele);
                var moved = swipeRegex.test(_this.movedDirection);
                if ((tDistance < _this.distanceX && !moved) || (tDistance < _this.distanceY && moved)) {
                    if (!scrollBool) {
                        canTrigger = true;
                    }
                    else {
                        canTrigger = _this.checkSwipe(ele, moved);
                    }
                }
                if (canTrigger) {
                    _this.trigger('swipe', eSwipeArgs);
                }
            }
            _this.modeclear();
        };
        _this.modeclear = function () {
            _this.modeClear = setTimeout(function () {
                _this.touchAction = true;
            }, (typeof _this.tap !== 'function' ? 0 : 20));
            _this.lastTapTime = new Date().getTime();
            EventHandler.remove(_this.element, Browser.touchMoveEvent, _this.moveEvent);
            EventHandler.remove(_this.element, Browser.touchEndEvent, _this.endEvent);
            EventHandler.remove(_this.element, Browser.touchCancelEvent, _this.cancelEvent);
        };
        _this.bind();
        return _this;
    }
    // triggers when property changed
    /**
     *
     * @private
     * @param {TouchModel} newProp ?
     * @param {TouchModel} oldProp ?
     * @returns {void} ?
     */
    // eslint-disable-next-line
    Touch.prototype.onPropertyChanged = function (newProp, oldProp) {
        //No Code to handle
    };
    Touch.prototype.bind = function () {
        this.wireEvents();
        if (Browser.isIE) {
            this.element.classList.add('e-block-touch');
        }
    };
    /**
     * To destroy the touch instance.
     *
     * @returns {void}
     */
    Touch.prototype.destroy = function () {
        this.unwireEvents();
        _super.prototype.destroy.call(this);
    };
    // Need to changes the event binding once we updated the event handler.
    Touch.prototype.wireEvents = function () {
        EventHandler.add(this.element, Browser.touchStartEvent, this.startEvent, this);
    };
    Touch.prototype.unwireEvents = function () {
        EventHandler.remove(this.element, Browser.touchStartEvent, this.startEvent);
    };
    /**
     * Returns module name as touch
     *
     * @returns {string} ?
     * @private
     */
    Touch.prototype.getModuleName = function () {
        return 'touch';
    };
    /**
     * Returns if the HTML element is Scrollable.
     *
     * @param {HTMLElement} element - HTML Element to check if Scrollable.
     * @returns {boolean} ?
     */
    Touch.prototype.isScrollable = function (element) {
        var eleStyle = getComputedStyle(element);
        var style = eleStyle.overflow + eleStyle.overflowX + eleStyle.overflowY;
        if ((/(auto|scroll)/).test(style)) {
            return true;
        }
        return false;
    };
    /**
     *
     * @param {MouseEventArgs | TouchEventArgs} evt ?
     * @returns {void} ?
     */
    Touch.prototype.tapHoldEvent = function (evt) {
        this.tapCount = 0;
        this.touchAction = true;
        var eTapArgs;
        EventHandler.remove(this.element, Browser.touchMoveEvent, this.moveEvent);
        EventHandler.remove(this.element, Browser.touchEndEvent, this.endEvent);
        // eslint-disable-next-line
        eTapArgs = { originalEvent: evt };
        this.trigger('tapHold', eTapArgs);
        EventHandler.remove(this.element, Browser.touchCancelEvent, this.cancelEvent);
    };
    Touch.prototype.calcPoints = function (evt) {
        var point = this.updateChangeTouches(evt);
        this.defaultArgs = { originalEvent: evt };
        this.distanceX = Math.abs((Math.abs(point.clientX) - Math.abs(this.startPoint.clientX)));
        this.distanceY = Math.abs((Math.abs(point.clientY) - Math.abs(this.startPoint.clientY)));
        if (this.distanceX > this.distanceY) {
            this.movedDirection = (point.clientX > this.startPoint.clientX) ? 'Right' : 'Left';
        }
        else {
            this.movedDirection = (point.clientY < this.startPoint.clientY) ? 'Up' : 'Down';
        }
    };
    Touch.prototype.calcScrollPoints = function (evt) {
        var point = this.updateChangeTouches(evt);
        this.defaultArgs = { originalEvent: evt };
        this.distanceX = Math.abs((Math.abs(point.clientX) - Math.abs(this.lastMovedPoint.clientX)));
        this.distanceY = Math.abs((Math.abs(point.clientY) - Math.abs(this.lastMovedPoint.clientY)));
        if ((this.distanceX > this.distanceY || this.hScrollLocked === true) && this.vScrollLocked === false) {
            this.scrollDirection = (point.clientX > this.lastMovedPoint.clientX) ? 'Right' : 'Left';
            this.hScrollLocked = true;
        }
        else {
            this.scrollDirection = (point.clientY < this.lastMovedPoint.clientY) ? 'Up' : 'Down';
            this.vScrollLocked = true;
        }
    };
    Touch.prototype.getVelocity = function (pnt) {
        var newX = pnt.clientX;
        var newY = pnt.clientY;
        var newT = Date.now();
        var xDist = newX - this.startPoint.clientX;
        var yDist = newY - this.startPoint.clientX;
        var interval = newT - this.tStampStart;
        return Math.sqrt(xDist * xDist + yDist * yDist) / interval;
    };
    // eslint-disable-next-line
    Touch.prototype.checkSwipe = function (ele, flag) {
        var keys = ['scroll', 'offset'];
        var temp = flag ? ['Height', 'Top'] : ['Width', 'Left'];
        if ((ele[keys[0] + temp[0]] <= ele[keys[1] + temp[0]])) {
            return true;
        }
        return (ele[keys[0] + temp[1]] === 0) ||
            (ele[keys[1] + temp[0]] + ele[keys[0] + temp[1]] >= ele[keys[0] + temp[0]]);
    };
    Touch.prototype.updateChangeTouches = function (evt) {
        var point = evt.changedTouches && evt.changedTouches.length !== 0 ? evt.changedTouches[0] : evt;
        return point;
    };
    __decorate$5([
        Event$1()
    ], Touch.prototype, "tap", void 0);
    __decorate$5([
        Event$1()
    ], Touch.prototype, "tapHold", void 0);
    __decorate$5([
        Event$1()
    ], Touch.prototype, "swipe", void 0);
    __decorate$5([
        Event$1()
    ], Touch.prototype, "scroll", void 0);
    __decorate$5([
        Property(350)
    ], Touch.prototype, "tapThreshold", void 0);
    __decorate$5([
        Property(750)
    ], Touch.prototype, "tapHoldThreshold", void 0);
    __decorate$5([
        Complex({}, SwipeSettings)
    ], Touch.prototype, "swipeSettings", void 0);
    Touch = __decorate$5([
        NotifyPropertyChanges
    ], Touch);
    return Touch;
}(Base));

/**
 * Template Engine
 */
var LINES = new RegExp('\\n|\\r|\\s\\s+', 'g');
var QUOTES = new RegExp(/'|"/g);
var IF_STMT = new RegExp('if ?\\(');
var ELSEIF_STMT = new RegExp('else if ?\\(');
var ELSE_STMT = new RegExp('else');
var FOR_STMT = new RegExp('for ?\\(');
var IF_OR_FOR = new RegExp('(/if|/for)');
var CALL_FUNCTION = new RegExp('\\((.*)\\)', '');
var NOT_NUMBER = new RegExp('^[0-9]+$', 'g');
var WORD = new RegExp('[\\w"\'.\\s+]+', 'g');
var DBL_QUOTED_STR = new RegExp('"(.*?)"', 'g');
var WORDIF = new RegExp('[\\w"\'@#$.\\s-+]+', 'g');
var exp = new RegExp('\\${([^}]*)}', 'g');
// let cachedTemplate: Object = {};
var ARR_OBJ = /^\..*/gm;
var SINGLE_SLASH = /\\/gi;
var DOUBLE_SLASH = /\\\\/gi;
var WORDFUNC = new RegExp('[\\w"\'@#$.\\s+]+', 'g');
var WINDOWFUNC = /\window\./gm;
/**
 * The function to set regular expression for template expression string.
 *
 * @param {RegExp} value - Value expression.
 * @returns {RegExp} ?
 * @private
 */

// /**
//  * To render the template string from the given data.
//  * @param  {string} template - String Template.
//  * @param  {Object[]|JSON} data - DataSource for the template.
//  * @param  {Object} helper? - custom helper object.
//  */
// export function template(template: string, data: JSON, helper?: Object): string {
//     let hash: string = hashCode(template);
//     let tmpl: Function;
//     if (!cachedTemplate[hash]) {
//         tmpl = cachedTemplate[hash] = compile(template, helper);
//     } else {
//         tmpl = cachedTemplate[hash];
//     }
//     return tmpl(data);
// }
/**
 * Compile the template string into template function.
 *
 * @param {string} template - The template string which is going to convert.
 * @param {Object} helper - Helper functions as an object.
 * @param {boolean} ignorePrefix ?
 * @returns {string} ?
 * @private
 */
function compile$1(template, helper, ignorePrefix) {
    var argName = 'data';
    var evalExpResult = evalExp(template, argName, helper, ignorePrefix);
    var condtion = "var valueRegEx = (/value=\\'([A-Za-z0-9 _]*)((.)([\\w)(!-;?-\u25A0\\s]+)['])/g);\n    var hrefRegex = (/(?:href)([\\s='\"./]+)([\\w-./?=&\\\\#\"]+)((.)([\\w)(!-;/?-\u25A0\\s]+)['])/g);\n    if(str.match(valueRegEx)){\n        var check = str.match(valueRegEx);\n        var str1 = str;\n        for (var i=0; i < check.length; i++) {\n            var check1 = str.match(valueRegEx)[i].split('value=')[1];\n            var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '\"') : check1;\n            change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'\"') : change;\n            str1 = str1.replace(check1, change);\n        }\n        str = str.replace(str, str1);\n    }\n    else if(str.match(hrefRegex)) {\n        var check = str.match(hrefRegex);\n        var str1 = str;\n        for (var i=0; i < check.length; i++) {\n            var check1 = str.match(hrefRegex)[i].split('href=')[1];\n            var change = check1.match(/^'/) !== null ? check1.replace(/^'/, '\"') : check1;\n            change =change.match(/.$/)[0] === '\\'' ? change.replace(/.$/,'\"') : change;\n            str1 = str1.replace(check1, change);\n        }\n        str = str.replace(str, str1);\n    }\n    ";
    var fnCode = "var str=\"" + evalExpResult + "\";" + condtion + " return str;";
    var fn = new Function(argName, fnCode);
    return fn.bind(helper);
}
/** function used to evaluate the function expression
 *
 * @param {string} str ?
 * @param {string} nameSpace ?
 * @param {Object} helper ?
 * @param {boolean} ignorePrefix ?
 * @returns {string} ?
 */
function evalExp(str, nameSpace, helper, ignorePrefix) {
    var varCOunt = 0;
    /**
     * Variable containing Local Keys
     */
    var localKeys = [];
    var isClass = str.match(/class="([^"]+|)\s{2}/g);
    var singleSpace = '';
    if (isClass) {
        isClass.forEach(function (value) {
            singleSpace = value.replace(/\s\s+/g, ' ');
            str = str.replace(value, singleSpace);
        });
    }
    return str.replace(LINES, '').replace(DBL_QUOTED_STR, '\'$1\'').replace(exp, 
    // eslint-disable-next-line
    function (match, cnt, offset, matchStr) {
        var SPECIAL_CHAR = /@|#|\$/gm;
        var matches = cnt.match(CALL_FUNCTION);
        // matches to detect any function calls
        if (matches) {
            var rlStr = matches[1];
            if (ELSEIF_STMT.test(cnt)) {
                //handling else-if condition
                cnt = '";} ' + cnt.replace(matches[1], rlStr.replace(WORD, function (str) {
                    str = str.trim();
                    return addNameSpace(str, !(QUOTES.test(str)) && (localKeys.indexOf(str) === -1), nameSpace, localKeys, ignorePrefix);
                })) + '{ \n str = str + "';
            }
            else if (IF_STMT.test(cnt)) {
                //handling if condition
                cnt = '"; ' + cnt.replace(matches[1], rlStr.replace(WORDIF, function (strs) {
                    return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
                })) + '{ \n str = str + "';
            }
            else if (FOR_STMT.test(cnt)) {
                //handling for condition
                var rlStr_1 = matches[1].split(' of ');
                // replace for each into actual JavaScript
                // eslint-disable-next-line
                cnt = '"; ' + cnt.replace(matches[1], function (mtc) {
                    localKeys.push(rlStr_1[0]);
                    localKeys.push(rlStr_1[0] + 'Index');
                    varCOunt = varCOunt + 1;
                    // tslint:disable-next-line
                    return 'var i' + varCOunt + '=0; i' + varCOunt + ' < ' + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix) + '.length; i' + varCOunt + '++';
                }) + '{ \n ' + rlStr_1[0] + '= ' + addNameSpace(rlStr_1[1], true, nameSpace, localKeys, ignorePrefix)
                    + '[i' + varCOunt + ']; \n var ' + rlStr_1[0] + 'Index=i' + varCOunt + '; \n str = str + "';
            }
            else {
                //helper function handling
                var fnStr = cnt.split('(');
                // eslint-disable-next-line
                var fNameSpace = (helper && helper.hasOwnProperty(fnStr[0]) ? 'this.' : 'global');
                fNameSpace = (/\./.test(fnStr[0]) ? '' : fNameSpace);
                var ftArray = matches[1].split(',');
                if (matches[1].length !== 0 && !(/data/).test(ftArray[0]) && !(/window./).test(ftArray[0])) {
                    matches[1] = (fNameSpace === 'global' ? nameSpace + '.' + matches[1] : matches[1]);
                }
                var splRegexp = /@|\$|#/gm;
                var arrObj = /\]\./gm;
                if (WINDOWFUNC.test(cnt) && arrObj.test(cnt) || splRegexp.test(cnt)) {
                    var splArrRegexp = /@|\$|#|\]\./gm;
                    if (splArrRegexp.test(cnt)) {
                        // tslint:disable-next-line
                        cnt = '"+ ' + (fNameSpace === 'global' ? '' : fNameSpace) + cnt.replace(matches[1], rlStr.replace(WORDFUNC, function (strs) {
                            return HandleSpecialCharArrObj(strs, nameSpace, localKeys, ignorePrefix);
                        })) + '+ "';
                    }
                }
                else {
                    cnt = '" + ' + (fNameSpace === 'global' ? '' : fNameSpace) +
                        cnt.replace(rlStr, addNameSpace(matches[1].replace(/,( |)data.|,/gi, ',' + nameSpace + '.').replace(/,( |)data.window/gi, ',window'), (fNameSpace === 'global' ? false : true), nameSpace, localKeys, ignorePrefix)) +
                        '+"';
                }
            }
        }
        else if (ELSE_STMT.test(cnt)) {
            // handling else condition
            cnt = '"; ' + cnt.replace(ELSE_STMT, '} else { \n str = str + "');
            // eslint-disable-next-line
        }
        else if (!!cnt.match(IF_OR_FOR)) {
            // close condition
            cnt = cnt.replace(IF_OR_FOR, '"; \n } \n str = str + "');
        }
        else if (SPECIAL_CHAR.test(cnt)) {
            // template string with double slash with special character
            if (cnt.match(SINGLE_SLASH)) {
                cnt = SlashReplace(cnt);
            }
            cnt = '"+' + NameSpaceForspecialChar(cnt, (localKeys.indexOf(cnt) === -1), nameSpace, localKeys) + '"]+"';
        }
        else {
            // template string with double slash
            if (cnt.match(SINGLE_SLASH)) {
                cnt = SlashReplace(cnt);
                cnt = '"+' + NameSpaceForspecialChar(cnt, (localKeys.indexOf(cnt) === -1), nameSpace, localKeys) + '"]+"';
            }
            else {
                // evaluate normal expression
                cnt = '"+' + addNameSpace(cnt.replace(/,/gi, '+' + nameSpace + '.'), (localKeys.indexOf(cnt) === -1), nameSpace, localKeys, ignorePrefix) + '+"';
            }
        }
        return cnt;
    });
}
/**
 *
 * @param {string} str ?
 * @param {boolean} addNS ?
 * @param {string} nameSpace ?
 * @param {string[]} ignoreList ?
 * @param {boolean} ignorePrefix ?
 * @returns {string} ?
 */
function addNameSpace(str, addNS, nameSpace, ignoreList, ignorePrefix) {
    return ((addNS && !(NOT_NUMBER.test(str)) && ignoreList.indexOf(str.split('.')[0]) === -1 && !ignorePrefix) ? nameSpace + '.' + str : str);
}
/**
 *
 * @param {string} str ?
 * @param {boolean} addNS ?
 * @param {string} nameSpace ?
 * @param {string[]} ignoreList ?
 * @returns {string} ?
 */
function NameSpaceArrObj(str, addNS, nameSpace, ignoreList) {
    var arrObjReg = /^\..*/gm;
    return ((addNS && !(NOT_NUMBER.test(str)) &&
        ignoreList.indexOf(str.split('.')[0]) === -1 && !(arrObjReg.test(str))) ? nameSpace + '.' + str : str);
}
// // Create hashCode for template string to storeCached function
// function hashCode(str: string): string {
//     return str.split('').reduce((a: number, b: string) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a; }, 0).toString();
// }
/**
 *
 * @param {string} str ?
 * @param {boolean} addNS ?
 * @param {string} nameSpace ?
 * @param {string[]} ignoreList ?
 * @returns {string} ?
 */
function NameSpaceForspecialChar(str, addNS, nameSpace, ignoreList) {
    return ((addNS && !(NOT_NUMBER.test(str)) && ignoreList.indexOf(str.split('.')[0]) === -1) ? nameSpace + '["' + str : str);
}
// eslint-disable-next-line
function SlashReplace(tempStr) {
    var double = '\\\\';
    if (tempStr.match(DOUBLE_SLASH)) {
        // eslint-disable-next-line
        tempStr = tempStr;
    }
    else {
        tempStr = tempStr.replace(SINGLE_SLASH, double);
    }
    return tempStr;
}
/**
 *
 * @param {string} str ?
 * @param {string} nameSpaceNew ?
 * @param {string[]} keys ?
 * @param {boolean} ignorePrefix ?
 * @returns {string} ?
 */
function HandleSpecialCharArrObj(str, nameSpaceNew, keys, ignorePrefix) {
    str = str.trim();
    var windowFunc = /\window\./gm;
    if (!windowFunc.test(str)) {
        var quotes = /'|"/gm;
        var splRegexp = /@|\$|#/gm;
        if (splRegexp.test(str)) {
            str = NameSpaceForspecialChar(str, (keys.indexOf(str) === -1), nameSpaceNew, keys) + '"]';
        }
        if (ARR_OBJ.test(str)) {
            return NameSpaceArrObj(str, !(quotes.test(str)) && (keys.indexOf(str) === -1), nameSpaceNew, keys);
        }
        else {
            return addNameSpace(str, !(quotes.test(str)) && (keys.indexOf(str) === -1), nameSpaceNew, keys, ignorePrefix);
        }
    }
    else {
        return str;
    }
}

/**
 * Template Engine Bridge
 */
var HAS_ROW = /^[\n\r.]+<tr|^<tr/;
var HAS_SVG = /^[\n\r.]+<svg|^<path|^<g/;
var blazorTemplates = {};
/**
 *
 * @returns {string} ?
 */
function getRandomId() {
    return '-' + Math.random().toString(36).substr(2, 5);
}
/**
 * Compile the template string into template function.
 *
 * @param {string} templateString - The template string which is going to convert.
 * @param {Object} helper - Helper functions as an object.
 * @param {boolean} ignorePrefix ?
 * @returns {NodeList} ?
 * @private
 */
// eslint-disable-next-line
function compile$$1(templateString, helper, ignorePrefix) {
    var compiler = engineObj.compile(templateString, helper, ignorePrefix);
    // eslint-disable-next-line
    return function (data, component, propName, templateId, isStringTemplate, index, element) {
        var result = compiler(data, component, propName, element);
        var blazorTemplateId = 'BlazorTemplateId';
        if (isBlazor() && !isStringTemplate) {
            var randomId = getRandomId();
            var blazorId = templateId + randomId;
            if (!blazorTemplates[templateId]) {
                blazorTemplates[templateId] = [];
            }
            if (!isNullOrUndefined(index)) {
                var keys = Object.keys(blazorTemplates[templateId][index]);
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    if (key !== blazorTemplateId && data[key]) {
                        blazorTemplates[templateId][index][key] = data[key];
                    }
                    if (key === blazorTemplateId) {
                        blazorId = blazorTemplates[templateId][index][key];
                    }
                }
            }
            else {
                data[blazorTemplateId] = blazorId;
                blazorTemplates[templateId].push(data);
            }
            // eslint-disable-next-line
            return propName === 'rowTemplate' ? [createElement('tr', { id: blazorId, className: 'e-blazor-template' })] :
                // eslint-disable-next-line
                [createElement('div', { id: blazorId, className: 'e-blazor-template' })];
        }
        if (typeof result === 'string') {
            if (HAS_SVG.test(result)) {
                var ele = createElement('svg', { innerHTML: result });
                return ele.childNodes;
            }
            else {
                var ele = createElement((HAS_ROW.test(result) ? 'table' : 'div'), { innerHTML: result });
                return ele.childNodes;
            }
        }
        else {
            return result;
        }
    };
}
/**
 *
 * @param {string} templateId ?
 * @param {string} templateName ?
 * @param {string} comp ?
 * @param {boolean} isEmpty ?
 * @param {Function} callBack ?
 * @returns {void} ?
 */
function updateBlazorTemplate(templateId, templateName, comp, isEmpty, callBack) {
    if (isBlazor()) {
        var ejsIntrop = 'sfBlazor';
        window[ejsIntrop].updateTemplate(templateName, blazorTemplates[templateId], templateId, comp, callBack);
        if (isEmpty !== false) {
            blazorTemplates[templateId] = [];
        }
    }
}
/**
 *
 * @param {string} templateId ?
 * @param {string} templateName ?
 * @param {number} index ?
 * @returns {void} ?
 */
function resetBlazorTemplate(templateId, templateName, index) {
    var templateDiv = document.getElementById(templateId);
    if (templateDiv) {
        // eslint-disable-next-line
        var innerTemplates = templateDiv.getElementsByClassName('blazor-inner-template');
        for (var i = 0; i < innerTemplates.length; i++) {
            var tempId = ' ';
            if (!isNullOrUndefined(index)) {
                tempId = innerTemplates[index].getAttribute('data-templateId');
            }
            else {
                tempId = innerTemplates[i].getAttribute('data-templateId');
            }
            var tempElement = document.getElementById(tempId);
            if (tempElement) {
                var length_1 = tempElement.childNodes.length;
                for (var j = 0; j < length_1; j++) {
                    if (!isNullOrUndefined(index)) {
                        innerTemplates[index].appendChild(tempElement.childNodes[0]);
                        i = innerTemplates.length;
                    }
                    else {
                        innerTemplates[i].appendChild(tempElement.childNodes[0]);
                    }
                }
            }
        }
    }
}
/**
 * Set your custom template engine for template rendering.
 *
 * @param  {ITemplateEngine} classObj - Class object for custom template.
 * @returns {void} ?
 * @private
 */
function setTemplateEngine(classObj) {
    engineObj.compile = classObj.compile;
}
/**
 * Get current template engine for template rendering
 *
 * @returns {string} ?
 * @private
 */
function getTemplateEngine() {
    return engineObj.compile;
}
//Default Engine Class
var Engine = /** @class */ (function () {
    function Engine() {
    }
    // eslint-disable-next-line
    Engine.prototype.compile = function (templateString, helper, ignorePrefix) {
        if (helper === void 0) { helper = {}; }
        return compile$1(templateString, helper);
    };
    return Engine;
}());
var engineObj = { compile: new Engine().compile };

/**
 * SanitizeHtmlHelper for sanitize the value.
 */
var removeTags = [
    'script',
    'style',
    'iframe[src]',
    'link[href*="javascript:"]',
    'object[type="text/x-scriptlet"]',
    'object[data^="data:text/html;base64"]',
    'img[src^="data:text/html;base64"]',
    '[src^="javascript:"]',
    '[dynsrc^="javascript:"]',
    '[lowsrc^="javascript:"]',
    '[type^="application/x-shockwave-flash"]'
];
var removeAttrs = [
    { attribute: 'href', selector: '[href*="javascript:"]' },
    { attribute: 'background', selector: '[background^="javascript:"]' },
    { attribute: 'style', selector: '[style*="javascript:"]' },
    { attribute: 'style', selector: '[style*="expression("]' },
    { attribute: 'href', selector: 'a[href^="data:text/html;base64"]' }
];
var jsEvents = ['onchange',
    'onclick',
    'onmouseover',
    'onmouseout',
    'onkeydown',
    'onload',
    'onerror',
    'onblur',
    'onfocus',
    'onbeforeload',
    'onbeforeunload',
    'onkeyup',
    'onsubmit',
    'onafterprint',
    'onbeforeonload',
    'onbeforeprint',
    'onblur',
    'oncanplay',
    'oncanplaythrough',
    'onchange',
    'onclick',
    'oncontextmenu',
    'ondblclick',
    'ondrag',
    'ondragend',
    'ondragenter',
    'ondragleave',
    'ondragover',
    'ondragstart',
    'ondrop',
    'ondurationchange',
    'onemptied',
    'onended',
    'onerror',
    'onerror',
    'onfocus',
    'onformchange',
    'onforminput',
    'onhaschange',
    'oninput',
    'oninvalid',
    'onkeydown',
    'onkeypress',
    'onkeyup',
    'onload',
    'onloadeddata',
    'onloadedmetadata',
    'onloadstart',
    'onmessage',
    'onmousedown',
    'onmousemove',
    'onmouseout',
    'onmouseover',
    'onmouseup',
    'onmousewheel',
    'onoffline',
    'onoine',
    'ononline',
    'onpagehide',
    'onpageshow',
    'onpause',
    'onplay',
    'onplaying',
    'onpopstate',
    'onprogress',
    'onratechange',
    'onreadystatechange',
    'onredo',
    'onresize',
    'onscroll',
    'onseeked',
    'onseeking',
    'onselect',
    'onstalled',
    'onstorage',
    'onsubmit',
    'onsuspend',
    'ontimeupdate',
    'onundo',
    'onunload',
    'onvolumechange',
    'onwaiting',
    'onmouseenter',
    'onmouseleave',
    'onmousewheel',
    'onstart',
    'onpropertychange'
];
var SanitizeHtmlHelper = /** @class */ (function () {
    function SanitizeHtmlHelper() {
    }
    SanitizeHtmlHelper.beforeSanitize = function () {
        return {
            selectors: {
                tags: removeTags,
                attributes: removeAttrs
            }
        };
    };
    SanitizeHtmlHelper.sanitize = function (value) {
        var item = this.beforeSanitize();
        var output = this.serializeValue(item, value);
        return output;
    };
    SanitizeHtmlHelper.serializeValue = function (item, value) {
        this.removeAttrs = item.selectors.attributes;
        this.removeTags = item.selectors.tags;
        this.wrapElement = document.createElement('div');
        this.wrapElement.innerHTML = value;
        this.removeXssTags();
        this.removeJsEvents();
        this.removeXssAttrs();
        var tempEleValue = this.wrapElement.innerHTML;
        this.removeElement();
        return tempEleValue;
    };
    SanitizeHtmlHelper.removeElement = function () {
        // Removes an element's attibute to avoid html tag validation
        var nodes = this.wrapElement.children;
        for (var j = 0; j < nodes.length; j++) {
            var attribute = nodes[j].attributes;
            for (var i = 0; i < attribute.length; i++) {
                this.wrapElement.children[j].removeAttribute(attribute[i].localName);
            }
        }
    };
    SanitizeHtmlHelper.removeXssTags = function () {
        var elements = this.wrapElement.querySelectorAll(this.removeTags.join(','));
        if (elements.length > 0) {
            elements.forEach(function (element) {
                detach(element);
            });
        }
        else {
            return;
        }
    };
    SanitizeHtmlHelper.removeJsEvents = function () {
        var elements = this.wrapElement.querySelectorAll('[' + jsEvents.join('],[') + ']');
        if (elements.length > 0) {
            elements.forEach(function (element) {
                jsEvents.forEach(function (attr) {
                    if (element.hasAttribute(attr)) {
                        element.removeAttribute(attr);
                    }
                });
            });
        }
        else {
            return;
        }
    };
    SanitizeHtmlHelper.removeXssAttrs = function () {
        var _this = this;
        // eslint-disable-next-line
        this.removeAttrs.forEach(function (item, index) {
            var elements = _this.wrapElement.querySelectorAll(item.selector);
            if (elements.length > 0) {
                elements.forEach(function (element) {
                    element.removeAttribute(item.attribute);
                });
            }
        });
    };
    return SanitizeHtmlHelper;
}());

/**
 * Base modules
 */

exports.blazorCultureFormats = blazorCultureFormats;
exports.Ajax = Ajax;
exports.Animation = Animation;
exports.rippleEffect = rippleEffect;
exports.enableRipple = enableRipple;
exports.Base = Base;
exports.getComponent = getComponent;
exports.removeChildInstance = removeChildInstance;
exports.Browser = Browser;
exports.enableVersionBasedPersistence = enableVersionBasedPersistence;
exports.Component = Component;
exports.ChildProperty = ChildProperty;
exports.Position = Position;
exports.Draggable = Draggable;
exports.Droppable = Droppable;
exports.EventHandler = EventHandler;
exports.onIntlChange = onIntlChange;
exports.cldrData = cldrData;
exports.Internationalization = Internationalization;
exports.setCulture = setCulture;
exports.setCurrencyCode = setCurrencyCode;
exports.loadCldr = loadCldr;
exports.enableRtl = enableRtl;
exports.getNumericObject = getNumericObject;
exports.getNumberDependable = getNumberDependable;
exports.getDefaultDateObject = getDefaultDateObject;
exports.KeyboardEvents = KeyboardEvents;
exports.L10n = L10n;
exports.ModuleLoader = ModuleLoader;
exports.Property = Property;
exports.Complex = Complex;
exports.ComplexFactory = ComplexFactory;
exports.Collection = Collection;
exports.CollectionFactory = CollectionFactory;
exports.Event = Event$1;
exports.NotifyPropertyChanges = NotifyPropertyChanges;
exports.CreateBuilder = CreateBuilder;
exports.SwipeSettings = SwipeSettings;
exports.Touch = Touch;
exports.blazorTemplates = blazorTemplates;
exports.getRandomId = getRandomId;
exports.compile = compile$$1;
exports.updateBlazorTemplate = updateBlazorTemplate;
exports.resetBlazorTemplate = resetBlazorTemplate;
exports.setTemplateEngine = setTemplateEngine;
exports.getTemplateEngine = getTemplateEngine;
exports.disableBlazorMode = disableBlazorMode;
exports.createInstance = createInstance;
exports.setImmediate = setImmediate;
exports.getValue = getValue;
exports.setValue = setValue;
exports.deleteObject = deleteObject;
exports.isObject = isObject;
exports.getEnumValue = getEnumValue;
exports.merge = merge;
exports.extend = extend;
exports.isNullOrUndefined = isNullOrUndefined;
exports.isUndefined = isUndefined;
exports.getUniqueID = getUniqueID;
exports.debounce = debounce;
exports.queryParams = queryParams;
exports.isObjectArray = isObjectArray;
exports.compareElementParent = compareElementParent;
exports.throwError = throwError;
exports.print = print;
exports.formatUnit = formatUnit;
exports.enableBlazorMode = enableBlazorMode;
exports.isBlazor = isBlazor;
exports.getElement = getElement;
exports.getInstance = getInstance;
exports.addInstance = addInstance;
exports.uniqueID = uniqueID;
exports.createElement = createElement;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.isVisible = isVisible;
exports.prepend = prepend;
exports.append = append;
exports.detach = detach;
exports.remove = remove;
exports.attributes = attributes;
exports.select = select;
exports.selectAll = selectAll;
exports.closest = closest;
exports.siblings = siblings;
exports.getAttributeOrDefault = getAttributeOrDefault;
exports.setStyleAttribute = setStyleAttribute;
exports.classList = classList;
exports.matches = matches;
exports.includeInnerHTML = includeInnerHTML;
exports.containsClass = containsClass;
exports.cloneNode = cloneNode;
exports.Observer = Observer;
exports.SanitizeHtmlHelper = SanitizeHtmlHelper;

return exports;

}({}));


/***/ }),

/***/ "./resources/19.3.44/Scripts/common/syncfusion-blazor.js":
/*!***************************************************************!*\
  !*** ./resources/19.3.44/Scripts/common/syncfusion-blazor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var sfBlazorBase = {
    getElementByXpath: function (xPath) {
        return document.evaluate(xPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
    },
    getElement: function (elementID, id, xPath) {
        var dom = (elementID != null && window[elementID] != null) ? window[elementID][id] : null;
        return (dom != null ? dom : window.sfBlazor.getElementByXpath(xPath));
    },
    getAttribute: function (elementID, dom, xPath, propName) {
        var element = window.sfBlazor.getElement(elementID, dom, xPath);
        if (element != null)
            return element.getAttribute(propName);
    },
    setAttribute: function (elementID, dom, xPath, propName, value) {
        (window.sfBlazor.getElement(elementID, dom, xPath)).setAttribute(propName, value);
    },
    addClass: function (elementID, dom, xPath, classList) {
        sf.base.addClass([window.sfBlazor.getElement(elementID, dom, xPath)], classList);
    },
    removeClass: function (elementID, dom, xPath, classList) {
        sf.base.removeClass([window.sfBlazor.getElement(elementID, dom, xPath)], classList);
    },
    getClassList: function (elementID, dom, xPath) {
        return Array.prototype.slice.call((window.sfBlazor.getElement(elementID, dom, xPath)).classList);
    },
    enableRipple: function (isRipple) {
        sf.base.enableRipple(isRipple);
    },
    isDevice: function (isRtl) {
        if (isRtl) {
           this.enableRtl(isRtl);
        }
        return sf.base.Browser.isDevice;
    },
    animate: function (elementRef, animationSettings) {
        var animationObj = new sf.base.Animation(animationSettings);
        animationObj.animate(elementRef);
    },
    callRipple: function (elementRef, rippleSettings) {
        sf.base.rippleEffect(elementRef, rippleSettings);
    },
    createXPathFromElement: function (elm) {
        var allNodes = document.getElementsByTagName('*');
        for (var segs = []; elm && elm.nodeType === 1; elm = elm.parentNode) {
            if (elm.hasAttribute('id')) {
                var uniqueIdCount = 0;
                for (var n = 0; n < allNodes.length; n++) {
                    if (allNodes[n].hasAttribute('id') && allNodes[n].id === elm.id) uniqueIdCount++;
                    if (uniqueIdCount > 1) break;
                };
                if (uniqueIdCount === 1) {
                    segs.unshift('id("' + elm.getAttribute('id') + '")');
                    return segs.join('/');
                } else {
                    segs.unshift(elm.localName.toLowerCase() + '[@id="' + elm.getAttribute('id') + '"]');
                }
            } else {
                for (var i = 1, sib = elm.previousSibling; sib; sib = sib.previousSibling) {
                    if (sib.localName === elm.localName) i++;
                }
                segs.unshift(elm.localName.toLowerCase() + '[' + i + ']');
            }
        }
        return segs.length ? '/' + segs.join('/') : null;
    },
    getDomObject: function (key, node, object) {
        var uuid = key + sf.base.getUniqueID(key);
        var domObject = {
            id: node.id,
            class: node.className,
            xPath: window.sfBlazor.createXPathFromElement(node),
            domUUID: uuid
        };
        var elementID = object && object["elementID"];
        if (elementID) {
            window[elementID] = sf.base.isNullOrUndefined(window[elementID]) ? {} : window[elementID];
            window[elementID][uuid] = node;
            domObject["elementID"] = elementID;
        }
        return domObject;
    },
    focusButton: function (element) {
        element.focus();
    },
    //sf-progressbutton interop start
    setProgress: function (progressElem, contElem, spinnerElem, percent, enableProgress, isVertical) {
		spinnerElem = spinnerElem.querySelector('.e-spinner');
        return window.requestAnimationFrame(function () {
            if (enableProgress) {
                progressElem.style[isVertical ? 'height' : 'width'] = percent + '%';
            }
            contElem.parentElement.setAttribute('aria-valuenow', percent.toString());
            if (percent === 100) {
                contElem.classList.remove('e-cont-animate', 'e-animate-end');
                spinnerElem.style.width = 'auto';
                spinnerElem.style.height = 'auto';
            }
        });
    },
    setAnimation: function (contElem, spinnerElem, effect, duration, easing, isCenter) {
		spinnerElem = spinnerElem.querySelector('.e-spinner');
        new sf.base.Animation({}).animate(contElem, {
            duration: duration,
            name: 'Progress' + effect,
            timingFunction: easing,
            begin: function () {
                if (isCenter) {
                    spinnerElem.style.width = Math.max(spinnerElem.offsetWidth, contElem.offsetWidth) + 'px';
                    spinnerElem.style.height = Math.max(spinnerElem.offsetHeight, contElem.offsetHeight) + 'px';
                    contElem.classList.add('e-cont-animate');
                }
            },
            end: function () {
                contElem.classList.add('e-animate-end');
            }
        });
    },
    cancelAnimation: function(timerId) {
        window.cancelAnimationFrame(timerId);
    }
    //sf-progressbutton interop end
};
(function () {
    sf.base.enableBlazorMode();
})();

window.sfBlazor = window.sfBlazor || {};
Object.assign(window.sfBlazor, sfBlazorBase);


/***/ }),

/***/ "./resources/19.3.44/Scripts/navigationsbase.js":
/*!******************************************************!*\
  !*** ./resources/19.3.44/Scripts/navigationsbase.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sf = window.sf || {};
var navigationsbase = (function (exports) {
'use strict';

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_ROOT = 'e-hscroll';
var CLS_RTL = 'e-rtl';
var CLS_DISABLE = 'e-overlay';
var CLS_HSCROLLBAR = 'e-hscroll-bar';
var CLS_HSCROLLCON = 'e-hscroll-content';
var CLS_NAVARROW = 'e-nav-arrow';
var CLS_NAVRIGHTARROW = 'e-nav-right-arrow';
var CLS_NAVLEFTARROW = 'e-nav-left-arrow';
var CLS_HSCROLLNAV = 'e-scroll-nav';
var CLS_HSCROLLNAVRIGHT = 'e-scroll-right-nav';
var CLS_HSCROLLNAVLEFT = 'e-scroll-left-nav';
var CLS_DEVICE = 'e-scroll-device';
var CLS_OVERLAY = 'e-scroll-overlay';
var CLS_RIGHTOVERLAY = 'e-scroll-right-overlay';
var CLS_LEFTOVERLAY = 'e-scroll-left-overlay';
var OVERLAY_MAXWID = 40;
/**
 * HScroll module is introduces horizontal scroller when content exceeds the current viewing area.
 * It can be useful for the components like Toolbar, Tab which needs horizontal scrolling alone.
 * Hidden content can be view by touch moving or icon click.
 * ```html
 * <div id="scroll"/>
 * <script>
 *   var scrollObj = new HScroll();
 *   scrollObj.appendTo("#scroll");
 * </script>
 * ```
 */
var HScroll = /** @class */ (function (_super) {
    __extends(HScroll, _super);
    /**
     * Initializes a new instance of the HScroll class.
     *
     * @param {HScrollModel} options  - Specifies HScroll model properties as options.
     * @param {string | HTMLElement} element  - Specifies the element for which horizontal scrolling applies.
     */
    function HScroll(options, element) {
        return _super.call(this, options, element) || this;
    }
    /**
     * Initialize the event handler
     *
     * @private
     * @returns {void}
     */
    HScroll.prototype.preRender = function () {
        this.browser = sf.base.Browser.info.name;
        this.browserCheck = this.browser === 'mozilla';
        this.isDevice = sf.base.Browser.isDevice;
        this.customStep = true;
        var element = this.element;
        this.ieCheck = this.browser === 'edge' || this.browser === 'msie';
        this.initialize();
        if (element.id === '') {
            element.id = sf.base.getUniqueID('hscroll');
            this.uniqueId = true;
        }
        element.style.display = 'block';
        if (this.enableRtl) {
            element.classList.add(CLS_RTL);
        }
    };
    /**
     * To Initialize the horizontal scroll  rendering
     *
     * @private
     * @returns {void}
     */
    HScroll.prototype.render = function () {
        this.touchModule = new sf.base.Touch(this.element, { scroll: this.touchHandler.bind(this), swipe: this.swipeHandler.bind(this) });
        sf.base.EventHandler.add(this.scrollEle, 'scroll', this.scrollHandler, this);
        if (!this.isDevice) {
            this.createNavIcon(this.element);
        }
        else {
            this.element.classList.add(CLS_DEVICE);
            this.createOverlay(this.element);
        }
        this.setScrollState();
    };
    HScroll.prototype.setScrollState = function () {
        if (sf.base.isNullOrUndefined(this.scrollStep) || this.scrollStep < 0) {
            this.scrollStep = this.scrollEle.offsetWidth;
            this.customStep = false;
        }
        else {
            this.customStep = true;
        }
    };
    HScroll.prototype.initialize = function () {
        var scrollEle = this.createElement('div', { className: CLS_HSCROLLCON });
        var scrollDiv = this.createElement('div', { className: CLS_HSCROLLBAR });
        scrollDiv.setAttribute('tabindex', '-1');
        var ele = this.element;
        var innerEle = [].slice.call(ele.children);
        for (var _i = 0, innerEle_1 = innerEle; _i < innerEle_1.length; _i++) {
            var ele_1 = innerEle_1[_i];
            scrollEle.appendChild(ele_1);
        }
        scrollDiv.appendChild(scrollEle);
        ele.appendChild(scrollDiv);
        scrollDiv.style.overflowX = 'hidden';
        this.scrollEle = scrollDiv;
        this.scrollItems = scrollEle;
    };
    HScroll.prototype.getPersistData = function () {
        var keyEntity = ['scrollStep'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Returns the current module name.
     *
     * @returns {string} - It returns the current module name.
     * @private
     */
    HScroll.prototype.getModuleName = function () {
        return 'hScroll';
    };
    /**
     * Removes the control from the DOM and also removes all its related events.
     *
     * @returns {void}
     */
    HScroll.prototype.destroy = function () {
        var ele = this.element;
        ele.style.display = '';
        ele.classList.remove(CLS_ROOT);
        ele.classList.remove(CLS_DEVICE);
        var nav = sf.base.selectAll('.e-' + ele.id + '_nav.' + CLS_HSCROLLNAV, ele);
        var overlay = sf.base.selectAll('.' + CLS_OVERLAY, ele);
        [].slice.call(overlay).forEach(function (ele) {
            sf.base.detach(ele);
        });
        for (var _i = 0, _a = [].slice.call(this.scrollItems.children); _i < _a.length; _i++) {
            var elem = _a[_i];
            ele.appendChild(elem);
        }
        if (this.uniqueId) {
            this.element.removeAttribute('id');
        }
        sf.base.detach(this.scrollEle);
        if (nav.length > 0) {
            sf.base.detach(nav[0]);
            if (!sf.base.isNullOrUndefined(nav[1])) {
                sf.base.detach(nav[1]);
            }
        }
        sf.base.EventHandler.remove(this.scrollEle, 'scroll', this.scrollHandler);
        this.touchModule.destroy();
        this.touchModule = null;
        _super.prototype.destroy.call(this);
    };
    /**
     * Specifies the value to disable/enable the HScroll component.
     * When set to `true` , the component will be disabled.
     *
     * @param  {boolean} value - Based on this Boolean value, HScroll will be enabled (false) or disabled (true).
     * @returns {void}.
     */
    HScroll.prototype.disable = function (value) {
        var navEles = sf.base.selectAll('.e-scroll-nav:not(.' + CLS_DISABLE + ')', this.element);
        if (value) {
            this.element.classList.add(CLS_DISABLE);
        }
        else {
            this.element.classList.remove(CLS_DISABLE);
        }
        [].slice.call(navEles).forEach(function (el) {
            el.setAttribute('tabindex', !value ? '0' : '-1');
        });
    };
    HScroll.prototype.createOverlay = function (element) {
        var id = element.id.concat('_nav');
        var rightOverlayEle = this.createElement('div', { className: CLS_OVERLAY + ' ' + CLS_RIGHTOVERLAY });
        var clsRight = 'e-' + element.id.concat('_nav ' + CLS_HSCROLLNAV + ' ' + CLS_HSCROLLNAVRIGHT);
        var rightEle = this.createElement('div', { id: id.concat('_right'), className: clsRight });
        var navItem = this.createElement('div', { className: CLS_NAVRIGHTARROW + ' ' + CLS_NAVARROW + ' e-icons' });
        rightEle.appendChild(navItem);
        var leftEle = this.createElement('div', { className: CLS_OVERLAY + ' ' + CLS_LEFTOVERLAY });
        if (this.ieCheck) {
            rightEle.classList.add('e-ie-align');
        }
        element.appendChild(rightOverlayEle);
        element.appendChild(rightEle);
        element.insertBefore(leftEle, element.firstChild);
        this.eventBinding([rightEle]);
    };
    HScroll.prototype.createNavIcon = function (element) {
        var id = element.id.concat('_nav');
        var clsRight = 'e-' + element.id.concat('_nav ' + CLS_HSCROLLNAV + ' ' + CLS_HSCROLLNAVRIGHT);
        var nav = this.createElement('div', { id: id.concat('_right'), className: clsRight });
        nav.setAttribute('aria-disabled', 'false');
        var navItem = this.createElement('div', { className: CLS_NAVRIGHTARROW + ' ' + CLS_NAVARROW + ' e-icons' });
        var clsLeft = 'e-' + element.id.concat('_nav ' + CLS_HSCROLLNAV + ' ' + CLS_HSCROLLNAVLEFT);
        var navEle = this.createElement('div', { id: id.concat('_left'), className: clsLeft + ' ' + CLS_DISABLE });
        navEle.setAttribute('aria-disabled', 'true');
        var navLeftItem = this.createElement('div', { className: CLS_NAVLEFTARROW + ' ' + CLS_NAVARROW + ' e-icons' });
        navEle.appendChild(navLeftItem);
        nav.appendChild(navItem);
        element.appendChild(nav);
        element.insertBefore(navEle, element.firstChild);
        if (this.ieCheck) {
            nav.classList.add('e-ie-align');
            navEle.classList.add('e-ie-align');
        }
        this.eventBinding([nav, navEle]);
    };
    HScroll.prototype.onKeyPress = function (e) {
        var _this = this;
        if (e.key === 'Enter') {
            var timeoutFun_1 = function () {
                _this.keyTimeout = true;
                _this.eleScrolling(10, e.target, true);
            };
            this.keyTimer = window.setTimeout(function () {
                timeoutFun_1();
            }, 100);
        }
    };
    HScroll.prototype.onKeyUp = function (e) {
        if (e.key !== 'Enter') {
            return;
        }
        if (this.keyTimeout) {
            this.keyTimeout = false;
        }
        else {
            e.target.click();
        }
        clearTimeout(this.keyTimer);
    };
    HScroll.prototype.eventBinding = function (ele) {
        var _this = this;
        [].slice.call(ele).forEach(function (el) {
            new sf.base.Touch(el, { tapHold: _this.tabHoldHandler.bind(_this), tapHoldThreshold: 500 });
            el.addEventListener('keydown', _this.onKeyPress.bind(_this));
            el.addEventListener('keyup', _this.onKeyUp.bind(_this));
            el.addEventListener('mouseup', _this.repeatScroll.bind(_this));
            el.addEventListener('touchend', _this.repeatScroll.bind(_this));
            el.addEventListener('contextmenu', function (e) {
                e.preventDefault();
            });
            sf.base.EventHandler.add(el, 'click', _this.clickEventHandler, _this);
        });
    };
    HScroll.prototype.repeatScroll = function () {
        clearInterval(this.timeout);
    };
    HScroll.prototype.tabHoldHandler = function (e) {
        var _this = this;
        var trgt = e.originalEvent.target;
        trgt = this.contains(trgt, CLS_HSCROLLNAV) ? trgt.firstElementChild : trgt;
        var scrollDis = 10;
        var timeoutFun = function () {
            _this.eleScrolling(scrollDis, trgt, true);
        };
        this.timeout = window.setInterval(function () {
            timeoutFun();
        }, 50);
    };
    HScroll.prototype.contains = function (ele, className) {
        return ele.classList.contains(className);
    };
    HScroll.prototype.eleScrolling = function (scrollDis, trgt, isContinuous) {
        var rootEle = this.element;
        var classList$$1 = trgt.classList;
        if (classList$$1.contains(CLS_HSCROLLNAV)) {
            classList$$1 = trgt.querySelector('.' + CLS_NAVARROW).classList;
        }
        if (this.contains(rootEle, CLS_RTL) && this.browserCheck) {
            scrollDis = -scrollDis;
        }
        if ((!this.contains(rootEle, CLS_RTL) || this.browserCheck) || this.ieCheck) {
            if (classList$$1.contains(CLS_NAVRIGHTARROW)) {
                this.frameScrollRequest(scrollDis, 'add', isContinuous);
            }
            else {
                this.frameScrollRequest(scrollDis, '', isContinuous);
            }
        }
        else {
            if (classList$$1.contains(CLS_NAVLEFTARROW)) {
                this.frameScrollRequest(scrollDis, 'add', isContinuous);
            }
            else {
                this.frameScrollRequest(scrollDis, '', isContinuous);
            }
        }
    };
    HScroll.prototype.clickEventHandler = function (e) {
        this.eleScrolling(this.scrollStep, e.target, false);
    };
    HScroll.prototype.swipeHandler = function (e) {
        var swipeEle = this.scrollEle;
        var distance;
        if (e.velocity <= 1) {
            distance = e.distanceX / (e.velocity * 10);
        }
        else {
            distance = e.distanceX / e.velocity;
        }
        var start = 0.5;
        var animate = function () {
            var step = Math.sin(start);
            if (step <= 0) {
                window.cancelAnimationFrame(step);
            }
            else {
                if (e.swipeDirection === 'Left') {
                    swipeEle.scrollLeft += distance * step;
                }
                else if (e.swipeDirection === 'Right') {
                    swipeEle.scrollLeft -= distance * step;
                }
                start -= 0.5;
                window.requestAnimationFrame(animate);
            }
        };
        animate();
    };
    HScroll.prototype.scrollUpdating = function (scrollVal, action) {
        if (action === 'add') {
            this.scrollEle.scrollLeft += scrollVal;
        }
        else {
            this.scrollEle.scrollLeft -= scrollVal;
        }
    };
    HScroll.prototype.frameScrollRequest = function (scrollVal, action, isContinuous) {
        var _this = this;
        var step = 10;
        if (isContinuous) {
            this.scrollUpdating(scrollVal, action);
            return;
        }
        if (!this.customStep) {
            [].slice.call(sf.base.selectAll('.' + CLS_OVERLAY, this.element)).forEach(function (el) {
                scrollVal -= el.offsetWidth;
            });
        }
        var animate = function () {
            var scrollValue;
            var scrollStep;
            if (_this.contains(_this.element, CLS_RTL) && _this.browserCheck) {
                scrollValue = -scrollVal;
                scrollStep = -step;
            }
            else {
                scrollValue = scrollVal;
                scrollStep = step;
            }
            if (scrollValue < step) {
                window.cancelAnimationFrame(scrollStep);
            }
            else {
                _this.scrollUpdating(scrollStep, action);
                scrollVal -= scrollStep;
                window.requestAnimationFrame(animate);
            }
        };
        animate();
    };
    HScroll.prototype.touchHandler = function (e) {
        var ele = this.scrollEle;
        var distance = e.distanceX;
        if ((this.ieCheck) && this.contains(this.element, CLS_RTL)) {
            distance = -distance;
        }
        if (e.scrollDirection === 'Left') {
            ele.scrollLeft = ele.scrollLeft + distance;
        }
        else if (e.scrollDirection === 'Right') {
            ele.scrollLeft = ele.scrollLeft - distance;
        }
    };
    HScroll.prototype.arrowDisabling = function (addDisable, removeDisable) {
        if (this.isDevice) {
            var arrowEle = sf.base.isNullOrUndefined(addDisable) ? removeDisable : addDisable;
            var arrowIcon = arrowEle.querySelector('.' + CLS_NAVARROW);
            if (sf.base.isNullOrUndefined(addDisable)) {
                sf.base.classList(arrowIcon, [CLS_NAVRIGHTARROW], [CLS_NAVLEFTARROW]);
            }
            else {
                sf.base.classList(arrowIcon, [CLS_NAVLEFTARROW], [CLS_NAVRIGHTARROW]);
            }
        }
        else {
            addDisable.classList.add(CLS_DISABLE);
            addDisable.setAttribute('aria-disabled', 'true');
            addDisable.removeAttribute('tabindex');
            removeDisable.classList.remove(CLS_DISABLE);
            removeDisable.setAttribute('aria-disabled', 'false');
            removeDisable.setAttribute('tabindex', '0');
        }
        this.repeatScroll();
    };
    HScroll.prototype.scrollHandler = function (e) {
        var target = e.target;
        var width = target.offsetWidth;
        var rootEle = this.element;
        var navLeftEle = this.element.querySelector('.' + CLS_HSCROLLNAVLEFT);
        var navRightEle = this.element.querySelector('.' + CLS_HSCROLLNAVRIGHT);
        var leftOverlay = this.element.querySelector('.' + CLS_LEFTOVERLAY);
        var rightOverlay = this.element.querySelector('.' + CLS_RIGHTOVERLAY);
        var scrollLeft = target.scrollLeft;
        if (scrollLeft <= 0) {
            scrollLeft = -scrollLeft;
        }
        if (this.isDevice) {
            if (this.enableRtl && !(this.browserCheck || this.ieCheck)) {
                leftOverlay = this.element.querySelector('.' + CLS_RIGHTOVERLAY);
                rightOverlay = this.element.querySelector('.' + CLS_LEFTOVERLAY);
            }
            if (scrollLeft < OVERLAY_MAXWID) {
                leftOverlay.style.width = scrollLeft + 'px';
            }
            else {
                leftOverlay.style.width = '40px';
            }
            if ((target.scrollWidth - Math.ceil(width + scrollLeft)) < OVERLAY_MAXWID) {
                rightOverlay.style.width = (target.scrollWidth - Math.ceil(width + scrollLeft)) + 'px';
            }
            else {
                rightOverlay.style.width = '40px';
            }
        }
        if (scrollLeft === 0) {
            this.arrowDisabling(navLeftEle, navRightEle);
        }
        else if (Math.ceil(width + scrollLeft + .1) >= target.scrollWidth) {
            this.arrowDisabling(navRightEle, navLeftEle);
        }
        else {
            var disEle = this.element.querySelector('.' + CLS_HSCROLLNAV + '.' + CLS_DISABLE);
            if (disEle) {
                disEle.classList.remove(CLS_DISABLE);
                disEle.setAttribute('aria-disabled', 'false');
                disEle.setAttribute('tabindex', '0');
            }
        }
    };
    /**
     * Gets called when the model property changes.The data that describes the old and new values of property that changed.
     *
     * @param  {HScrollModel} newProp - It contains the new value of data.
     * @param  {HScrollModel} oldProp - It contains the old value of data.
     * @returns {void}
     * @private
     */
    HScroll.prototype.onPropertyChanged = function (newProp, oldProp) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'scrollStep':
                    this.setScrollState();
                    break;
                case 'enableRtl':
                    newProp.enableRtl ? this.element.classList.add(CLS_RTL) : this.element.classList.remove(CLS_RTL);
                    break;
            }
        }
    };
    __decorate([
        sf.base.Property(null)
    ], HScroll.prototype, "scrollStep", void 0);
    HScroll = __decorate([
        sf.base.NotifyPropertyChanges
    ], HScroll);
    return HScroll;
}(sf.base.Component));

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var CLS_ROOT$1 = 'e-vscroll';
var CLS_RTL$1 = 'e-rtl';
var CLS_DISABLE$1 = 'e-overlay';
var CLS_VSCROLLBAR = 'e-vscroll-bar';
var CLS_VSCROLLCON = 'e-vscroll-content';
var CLS_NAVARROW$1 = 'e-nav-arrow';
var CLS_NAVUPARROW = 'e-nav-up-arrow';
var CLS_NAVDOWNARROW = 'e-nav-down-arrow';
var CLS_VSCROLLNAV = 'e-scroll-nav';
var CLS_VSCROLLNAVUP = 'e-scroll-up-nav';
var CLS_VSCROLLNAVDOWN = 'e-scroll-down-nav';
var CLS_DEVICE$1 = 'e-scroll-device';
var CLS_OVERLAY$1 = 'e-scroll-overlay';
var CLS_UPOVERLAY = 'e-scroll-up-overlay';
var CLS_DOWNOVERLAY = 'e-scroll-down-overlay';
var OVERLAY_MAXWID$1 = 40;
/**
 * VScroll module is introduces vertical scroller when content exceeds the current viewing area.
 * It can be useful for the components like Toolbar, Tab which needs vertical scrolling alone.
 * Hidden content can be view by touch moving or icon click.
 * ```html
 * <div id="scroll"/>
 * <script>
 *   var scrollObj = new VScroll();
 *   scrollObj.appendTo("#scroll");
 * </script>
 * ```
 */
var VScroll = /** @class */ (function (_super) {
    __extends$1(VScroll, _super);
    /**
     * Initializes a new instance of the VScroll class.
     *
     * @param {VScrollModel} options  - Specifies VScroll model properties as options.
     * @param {string | HTMLElement} element  - Specifies the element for which vertical scrolling applies.
     */
    function VScroll(options, element) {
        return _super.call(this, options, element) || this;
    }
    /**
     * Initialize the event handler
     *
     * @private
     * @returns {void}
     */
    VScroll.prototype.preRender = function () {
        this.browser = sf.base.Browser.info.name;
        this.browserCheck = this.browser === 'mozilla';
        this.isDevice = sf.base.Browser.isDevice;
        this.customStep = true;
        var ele = this.element;
        this.ieCheck = this.browser === 'edge' || this.browser === 'msie';
        this.initialize();
        if (ele.id === '') {
            ele.id = sf.base.getUniqueID('vscroll');
            this.uniqueId = true;
        }
        ele.style.display = 'block';
        if (this.enableRtl) {
            ele.classList.add(CLS_RTL$1);
        }
    };
    /**
     * To Initialize the vertical scroll rendering
     *
     * @private
     * @returns {void}
     */
    VScroll.prototype.render = function () {
        this.touchModule = new sf.base.Touch(this.element, { scroll: this.touchHandler.bind(this), swipe: this.swipeHandler.bind(this) });
        sf.base.EventHandler.add(this.scrollEle, 'scroll', this.scrollEventHandler, this);
        if (!this.isDevice) {
            this.createNavIcon(this.element);
        }
        else {
            this.element.classList.add(CLS_DEVICE$1);
            this.createOverlayElement(this.element);
        }
        this.setScrollState();
        sf.base.EventHandler.add(this.element, 'wheel', this.wheelEventHandler, this);
    };
    VScroll.prototype.setScrollState = function () {
        if (sf.base.isNullOrUndefined(this.scrollStep) || this.scrollStep < 0) {
            this.scrollStep = this.scrollEle.offsetHeight;
            this.customStep = false;
        }
        else {
            this.customStep = true;
        }
    };
    VScroll.prototype.initialize = function () {
        var scrollCnt = sf.base.createElement('div', { className: CLS_VSCROLLCON });
        var scrollBar = sf.base.createElement('div', { className: CLS_VSCROLLBAR });
        scrollBar.setAttribute('tabindex', '-1');
        var ele = this.element;
        var innerEle = [].slice.call(ele.children);
        for (var _i = 0, innerEle_1 = innerEle; _i < innerEle_1.length; _i++) {
            var ele_1 = innerEle_1[_i];
            scrollCnt.appendChild(ele_1);
        }
        scrollBar.appendChild(scrollCnt);
        ele.appendChild(scrollBar);
        scrollBar.style.overflowY = 'hidden';
        this.scrollEle = scrollBar;
        this.scrollItems = scrollCnt;
    };
    VScroll.prototype.getPersistData = function () {
        var keyEntity = ['scrollStep'];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Returns the current module name.
     *
     * @returns {string} - It returns the current module name.
     * @private
     */
    VScroll.prototype.getModuleName = function () {
        return 'vScroll';
    };
    /**
     * Removes the control from the DOM and also removes all its related events.
     *
     * @returns {void}
     */
    VScroll.prototype.destroy = function () {
        var el = this.element;
        el.style.display = '';
        sf.base.removeClass([this.element], [CLS_ROOT$1, CLS_DEVICE$1]);
        var navs = sf.base.selectAll('.e-' + el.id + '_nav.' + CLS_VSCROLLNAV, el);
        var overlays = sf.base.selectAll('.' + CLS_OVERLAY$1, el);
        [].slice.call(overlays).forEach(function (ele) {
            sf.base.detach(ele);
        });
        for (var _i = 0, _a = [].slice.call(this.scrollItems.children); _i < _a.length; _i++) {
            var elem = _a[_i];
            el.appendChild(elem);
        }
        if (this.uniqueId) {
            this.element.removeAttribute('id');
        }
        sf.base.detach(this.scrollEle);
        if (navs.length > 0) {
            sf.base.detach(navs[0]);
            if (!sf.base.isNullOrUndefined(navs[1])) {
                sf.base.detach(navs[1]);
            }
        }
        sf.base.EventHandler.remove(this.scrollEle, 'scroll', this.scrollEventHandler);
        this.touchModule.destroy();
        this.touchModule = null;
        _super.prototype.destroy.call(this);
    };
    /**
     * Specifies the value to disable/enable the VScroll component.
     * When set to `true` , the component will be disabled.
     *
     * @param  {boolean} value - Based on this Boolean value, VScroll will be enabled (false) or disabled (true).
     * @returns {void}.
     */
    VScroll.prototype.disable = function (value) {
        var navEle = sf.base.selectAll('.e-scroll-nav:not(.' + CLS_DISABLE$1 + ')', this.element);
        if (value) {
            this.element.classList.add(CLS_DISABLE$1);
        }
        else {
            this.element.classList.remove(CLS_DISABLE$1);
        }
        [].slice.call(navEle).forEach(function (el) {
            el.setAttribute('tabindex', !value ? '0' : '-1');
        });
    };
    VScroll.prototype.createOverlayElement = function (element) {
        var id = element.id.concat('_nav');
        var downOverlayEle = sf.base.createElement('div', { className: CLS_OVERLAY$1 + ' ' + CLS_DOWNOVERLAY });
        var clsDown = 'e-' + element.id.concat('_nav ' + CLS_VSCROLLNAV + ' ' + CLS_VSCROLLNAVDOWN);
        var downEle = sf.base.createElement('div', { id: id.concat('down'), className: clsDown });
        var navItem = sf.base.createElement('div', { className: CLS_NAVDOWNARROW + ' ' + CLS_NAVARROW$1 + ' e-icons' });
        downEle.appendChild(navItem);
        var upEle = sf.base.createElement('div', { className: CLS_OVERLAY$1 + ' ' + CLS_UPOVERLAY });
        if (this.ieCheck) {
            downEle.classList.add('e-ie-align');
        }
        element.appendChild(downOverlayEle);
        element.appendChild(downEle);
        element.insertBefore(upEle, element.firstChild);
        this.eventBinding([downEle]);
    };
    VScroll.prototype.createNavIcon = function (element) {
        var id = element.id.concat('_nav');
        var clsDown = 'e-' + element.id.concat('_nav ' + CLS_VSCROLLNAV + ' ' + CLS_VSCROLLNAVDOWN);
        var nav = sf.base.createElement('div', { id: id.concat('_down'), className: clsDown });
        nav.setAttribute('aria-disabled', 'false');
        var navItem = sf.base.createElement('div', { className: CLS_NAVDOWNARROW + ' ' + CLS_NAVARROW$1 + ' e-icons' });
        var clsUp = 'e-' + element.id.concat('_nav ' + CLS_VSCROLLNAV + ' ' + CLS_VSCROLLNAVUP);
        var navElement = sf.base.createElement('div', { id: id.concat('_up'), className: clsUp + ' ' + CLS_DISABLE$1 });
        navElement.setAttribute('aria-disabled', 'true');
        var navUpItem = sf.base.createElement('div', { className: CLS_NAVUPARROW + ' ' + CLS_NAVARROW$1 + ' e-icons' });
        navElement.appendChild(navUpItem);
        nav.appendChild(navItem);
        nav.setAttribute('tabindex', '0');
        element.appendChild(nav);
        element.insertBefore(navElement, element.firstChild);
        if (this.ieCheck) {
            nav.classList.add('e-ie-align');
            navElement.classList.add('e-ie-align');
        }
        this.eventBinding([nav, navElement]);
    };
    VScroll.prototype.onKeyPress = function (ev) {
        var _this = this;
        if (ev.key === 'Enter') {
            var timeoutFun_1 = function () {
                _this.keyTimeout = true;
                _this.eleScrolling(10, ev.target, true);
            };
            this.keyTimer = window.setTimeout(function () {
                timeoutFun_1();
            }, 100);
        }
    };
    VScroll.prototype.onKeyUp = function (ev) {
        if (ev.key !== 'Enter') {
            return;
        }
        if (this.keyTimeout) {
            this.keyTimeout = false;
        }
        else {
            ev.target.click();
        }
        clearTimeout(this.keyTimer);
    };
    VScroll.prototype.eventBinding = function (element) {
        var _this = this;
        [].slice.call(element).forEach(function (ele) {
            new sf.base.Touch(ele, { tapHold: _this.tabHoldHandler.bind(_this), tapHoldThreshold: 500 });
            ele.addEventListener('keydown', _this.onKeyPress.bind(_this));
            ele.addEventListener('keyup', _this.onKeyUp.bind(_this));
            ele.addEventListener('mouseup', _this.repeatScroll.bind(_this));
            ele.addEventListener('touchend', _this.repeatScroll.bind(_this));
            ele.addEventListener('contextmenu', function (e) {
                e.preventDefault();
            });
            sf.base.EventHandler.add(ele, 'click', _this.clickEventHandler, _this);
        });
    };
    VScroll.prototype.repeatScroll = function () {
        clearInterval(this.timeout);
    };
    VScroll.prototype.tabHoldHandler = function (ev) {
        var _this = this;
        var trgt = ev.originalEvent.target;
        trgt = this.contains(trgt, CLS_VSCROLLNAV) ? trgt.firstElementChild : trgt;
        var scrollDistance = 10;
        var timeoutFun = function () {
            _this.eleScrolling(scrollDistance, trgt, true);
        };
        this.timeout = window.setInterval(function () {
            timeoutFun();
        }, 50);
    };
    VScroll.prototype.contains = function (element, className) {
        return element.classList.contains(className);
    };
    VScroll.prototype.eleScrolling = function (scrollDis, trgt, isContinuous) {
        var classList$$1 = trgt.classList;
        if (classList$$1.contains(CLS_VSCROLLNAV)) {
            classList$$1 = trgt.querySelector('.' + CLS_NAVARROW$1).classList;
        }
        if (classList$$1.contains(CLS_NAVDOWNARROW)) {
            this.frameScrollRequest(scrollDis, 'add', isContinuous);
        }
        else if (classList$$1.contains(CLS_NAVUPARROW)) {
            this.frameScrollRequest(scrollDis, '', isContinuous);
        }
    };
    VScroll.prototype.clickEventHandler = function (event) {
        this.eleScrolling(this.scrollStep, event.target, false);
    };
    VScroll.prototype.wheelEventHandler = function (e) {
        e.preventDefault();
        this.frameScrollRequest(this.scrollStep, (e.deltaY > 0 ? 'add' : ''), false);
    };
    VScroll.prototype.swipeHandler = function (e) {
        var swipeElement = this.scrollEle;
        var distance;
        if (e.velocity <= 1) {
            distance = e.distanceY / (e.velocity * 10);
        }
        else {
            distance = e.distanceY / e.velocity;
        }
        var start = 0.5;
        var animate = function () {
            var step = Math.sin(start);
            if (step <= 0) {
                window.cancelAnimationFrame(step);
            }
            else {
                if (e.swipeDirection === 'Up') {
                    swipeElement.scrollTop += distance * step;
                }
                else if (e.swipeDirection === 'Down') {
                    swipeElement.scrollTop -= distance * step;
                }
                start -= 0.02;
                window.requestAnimationFrame(animate);
            }
        };
        animate();
    };
    VScroll.prototype.scrollUpdating = function (scrollVal, action) {
        if (action === 'add') {
            this.scrollEle.scrollTop += scrollVal;
        }
        else {
            this.scrollEle.scrollTop -= scrollVal;
        }
    };
    VScroll.prototype.frameScrollRequest = function (scrollValue, action, isContinuous) {
        var _this = this;
        var step = 10;
        if (isContinuous) {
            this.scrollUpdating(scrollValue, action);
            return;
        }
        if (!this.customStep) {
            [].slice.call(sf.base.selectAll('.' + CLS_OVERLAY$1, this.element)).forEach(function (el) {
                scrollValue -= el.offsetHeight;
            });
        }
        var animate = function () {
            if (scrollValue < step) {
                window.cancelAnimationFrame(step);
            }
            else {
                _this.scrollUpdating(step, action);
                scrollValue -= step;
                window.requestAnimationFrame(animate);
            }
        };
        animate();
    };
    VScroll.prototype.touchHandler = function (e) {
        var el = this.scrollEle;
        var distance = e.distanceY;
        if (e.scrollDirection === 'Up') {
            el.scrollTop = el.scrollTop + distance;
        }
        else if (e.scrollDirection === 'Down') {
            el.scrollTop = el.scrollTop - distance;
        }
    };
    VScroll.prototype.arrowDisabling = function (addDisableCls, removeDisableCls) {
        if (this.isDevice) {
            var arrowEle = sf.base.isNullOrUndefined(addDisableCls) ? removeDisableCls : addDisableCls;
            var arrowIcon = arrowEle.querySelector('.' + CLS_NAVARROW$1);
            if (sf.base.isNullOrUndefined(addDisableCls)) {
                sf.base.classList(arrowIcon, [CLS_NAVDOWNARROW], [CLS_NAVUPARROW]);
            }
            else {
                sf.base.classList(arrowIcon, [CLS_NAVUPARROW], [CLS_NAVDOWNARROW]);
            }
        }
        else {
            addDisableCls.classList.add(CLS_DISABLE$1);
            addDisableCls.setAttribute('aria-disabled', 'true');
            addDisableCls.removeAttribute('tabindex');
            removeDisableCls.classList.remove(CLS_DISABLE$1);
            removeDisableCls.setAttribute('aria-disabled', 'false');
            removeDisableCls.setAttribute('tabindex', '0');
        }
        this.repeatScroll();
    };
    VScroll.prototype.scrollEventHandler = function (e) {
        var target = e.target;
        var height = target.offsetHeight;
        var navUpEle = this.element.querySelector('.' + CLS_VSCROLLNAVUP);
        var navDownEle = this.element.querySelector('.' + CLS_VSCROLLNAVDOWN);
        var upOverlay = this.element.querySelector('.' + CLS_UPOVERLAY);
        var downOverlay = this.element.querySelector('.' + CLS_DOWNOVERLAY);
        var scrollTop = target.scrollTop;
        if (scrollTop <= 0) {
            scrollTop = -scrollTop;
        }
        if (this.isDevice) {
            if (scrollTop < OVERLAY_MAXWID$1) {
                upOverlay.style.height = scrollTop + 'px';
            }
            else {
                upOverlay.style.height = '40px';
            }
            if ((target.scrollHeight - Math.ceil(height + scrollTop)) < OVERLAY_MAXWID$1) {
                downOverlay.style.height = (target.scrollHeight - Math.ceil(height + scrollTop)) + 'px';
            }
            else {
                downOverlay.style.height = '40px';
            }
        }
        if (scrollTop === 0) {
            this.arrowDisabling(navUpEle, navDownEle);
        }
        else if (Math.ceil(height + scrollTop + .1) >= target.scrollHeight) {
            this.arrowDisabling(navDownEle, navUpEle);
        }
        else {
            var disEle = this.element.querySelector('.' + CLS_VSCROLLNAV + '.' + CLS_DISABLE$1);
            if (disEle) {
                disEle.classList.remove(CLS_DISABLE$1);
                disEle.setAttribute('aria-disabled', 'false');
                disEle.setAttribute('tabindex', '0');
            }
        }
    };
    /**
     * Gets called when the model property changes.The data that describes the old and new values of property that changed.
     *
     * @param  {VScrollModel} newProp - It contains the new value of data.
     * @param  {VScrollModel} oldProp - It contains the old value of data.
     * @returns {void}
     * @private
     */
    VScroll.prototype.onPropertyChanged = function (newProp, oldProp) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'scrollStep':
                    this.setScrollState();
                    break;
                case 'enableRtl':
                    if (newProp.enableRtl) {
                        this.element.classList.add(CLS_RTL$1);
                    }
                    else {
                        this.element.classList.remove(CLS_RTL$1);
                    }
                    break;
            }
        }
    };
    __decorate$1([
        sf.base.Property(null)
    ], VScroll.prototype, "scrollStep", void 0);
    VScroll = __decorate$1([
        sf.base.NotifyPropertyChanges
    ], VScroll);
    return VScroll;
}(sf.base.Component));

/**
 * Used to add scroll in menu.
 *
 * @param {createElementType} createElement - Specifies the create element model
 * @param {HTMLElement} container - Specifies the element container
 * @param {HTMLElement} content - Specifies the content element
 * @param {string} scrollType - Specifies the scroll type
 * @param {boolean} enableRtl - Specifies the enable RTL property
 * @param {boolean} offset - Specifies the offset value
 * @returns {HTMLElement} - Element
 * @hidden
 */
function addScrolling(createElement$$1, container, content, scrollType, enableRtl, offset) {
    var containerOffset;
    var contentOffset;
    var parentElem = container.parentElement;
    if (scrollType === 'vscroll') {
        containerOffset = offset || container.getBoundingClientRect().height;
        contentOffset = content.getBoundingClientRect().height;
    }
    else {
        containerOffset = container.getBoundingClientRect().width;
        contentOffset = content.getBoundingClientRect().width;
    }
    if (containerOffset < contentOffset) {
        return createScrollbar(createElement$$1, container, content, scrollType, enableRtl, offset);
    }
    else if (parentElem) {
        var width = parentElem.getBoundingClientRect().width;
        if (width < containerOffset && scrollType === 'hscroll') {
            contentOffset = width;
            container.style.maxWidth = width + 'px';
            return createScrollbar(createElement$$1, container, content, scrollType, enableRtl, offset);
        }
        return content;
    }
    else {
        return content;
    }
}
/**
 * Used to create scroll bar in menu.
 *
 * @param {createElementType} createElement - Specifies the create element model
 * @param {HTMLElement} container - Specifies the element container
 * @param {HTMLElement} content - Specifies the content element
 * @param {string} scrollType - Specifies the scroll type
 * @param {boolean} enableRtl - Specifies the enable RTL property
 * @param {boolean} offset - Specifies the offset value
 * @returns {HTMLElement} - Element
 * @hidden
 */
function createScrollbar(createElement$$1, container, content, scrollType, enableRtl, offset) {
    var scrollEle = createElement$$1('div', { className: 'e-menu-' + scrollType });
    container.appendChild(scrollEle);
    scrollEle.appendChild(content);
    if (offset) {
        scrollEle.style.overflow = 'hidden';
        scrollEle.style.height = offset + 'px';
    }
    else {
        scrollEle.style.maxHeight = container.style.maxHeight;
        container.style.overflow = 'hidden';
    }
    var scrollObj;
    if (scrollType === 'vscroll') {
        scrollObj = new VScroll({ enableRtl: enableRtl }, scrollEle);
        scrollObj.scrollStep = sf.base.select('.e-' + scrollType + '-bar', container).offsetHeight / 2;
    }
    else {
        scrollObj = new HScroll({ enableRtl: enableRtl }, scrollEle);
        scrollObj.scrollStep = sf.base.select('.e-' + scrollType + '-bar', container).offsetWidth;
    }
    return scrollEle;
}
/**
 * Used to destroy the scroll option.
 *
 * @param {VScroll | HScroll} scrollObj - Specifies the scroller object
 * @param {Element} element - Specifies the element
 * @param {HTMLElement} skipEle - Specifies the skip  element
 * @returns {void}
 * @hidden
 */
function destroyScroll(scrollObj, element, skipEle) {
    if (scrollObj) {
        var menu = sf.base.select('.e-menu-parent', element);
        if (menu) {
            if (!skipEle || skipEle === menu) {
                scrollObj.destroy();
                element.parentElement.appendChild(menu);
                sf.base.detach(element);
            }
        }
        else {
            scrollObj.destroy();
            sf.base.detach(element);
        }
    }
}

exports.HScroll = HScroll;
exports.VScroll = VScroll;
exports.addScrolling = addScrolling;
exports.destroyScroll = destroyScroll;

return exports;

});
window.sf.navigations = window.sf.base.extend({}, window.sf.navigations, navigationsbase({}));


/***/ }),

/***/ "./resources/19.3.44/Scripts/popup.js":
/*!********************************************!*\
  !*** ./resources/19.3.44/Scripts/popup.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sf = window.sf || {};
var sfpopup = (function (exports) {
'use strict';

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Specifies the offset position values.
 */
var PositionData = /** @class */ (function (_super) {
    __extends(PositionData, _super);
    function PositionData() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sf.base.Property('left')
    ], PositionData.prototype, "X", void 0);
    __decorate([
        sf.base.Property('top')
    ], PositionData.prototype, "Y", void 0);
    return PositionData;
}(sf.base.ChildProperty));
// don't use space in classNames
var CLASSNAMES = {
    ROOT: 'e-popup',
    RTL: 'e-rtl',
    OPEN: 'e-popup-open',
    CLOSE: 'e-popup-close'
};
/**
 * Represents the Popup Component
 * ```html
 * <div id="popup" style="position:absolute;height:100px;width:100px;">
 * <div style="margin:35px 25px;">Popup Content</div></div>
 * ```
 * ```typescript
 * <script>
 *   var popupObj = new Popup();
 *   popupObj.appendTo("#popup");
 * </script>
 * ```
 */
var Popup = /** @class */ (function (_super) {
    __extends(Popup, _super);
    function Popup(element, options) {
        return _super.call(this, options, element) || this;
    }
    /**
     * Called internally if any of the property value changed.
     *
     * @param {PopupModel} newProp - specifies the new property
     * @param {PopupModel} oldProp - specifies the old property
     * @private
     * @returns {void}
     */
    Popup.prototype.onPropertyChanged = function (newProp, oldProp) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'width':
                    sf.base.setStyleAttribute(this.element, { 'width': sf.base.formatUnit(newProp.width) });
                    break;
                case 'height':
                    sf.base.setStyleAttribute(this.element, { 'height': sf.base.formatUnit(newProp.height) });
                    break;
                case 'zIndex':
                    sf.base.setStyleAttribute(this.element, { 'zIndex': newProp.zIndex });
                    break;
                case 'enableRtl':
                    this.setEnableRtl();
                    break;
                case 'position':
                case 'relateTo':
                    this.refreshPosition();
                    break;
                case 'offsetX':
                    // eslint-disable-next-line
                    var x = newProp.offsetX - oldProp.offsetX;
                    this.element.style.left = (parseInt(this.element.style.left, 10) + (x)).toString() + 'px';
                    break;
                case 'offsetY':
                    // eslint-disable-next-line
                    var y = newProp.offsetY - oldProp.offsetY;
                    this.element.style.top = (parseInt(this.element.style.top, 10) + (y)).toString() + 'px';
                    break;
                case 'content':
                    this.setContent();
                    break;
                case 'actionOnScroll':
                    if (newProp.actionOnScroll !== 'none') {
                        this.wireScrollEvents();
                    }
                    else {
                        this.unwireScrollEvents();
                    }
                    break;
            }
        }
    };
    /**
     * gets the Component module name.
     *
     * @returns {void}
     * @private
     */
    Popup.prototype.getModuleName = function () {
        return 'popup';
    };
    /**
     * To resolve if any collision occurs.
     *
     * @returns {void}
     */
    Popup.prototype.resolveCollision = function () {
        this.checkCollision();
    };
    /**
     * gets the persisted state properties of the Component.
     *
     * @returns {void}
     */
    Popup.prototype.getPersistData = function () {
        return this.addOnPersist([]);
    };
    /**
     * To destroy the control.
     *
     * @returns {void}
     */
    Popup.prototype.destroy = function () {
        this.element.classList.remove(CLASSNAMES.ROOT, CLASSNAMES.RTL, CLASSNAMES.OPEN, CLASSNAMES.CLOSE);
        this.unwireEvents();
        _super.prototype.destroy.call(this);
    };
    /**
     * To Initialize the control rendering
     *
     * @returns {void}
     * @private
     */
    Popup.prototype.render = function () {
        this.element.classList.add(CLASSNAMES.ROOT);
        var styles = {};
        if (this.zIndex !== 1000) {
            styles.zIndex = this.zIndex;
        }
        if (this.width !== 'auto') {
            styles.width = sf.base.formatUnit(this.width);
        }
        if (this.height !== 'auto') {
            styles.height = sf.base.formatUnit(this.height);
        }
        sf.base.setStyleAttribute(this.element, styles);
        this.fixedParent = false;
        this.setEnableRtl();
        this.setContent();
    };
    Popup.prototype.wireEvents = function () {
        if (sf.base.Browser.isDevice) {
            sf.base.EventHandler.add(window, 'orientationchange', this.orientationOnChange, this);
        }
        if (this.actionOnScroll !== 'none') {
            this.wireScrollEvents();
        }
    };
    Popup.prototype.wireScrollEvents = function () {
        if (this.getRelateToElement()) {
            for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
                var parent_1 = _a[_i];
                sf.base.EventHandler.add(parent_1, 'scroll', this.scrollRefresh, this);
            }
        }
    };
    Popup.prototype.unwireEvents = function () {
        if (sf.base.Browser.isDevice) {
            sf.base.EventHandler.remove(window, 'orientationchange', this.orientationOnChange);
        }
        if (this.actionOnScroll !== 'none') {
            this.unwireScrollEvents();
        }
    };
    Popup.prototype.unwireScrollEvents = function () {
        if (this.getRelateToElement()) {
            for (var _i = 0, _a = this.getScrollableParent(this.getRelateToElement()); _i < _a.length; _i++) {
                var parent_2 = _a[_i];
                sf.base.EventHandler.remove(parent_2, 'scroll', this.scrollRefresh);
            }
        }
    };
    Popup.prototype.getRelateToElement = function () {
        var relateToElement = this.relateTo === '' || sf.base.isNullOrUndefined(this.relateTo) ?
            document.body : this.relateTo;
        this.setProperties({ relateTo: relateToElement }, true);
        return ((typeof this.relateTo) === 'string') ?
            document.querySelector(this.relateTo) : this.relateTo;
    };
    Popup.prototype.scrollRefresh = function (e) {
        if (this.actionOnScroll === 'reposition') {
            if (!sf.base.isNullOrUndefined(this.element) && !(this.element.offsetParent === e.target ||
                (this.element.offsetParent && this.element.offsetParent.tagName === 'BODY' &&
                    e.target.parentElement == null))) {
                this.refreshPosition();
            }
        }
        else if (this.actionOnScroll === 'hide') {
            this.hide();
        }
        if (this.actionOnScroll !== 'none') {
            if (this.getRelateToElement()) {
                var targetVisible = this.isElementOnViewport(this.getRelateToElement(), e.target);
                if (!targetVisible && !this.targetInvisibleStatus) {
                    this.trigger('targetExitViewport');
                    this.targetInvisibleStatus = true;
                }
                else if (targetVisible) {
                    this.targetInvisibleStatus = false;
                }
            }
        }
    };
    /**
     * This method is to get the element visibility on viewport when scroll
     * the page. This method will returns true even though 1 px of element
     * part is in visible.
     *
     * @param {HTMLElement} relateToElement - specifies the element
     * @param {HTMLElement} scrollElement - specifies the scroll element
     * @returns {boolean} - retruns the boolean
     */
    // eslint-disable-next-line
    Popup.prototype.isElementOnViewport = function (relateToElement, scrollElement) {
        var scrollParents = this.getScrollableParent(relateToElement);
        for (var parent_3 = 0; parent_3 < scrollParents.length; parent_3++) {
            if (this.isElementVisible(relateToElement, scrollParents[parent_3])) {
                continue;
            }
            else {
                return false;
            }
        }
        return true;
    };
    Popup.prototype.isElementVisible = function (relateToElement, scrollElement) {
        var rect = this.checkGetBoundingClientRect(relateToElement);
        if (!rect.height || !rect.width) {
            return false;
        }
        if (!sf.base.isNullOrUndefined(this.checkGetBoundingClientRect(scrollElement))) {
            var parent_4 = scrollElement.getBoundingClientRect();
            return !(rect.bottom < parent_4.top) &&
                (!(rect.bottom > parent_4.bottom) &&
                    (!(rect.right > parent_4.right) &&
                        !(rect.left < parent_4.left)));
        }
        else {
            var win = window;
            var windowView = {
                top: win.scrollY,
                left: win.scrollX,
                right: win.scrollX + win.outerWidth,
                bottom: win.scrollY + win.outerHeight
            };
            var off = sf.popups.calculatePosition(relateToElement);
            var ele = {
                top: off.top,
                left: off.left,
                right: off.left + rect.width,
                bottom: off.top + rect.height
            };
            var elementView = {
                top: windowView.bottom - ele.top,
                left: windowView.right - ele.left,
                bottom: ele.bottom - windowView.top,
                right: ele.right - windowView.left
            };
            return elementView.top > 0
                && elementView.left > 0
                && elementView.right > 0
                && elementView.bottom > 0;
        }
    };
    /**
     * Initialize the event handler
     *
     * @returns {void}
     * @private
     */
    Popup.prototype.preRender = function () {
        //There is no event handler
    };
    Popup.prototype.setEnableRtl = function () {
        this.reposition();
        // eslint-disable-next-line
        this.enableRtl ? this.element.classList.add(CLASSNAMES.RTL) : this.element.classList.remove(CLASSNAMES.RTL);
    };
    Popup.prototype.setContent = function () {
        if (!sf.base.isNullOrUndefined(this.content)) {
            this.element.innerHTML = '';
            if (typeof (this.content) === 'string') {
                this.element.textContent = this.content;
            }
            else {
                this.element.appendChild(this.content);
            }
        }
    };
    Popup.prototype.orientationOnChange = function () {
        var _this = this;
        setTimeout(function () {
            _this.refreshPosition();
        }, 200);
    };
    // eslint-disable-next-line
    /**
     * Based on the `relative` element and `offset` values, `Popup` element position will refreshed.
     *
     * @returns {void}
     */
    Popup.prototype.refreshPosition = function (target, collision) {
        if (!sf.base.isNullOrUndefined(target)) {
            this.checkFixedParent(target);
        }
        this.reposition();
        if (!collision) {
            this.checkCollision();
        }
    };
    Popup.prototype.reposition = function () {
        var pos;
        var position;
        var relateToElement = this.getRelateToElement();
        if (typeof this.position.X === 'number' && typeof this.position.Y === 'number') {
            pos = { left: this.position.X, top: this.position.Y };
        }
        else if ((typeof this.position.X === 'string' && typeof this.position.Y === 'number') ||
            (typeof this.position.X === 'number' && typeof this.position.Y === 'string')) {
            var parentDisplay = void 0;
            var display = this.element.style.display;
            this.element.style.display = 'block';
            if (this.element.classList.contains('e-dlg-modal')) {
                parentDisplay = this.element.parentElement.style.display;
                this.element.parentElement.style.display = 'block';
            }
            position = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);
            if (typeof this.position.X === 'string') {
                pos = { left: position.left, top: this.position.Y };
            }
            else {
                pos = { left: this.position.X, top: position.top };
            }
            this.element.style.display = display;
            if (this.element.classList.contains('e-dlg-modal')) {
                this.element.parentElement.style.display = parentDisplay;
            }
        }
        else if (relateToElement) {
            var display = this.element.style.display;
            this.element.style.display = 'block';
            pos = this.getAnchorPosition(relateToElement, this.element, this.position, this.offsetX, this.offsetY);
            this.element.style.display = display;
        }
        else {
            pos = { left: 0, top: 0 };
        }
        if (!sf.base.isNullOrUndefined(pos)) {
            this.element.style.left = pos.left + 'px';
            this.element.style.top = pos.top + 'px';
        }
    };
    Popup.prototype.checkGetBoundingClientRect = function (ele) {
        var eleRect;
        try {
            eleRect = ele.getBoundingClientRect();
            return eleRect;
        }
        catch (error) {
            return null;
        }
    };
    Popup.prototype.getAnchorPosition = function (anchorEle, ele, position, offsetX, offsetY) {
        var eleRect = this.checkGetBoundingClientRect(ele);
        var anchorRect = this.checkGetBoundingClientRect(anchorEle);
        if (sf.base.isNullOrUndefined(eleRect) || sf.base.isNullOrUndefined(anchorRect)) {
            return null;
        }
        var anchor = anchorEle;
        var anchorPos = { left: 0, top: 0 };
        if (ele.offsetParent && ele.offsetParent.tagName === 'BODY' && anchorEle.tagName === 'BODY') {
            anchorPos = sf.popups.calculatePosition(anchorEle);
        }
        else {
            if ((ele.classList.contains('e-dlg-modal') && anchor.tagName !== 'BODY')) {
                ele = ele.parentElement;
            }
            anchorPos = sf.popups.calculateRelativeBasedPosition(anchor, ele);
        }
        switch (position.X) {
            default:
            case 'left':
                break;
            case 'center':
                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
                    anchorPos.left += (window.innerWidth / 2 - eleRect.width / 2);
                }
                else if (this.targetType === 'container') {
                    anchorPos.left += (anchorRect.width / 2 - eleRect.width / 2);
                }
                else {
                    anchorPos.left += (anchorRect.width / 2);
                }
                break;
            case 'right':
                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
                    anchorPos.left += (window.innerWidth - eleRect.width);
                }
                else if (this.targetType === 'container') {
                    anchorPos.left += (anchorRect.width - eleRect.width);
                }
                else {
                    anchorPos.left += (anchorRect.width);
                }
                break;
        }
        switch (position.Y) {
            default:
            case 'top':
                break;
            case 'center':
                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
                    anchorPos.top += (window.innerHeight / 2 - eleRect.height / 2);
                }
                else if (this.targetType === 'container') {
                    anchorPos.top += (anchorRect.height / 2 - eleRect.height / 2);
                }
                else {
                    anchorPos.top += (anchorRect.height / 2);
                }
                break;
            case 'bottom':
                if ((ele.classList.contains('e-dlg-modal') && anchor.tagName === 'BODY' && this.targetType === 'container')) {
                    anchorPos.top += (window.innerHeight - eleRect.height);
                }
                else if (this.targetType === 'container') {
                    anchorPos.top += (anchorRect.height - eleRect.height);
                }
                else {
                    anchorPos.top += (anchorRect.height);
                }
                break;
        }
        anchorPos.left += offsetX;
        anchorPos.top += offsetY;
        return anchorPos;
    };
    Popup.prototype.callFlip = function (param) {
        var relateToElement = this.getRelateToElement();
        sf.popups.flip(this.element, relateToElement, this.offsetX, this.offsetY, this.position.X, this.position.Y, this.viewPortElement, param, this.fixedParent);
    };
    Popup.prototype.callFit = function (param) {
        if (sf.popups.isCollide(this.element, this.viewPortElement).length !== 0) {
            if (sf.base.isNullOrUndefined(this.viewPortElement)) {
                var data = sf.popups.fit(this.element, this.viewPortElement, param);
                if (param.X) {
                    this.element.style.left = data.left + 'px';
                }
                if (param.Y) {
                    this.element.style.top = data.top + 'px';
                }
            }
            else {
                var elementRect = this.checkGetBoundingClientRect(this.element);
                var viewPortRect = this.checkGetBoundingClientRect(this.viewPortElement);
                if (sf.base.isNullOrUndefined(elementRect) || sf.base.isNullOrUndefined(viewPortRect)) {
                    return null;
                }
                if (param && param.Y === true) {
                    if (viewPortRect.top > elementRect.top) {
                        this.element.style.top = '0px';
                    }
                    else if (viewPortRect.bottom < elementRect.bottom) {
                        this.element.style.top = parseInt(this.element.style.top, 10) - (elementRect.bottom - viewPortRect.bottom) + 'px';
                    }
                }
                if (param && param.X === true) {
                    if (viewPortRect.right < elementRect.right) {
                        this.element.style.left = parseInt(this.element.style.left, 10) - (elementRect.right - viewPortRect.right) + 'px';
                    }
                    else if (viewPortRect.left > elementRect.left) {
                        this.element.style.left = parseInt(this.element.style.left, 10) + (viewPortRect.left - elementRect.left) + 'px';
                    }
                }
            }
        }
    };
    Popup.prototype.checkCollision = function () {
        var horz = this.collision.X;
        var vert = this.collision.Y;
        if (horz === 'none' && vert === 'none') {
            return;
        }
        if (horz === 'flip' && vert === 'flip') {
            this.callFlip({ X: true, Y: true });
        }
        else if (horz === 'fit' && vert === 'fit') {
            this.callFit({ X: true, Y: true });
        }
        else {
            if (horz === 'flip') {
                this.callFlip({ X: true, Y: false });
            }
            else if (vert === 'flip') {
                this.callFlip({ Y: true, X: false });
            }
            if (horz === 'fit') {
                this.callFit({ X: true, Y: false });
            }
            else if (vert === 'fit') {
                this.callFit({ X: false, Y: true });
            }
        }
    };
    /**
     * Shows the popup element from screen.
     *
     * @returns {void}
     * @param {AnimationModel} animationOptions - specifies the model
     * @param { HTMLElement } relativeElement - To calculate the zIndex value dynamically.
     */
    Popup.prototype.show = function (animationOptions, relativeElement) {
        var _this = this;
        this.wireEvents();
        if (this.zIndex === 1000 || !sf.base.isNullOrUndefined(relativeElement)) {
            var zIndexElement = (sf.base.isNullOrUndefined(relativeElement)) ? this.element : relativeElement;
            this.zIndex = getZindexPartial(zIndexElement);
            sf.base.setStyleAttribute(this.element, { 'zIndex': this.zIndex });
        }
        animationOptions = (!sf.base.isNullOrUndefined(animationOptions) && typeof animationOptions === 'object') ?
            animationOptions : this.showAnimation;
        if (this.collision.X !== 'none' || this.collision.Y !== 'none') {
            sf.base.removeClass([this.element], CLASSNAMES.CLOSE);
            sf.base.addClass([this.element], CLASSNAMES.OPEN);
            this.checkCollision();
            sf.base.removeClass([this.element], CLASSNAMES.OPEN);
            sf.base.addClass([this.element], CLASSNAMES.CLOSE);
        }
        if (!sf.base.isNullOrUndefined(animationOptions)) {
            animationOptions.begin = function () {
                if (!_this.isDestroyed) {
                    sf.base.removeClass([_this.element], CLASSNAMES.CLOSE);
                    sf.base.addClass([_this.element], CLASSNAMES.OPEN);
                }
            };
            animationOptions.end = function () {
                if (!_this.isDestroyed) {
                    _this.trigger('open');
                }
            };
            new sf.base.Animation(animationOptions).animate(this.element);
        }
        else {
            sf.base.removeClass([this.element], CLASSNAMES.CLOSE);
            sf.base.addClass([this.element], CLASSNAMES.OPEN);
            this.trigger('open');
        }
    };
    /**
     * Hides the popup element from screen.
     *
     * @param {AnimationModel} animationOptions - To give the animation options.
     * @returns {void}
     */
    Popup.prototype.hide = function (animationOptions) {
        var _this = this;
        animationOptions = (!sf.base.isNullOrUndefined(animationOptions) && typeof animationOptions === 'object') ?
            animationOptions : this.hideAnimation;
        if (!sf.base.isNullOrUndefined(animationOptions)) {
            animationOptions.end = function () {
                if (!_this.isDestroyed) {
                    sf.base.removeClass([_this.element], CLASSNAMES.OPEN);
                    sf.base.addClass([_this.element], CLASSNAMES.CLOSE);
                    _this.trigger('close');
                }
            };
            new sf.base.Animation(animationOptions).animate(this.element);
        }
        else {
            sf.base.removeClass([this.element], CLASSNAMES.OPEN);
            sf.base.addClass([this.element], CLASSNAMES.CLOSE);
            this.trigger('close');
        }
        this.unwireEvents();
    };
    /**
     * Gets scrollable parent elements for the given element.
     *
     * @returns {void}
     * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
     */
    Popup.prototype.getScrollableParent = function (element) {
        this.checkFixedParent(element);
        return getScrollableParent(element, this.fixedParent);
    };
    Popup.prototype.checkFixedParent = function (element) {
        var parent = element.parentElement;
        while (parent && parent.tagName !== 'HTML') {
            var parentStyle = getComputedStyle(parent);
            if (parentStyle.position === 'fixed' && !sf.base.isNullOrUndefined(this.element) && this.element.offsetParent && this.element.offsetParent.tagName === 'BODY') {
                this.element.style.top = window.scrollY > parseInt(this.element.style.top) ? sf.base.formatUnit(window.scrollY - parseInt(this.element.style.top))
                    : sf.base.formatUnit(parseInt(this.element.style.top) - window.scrollY);
                this.element.style.position = 'fixed';
                this.fixedParent = true;
            }
            parent = parent.parentElement;
            if (!sf.base.isNullOrUndefined(this.element) && sf.base.isNullOrUndefined(this.element.offsetParent) && parentStyle.position === 'fixed'
                && this.element.style.position === 'fixed') {
                this.fixedParent = true;
            }
        }
    };
    __decorate([
        sf.base.Property('auto')
    ], Popup.prototype, "height", void 0);
    __decorate([
        sf.base.Property('auto')
    ], Popup.prototype, "width", void 0);
    __decorate([
        sf.base.Property(null)
    ], Popup.prototype, "content", void 0);
    __decorate([
        sf.base.Property('container')
    ], Popup.prototype, "targetType", void 0);
    __decorate([
        sf.base.Property(null)
    ], Popup.prototype, "viewPortElement", void 0);
    __decorate([
        sf.base.Property({ X: 'none', Y: 'none' })
    ], Popup.prototype, "collision", void 0);
    __decorate([
        sf.base.Property('')
    ], Popup.prototype, "relateTo", void 0);
    __decorate([
        sf.base.Complex({}, PositionData)
    ], Popup.prototype, "position", void 0);
    __decorate([
        sf.base.Property(0)
    ], Popup.prototype, "offsetX", void 0);
    __decorate([
        sf.base.Property(0)
    ], Popup.prototype, "offsetY", void 0);
    __decorate([
        sf.base.Property(1000)
    ], Popup.prototype, "zIndex", void 0);
    __decorate([
        sf.base.Property(false)
    ], Popup.prototype, "enableRtl", void 0);
    __decorate([
        sf.base.Property('reposition')
    ], Popup.prototype, "actionOnScroll", void 0);
    __decorate([
        sf.base.Property(null)
    ], Popup.prototype, "showAnimation", void 0);
    __decorate([
        sf.base.Property(null)
    ], Popup.prototype, "hideAnimation", void 0);
    __decorate([
        sf.base.Event()
    ], Popup.prototype, "open", void 0);
    __decorate([
        sf.base.Event()
    ], Popup.prototype, "close", void 0);
    __decorate([
        sf.base.Event()
    ], Popup.prototype, "targetExitViewport", void 0);
    Popup = __decorate([
        sf.base.NotifyPropertyChanges
    ], Popup);
    return Popup;
}(sf.base.Component));
/**
 * Gets scrollable parent elements for the given element.
 *
 * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
 * @param {boolean} fixedParent - specifies the parent element
 * @private
 * @returns {void}
 */
function getScrollableParent(element, fixedParent) {
    var eleStyle = getComputedStyle(element);
    var scrollParents = [];
    var overflowRegex = /(auto|scroll)/;
    var parent = element.parentElement;
    while (parent && parent.tagName !== 'HTML') {
        var parentStyle = getComputedStyle(parent);
        if (!(eleStyle.position === 'absolute' && parentStyle.position === 'static')
            && overflowRegex.test(parentStyle.overflow + parentStyle.overflowY + parentStyle.overflowX)) {
            scrollParents.push(parent);
        }
        parent = parent.parentElement;
    }
    if (!fixedParent) {
        scrollParents.push(document);
    }
    return scrollParents;
}
/**
 * Gets the maximum z-index of the given element.
 *
 * @returns {void}
 * @param { HTMLElement } element - Specify the element to get the maximum z-index of it.
 * @private
 */
function getZindexPartial(element) {
    // upto body traversal
    var parent = element.parentElement;
    var parentZindex = [];
    while (parent) {
        if (parent.tagName !== 'BODY') {
            var index = document.defaultView.getComputedStyle(parent, null).getPropertyValue('z-index');
            var position = document.defaultView.getComputedStyle(parent, null).getPropertyValue('position');
            if (index !== 'auto' && position !== 'static') {
                parentZindex.push(index);
            }
            parent = parent.parentElement;
        }
        else {
            break;
        }
    }
    var childrenZindex = [];
    for (var i = 0; i < document.body.children.length; i++) {
        if (!element.isEqualNode(document.body.children[i])) {
            var index = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('z-index');
            var position = document.defaultView.getComputedStyle(document.body.children[i], null).getPropertyValue('position');
            if (index !== 'auto' && position !== 'static') {
                childrenZindex.push(index);
            }
        }
    }
    childrenZindex.push('999');
    var siblingsZindex = [];
    if (!sf.base.isNullOrUndefined(element.parentElement) && element.parentElement.tagName !== 'BODY') {
        var childNodes = [].slice.call(element.parentElement.children);
        for (var i = 0; i < childNodes.length; i++) {
            if (!element.isEqualNode(childNodes[i])) {
                var index = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('z-index');
                var position = document.defaultView.getComputedStyle(childNodes[i], null).getPropertyValue('position');
                if (index !== 'auto' && position !== 'static') {
                    siblingsZindex.push(index);
                }
            }
        }
    }
    var finalValue = parentZindex.concat(childrenZindex, siblingsZindex);
    // eslint-disable-next-line
    var currentZindexValue = Math.max.apply(Math, finalValue) + 1;
    return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;
}
/**
 * Gets the maximum z-index of the page.
 *
 * @returns {void}
 * @param { HTMLElement } tagName - Specify the tagName to get the maximum z-index of it.
 * @private
 */
function getMaxZindex(tagName) {
    if (tagName === void 0) { tagName = ['*']; }
    var maxZindex = [];
    for (var i = 0; i < tagName.length; i++) {
        var elements = document.getElementsByTagName(tagName[i]);
        for (var i_1 = 0; i_1 < elements.length; i_1++) {
            var index = document.defaultView.getComputedStyle(elements[i_1], null).getPropertyValue('z-index');
            var position = document.defaultView.getComputedStyle(elements[i_1], null).getPropertyValue('position');
            if (index !== 'auto' && position !== 'static') {
                maxZindex.push(index);
            }
        }
    }
    // eslint-disable-next-line
    var currentZindexValue = Math.max.apply(Math, maxZindex) + 1;
    return currentZindexValue > 2147483647 ? 2147483647 : currentZindexValue;
}

/**
 * Popup Components
 */

exports.PositionData = PositionData;
exports.Popup = Popup;
exports.getScrollableParent = getScrollableParent;
exports.getZindexPartial = getZindexPartial;
exports.getMaxZindex = getMaxZindex;

return exports;

});

    sf.popups = sf.base.extend({}, sf.popups, sfpopup({}));

/***/ }),

/***/ "./resources/19.3.44/Scripts/popupsbase.js":
/*!*************************************************!*\
  !*** ./resources/19.3.44/Scripts/popupsbase.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sf = window.sf || {};
var popupsbase = (function (exports) {
'use strict';

/**
 * Position library
 */
var elementRect;
var popupRect;
var element;
var parentDocument$1;
var fixedParent = false;
/**
 *
 * @param {HTMLElement} anchor - specifies the element
 * @param {HTMLElement} element - specifies the element
 * @returns {OffsetPosition} - returns the value
 */
function calculateRelativeBasedPosition(anchor, element) {
    var fixedElement = false;
    var anchorPos = { left: 0, top: 0 };
    var tempAnchor = anchor;
    if (!anchor || !element) {
        return anchorPos;
    }
    if (sf.base.isNullOrUndefined(element.offsetParent) && element.style.position === 'fixed') {
        fixedElement = true;
    }
    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
        anchorPos.left += anchor.offsetLeft;
        anchorPos.top += anchor.offsetTop;
        anchor = anchor.offsetParent;
    }
    anchor = tempAnchor;
    while ((element.offsetParent || fixedElement) && anchor && element.offsetParent !== anchor) {
        anchorPos.left -= anchor.scrollLeft;
        anchorPos.top -= anchor.scrollTop;
        anchor = anchor.parentElement;
    }
    return anchorPos;
}
/**
 *
 * @param {Element} currentElement - specifies the element
 * @param {string} positionX - specifies the position
 * @param {string} positionY - specifies the position
 * @param {boolean} parentElement - specifies the boolean
 * @param {ClientRect} targetValues - specifies the client
 * @returns {OffsetPosition} - returns the position
 */
function calculatePosition(currentElement, positionX, positionY, parentElement, targetValues) {
    //eslint-disable-next-line
    popupRect = undefined;
    popupRect = targetValues;
    fixedParent = parentElement ? true : false;
    if (!currentElement) {
        return { left: 0, top: 0 };
    }
    if (!positionX) {
        positionX = 'left';
    }
    if (!positionY) {
        positionY = 'top';
    }
    parentDocument$1 = currentElement.ownerDocument;
    element = currentElement;
    var pos = { left: 0, top: 0 };
    return updatePosition(positionX.toLowerCase(), positionY.toLowerCase(), pos);
}
/**
 *
 * @param {number} value - specifies the number
 * @param {OffsetPosition} pos - specifies the position
 * @returns {void}
 */
function setPosx(value, pos) {
    pos.left = value;
}
/**
 *
 * @param {number} value - specifies the number
 * @param {OffsetPosition} pos - specifies the position
 * @returns {void}
 */
function setPosy(value, pos) {
    pos.top = value;
}
/**
 *
 * @param {string} posX - specifies the position
 * @param {string} posY - specifies the position
 * @param {OffsetPosition} pos - specifies the position
 * @returns {OffsetPosition} - returns the postion
 */
function updatePosition(posX, posY, pos) {
    elementRect = element.getBoundingClientRect();
    switch (posY + posX) {
        case 'topcenter':
            setPosx(getElementHCenter(), pos);
            setPosy(getElementTop(), pos);
            break;
        case 'topright':
            setPosx(getElementRight(), pos);
            setPosy(getElementTop(), pos);
            break;
        case 'centercenter':
            setPosx(getElementHCenter(), pos);
            setPosy(getElementVCenter(), pos);
            break;
        case 'centerright':
            setPosx(getElementRight(), pos);
            setPosy(getElementVCenter(), pos);
            break;
        case 'centerleft':
            setPosx(getElementLeft(), pos);
            setPosy(getElementVCenter(), pos);
            break;
        case 'bottomcenter':
            setPosx(getElementHCenter(), pos);
            setPosy(getElementBottom(), pos);
            break;
        case 'bottomright':
            setPosx(getElementRight(), pos);
            setPosy(getElementBottom(), pos);
            break;
        case 'bottomleft':
            setPosx(getElementLeft(), pos);
            setPosy(getElementBottom(), pos);
            break;
        default:
        case 'topleft':
            setPosx(getElementLeft(), pos);
            setPosy(getElementTop(), pos);
            break;
    }
    return pos;
}
/**
 * @returns {number} - specifies the number value
 */
function getBodyScrollTop$1() {
    return parentDocument$1.documentElement.scrollTop || parentDocument$1.body.scrollTop;
}
/**
 * @returns {number} - specifies the number value
 */
function getBodyScrollLeft$1() {
    return parentDocument$1.documentElement.scrollLeft || parentDocument$1.body.scrollLeft;
}
/**
 * @returns {number} - specifies the number value
 */
function getElementBottom() {
    return fixedParent ? elementRect.bottom : elementRect.bottom + getBodyScrollTop$1();
}
/**
 * @returns {number} - specifies the number value
 */
function getElementVCenter() {
    return getElementTop() + (elementRect.height / 2);
}
/**
 * @returns {number} - specifies the number value
 */
function getElementTop() {
    return fixedParent ? elementRect.top : elementRect.top + getBodyScrollTop$1();
}
/**
 * @returns {number} - specifies the number value
 */
function getElementLeft() {
    return elementRect.left + getBodyScrollLeft$1();
}
/**
 * @returns {number} - specifies the number value
 */
function getElementRight() {
    var popupWidth = (element && element.classList.contains('e-date-range-wrapper')) ? (popupRect ? popupRect.width : 0) :
        (popupRect && (elementRect.width >= popupRect.width) ? popupRect.width : 0);
    return elementRect.right + getBodyScrollLeft$1() - popupWidth;
}
/**
 * @returns {number} - specifies the number value
 */
function getElementHCenter() {
    return getElementLeft() + (elementRect.width / 2);
}

/**
 * Collision module.
 */
var parentDocument;
var targetContainer;
/**
 *
 * @param {HTMLElement} element - specifies the element
 * @param {HTMLElement} viewPortElement - specifies the element
 * @param {CollisionCoordinates} axis - specifies the collision coordinates
 * @param {OffsetPosition} position - specifies the position
 * @returns {void}
 */
function fit(element, viewPortElement, axis, position) {
    if (viewPortElement === void 0) { viewPortElement = null; }
    if (axis === void 0) { axis = { X: false, Y: false }; }
    if (!axis.Y && !axis.X) {
        return { left: 0, top: 0 };
    }
    var elemData = element.getBoundingClientRect();
    targetContainer = viewPortElement;
    parentDocument = element.ownerDocument;
    if (!position) {
        position = calculatePosition(element, 'left', 'top');
    }
    if (axis.X) {
        var containerWidth = targetContainer ? getTargetContainerWidth() : getViewPortWidth();
        var containerLeft = ContainerLeft();
        var containerRight = ContainerRight();
        var overLeft = containerLeft - position.left;
        var overRight = position.left + elemData.width - containerRight;
        if (elemData.width > containerWidth) {
            if (overLeft > 0 && overRight <= 0) {
                position.left = containerRight - elemData.width;
            }
            else if (overRight > 0 && overLeft <= 0) {
                position.left = containerLeft;
            }
            else {
                position.left = overLeft > overRight ? (containerRight - elemData.width) : containerLeft;
            }
        }
        else if (overLeft > 0) {
            position.left += overLeft;
        }
        else if (overRight > 0) {
            position.left -= overRight;
        }
    }
    if (axis.Y) {
        var containerHeight = targetContainer ? getTargetContainerHeight() : getViewPortHeight();
        var containerTop = ContainerTop();
        var containerBottom = ContainerBottom();
        var overTop = containerTop - position.top;
        var overBottom = position.top + elemData.height - containerBottom;
        if (elemData.height > containerHeight) {
            if (overTop > 0 && overBottom <= 0) {
                position.top = containerBottom - elemData.height;
            }
            else if (overBottom > 0 && overTop <= 0) {
                position.top = containerTop;
            }
            else {
                position.top = overTop > overBottom ? (containerBottom - elemData.height) : containerTop;
            }
        }
        else if (overTop > 0) {
            position.top += overTop;
        }
        else if (overBottom > 0) {
            position.top -= overBottom;
        }
    }
    return position;
}
/**
 *
 * @param {HTMLElement} element - specifies the html element
 * @param {HTMLElement} viewPortElement - specifies the html element
 * @param {number} x - specifies the number
 * @param {number} y - specifies the number
 * @returns {string[]} - returns the string value
 */
function isCollide(element, viewPortElement, x, y) {
    if (viewPortElement === void 0) { viewPortElement = null; }
    var elemOffset = calculatePosition(element, 'left', 'top');
    if (x) {
        elemOffset.left = x;
    }
    if (y) {
        elemOffset.top = y;
    }
    var data = [];
    targetContainer = viewPortElement;
    parentDocument = element.ownerDocument;
    var elementRect = element.getBoundingClientRect();
    var top = elemOffset.top;
    var left = elemOffset.left;
    var right = elemOffset.left + elementRect.width;
    var bottom = elemOffset.top + elementRect.height;
    // eslint-disable-next-line
    var yAxis = topCollideCheck(top, bottom);
    var xAxis = leftCollideCheck(left, right);
    if (yAxis.topSide) {
        data.push('top');
    }
    if (xAxis.rightSide) {
        data.push('right');
    }
    if (xAxis.leftSide) {
        data.push('left');
    }
    if (yAxis.bottomSide) {
        data.push('bottom');
    }
    return data;
}
/**
 *
 * @param {HTMLElement} element - specifies the element
 * @param {HTMLElement} target - specifies the element
 * @param {number} offsetX - specifies the number
 * @param {number} offsetY - specifies the number
 * @param {string} positionX - specifies the string value
 * @param {string} positionY - specifies the string value
 * @param {HTMLElement} viewPortElement - specifies the element
 * @param {CollisionCoordinates} axis - specifies the collision axis
 * @param {boolean} fixedParent - specifies the boolean
 * @returns {void}
 */
function flip(element, target, offsetX, offsetY, positionX, positionY, viewPortElement, 
/* eslint-disable */
axis, fixedParent) {
    if (viewPortElement === void 0) { viewPortElement = null; }
    if (axis === void 0) { axis = { X: true, Y: true }; }
    if (!target || !element || !positionX || !positionY || (!axis.X && !axis.Y)) {
        return;
    }
    // eslint-disable-next-line
    var tEdge = { TL: null,
        TR: null,
        BL: null,
        BR: null
    }, eEdge = {
        TL: null,
        TR: null,
        BL: null,
        BR: null
        /* eslint-enable */
    };
    var elementRect;
    if (window.getComputedStyle(element).display === 'none') {
        var oldVisibility = element.style.visibility;
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        elementRect = element.getBoundingClientRect();
        element.style.removeProperty('display');
        element.style.visibility = oldVisibility;
    }
    else {
        elementRect = element.getBoundingClientRect();
    }
    var pos = {
        posX: positionX, posY: positionY, offsetX: offsetX, offsetY: offsetY, position: { left: 0, top: 0 }
    };
    targetContainer = viewPortElement;
    parentDocument = target.ownerDocument;
    updateElementData(target, tEdge, pos, fixedParent, elementRect);
    setPosition(eEdge, pos, elementRect);
    if (axis.X) {
        leftFlip(target, eEdge, tEdge, pos, elementRect, true);
    }
    if (axis.Y && tEdge.TL.top > -1) {
        topFlip(target, eEdge, tEdge, pos, elementRect, true);
    }
    setPopup(element, pos, elementRect);
}
/**
 *
 * @param {HTMLElement} element - specifies the element
 * @param {PositionLocation} pos - specifies the location
 * @param {ClientRect} elementRect - specifies the client rect
 * @returns {void}
 */
function setPopup(element, pos, elementRect) {
    //eslint-disable-next-line
    var left = 0, top = 0;
    if (element.offsetParent != null
        && (getComputedStyle(element.offsetParent).position === 'absolute' ||
            getComputedStyle(element.offsetParent).position === 'relative')) {
        var data = calculatePosition(element.offsetParent, 'left', 'top', false, elementRect);
        left = data.left;
        top = data.top;
    }
    element.style.top = (pos.position.top + pos.offsetY - (top)) + 'px';
    element.style.left = (pos.position.left + pos.offsetX - (left)) + 'px';
}
/**
 *
 * @param {HTMLElement} target - specifies the element
 * @param {EdgeOffset} edge - specifies the offset
 * @param {PositionLocation} pos - specifies theloaction
 * @param {boolean} fixedParent - specifies the boolean
 * @param {ClientRect} elementRect - specifies the client rect
 * @returns {void}
 */
function updateElementData(target, edge, pos, fixedParent, elementRect) {
    pos.position = calculatePosition(target, pos.posX, pos.posY, fixedParent, elementRect);
    edge.TL = calculatePosition(target, 'left', 'top', fixedParent, elementRect);
    edge.TR = calculatePosition(target, 'right', 'top', fixedParent, elementRect);
    edge.BR = calculatePosition(target, 'left', 'bottom', fixedParent, elementRect);
    edge.BL = calculatePosition(target, 'right', 'bottom', fixedParent, elementRect);
}
/**
 *
 * @param {EdgeOffset} eStatus - specifies the status
 * @param {PositionLocation} pos - specifies the location
 * @param {ClientRect} elementRect - specifies the client
 * @returns {void}
 */
function setPosition(eStatus, pos, elementRect) {
    eStatus.TL = { top: pos.position.top + pos.offsetY, left: pos.position.left + pos.offsetX };
    eStatus.TR = { top: eStatus.TL.top, left: eStatus.TL.left + elementRect.width };
    eStatus.BL = { top: eStatus.TL.top + elementRect.height,
        left: eStatus.TL.left };
    eStatus.BR = { top: eStatus.TL.top + elementRect.height,
        left: eStatus.TL.left + elementRect.width };
}
/**
 *
 * @param {number} left - specifies the  number
 * @param {number} right - specifies the number
 * @returns {LeftCorners} - returns the value
 */
function leftCollideCheck(left, right) {
    //eslint-disable-next-line
    var leftSide = false, rightSide = false;
    if (((left - getBodyScrollLeft()) < ContainerLeft())) {
        leftSide = true;
    }
    if (right > ContainerRight()) {
        rightSide = true;
    }
    return { leftSide: leftSide, rightSide: rightSide };
}
/**
 *
 * @param {HTMLElement} target - specifies the element
 * @param {EdgeOffset} edge - specifes the element
 * @param {EdgeOffset} tEdge - specifies the edge offset
 * @param {PositionLocation} pos - specifes the location
 * @param {ClientRect} elementRect - specifies the client
 * @param {boolean} deepCheck - specifies the boolean value
 * @returns {void}
 */
function leftFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
    var collideSide = leftCollideCheck(edge.TL.left, edge.TR.left);
    if ((tEdge.TL.left - getBodyScrollLeft()) <= ContainerLeft()) {
        collideSide.leftSide = false;
    }
    if (tEdge.TR.left > ContainerRight()) {
        collideSide.rightSide = false;
    }
    if ((collideSide.leftSide && !collideSide.rightSide) || (!collideSide.leftSide && collideSide.rightSide)) {
        if (pos.posX === 'right') {
            pos.posX = 'left';
        }
        else {
            pos.posX = 'right';
        }
        pos.offsetX = pos.offsetX + elementRect.width;
        pos.offsetX = -1 * pos.offsetX;
        pos.position = calculatePosition(target, pos.posX, pos.posY, false);
        setPosition(edge, pos, elementRect);
        if (deepCheck) {
            leftFlip(target, edge, tEdge, pos, elementRect, false);
        }
    }
}
/**
 *
 * @param {HTMLElement} target - specifies the element
 * @param {EdgeOffset} edge - specifies the offset
 * @param {EdgeOffset} tEdge - specifies the offset
 * @param {PositionLocation} pos - specifies the location
 * @param {ClientRect} elementRect - specifies the client rect
 * @param {boolean} deepCheck - specifies the boolean
 * @returns {void}
 */
function topFlip(target, edge, tEdge, pos, elementRect, deepCheck) {
    var collideSide = topCollideCheck(edge.TL.top, edge.BL.top);
    if ((tEdge.TL.top - getBodyScrollTop()) <= ContainerTop()) {
        collideSide.topSide = false;
    }
    if (tEdge.BL.top >= ContainerBottom() && target.getBoundingClientRect().bottom < window.innerHeight) {
        collideSide.bottomSide = false;
    }
    if ((collideSide.topSide && !collideSide.bottomSide) || (!collideSide.topSide && collideSide.bottomSide)) {
        if (pos.posY === 'top') {
            pos.posY = 'bottom';
        }
        else {
            pos.posY = 'top';
        }
        pos.offsetY = pos.offsetY + elementRect.height;
        pos.offsetY = -1 * pos.offsetY;
        pos.position = calculatePosition(target, pos.posX, pos.posY, false, elementRect);
        setPosition(edge, pos, elementRect);
        if (deepCheck) {
            topFlip(target, edge, tEdge, pos, elementRect, false);
        }
    }
}
/**
 *
 * @param {number} top - specifies the number
 * @param {number} bottom - specifies the number
 * @returns {TopCorners} - retyrns the value
 */
function topCollideCheck(top, bottom) {
    //eslint-disable-next-line
    var topSide = false, bottomSide = false;
    if ((top - getBodyScrollTop()) < ContainerTop()) {
        topSide = true;
    }
    if (bottom > ContainerBottom()) {
        bottomSide = true;
    }
    return { topSide: topSide, bottomSide: bottomSide };
}
/**
 * @returns {void}
 */
function getTargetContainerWidth() {
    return targetContainer.getBoundingClientRect().width;
}
/**
 * @returns {void}
 */
function getTargetContainerHeight() {
    return targetContainer.getBoundingClientRect().height;
}
/**
 * @returns {void}
 */
function getTargetContainerLeft() {
    return targetContainer.getBoundingClientRect().left;
}
/**
 * @returns {void}
 */
function getTargetContainerTop() {
    return targetContainer.getBoundingClientRect().top;
}
//eslint-disable-next-line
function ContainerTop() {
    if (targetContainer) {
        return getTargetContainerTop();
    }
    return 0;
}
//eslint-disable-next-line
function ContainerLeft() {
    if (targetContainer) {
        return getTargetContainerLeft();
    }
    return 0;
}
//eslint-disable-next-line
function ContainerRight() {
    if (targetContainer) {
        return (getBodyScrollLeft() + getTargetContainerLeft() + getTargetContainerWidth());
    }
    return (getBodyScrollLeft() + getViewPortWidth());
}
//eslint-disable-next-line
function ContainerBottom() {
    if (targetContainer) {
        return (getBodyScrollTop() + getTargetContainerTop() + getTargetContainerHeight());
    }
    return (getBodyScrollTop() + getViewPortHeight());
}
/**
 * @returns {void}
 */
function getBodyScrollTop() {
    // if(targetContainer)
    //     return targetContainer.scrollTop;
    return parentDocument.documentElement.scrollTop || parentDocument.body.scrollTop;
}
/**
 * @returns {void}
 */
function getBodyScrollLeft() {
    // if(targetContainer)
    //     return targetContainer.scrollLeft;
    return parentDocument.documentElement.scrollLeft || parentDocument.body.scrollLeft;
}
/**
 * @returns {void}
 */
function getViewPortHeight() {
    return window.innerHeight;
}
/**
 * @returns {void}
 */
function getViewPortWidth() {
    var windowWidth = window.innerWidth;
    var documentReact = document.documentElement.getBoundingClientRect();
    var offsetWidth = (sf.base.isNullOrUndefined(document.documentElement)) ? 0 : documentReact.width;
    return windowWidth - (windowWidth - offsetWidth);
}

/**
 * Resize library
 */
/* eslint-disable */
var elementClass = ['north-west', 'north', 'north-east', 'west', 'east', 'south-west', 'south', 'south-east'];
var RESIZE_HANDLER = 'e-resize-handle';
var FOCUSED_HANDLER = 'e-focused-handle';
var RESTRICT_LEFT = ['e-restrict-left'];
var RESIZE_WITHIN_VIEWPORT = 'e-resize-viewport';
var dialogBorderResize = ['north', 'west', 'east', 'south'];
var targetElement;
var selectedHandler;
var originalWidth = 0;
var originalHeight = 0;
var originalX = 0;
var originalY = 0;
var originalMouseX = 0;
var originalMouseY = 0;
var minHeight;
var maxHeight;
var minWidth;
var maxWidth;
var containerElement;
/* eslint-disable */
var resizeStart = null;
var resize = null;
var resizeEnd = null;
/* eslint-enable */
var resizeWestWidth;
var setLeft = true;
var previousWidth = 0;
var setWidth = true;
// eslint-disable-next-line
var proxy;
/**
 *
 * @param {ResizeArgs} args - specifies the resize args
 * @returns {void}
 */
function createResize(args) {
    resizeStart = args.resizeBegin;
    resize = args.resizing;
    resizeEnd = args.resizeComplete;
    targetElement = getDOMElement(args.element);
    containerElement = getDOMElement(args.boundary);
    var directions = args.direction.split(' ');
    for (var i = 0; i < directions.length; i++) {
        if (dialogBorderResize.indexOf(directions[i]) >= 0 && directions[i]) {
            setBorderResizeElm(directions[i]);
        }
        else if (directions[i].trim() !== '') {
            var resizeHandler = sf.base.createElement('div', { className: 'e-icons ' + RESIZE_HANDLER + ' ' + 'e-' + directions[i] });
            targetElement.appendChild(resizeHandler);
        }
    }
    minHeight = args.minHeight;
    minWidth = args.minWidth;
    maxWidth = args.maxWidth;
    maxHeight = args.maxHeight;
    if (args.proxy && args.proxy.element && args.proxy.element.classList.contains('e-dialog')) {
        wireEvents(args.proxy);
    }
    else {
        wireEvents();
    }
}
/**
 *
 * @param {string} direction - specifies the string
 * @returns {void}
 */
function setBorderResizeElm(direction) {
    calculateValues();
    var borderBottom = sf.base.createElement('span', {
        attrs: {
            'unselectable': 'on', 'contenteditable': 'false'
        }
    });
    borderBottom.setAttribute('class', 'e-dialog-border-resize e-' + direction);
    if (direction === 'south') {
        borderBottom.style.height = '2px';
        borderBottom.style.width = '100%';
        borderBottom.style.bottom = '0px';
        borderBottom.style.left = '0px';
    }
    if (direction === 'north') {
        borderBottom.style.height = '2px';
        borderBottom.style.width = '100%';
        borderBottom.style.top = '0px';
        borderBottom.style.left = '0px';
    }
    if (direction === 'east') {
        borderBottom.style.height = '100%';
        borderBottom.style.width = '2px';
        borderBottom.style.right = '0px';
        borderBottom.style.top = '0px';
    }
    if (direction === 'west') {
        borderBottom.style.height = '100%';
        borderBottom.style.width = '2px';
        borderBottom.style.left = '0px';
        borderBottom.style.top = '0px';
    }
    targetElement.appendChild(borderBottom);
}
/**
 *
 * @param {string} element - specifies the element
 * @returns {HTMLElement} - returns the element
 */
function getDOMElement(element) {
    var domElement;
    if (!sf.base.isNullOrUndefined(element)) {
        if (typeof (element) === 'string') {
            domElement = document.querySelector(element);
        }
        else {
            domElement = element;
        }
    }
    return domElement;
}
// eslint-disable-next-line
function wireEvents(args) {
    if (sf.base.isNullOrUndefined(args)) {
        args = this;
    }
    var resizers = targetElement.querySelectorAll('.' + RESIZE_HANDLER);
    for (var i = 0; i < resizers.length; i++) {
        selectedHandler = resizers[i];
        sf.base.EventHandler.add(selectedHandler, 'mousedown', onMouseDown, args);
        var eventName = (sf.base.Browser.info.name === 'msie') ? 'pointerdown' : 'touchstart';
        sf.base.EventHandler.add(selectedHandler, eventName, onTouchStart, args);
    }
    var borderResizers = targetElement.querySelectorAll('.e-dialog-border-resize');
    if (!sf.base.isNullOrUndefined(borderResizers)) {
        for (var i = 0; i < borderResizers.length; i++) {
            selectedHandler = borderResizers[i];
            sf.base.EventHandler.add(selectedHandler, 'mousedown', onMouseDown, args);
            var eventName = (sf.base.Browser.info.name === 'msie') ? 'pointerdown' : 'touchstart';
            sf.base.EventHandler.add(selectedHandler, eventName, onTouchStart, args);
        }
    }
}
/* istanbul ignore next */
/**
 *
 * @param {string} e - specifies the string
 * @returns {string} - returns the string
 */
function getEventType(e) {
    return (e.indexOf('mouse') > -1) ? 'mouse' : 'touch';
}
/* istanbul ignore next */
/**
 *
 * @param {MouseEvent} e - specifies the mouse event
 * @returns {void}
 */
function onMouseDown(e) {
    e.preventDefault();
    targetElement = e.target.parentElement;
    calculateValues();
    originalMouseX = e.pageX;
    originalMouseY = e.pageY;
    e.target.classList.add(FOCUSED_HANDLER);
    if (!sf.base.isNullOrUndefined(resizeStart)) {
        proxy = this;
        if (resizeStart(e, proxy) === true) {
            return;
        }
    }
    var target = (sf.base.isNullOrUndefined(containerElement)) ? document : containerElement;
    sf.base.EventHandler.add(target, 'mousemove', onMouseMove, this);
    sf.base.EventHandler.add(document, 'mouseup', onMouseUp, this);
    for (var i = 0; i < RESTRICT_LEFT.length; i++) {
        if (targetElement.classList.contains(RESTRICT_LEFT[i])) {
            setLeft = false;
        }
        else {
            setLeft = true;
        }
    }
}
/* istanbul ignore next */
/**
 *
 * @param {MouseEvent} e - specifies the event
 * @returns {void}
 */
function onMouseUp(e) {
    var touchMoveEvent = (sf.base.Browser.info.name === 'msie') ? 'pointermove' : 'touchmove';
    var touchEndEvent = (sf.base.Browser.info.name === 'msie') ? 'pointerup' : 'touchend';
    var target = (sf.base.isNullOrUndefined(containerElement)) ? document : containerElement;
    var eventName = (sf.base.Browser.info.name === 'msie') ? 'pointerdown' : 'touchstart';
    sf.base.EventHandler.remove(target, 'mousemove', onMouseMove);
    sf.base.EventHandler.remove(target, touchMoveEvent, onMouseMove);
    sf.base.EventHandler.remove(target, eventName, onMouseMove);
    if (!sf.base.isNullOrUndefined(document.body.querySelector('.' + FOCUSED_HANDLER))) {
        document.body.querySelector('.' + FOCUSED_HANDLER).classList.remove(FOCUSED_HANDLER);
    }
    if (!sf.base.isNullOrUndefined(resizeEnd)) {
        proxy = this;
        resizeEnd(e, proxy);
    }
    sf.base.EventHandler.remove(document, 'mouseup', onMouseUp);
    sf.base.EventHandler.remove(document, touchEndEvent, onMouseUp);
}
/* istanbul ignore next */
/**
 * @returns {void}
 */
function calculateValues() {
    originalWidth = parseFloat(getComputedStyle(targetElement, null).getPropertyValue('width').replace('px', ''));
    originalHeight = parseFloat(getComputedStyle(targetElement, null).getPropertyValue('height').replace('px', ''));
    originalX = targetElement.getBoundingClientRect().left;
    originalY = targetElement.getBoundingClientRect().top;
}
/* istanbul ignore next */
/**
 *
 * @param {MouseEvent} e - specifies the event
 * @returns {void}
 */
function onTouchStart(e) {
    targetElement = e.target.parentElement;
    calculateValues();
    var coordinates = e.touches ? e.changedTouches[0] : e;
    originalMouseX = coordinates.pageX;
    originalMouseY = coordinates.pageY;
    if (!sf.base.isNullOrUndefined(resizeStart)) {
        proxy = this;
        if (resizeStart(e, proxy) === true) {
            return;
        }
    }
    var touchMoveEvent = (sf.base.Browser.info.name === 'msie') ? 'pointermove' : 'touchmove';
    var touchEndEvent = (sf.base.Browser.info.name === 'msie') ? 'pointerup' : 'touchend';
    var target = (sf.base.isNullOrUndefined(containerElement)) ? document : containerElement;
    sf.base.EventHandler.add(target, touchMoveEvent, onMouseMove, this);
    sf.base.EventHandler.add(document, touchEndEvent, onMouseUp);
}
/* istanbul ignore next */
/**
 *
 * @param {MouseEvent} e - specifies the event
 * @returns {void}
 */
function onMouseMove(e) {
    if (e.target.classList.contains(RESIZE_HANDLER) && e.target.classList.contains(FOCUSED_HANDLER)) {
        selectedHandler = e.target;
    }
    else if (!sf.base.isNullOrUndefined(document.body.querySelector('.' + FOCUSED_HANDLER))) {
        selectedHandler = document.body.querySelector('.' + FOCUSED_HANDLER);
    }
    if (!sf.base.isNullOrUndefined(selectedHandler)) {
        var resizeTowards = '';
        for (var i = 0; i < elementClass.length; i++) {
            if (selectedHandler.classList.contains('e-' + elementClass[i])) {
                resizeTowards = elementClass[i];
            }
        }
        if (!sf.base.isNullOrUndefined(resize)) {
            proxy = this;
            resize(e, proxy);
        }
        switch (resizeTowards) {
            case 'south':
                resizeSouth(e);
                break;
            case 'north':
                resizeNorth(e);
                break;
            case 'west':
                resizeWest(e);
                break;
            case 'east':
                resizeEast(e);
                break;
            case 'south-east':
                resizeSouth(e);
                resizeEast(e);
                break;
            case 'south-west':
                resizeSouth(e);
                resizeWest(e);
                break;
            case 'north-east':
                resizeNorth(e);
                resizeEast(e);
                break;
            case 'north-west':
                resizeNorth(e);
                resizeWest(e);
                break;
            default: break;
        }
    }
}
/* istanbul ignore next */
/**
 *
 * @param {HTMLElement} element - specifies the eleemnt
 * @returns {ClientRect} - returns the client
 */
function getClientRectValues(element) {
    return element.getBoundingClientRect();
}
/* istanbul ignore next */
// eslint-disable-next-line
function resizeSouth(e) {
    var documentHeight = document.documentElement.clientHeight;
    var calculateValue = false;
    var coordinates = e.touches ? e.changedTouches[0] : e;
    var currentpageY = coordinates.pageY;
    var targetRectValues = getClientRectValues(targetElement);
    var containerRectValues;
    if (!sf.base.isNullOrUndefined(containerElement)) {
        containerRectValues = getClientRectValues(containerElement);
    }
    if (!sf.base.isNullOrUndefined(containerElement)) {
        calculateValue = true;
    }
    else if (sf.base.isNullOrUndefined(containerElement) && ((documentHeight - currentpageY) >= 0 || (targetRectValues.top < 0))) {
        calculateValue = true;
    }
    var calculatedHeight = originalHeight + (currentpageY - originalMouseY);
    calculatedHeight = (calculatedHeight > minHeight) ? calculatedHeight : minHeight;
    var containerTop = 0;
    if (!sf.base.isNullOrUndefined(containerElement)) {
        containerTop = containerRectValues.top;
    }
    var borderValue = sf.base.isNullOrUndefined(containerElement) ? 0 : containerElement.offsetHeight - containerElement.clientHeight;
    var topWithoutborder = (targetRectValues.top - containerTop) - (borderValue / 2);
    topWithoutborder = (topWithoutborder < 0) ? 0 : topWithoutborder;
    if (targetRectValues.top > 0 && (topWithoutborder + calculatedHeight) > maxHeight) {
        calculateValue = false;
        if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
            return;
        }
        targetElement.style.height = (maxHeight - parseInt(topWithoutborder.toString(), 10)) + 'px';
        return;
    }
    var targetTop = 0;
    if (calculateValue) {
        if (targetRectValues.top < 0 && (documentHeight + (targetRectValues.height + targetRectValues.top) > 0)) {
            targetTop = targetRectValues.top;
            if ((calculatedHeight + targetTop) <= 30) {
                calculatedHeight = (targetRectValues.height - (targetRectValues.height + targetRectValues.top)) + 30;
            }
        }
        if (((calculatedHeight + targetRectValues.top) >= maxHeight)) {
            targetElement.style.height = targetRectValues.height +
                (documentHeight - (targetRectValues.height + targetRectValues.top)) + 'px';
        }
        var calculatedTop = (sf.base.isNullOrUndefined(containerElement)) ? targetTop : topWithoutborder;
        if (calculatedHeight >= minHeight && ((calculatedHeight + calculatedTop) <= maxHeight)) {
            targetElement.style.height = calculatedHeight + 'px';
        }
    }
}
/* istanbul ignore next */
// eslint-disable-next-line
function resizeNorth(e) {
    var calculateValue = false;
    var boundaryRectValues;
    var pageY = (getEventType(e.type) === 'mouse') ? e.pageY : e.touches[0].pageY;
    var targetRectValues = getClientRectValues(targetElement);
    if (!sf.base.isNullOrUndefined(containerElement)) {
        boundaryRectValues = getClientRectValues(containerElement);
    }
    if (!sf.base.isNullOrUndefined(containerElement) && (targetRectValues.top - boundaryRectValues.top) > 0) {
        calculateValue = true;
    }
    else if (sf.base.isNullOrUndefined(containerElement) && pageY > 0) {
        calculateValue = true;
    }
    var currentHeight = originalHeight - (pageY - originalMouseY);
    if (calculateValue) {
        if (currentHeight >= minHeight && currentHeight <= maxHeight) {
            var containerTop = 0;
            if (!sf.base.isNullOrUndefined(containerElement)) {
                containerTop = boundaryRectValues.top;
            }
            var top_1 = (originalY - containerTop) + (pageY - originalMouseY);
            top_1 = top_1 > 0 ? top_1 : 1;
            targetElement.style.height = currentHeight + 'px';
            targetElement.style.top = top_1 + 'px';
        }
    }
}
/* istanbul ignore next */
// eslint-disable-next-line
function resizeWest(e) {
    var documentWidth = document.documentElement.clientWidth;
    var calculateValue = false;
    var rectValues;
    if (!sf.base.isNullOrUndefined(containerElement)) {
        rectValues = getClientRectValues(containerElement);
    }
    var pageX = (getEventType(e.type) === 'mouse') ? e.pageX : e.touches[0].pageX;
    var targetRectValues = getClientRectValues(targetElement);
    var borderValue = sf.base.isNullOrUndefined(containerElement) ? 0 : containerElement.offsetWidth - containerElement.clientWidth;
    /* eslint-disable */
    var left = sf.base.isNullOrUndefined(containerElement) ? 0 : rectValues.left;
    var containerWidth = sf.base.isNullOrUndefined(containerElement) ? 0 : rectValues.width;
    /* eslint-enable */
    if (sf.base.isNullOrUndefined(resizeWestWidth)) {
        if (!sf.base.isNullOrUndefined(containerElement)) {
            resizeWestWidth = (((targetRectValues.left - left) - borderValue / 2)) + targetRectValues.width;
            resizeWestWidth = resizeWestWidth + (containerWidth - borderValue - resizeWestWidth);
        }
        else {
            resizeWestWidth = documentWidth;
        }
    }
    if (!sf.base.isNullOrUndefined(containerElement) &&
        (Math.floor((targetRectValues.left - rectValues.left) + targetRectValues.width +
            (rectValues.right - targetRectValues.right)) - borderValue) <= maxWidth) {
        calculateValue = true;
    }
    else if (sf.base.isNullOrUndefined(containerElement) && pageX >= 0) {
        calculateValue = true;
    }
    var calculatedWidth = originalWidth - (pageX - originalMouseX);
    if (setLeft) {
        calculatedWidth = (calculatedWidth > resizeWestWidth) ? resizeWestWidth : calculatedWidth;
    }
    if (calculateValue) {
        if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
            var containerLeft = 0;
            if (!sf.base.isNullOrUndefined(containerElement)) {
                containerLeft = rectValues.left;
            }
            var left_1 = (originalX - containerLeft) + (pageX - originalMouseX);
            left_1 = (left_1 > 0) ? left_1 : 1;
            if (calculatedWidth !== previousWidth && setWidth) {
                targetElement.style.width = calculatedWidth + 'px';
            }
            if (setLeft) {
                targetElement.style.left = left_1 + 'px';
                if (left_1 === 1) {
                    setWidth = false;
                }
                else {
                    setWidth = true;
                }
            }
        }
    }
    previousWidth = calculatedWidth;
}
/* istanbul ignore next */
// eslint-disable-next-line
function resizeEast(e) {
    var documentWidth = document.documentElement.clientWidth;
    var calculateValue = false;
    var containerRectValues;
    if (!sf.base.isNullOrUndefined(containerElement)) {
        containerRectValues = getClientRectValues(containerElement);
    }
    var coordinates = e.touches ? e.changedTouches[0] : e;
    var pageX = coordinates.pageX;
    var targetRectValues = getClientRectValues(targetElement);
    if (!sf.base.isNullOrUndefined(containerElement) && (((targetRectValues.left - containerRectValues.left) + targetRectValues.width) <= maxWidth
        || (targetRectValues.right - containerRectValues.left) >= targetRectValues.width)) {
        calculateValue = true;
    }
    else if (sf.base.isNullOrUndefined(containerElement) && (documentWidth - pageX) > 0) {
        calculateValue = true;
    }
    var calculatedWidth = originalWidth + (pageX - originalMouseX);
    var containerLeft = 0;
    if (!sf.base.isNullOrUndefined(containerElement)) {
        containerLeft = containerRectValues.left;
    }
    if (((targetRectValues.left - containerLeft) + calculatedWidth) > maxWidth) {
        calculateValue = false;
        if (targetElement.classList.contains(RESIZE_WITHIN_VIEWPORT)) {
            return;
        }
        targetElement.style.width = maxWidth - (targetRectValues.left - containerLeft) + 'px';
    }
    if (calculateValue) {
        if (calculatedWidth >= minWidth && calculatedWidth <= maxWidth) {
            targetElement.style.width = calculatedWidth + 'px';
        }
    }
}
/* istanbul ignore next */
/**
 *
 * @param {number} minimumHeight - specifies the number
 * @returns {void}
 */
function setMinHeight(minimumHeight) {
    minHeight = minimumHeight;
}
/**
 *
 * @param {number} value - specifies the number value
 * @returns {void}
 */
function setMaxWidth(value) {
    maxWidth = value;
}
/**
 *
 * @param {number} value - specifies the number value
 * @returns {void}
 */
function setMaxHeight(value) {
    maxHeight = value;
}
/**
 * @returns {void}
 */
function removeResize() {
    var handlers = targetElement.querySelectorAll('.' + RESIZE_HANDLER);
    for (var i = 0; i < handlers.length; i++) {
        sf.base.detach(handlers[i]);
    }
    var borderResizers = targetElement.querySelectorAll('.e-dialog-border-resize');
    if (!sf.base.isNullOrUndefined(borderResizers)) {
        for (var i = 0; i < borderResizers.length; i++) {
            sf.base.detach(borderResizers[i]);
        }
    }
}

exports.fit = fit;
exports.isCollide = isCollide;
exports.flip = flip;
exports.calculateRelativeBasedPosition = calculateRelativeBasedPosition;
exports.calculatePosition = calculatePosition;
exports.createResize = createResize;
exports.setMinHeight = setMinHeight;
exports.setMaxWidth = setMaxWidth;
exports.setMaxHeight = setMaxHeight;
exports.removeResize = removeResize;

return exports;

});
window.sf.popups = window.sf.base.extend({}, window.sf.popups, popupsbase({}));


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-accordion.js":
/*!***************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-accordion.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Accordion = (function () {
'use strict';

var CLS_ACRDN_ROOT = 'e-acrdn-root';
var CLS_ROOT = 'e-accordion';
var CLS_ITEM = 'e-acrdn-item';
var CLS_ITEMFOCUS = 'e-item-focus';
var CLS_HEADER = 'e-acrdn-header';
var CLS_CONTENT = 'e-acrdn-panel';
var CLS_TOOGLEICN = 'e-toggle-icon';
var CLS_EXPANDICN = 'e-expand-icon';
var CLS_CTNHIDE = 'e-content-hide';
var CLS_SLCT = 'e-select';
var CLS_SLCTED = 'e-selected';
var CLS_ACTIVE = 'e-active';
var CLS_ANIMATE = 'e-animate';
var CLS_DISABLE = 'e-overlay';
var CLS_TOGANIMATE = 'e-toggle-animation';
var CLS_NEST = 'e-nested';
var CLS_EXPANDSTATE = 'e-expand-state';
var CLS_SCOPE = 'scope';
var CLS_RTL = 'e-rtl';
var SfAccordion = /** @class */ (function () {
    function SfAccordion(element, options, dotnetRef) {
        this.keyConfigs = {
            moveUp: 'uparrow',
            moveDown: 'downarrow',
            enter: 'enter',
            space: 'space',
            home: 'home',
            end: 'end'
        };
        this.element = element;
        // eslint-disable-next-line camelcase
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
        this.options = options;
    }
    SfAccordion.prototype.destroy = function () {
        var ele = this.element;
        this.unwireEvents();
        this.isDestroy = true;
        ele.classList.remove(CLS_ACRDN_ROOT);
        if (!this.isNested && sf.base.isRippleEnabled) {
            this.removeRippleEffect();
        }
    };
    SfAccordion.prototype.render = function () {
        var nested = sf.base.closest(this.element, '.' + CLS_CONTENT);
        this.isNested = false;
        if (!this.isDestroy) {
            this.isDestroy = false;
        }
        if (!sf.base.isNullOrUndefined(nested)) {
            nested.classList.add(CLS_NEST);
            this.isNested = true;
        }
        else {
            this.element.classList.add(CLS_ACRDN_ROOT);
        }
        this.wireFocusEvents();
        this.wireEvents();
    };
    SfAccordion.prototype.wireFocusEvents = function () {
        var acrdItem = [].slice.call(this.element.querySelectorAll('.' + CLS_ITEM));
        for (var _i = 0, acrdItem_1 = acrdItem; _i < acrdItem_1.length; _i++) {
            var item = acrdItem_1[_i];
            var headerEle = item.querySelector('.' + CLS_HEADER);
            if (item.childElementCount > 0 && headerEle) {
                sf.base.EventHandler.clearEvents(headerEle);
                sf.base.EventHandler.add(headerEle, 'focus', this.focusIn, this);
                sf.base.EventHandler.add(headerEle, 'blur', this.focusOut, this);
            }
        }
    };
    SfAccordion.prototype.unwireEvents = function () {
        if (!sf.base.isNullOrUndefined(this.keyModule)) {
            this.keyModule.destroy();
        }
    };
    SfAccordion.prototype.wireEvents = function () {
        if (!this.isNested && !this.isDestroy) {
            this.removeRippleEffect = sf.base.rippleEffect(this.element, { selector: '.' + CLS_HEADER });
        }
        if (!this.isNested) {
            this.keyModule = new sf.base.KeyboardEvents(this.element, {
                keyAction: this.keyActionHandler.bind(this),
                keyConfigs: this.keyConfigs,
                eventName: 'keydown'
            });
        }
    };
    SfAccordion.prototype.focusIn = function (e) {
        e.target.parentElement.classList.add(CLS_ITEMFOCUS);
    };
    SfAccordion.prototype.focusOut = function (e) {
        e.target.parentElement.classList.remove(CLS_ITEMFOCUS);
    };
    /**
     * To perform expand and collapse action while clicking the item
     *
     * @param {HTEle} targetEle Accepts the DOM element
     * @returns {void}
     */
    SfAccordion.prototype.afterContentRender = function (targetEle) {
        var _this = this;
        var acrdActive = [];
        var acrdnItem = targetEle;
        var acrdnHdr = acrdnItem.children[0];
        var acrdnCtn = acrdnItem.children[1];
        var acrdnCtnItem;
        if (acrdnHdr) {
            acrdnCtnItem = sf.base.closest(acrdnHdr, '.' + CLS_ITEM);
        }
        else if (acrdnCtn) {
            acrdnCtnItem = sf.base.closest(acrdnCtn, '.' + CLS_ITEM);
        }
        var acrdnchild = this.element.children;
        [].slice.call(acrdnchild).forEach(function (el) {
            if (el.classList.contains(CLS_ACTIVE)) {
                acrdActive.push(el);
            }
        });
        var acrdAniEle = [].slice.call(this.element.querySelectorAll('.' + CLS_ITEM + ' [' + CLS_ANIMATE + ']'));
        if (acrdAniEle.length > 0) {
            for (var _i = 0, acrdAniEle_1 = acrdAniEle; _i < acrdAniEle_1.length; _i++) {
                var el = acrdAniEle_1[_i];
                acrdActive.push(el.parentElement);
            }
        }
        var sameContentCheck = acrdActive.indexOf(acrdnCtnItem) !== -1 && acrdnCtn.getAttribute('e-animate') === 'true';
        var sameHeader = false;
        if (!sf.base.isNullOrUndefined(acrdnItem) && !sf.base.isNullOrUndefined(acrdnHdr)) {
            var acrdnCtn_1 = sf.base.select('.' + CLS_CONTENT, acrdnItem);
            var acrdnRoot = sf.base.closest(acrdnItem, '.' + CLS_ACRDN_ROOT);
            var expandState = acrdnRoot.querySelector('.' + CLS_EXPANDSTATE);
            if (sf.base.isNullOrUndefined(acrdnCtn_1)) {
                return;
            }
            sameHeader = (expandState === acrdnItem);
            if (sf.base.isVisible(acrdnCtn_1) && (!sameContentCheck || acrdnCtnItem.classList.contains(CLS_SLCTED))) {
                this.collapse(acrdnCtn_1);
            }
            else {
                if ((acrdActive.length > 0) && this.options.expandMode === 'Single' && !sameContentCheck) {
                    acrdActive.forEach(function (el) {
                        _this.collapse(sf.base.select('.' + CLS_CONTENT, el));
                        el.classList.remove(CLS_EXPANDSTATE);
                    });
                }
                this.expand(acrdnCtn_1);
            }
            if (!sf.base.isNullOrUndefined(expandState) && !sameHeader) {
                expandState.classList.remove(CLS_EXPANDSTATE);
            }
        }
    };
    SfAccordion.prototype.eleMoveFocus = function (action, root, trgt) {
        var clst;
        var clstItem = sf.base.closest(trgt, '.' + CLS_ITEM);
        if (trgt === root) {
            clst = ((action === 'moveUp' ? trgt.lastElementChild : trgt).querySelector('.' + CLS_HEADER));
        }
        else if (trgt.classList.contains(CLS_HEADER)) {
            clstItem = (action === 'moveUp' ? clstItem.previousElementSibling : clstItem.nextElementSibling);
            if (clstItem) {
                clst = sf.base.select('.' + CLS_HEADER, clstItem);
            }
        }
        if (clst) {
            clst.focus();
        }
    };
    SfAccordion.prototype.keyActionHandler = function (e) {
        var trgt = e.target;
        var header = sf.base.closest(e.target, CLS_HEADER);
        if (sf.base.isNullOrUndefined(header) && !trgt.classList.contains(CLS_ROOT) && !trgt.classList.contains(CLS_HEADER)) {
            return;
        }
        var clst;
        var root = this.element;
        var content;
        switch (e.action) {
            case 'moveUp':
            case 'moveDown':
                this.eleMoveFocus(e.action, root, trgt);
                break;
            case 'space':
            case 'enter':
                content = trgt.nextElementSibling;
                if (!sf.base.isNullOrUndefined(content) && content.classList.contains(CLS_CONTENT)) {
                    if (content.getAttribute('e-animate') !== 'true') {
                        trgt.click();
                    }
                }
                else {
                    trgt.click();
                }
                break;
            case 'home':
            case 'end':
                clst = e.action === 'home' ? root.firstElementChild.children[0] : root.lastElementChild.children[0];
                clst.focus();
                break;
        }
    };
    SfAccordion.prototype.expand = function (trgt) {
        var trgtItemEle = sf.base.closest(trgt, '.' + CLS_ITEM);
        if (sf.base.isNullOrUndefined(trgt) || (sf.base.isVisible(trgt) && trgt.getAttribute('e-animate') !== 'true') || trgtItemEle.classList.contains(CLS_DISABLE)) {
            return;
        }
        this.dotNetRef.invokeMethodAsync('TriggerExpandingEvent', this.getIndexByItem(trgtItemEle));
    };
    SfAccordion.prototype.expandAnimation = function (ef, icn, trgt, trgtItemEle, animate, args) {
        var _this = this;
        var height;
        this.lastActiveItemId = trgtItemEle.id;
        if (ef === 'SlideDown') {
            animate.begin = function () {
                _this.expandProgress('begin', icn, trgt, trgtItemEle, args);
                trgt.style.position = 'absolute';
                height = trgtItemEle.offsetHeight;
                trgt.style.maxHeight = (trgt.offsetHeight) + 'px';
                trgtItemEle.style.maxHeight = '';
            };
            animate.progress = function () {
                trgtItemEle.style.minHeight = (height + trgt.offsetHeight) + 'px';
            };
            animate.end = function () {
                sf.base.setStyleAttribute(trgt, { 'position': '', 'maxHeight': '' });
                trgtItemEle.style.minHeight = '';
                _this.expandProgress('end', icn, trgt, trgtItemEle, args);
            };
        }
        else {
            animate.begin = function () {
                _this.expandProgress('begin', icn, trgt, trgtItemEle, args);
            };
            animate.end = function () {
                _this.expandProgress('end', icn, trgt, trgtItemEle, args);
            };
        }
        new sf.base.Animation(animate).animate(trgt);
    };
    SfAccordion.prototype.expandProgress = function (progress, icon, trgt, trgtItemEle, eventArgs) {
        sf.base.removeClass([trgt], CLS_CTNHIDE);
        sf.base.addClass([trgtItemEle], CLS_SLCTED);
        sf.base.addClass([icon], CLS_EXPANDICN);
        if (progress === 'end') {
            sf.base.addClass([trgtItemEle], CLS_ACTIVE);
            trgt.setAttribute('aria-hidden', 'false');
            sf.base.attributes(trgtItemEle, { 'aria-expanded': 'true' });
            sf.base.attributes(trgt.previousElementSibling, { 'aria-selected': 'true' });
            icon.classList.remove(CLS_TOGANIMATE);
            this.dotNetRef.invokeMethodAsync('TriggerExpandedEvent', eventArgs);
            this.setPersistence('accordion' + this.element.id);
        }
    };
    SfAccordion.prototype.expandedItemsPush = function (item) {
        var index = this.getIndexByItem(item);
        if (this.options.expandedIndices.indexOf(index) === -1) {
            var temp = [].slice.call(this.options.expandedIndices);
            temp.push(index);
            this.options.expandedIndices = temp;
        }
    };
    SfAccordion.prototype.getIndexByItem = function (item) {
        var itemEle = this.getItemElements();
        return [].slice.call(itemEle).indexOf(item);
    };
    SfAccordion.prototype.getItemElements = function () {
        var itemEle = [];
        var itemCollection = this.element.children;
        [].slice.call(itemCollection).forEach(function (el) {
            if (el.classList.contains(CLS_ITEM)) {
                itemEle.push(el);
            }
        });
        return itemEle;
    };
    SfAccordion.prototype.expandedItemsPop = function (item) {
        var index = this.getIndexByItem(item);
        var temp = [].slice.call(this.options.expandedIndices);
        temp.splice(temp.indexOf(index), 1);
        this.options.expandedIndices = temp;
    };
    SfAccordion.prototype.collapse = function (trgt) {
        var trgtItemEle = sf.base.closest(trgt, '.' + CLS_ITEM);
        if (sf.base.isNullOrUndefined(trgt) || !sf.base.isVisible(trgt) || trgtItemEle.classList.contains(CLS_DISABLE)) {
            return;
        }
        this.dotNetRef.invokeMethodAsync('TriggerCollapsingEvent', this.getIndexByItem(trgtItemEle));
    };
    SfAccordion.prototype.collapseAnimation = function (ef, trgt, trgtItEl, icn, animate, args) {
        var _this = this;
        var height;
        var trgtHeight;
        var itemHeight;
        var remain;
        this.lastActiveItemId = trgtItEl.id;
        if (ef === 'SlideUp') {
            animate.begin = function () {
                itemHeight = trgtItEl.offsetHeight;
                trgtItEl.style.minHeight = itemHeight + 'px';
                trgt.style.position = 'absolute';
                height = trgtItEl.offsetHeight;
                trgtHeight = trgt.offsetHeight;
                trgt.style.maxHeight = trgtHeight + 'px';
                _this.collapseProgress('begin', icn, trgt, trgtItEl, args);
            };
            animate.progress = function () {
                remain = ((height - (trgtHeight - trgt.offsetHeight)));
                if (remain < itemHeight) {
                    trgtItEl.style.minHeight = remain + 'px';
                }
            };
            animate.end = function () {
                trgt.style.display = 'none';
                _this.collapseProgress('end', icn, trgt, trgtItEl, args);
                trgtItEl.style.minHeight = '';
                sf.base.setStyleAttribute(trgt, { 'position': '', 'maxHeight': '', 'display': '' });
            };
        }
        else {
            animate.begin = function () {
                _this.collapseProgress('begin', icn, trgt, trgtItEl, args);
            };
            animate.end = function () {
                _this.collapseProgress('end', icn, trgt, trgtItEl, args);
            };
        }
        new sf.base.Animation(animate).animate(trgt);
    };
    SfAccordion.prototype.collapseProgress = function (progress, icon, trgt, trgtItemEle, eventArgs) {
        sf.base.removeClass([icon], CLS_EXPANDICN);
        sf.base.removeClass([trgtItemEle], CLS_SLCTED);
        if (progress === 'end') {
            sf.base.addClass([trgt], CLS_CTNHIDE);
            icon.classList.remove(CLS_TOGANIMATE);
            sf.base.removeClass([trgtItemEle], CLS_ACTIVE);
            trgt.setAttribute('aria-hidden', 'true');
            sf.base.attributes(trgtItemEle, { 'aria-expanded': 'false' });
            sf.base.attributes(trgt.previousElementSibling, { 'aria-selected': 'false' });
            this.dotNetRef.invokeMethodAsync('TriggerCollapsedEvent', eventArgs);
            this.setPersistence('accordion' + this.element.id);
        }
    };
    SfAccordion.prototype.expandingItem = function (expandArgs) {
        this.accItem = sf.base.selectAll(':' + CLS_SCOPE + ' > .' + CLS_ITEM, this.element);
        var trgtItemEle = this.getElementByIndex(expandArgs.index);
        var trgt = sf.base.select('.' + CLS_CONTENT, trgtItemEle);
        var acrdnRoot = sf.base.closest(trgtItemEle, '.' + CLS_ACRDN_ROOT);
        var icon = sf.base.select('.' + CLS_TOOGLEICN, trgtItemEle).firstElementChild;
        var expandState = acrdnRoot.querySelector('.' + CLS_EXPANDSTATE);
        var animation = {
            name: this.options.animation.expand.effect,
            duration: this.options.animation.expand.duration,
            timingFunction: this.options.animation.expand.easing
        };
        icon.classList.add(CLS_TOGANIMATE);
        this.expandedItemsPush(trgtItemEle);
        if (!sf.base.isNullOrUndefined(expandState)) {
            expandState.classList.remove(CLS_EXPANDSTATE);
        }
        trgtItemEle.classList.add(CLS_EXPANDSTATE);
        if ((animation.name === 'None')) {
            this.expandProgress('begin', icon, trgt, trgtItemEle, expandArgs);
            this.expandProgress('end', icon, trgt, trgtItemEle, expandArgs);
        }
        else {
            this.expandAnimation(animation.name, icon, trgt, trgtItemEle, animation, expandArgs);
        }
    };
    SfAccordion.prototype.getElementByIndex = function (index) {
        if (this.accItem[index]) {
            return this.accItem[index];
        }
        return null;
    };
    SfAccordion.prototype.collapsingItem = function (expandArgs) {
        this.accItem = sf.base.selectAll(':' + CLS_SCOPE + ' > .' + CLS_ITEM, this.element);
        var trgtItemEle = this.getElementByIndex(expandArgs.index);
        var trgt = sf.base.select('.' + CLS_CONTENT, trgtItemEle);
        var icon = sf.base.select('.' + CLS_TOOGLEICN, trgtItemEle).firstElementChild;
        var animation = {
            name: this.options.animation.collapse.effect,
            duration: this.options.animation.collapse.duration,
            timingFunction: this.options.animation.collapse.easing
        };
        this.expandedItemsPop(trgtItemEle);
        trgtItemEle.classList.add(CLS_EXPANDSTATE);
        icon.classList.add(CLS_TOGANIMATE);
        if ((animation.name === 'None')) {
            this.collapseProgress('begin', icon, trgt, trgtItemEle, expandArgs);
            this.collapseProgress('end', icon, trgt, trgtItemEle, expandArgs);
        }
        else {
            this.collapseAnimation(animation.name, trgt, trgtItemEle, icon, animation, expandArgs);
        }
    };
    SfAccordion.prototype.select = function (index) {
        var itemEle = this.getItemElements();
        var ele = itemEle[index];
        if (sf.base.isNullOrUndefined(ele) || sf.base.isNullOrUndefined(sf.base.select('.' + CLS_HEADER, ele))) {
            return;
        }
        ele.children[0].focus();
    };
    SfAccordion.prototype.expandItem = function (isExpand, index) {
        var _this = this;
        var itemEle = this.getItemElements();
        if (sf.base.isNullOrUndefined(index)) {
            if (this.options.expandMode === 'Single' && isExpand) {
                var ele = itemEle[itemEle.length - 1];
                this.itemExpand(isExpand, ele, this.getIndexByItem(ele));
            }
            else {
                var item = sf.base.select('#' + this.lastActiveItemId, this.element);
                [].slice.call(itemEle).forEach(function (el) {
                    _this.itemExpand(isExpand, el, _this.getIndexByItem(el));
                    el.classList.remove(CLS_EXPANDSTATE);
                });
                var expandedItem = sf.base.select('.' + CLS_EXPANDSTATE, this.element);
                if (expandedItem) {
                    expandedItem.classList.remove(CLS_EXPANDSTATE);
                }
                if (item) {
                    item.classList.add(CLS_EXPANDSTATE);
                }
            }
        }
        else {
            var ele = itemEle[index];
            if (sf.base.isNullOrUndefined(ele) || !ele.classList.contains(CLS_SLCT) || (ele.classList.contains(CLS_ACTIVE) && isExpand)) {
                return;
            }
            else {
                if (this.options.expandMode === 'Single') {
                    this.expandItem(false);
                }
                this.itemExpand(isExpand, ele, index);
            }
        }
    };
    SfAccordion.prototype.setPersistence = function (elementId) {
        if (this.options.enablePersistence) {
            window.localStorage.setItem(elementId, this.options.expandedIndices.toString());
        }
    };
    SfAccordion.prototype.itemExpand = function (isExpand, ele, index) {
        var _this = this;
        var ctn = ele.children[1];
        if (ele.classList.contains(CLS_DISABLE)) {
            return;
        }
        if (sf.base.isNullOrUndefined(ctn) && isExpand) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.dotNetRef.invokeMethodAsync('OnAccordionClick', index).then(function () {
                ctn = ele.children[1];
                if (!sf.base.isNullOrUndefined(ctn)) {
                    _this.expand(ctn);
                }
            });
        }
        else if (!sf.base.isNullOrUndefined(ctn)) {
            if (isExpand) {
                this.expand(ctn);
            }
            else {
                this.collapse(ctn);
            }
        }
    };
    return SfAccordion;
}());
// tslint:disable
var Accordion = {
    initialize: function (element, options, dotnetRef) {
        if (element) {
            if (options.expandedIndices === null) {
                options.expandedIndices = [];
            }
            var instance = new SfAccordion(element, options, dotnetRef);
            instance.render();
            instance.dotNetRef.invokeMethodAsync('CreatedEvent', null);
        }
    },
    expandingItem: function (element, args) {
        if (element && element.blazor__instance) {
            element.blazor__instance.expandingItem(args);
        }
    },
    collapsingItem: function (element, args) {
        if (element && element.blazor__instance) {
            element.blazor__instance.collapsingItem(args);
        }
    },
    select: function (element, index) {
        if (element && element.blazor__instance) {
            element.blazor__instance.select(index);
        }
    },
    destroy: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.setPersistence('accordion' + element.id);
            element.blazor__instance.destroy();
        }
    },
    // eslint-disable-next-line max-len
    setExpandModeAndRTL: function (element, enableRtl, expandMode, isRtlChanged, isExpandModeChanged) {
        if (element && element.blazor__instance) {
            if (isRtlChanged) {
                if (enableRtl) {
                    sf.base.addClass([element], CLS_RTL);
                }
                else {
                    sf.base.removeClass([element], CLS_RTL);
                }
            }
            if (isExpandModeChanged) {
                element.blazor__instance.options.expandMode = expandMode;
                if (expandMode === 'Single') {
                    element.setAttribute('aria-multiselectable', 'false');
                    if (element.blazor__instance.options.expandedIndices.length > 1) {
                        element.blazor__instance.expandItem(false);
                    }
                }
                else {
                    element.setAttribute('aria-multiselectable', 'true');
                }
            }
        }
    },
    itemChanged: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.wireFocusEvents();
        }
    },
    afterContentRender: function (element, targetEle, animation) {
        if (element && element.blazor__instance) {
            element.blazor__instance.options.animation = animation;
            element.blazor__instance.afterContentRender(targetEle);
        }
    }
};

return Accordion;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-accumulation-chart.js":
/*!************************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-accumulation-chart.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.AccumulationChart = (function () {
'use strict';

/**
 * AccumulationChart blazor source file
 */
var throttle = sf.base.isNullOrUndefined(window['_']) ? null : window['_'].throttle;
var ChartLocation = /** @class */ (function () {
    function ChartLocation(x, y) {
        this.x = x;
        this.y = y;
    }
    return ChartLocation;
}());
var SfAccumulationChart = /** @class */ (function () {
    function SfAccumulationChart(id, element, dotnetRef) {
        this.chartOnMouseDownRef = null;
        this.mouseMoveRef = null;
        this.mouseEndRef = null;
        this.chartOnMouseClickRef = null;
        this.chartRightClickRef = null;
        this.mouseLeaveRef = null;
        this.chartMouseWheelRef = null;
        this.domMouseMoveRef = null;
        this.domMouseUpRef = null;
        this.longPressBound = null;
        this.touchObject = null;
        this.mouseY = 0;
        this.mouseX = 0;
        this.eventInterval = 80;
        this.id = id;
        this.element = element;
        this.dotnetref = dotnetRef;
        this.element.blazor__instance = this;
    }
    SfAccumulationChart.prototype.render = function () {
        this.unWireEvents();
        this.wireEvents();
    };
    SfAccumulationChart.prototype.destroy = function () {
        this.unWireEvents();
    };
    SfAccumulationChart.prototype.wireEvents = function () {
        var _this = this;
        var element = document.getElementById(this.id);
        if (!element) {
            return;
        }
        AccumulationChart.dotnetrefCollection.push({ id: this.id, dotnetref: this.dotnetref });
        /*! Find the Events type */
        var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.chartOnMouseDownRef = this.chartOnMouseDown.bind(this, this.dotnetref, this.id);
        this.mouseMoveRef = this.mouseMove.bind(this, this.dotnetref, this.id);
        this.mouseEndRef = this.mouseEnd.bind(this, this.dotnetref, this.id);
        this.chartOnMouseClickRef = this.chartOnMouseClick.bind(this, this.dotnetref, this.id);
        this.chartRightClickRef = this.chartRightClick.bind(this, this.dotnetref, this.id);
        this.mouseLeaveRef = this.mouseLeave.bind(this, this.dotnetref, this.id);
        /*! Bind the Event handler */
        element.addEventListener('mousemove', throttle(function (e) {
            _this.mouseMoveRef(e);
        }, this.eventInterval));
        element.addEventListener('touchmove', throttle(function (e) {
            _this.mouseMoveRef(e);
        }, this.eventInterval));
        sf.base.EventHandler.add(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
        sf.base.EventHandler.add(element, 'click', this.chartOnMouseClickRef);
        sf.base.EventHandler.add(element, 'contextmenu', this.chartRightClickRef);
        sf.base.EventHandler.add(element, cancelEvent, this.mouseLeaveRef);
        AccumulationChart.resizeBound = AccumulationChart.chartResize.bind(this, AccumulationChart.dotnetrefCollection);
        var resize = (sf.base.Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' :
            'resize';
        sf.base.EventHandler.add(window, resize, AccumulationChart.resizeBound);
        this.longPressBound = this.longPress.bind(this, this.dotnetref, this.id);
        this.touchObject = new sf.base.Touch(element, { tapHold: this.longPressBound, tapHoldThreshold: 500 });
        /*! Apply the style for chart */
    };
    SfAccumulationChart.prototype.unWireEvents = function () {
        var _this = this;
        var element = document.getElementById(this.id);
        if (!element) {
            return;
        }
        AccumulationChart.dotnetrefCollection = AccumulationChart.dotnetrefCollection.filter(function (item) {
            return item.id !== _this.id;
        });
        /*! Find the Events type */
        var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        sf.base.EventHandler.remove(element, sf.base.Browser.touchStartEvent, this.chartOnMouseDownRef);
        element.removeEventListener('mousemove', this.mouseMoveRef);
        element.removeEventListener('touchmove', this.mouseMoveRef);
        sf.base.EventHandler.remove(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
        sf.base.EventHandler.remove(element, 'click', this.chartOnMouseClickRef);
        sf.base.EventHandler.remove(element, 'contextmenu', this.chartRightClickRef);
        sf.base.EventHandler.remove(element, cancelEvent, this.mouseLeaveRef);
        var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
        sf.base.EventHandler.remove(window, resize, AccumulationChart.resizeBound);
        if (this.touchObject) {
            this.touchObject.destroy();
            this.touchObject = null;
        }
        /*! Apply the style for chart */
    };
    SfAccumulationChart.prototype.getEventArgs = function (e) {
        return {
            type: e.type,
            clientX: e.clientX,
            clientY: e.clientY,
            mouseX: this.mouseX,
            mouseY: this.mouseY,
            pointerType: e.pointerType,
            target: e.target.id,
            changedTouches: {
                clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
                clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
            }
        };
    };
    SfAccumulationChart.prototype.setMouseXY = function (pageX, pageY) {
        var svgRect = document.getElementById(this.id + '_svg').getBoundingClientRect();
        var rect = document.getElementById(this.id).getBoundingClientRect();
        this.mouseY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
        this.mouseX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
    };
    SfAccumulationChart.prototype.chartOnMouseDown = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        this.id = id;
        this.dotnetref.invokeMethodAsync('OnChartMouseDown', this.getEventArgs(e));
        return false;
    };
    SfAccumulationChart.prototype.mouseMove = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        this.id = id;
        var pageX;
        var pageY;
        var touchArg;
        if (e.type === 'touchmove') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
            pageX = e.clientX;
            pageY = e.clientY;
        }
        if (document.getElementById(this.id + '_svg')) {
            this.setMouseXY(pageX, pageY);
            this.dotnetref.invokeMethodAsync('OnChartMouseMove', this.getEventArgs(e));
        }
        return false;
    };
    SfAccumulationChart.prototype.mouseEnd = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        this.id = id;
        this.dotnetref.invokeMethodAsync('OnChartMouseEnd', this.getEventArgs(e));
        return false;
    };
    SfAccumulationChart.prototype.chartOnMouseClick = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        this.id = id;
        this.dotnetref.invokeMethodAsync('OnChartMouseClick', this.getEventArgs(e));
        return false;
    };
    SfAccumulationChart.prototype.chartRightClick = function (dotnetref, id, event) {
        this.dotnetref = dotnetref;
        this.id = id;
        this.dotnetref.invokeMethodAsync('OnChartRightClick', this.getEventArgs(event));
        return false;
    };
    SfAccumulationChart.prototype.mouseLeave = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        this.id = id;
        this.dotnetref.invokeMethodAsync('OnChartMouseLeave', this.getEventArgs(e));
        return false;
    };
    SfAccumulationChart.prototype.longPress = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        this.id = id;
        this.dotnetref.invokeMethodAsync('OnChartLongPress', e);
        return false;
    };
    return SfAccumulationChart;
}());
var AccumulationChart = {
    initialize: function (element, dotnetRef) {
        var instance = new SfAccumulationChart(element.id, element, dotnetRef);
        instance.render();
    },
    destroy: function (element) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.destroy();
        }
    },
    id: '',
    getParentElementBoundsById: function (id) {
        var element = document.getElementById(id);
        if (element) {
            element.style.width = '100%';
            element.style.height = '100%';
            var elementRect = element.getBoundingClientRect();
            return {
                width: elementRect.width || element.clientWidth || element.offsetWidth,
                height: elementRect.height || element.clientHeight || element.offsetHeight,
                left: elementRect.left,
                top: elementRect.top,
                right: elementRect.right,
                bottom: elementRect.bottom
            };
        }
        return { width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
    },
    getElementBoundsById: function (id, isSetId) {
        if (isSetId === void 0) { isSetId = true; }
        if (isSetId) {
            this.id = id;
        }
        var element = document.getElementById(id);
        if (element) {
            var elementRect = element.getBoundingClientRect();
            return {
                width: element.clientWidth || element.offsetWidth,
                height: element.clientHeight || element.offsetHeight,
                left: elementRect.left,
                top: elementRect.top,
                right: elementRect.right,
                bottom: elementRect.bottom
            };
        }
        return { width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
    },
    getAllCharacters: function () {
        var charCollection = [];
        for (var i = 33; i < 591; i++) {
            charCollection.push(String.fromCharCode(i));
        }
        return charCollection;
    },
    measureText: function (text, fontWeight, fontStyle, fontFamily) {
        var textObject = document.getElementById('chartmeasuretext');
        if (textObject === null) {
            textObject = sf.base.createElement('text', { id: 'chartmeasuretext' });
            document.body.appendChild(textObject);
        }
        if (text === ' ') {
            text = '&nbsp;';
        }
        textObject.innerHTML = text;
        textObject.style.position = 'fixed';
        textObject.style.fontSize = '100px';
        textObject.style.fontWeight = fontWeight;
        textObject.style.fontStyle = fontStyle;
        textObject.style.fontFamily = fontFamily;
        textObject.style.visibility = 'hidden';
        textObject.style.top = '-100';
        textObject.style.left = '0';
        textObject.style.whiteSpace = 'nowrap';
        textObject.style.lineHeight = 'normal';
        return {
            Width: textObject.clientWidth,
            Height: textObject.clientHeight
        };
    },
    getCharCollectionSize: function (fontkeys) {
        var charSizeList = [];
        var charSize;
        var tempSizeList = {};
        var charList = this.getAllCharacters();
        var charLength = charList.length;
        var fontKeysLength = fontkeys.length;
        for (var i = 0; i < fontKeysLength; i++) {
            var fontValues = fontkeys[i].split('_');
            var fontWeight = fontValues[0];
            var fontStyle = fontValues[1];
            var fontFamily = fontValues[2];
            for (var j = 0; j < charLength; j++) {
                charSize = this.measureText(charList[j], fontWeight, fontStyle, fontFamily);
                tempSizeList[charList[j]] = { X: charSize.Width, Y: charSize.Height };
            }
            charSizeList.push(tempSizeList);
        }
        var result = JSON.stringify(charSizeList);
        return result;
    },
    dotnetref: {},
    dotnetrefCollection: [],
    resizeBound: {},
    resize: {},
    chartResize: function (dotnetrefCollection, e) {
        var _this = this;
        if (this.resize) {
            clearTimeout(this.resize);
        }
        this.resize = setTimeout(function () {
            var count = dotnetrefCollection.length;
            var tempDotnetref;
            for (var i = 0; i < count; i++) {
                tempDotnetref = dotnetrefCollection[i].dotnetref;
                tempDotnetref.invokeMethodAsync('RemoveElements');
            }
            for (var i = 0; i < count; i++) {
                tempDotnetref = dotnetrefCollection[i].dotnetref;
                tempDotnetref.invokeMethodAsync('OnChartResize', e);
            }
            clearTimeout(_this.resize);
        }, 500);
        return false;
    },
    performAnimation: function (index, sliceId, startX, startY, endX, endY, duration, transform, isReverse) {
        var _this = this;
        var result = /translate\((-?\d+\.?\d*),?\s*(-?\d+[.]?\d*)?\)/.exec(transform);
        if (!sf.base.isNullOrUndefined(transform) && transform !== '') {
            endX = +result[1];
            endY = +result[2];
        }
        if (duration <= 0) {
            this.setElementTransform(sliceId, index, 'transform', 'translate(' + (endX) + ', ' + (endY) + ')');
            return null;
        }
        var xValue;
        var yValue;
        new sf.base.Animation({}).animate(sf.base.createElement('div'), {
            duration: duration,
            progress: function (args) {
                xValue = _this.linear(args.timeStamp, startX, endX, args.duration);
                yValue = _this.linear(args.timeStamp, startY, endY, args.duration);
                _this.setElementTransform(sliceId, index, 'transform', 'translate(' + (isReverse ? endX - xValue : xValue) + ', ' + (isReverse ? endY - yValue : yValue) + ')');
            },
            end: function (model) {
                _this.setElementTransform(sliceId, index, 'transform', 'translate(' + (isReverse ? startX : endX) + ', ' + (isReverse ? startX : endY) + ')');
            }
        });
    },
    setElementTransform: function (sliceId, index, attribute, value) {
        var chartID = sliceId.replace('Series_0', 'datalabel').replace('Point', 'Series_0');
        this.setElementAttribute(sliceId + index, 'transform', value);
        this.setElementAttribute(chartID + 'shape_' + index, 'transform', value);
        this.setElementAttribute(chartID + 'text_' + index, 'transform', value);
        this.setElementAttribute(chartID + 'connector_' + index, 'transform', value);
    },
    linear: function (currentTime, startValue, endValue, duration) {
        return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
    },
    setElementAttribute: function (id, attribute, value) {
        var element = document.getElementById(id);
        if (element) {
            element.setAttribute(attribute, value);
        }
    },
    getElementAttribute: function (id, attribute) {
        var element = document.getElementById(id);
        if (element) {
            return (element.getAttribute(attribute));
        }
        return '';
    },
    createStyleElement: function (styleId, styleInnerHTML) {
        document.body.appendChild(sf.base.createElement('style', { id: styleId, innerHTML: styleInnerHTML }));
    },
    renderTooltip: function (tooltipOptions, elementId, tooltipModule, element) {
        var svgElement = document.getElementById(elementId + '_svg');
        var firstRender = (svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0) ? false : true;
        var options = JSON.parse(tooltipOptions);
        var currentInstance = element.blazor__instance;
        if (firstRender && !sf.base.isNullOrUndefined(currentInstance)) {
            currentInstance.tooltip = new sf.svgbase.Tooltip(options);
            currentInstance.tooltip.tooltipRender = function () {
                tooltipModule.invokeMethodAsync('TooltipRender');
            };
            currentInstance.tooltip.animationComplete = function (args) {
                if (args.tooltip.fadeOuted) {
                    tooltipModule.invokeMethodAsync('TooltipAnimationComplete');
                }
            };
            currentInstance.tooltip.appendTo('#' + elementId);
        }
        else if (!sf.base.isNullOrUndefined(currentInstance.tooltip)) {
            currentInstance.tooltip.location = new sf.svgbase.TooltipLocation(options.location.x, options.location.y);
            currentInstance.tooltip.content = options.content;
            currentInstance.tooltip.header = options.header;
            currentInstance.tooltip.offset = options.offset;
            currentInstance.tooltip.palette = options.palette;
            currentInstance.tooltip.shapes = options.shapes;
            currentInstance.tooltip.data = options.data;
            currentInstance.tooltip.template = options.template;
            currentInstance.tooltip.textStyle.color = options.textStyle.color || currentInstance.tooltip.textStyle.color;
            currentInstance.tooltip.textStyle.fontFamily = options.textStyle.fontFamily || currentInstance.tooltip.textStyle.fontFamily;
            currentInstance.tooltip.textStyle.fontStyle = options.textStyle.fontStyle || currentInstance.tooltip.textStyle.fontStyle;
            currentInstance.tooltip.textStyle.fontWeight = options.textStyle.fontWeight || currentInstance.tooltip.textStyle.fontWeight;
            currentInstance.tooltip.textStyle.opacity = options.textStyle.opacity || currentInstance.tooltip.textStyle.opacity;
            currentInstance.tooltip.textStyle.size = options.textStyle.size || currentInstance.tooltip.textStyle.size;
            currentInstance.tooltip.isNegative = options.isNegative;
            currentInstance.tooltip.clipBounds = new sf.svgbase.TooltipLocation(options.clipBounds.x, options.clipBounds.y);
            currentInstance.tooltip.arrowPadding = options.arrowPadding;
            currentInstance.tooltip.dataBind();
        }
    },
    fadeOut: function (element) {
        if (sf.base.isNullOrUndefined(element.blazor__instance) ||
            (!sf.base.isNullOrUndefined(element.blazor__instance) && sf.base.isNullOrUndefined(element.blazor__instance.tooltip))) {
            return;
        }
        this.removeTooltipCommentElement(element);
        element.blazor__instance.tooltip.fadeOut();
    },
    removeTooltipCommentElement: function (chartInstance) {
        var tooltipDivElement = document.getElementById(chartInstance.blazor__instance.tooltip.element.id);
        if (tooltipDivElement && !chartInstance.blazor__instance.isRemoveCommentElement && tooltipDivElement.childNodes.length > 1) {
            var tooltipElements = tooltipDivElement.childNodes;
            var commentElements = [];
            for (var i = 0; i < tooltipElements.length; i++) {
                if (tooltipElements[i].nodeName.match('#comment') || tooltipElements[i].nodeName.match('#text')) {
                    commentElements.push(tooltipElements[i]);
                }
            }
            for (var _i = 0, commentElements_1 = commentElements; _i < commentElements_1.length; _i++) {
                var element = commentElements_1[_i];
                sf.base.remove(element);
                chartInstance.blazor__instance.isRemoveCommentElement = true;
            }
        }
    },
    animateRedrawElement: function (elementId, duration, startX, startY, endX, endY, x, y) {
        var _this = this;
        if (x === void 0) { x = 'x'; }
        if (y === void 0) { y = 'y'; }
        var element = document.getElementById(elementId);
        if (!element) {
            return null;
        }
        var isDiv = element.tagName === 'DIV';
        var setStyle = function (xValue, yValue) {
            if (isDiv) {
                element.style[x] = xValue + 'px';
                element.style[y] = yValue + 'px';
            }
            else {
                element.setAttribute(x, xValue + '');
                element.setAttribute(y, yValue + '');
            }
        };
        setStyle(startX, startY);
        new sf.base.Animation({}).animate(sf.base.createElement('div'), {
            duration: duration,
            progress: function (args) {
                setStyle(_this.linear(args.timeStamp, startX, endX - startX, args.duration), _this.linear(args.timeStamp, startY, endY - startY, args.duration));
            },
            end: function () {
                setStyle(endX, endY);
            }
        });
    },
    //Pie Animation starts here
    doAnimation: function (sliceId, startAngle, totalAngle, animationDuration, animationDelay, legendDuration, radius, center) {
        var _this = this;
        var slice = document.getElementById(sliceId);
        startAngle -= 90;
        var duration = legendDuration ? legendDuration : animationDuration;
        var value;
        center['x'] += 1;
        radius += radius * (0.414); // formula r + r / 2 * (1.414 -1)
        // need to check animation type
        new sf.base.Animation({}).animate(slice, {
            duration: duration,
            delay: animationDelay,
            progress: function (args) {
                value = _this.linear(args.timeStamp, startAngle, totalAngle, args.duration);
                slice.setAttribute('d', _this.getPathArc(center, startAngle, value, radius, 0));
            },
            end: function (args) {
                center.x -= 1;
                slice.setAttribute('d', _this.getPathArc(center, startAngle, startAngle - 0.00009, radius, 0));
                var datalabels = document.getElementById(slice.id.split('_')[0] + '_datalabel_Series_0');
                if (datalabels) {
                    datalabels.setAttribute('style', 'visibility: visible');
                }
            }
        });
    },
    getPathArc: function (center, start, end, radius, innerRadius) {
        var degree = end - start;
        degree = degree < 0 ? (degree + 360) : degree;
        var flag = (degree < 180) ? 0 : 1;
        if (!innerRadius && innerRadius === 0) {
            return this.getPiePath(center, this.degreeToLocation(start, radius, center), this.degreeToLocation(end, radius, center), radius, flag);
        }
        else {
            return this.getDoughnutPath(center, this.degreeToLocation(start, radius, center), this.degreeToLocation(end, radius, center), radius, this.degreeToLocation(start, innerRadius, center), this.degreeToLocation(end, innerRadius, center), innerRadius, flag);
        }
    },
    getPiePath: function (center, start, end, radius, clockWise) {
        return 'M ' + center.x + ' ' + center.y + ' L ' + start.x + ' ' + start.y + ' A ' + radius + ' ' +
            radius + ' 0 ' + clockWise + ' 1 ' + end.x + ' ' + end.y + ' Z';
    },
    getDoughnutPath: function (center, start, end, radius, innerStart, innerEnd, innerRadius, clockWise) {
        return 'M ' + start.x + ' ' + start.y + ' A ' + radius + ' ' + radius + ' 0 ' + clockWise +
            ' 1 ' + end.x + ' ' + end.y + ' L ' + innerEnd.x + ' ' + innerEnd.y + ' A ' + innerRadius +
            ' ' + innerRadius + ' 0 ' + clockWise + ',0 ' + innerStart.x + ' ' + innerStart.y + ' Z';
    },
    degreeToLocation: function (degree, radius, center) {
        var radian = (degree * Math.PI) / 180;
        return new ChartLocation(Math.cos(radian) * radius + center.x, Math.sin(radian) * radius + center.y);
    },
    //Pie Animation end here
    /**
     * Pie Series Legend Click Animation
     */
    ChangePiePath: function (pointOptions, center, duration) {
        for (var _i = 0, pointOptions_1 = pointOptions; _i < pointOptions_1.length; _i++) {
            var point = pointOptions_1[_i];
            this.ChangePointPath(point.point, point.degree, point.start, point.pathOption, duration, center, point.radius, point.innerRadius);
        }
    },
    GetPathOption: function (center, degree, startAngle, radius, innerRadius) {
        if (!degree) {
            return '';
        }
        return this.getPathArc(center, startAngle, (startAngle + degree) % 360, radius, innerRadius);
    },
    ChangePointPath: function (point, degree, start, option, duration, center, radius, innerRadius) {
        var _this = this;
        var seriesElement = document.getElementById(option.id);
        var currentStartAngle;
        var curentDegree;
        new sf.base.Animation({}).animate(sf.base.createElement('div'), {
            duration: duration,
            delay: 0,
            progress: function (args) {
                curentDegree = _this.linear(args.timeStamp, point.degree, (degree - point.degree), args.duration);
                currentStartAngle = _this.linear(args.timeStamp, point.start, start - point.start, args.duration);
                currentStartAngle = ((currentStartAngle / (Math.PI / 180)) + 360) % 360;
                seriesElement.setAttribute('d', _this.GetPathOption(center, curentDegree, currentStartAngle, radius, innerRadius));
                if (point.isExplode) {
                    //chart.accBaseModule.explodePoints(point.index, chart, true);
                }
                seriesElement.style.visibility = 'visible';
            },
            end: function (args) {
                seriesElement.style.visibility = point.visible ? 'visible' : 'hidden';
                seriesElement.setAttribute('d', option.direction);
                point.degree = degree;
                point.start = start;
            }
        });
    }
};

return AccumulationChart;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-calendarbase.js":
/*!******************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-calendarbase.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.CalendarBase = (function () {
'use strict';

// tslint:disable
var calendarBase = {
    initialize: function (element, dotnetRef, keyConfig, value, multiSelection) {
        var defaultKeyConfig = {
            controlUp: 'ctrl+38',
            controlDown: 'ctrl+40',
            moveDown: 'downarrow',
            moveUp: 'uparrow',
            moveLeft: 'leftarrow',
            moveRight: 'rightarrow',
            select: 'enter',
            home: 'home',
            end: 'end',
            pageUp: 'pageup',
            pageDown: 'pagedown',
            shiftPageUp: 'shift+pageup',
            shiftPageDown: 'shift+pagedown',
            controlHome: 'ctrl+home',
            controlEnd: 'ctrl+end',
            altUpArrow: 'alt+uparrow',
            spacebar: 'space',
            altRightArrow: 'alt+rightarrow',
            altLeftArrow: 'alt+leftarrow'
        };
        defaultKeyConfig = sf.base.extend(defaultKeyConfig, keyConfig);
        new sf.base.KeyboardEvents(element, {
            eventName: 'keydown',
            keyAction: this.keyActionHandle.bind(this, value, multiSelection, dotnetRef),
            keyConfigs: defaultKeyConfig
        });
    },
    keyActionHandle: function (value, multiSelection, dotnetRef, e) {
        e.preventDefault();
        var element = sf.base.closest(e.target, '.' + 'e-calendar');
        var tableBodyElement = element.querySelector('tbody');
        if (!tableBodyElement) {
            return;
        }
        multiSelection = false;
        var focusedDate = tableBodyElement.querySelector('tr td.e-focused-date');
        var selectedDate;
        if (multiSelection) {
            selectedDate = (!focusedDate && +value === parseInt(focusedDate.getAttribute('id').split('_')[0], 10)) ? focusedDate
                : tableBodyElement.querySelector('tr td.e-selected');
        }
        else {
            selectedDate = tableBodyElement.querySelector('tr td.e-selected');
        }
        tableBodyElement.focus();
        var targetEle = e.target;
        var args = {
            Action: e.action, Key: e.key, Events: e, SelectDate: selectedDate ? selectedDate.id : null,
            FocusedDate: focusedDate ? focusedDate.id : null,
            classList: selectedDate ? selectedDate.classList.toString() : focusedDate ? focusedDate.classList.toString() : 'e-cell',
            Id: focusedDate ? focusedDate.id : selectedDate ? selectedDate.id : null,
            TargetClassList: targetEle.classList.toString()
        };
        dotnetRef.invokeMethodAsync('OnCalendarKeyboardEvent', args);
        if (targetEle.classList.contains('e-today')) {
            targetEle.blur();
            tableBodyElement.focus();
        }
    }
};

return calendarBase;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-chart.js":
/*!***********************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-chart.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Chart = (function () {
'use strict';

/* eslint-disable no-case-declarations */
/* eslint-disable camelcase */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Chart native blazor source file
 */
var throttle = sf.base.isNullOrUndefined(window['_']) ? null : window['_'].throttle;
var SfChart = /** @class */ (function () {
    function SfChart(id, element, dotnetRef, isZooming, isScrollbar) {
        if (isZooming === void 0) { isZooming = false; }
        if (isScrollbar === void 0) { isScrollbar = false; }
        this.mouseY = 0;
        this.mouseX = 0;
        this.eventInterval = 80;
        this.chartOnMouseDownRef = null;
        this.mouseMoveRef = null;
        this.mouseEndRef = null;
        this.chartOnMouseClickRef = null;
        this.chartRightClickRef = null;
        this.mouseLeaveRef = null;
        this.chartMouseWheelRef = null;
        this.domMouseMoveRef = null;
        this.domMouseUpRef = null;
        this.longPressBound = null;
        this.touchObject = null;
        this.pinchStyle = 'opacity: 0; position: absolute; display: block; width: 100px; height: 100px; background: transparent; border: 2px solid blue;';
        this.pinchtarget = null;
        this.id = id;
        this.element = element;
        this.dotnetref = dotnetRef;
        this.isZooming = isZooming;
        this.isScrollbar = isScrollbar;
        this.element.blazor__instance = this;
    }
    SfChart.prototype.render = function () {
        this.unWireEvents(this.id, this.dotnetref);
        this.wireEvents(this.id, this.dotnetref);
    };
    SfChart.prototype.destroy = function () {
        this.unWireEvents(this.id, this.dotnetref);
    };
    SfChart.prototype.unWireEvents = function (id, dotnetref) {
        var element = document.getElementById(id);
        if (!element) {
            return;
        }
        this.dotnetref = dotnetref;
        Chart.dotnetrefCollection = Chart.dotnetrefCollection.filter(function (item) {
            return item.id !== id;
        });
        /*! Find the Events type */
        var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
        /*! Bind the Event handler */
        sf.base.EventHandler.remove(element, sf.base.Browser.touchStartEvent, this.chartOnMouseDownRef);
        element.removeEventListener('mousemove', this.mouseMoveRef);
        element.removeEventListener('touchmove', this.mouseMoveRef);
        sf.base.EventHandler.remove(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
        sf.base.EventHandler.remove(element, 'click', this.chartOnMouseClickRef);
        sf.base.EventHandler.remove(element, 'contextmenu', this.chartRightClickRef);
        sf.base.EventHandler.remove(element, cancelEvent, this.mouseLeaveRef);
        if (this.isZooming) {
            var wheelEvent = sf.base.Browser.info.name === 'mozilla' ? (sf.base.Browser.isPointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';
            element.removeEventListener(wheelEvent, this.chartMouseWheelRef);
        }
        if (this.isScrollbar) {
            window.removeEventListener('mousemove', this.domMouseMoveRef);
            window.removeEventListener('mouseup', this.domMouseUpRef, false);
        }
        var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
        sf.base.EventHandler.remove(window, resize, Chart.resizeBound);
        if (this.touchObject) {
            this.touchObject.destroy();
            this.touchObject = null;
        }
        /*! Apply the style for chart */
    };
    SfChart.prototype.wireEvents = function (id, dotnetref) {
        var _this = this;
        var element = document.getElementById(id);
        if (!element) {
            return;
        }
        this.dotnetref = dotnetref;
        Chart.dotnetrefCollection.push({ id: id, dotnetref: dotnetref });
        /*! Find the Events type */
        var cancelEvent = sf.base.Browser.isPointer ? 'pointerleave' : 'mouseleave';
        this.chartOnMouseDownRef = this.chartOnMouseDown.bind(this, dotnetref, id);
        this.mouseMoveRef = this.mouseMove.bind(this, dotnetref, id);
        this.mouseEndRef = this.mouseEnd.bind(this, dotnetref, id);
        this.chartOnMouseClickRef = this.chartOnMouseClick.bind(this, dotnetref, id);
        this.chartRightClickRef = this.chartRightClick.bind(this, dotnetref, id);
        this.mouseLeaveRef = this.mouseLeave.bind(this, dotnetref, id);
        /*! Bind the Event handler */
        sf.base.EventHandler.add(element, sf.base.Browser.touchStartEvent, this.chartOnMouseDownRef);
        element.addEventListener('mousemove', throttle(function (e) {
            _this.mouseMoveRef(e);
        }, this.eventInterval));
        element.addEventListener('touchmove', throttle(function (e) {
            _this.mouseMoveRef(e);
        }, this.eventInterval));
        sf.base.EventHandler.add(element, sf.base.Browser.touchEndEvent, this.mouseEndRef);
        sf.base.EventHandler.add(element, 'click', this.chartOnMouseClickRef);
        sf.base.EventHandler.add(element, 'contextmenu', this.chartRightClickRef);
        sf.base.EventHandler.add(element, cancelEvent, this.mouseLeaveRef);
        if (this.isZooming) {
            this.chartMouseWheelRef = this.chartMouseWheel.bind(this, dotnetref, id);
            var wheelEvent = sf.base.Browser.info.name === 'mozilla' ? (sf.base.Browser.isPointer ? 'mousewheel' : 'DOMMouseScroll') : 'mousewheel';
            element.addEventListener(wheelEvent, throttle(function (e) {
                _this.chartMouseWheelRef(e);
            }, this.eventInterval));
        }
        if (this.isScrollbar) {
            this.domMouseMoveRef = this.domMouseMove.bind(this, dotnetref, id);
            this.domMouseUpRef = this.domMouseUp.bind(this, dotnetref, id);
            window.addEventListener('mousemove', throttle(function (e) {
                _this.domMouseMoveRef(e);
            }, this.eventInterval));
            window.addEventListener('mouseup', this.domMouseUpRef, false);
        }
        Chart.resizeBound = Chart.chartResize.bind(this, Chart.dotnetrefCollection);
        var resize = sf.base.Browser.isTouch && 'orientation' in window && 'onorientationchange' in window ? 'orientationchange' : 'resize';
        sf.base.EventHandler.add(window, resize, Chart.resizeBound);
        this.longPressBound = this.longPress.bind(this, dotnetref, id);
        this.touchObject = new sf.base.Touch(element, { tapHold: this.longPressBound, tapHoldThreshold: 500 });
        /*! Apply the style for chart */
    };
    SfChart.prototype.getEventArgs = function (e, id) {
        var clientX = e.changedTouches ? e.changedTouches[0].clientX :
            e.clientX;
        var clientY = e.changedTouches ? e.changedTouches[0].clientY :
            e.clientY;
        this.setMouseXY(clientX, clientY, id);
        var touches = e.touches; //pointerId
        var touchList = [];
        if (e.type.indexOf('touch') > -1) {
            for (var i = 0, length_1 = touches.length; i < length_1; i++) {
                touchList.push({ pageX: touches[i].clientX, pageY: touches[i].clientY, pointerId: e.pointerId || 0 });
            }
        }
        return {
            type: e.type,
            clientX: e.clientX,
            clientY: e.clientY,
            mouseX: this.mouseX,
            mouseY: this.mouseY,
            pointerType: e.pointerType,
            target: e.target.id,
            changedTouches: {
                clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
                clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
            },
            touches: touchList,
            pointerId: e.pointerId
        };
    };
    SfChart.prototype.getWheelArgs = function (e, id) {
        this.setMouseXY(e.clientX, e.clientY, id);
        return {
            detail: e.detail,
            wheelDelta: e['wheelDelta'],
            target: e.currentTarget ? e.currentTarget['id'] : e.srcElement ? e.srcElement['id'] : e.target ? e.target['id'] : '',
            clientX: e.clientX,
            clientY: e.clientY,
            mouseX: this.mouseX,
            mouseY: this.mouseY,
            browserName: sf.base.Browser.info.name,
            isPointer: sf.base.Browser.isPointer
        };
    };
    SfChart.prototype.setMouseXY = function (pageX, pageY, id) {
        var svgRect = document.getElementById(id.replace('_stockChart_chart', '') + '_svg').getBoundingClientRect();
        var rect = document.getElementById(id).getBoundingClientRect();
        this.mouseY = (pageY - rect.top) - Math.max(svgRect.top - rect.top, 0);
        this.mouseX = (pageX - rect.left) - Math.max(svgRect.left - rect.left, 0);
    };
    SfChart.prototype.chartOnMouseDown = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        if (e.type.indexOf('touch') > -1) {
            var clientX = e.changedTouches ? e.changedTouches[0].clientX :
                e.clientX;
            var clientY = e.changedTouches ? e.changedTouches[0].clientY :
                e.clientY;
            this.pinchtarget = document.getElementById('pinchtarget');
            this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: ' + (clientY - 50) + 'px; left: ' + (clientX - 50) + 'px;');
        }
        dotnetref.invokeMethodAsync('OnChartMouseDown', this.getEventArgs(e, id));
        return false;
    };
    SfChart.prototype.chartMouseWheel = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        dotnetref.invokeMethodAsync('OnChartMouseWheel', this.getWheelArgs(e, id));
        e.preventDefault();
        return false;
    };
    SfChart.prototype.mouseMove = function (dotnetref, id, e) {
        var pageX;
        var pageY;
        var touchArg;
        if (e.type === 'touchmove') {
            this.isTouch = true;
            touchArg = e;
            pageX = touchArg.changedTouches[0].clientX;
            pageY = touchArg.changedTouches[0].clientY;
            if (this.pinchtarget) {
                this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: ' + (pageY - 50) + 'px; left: ' + (pageX - 50) + 'px;');
            }
            e.preventDefault();
        }
        else {
            this.isTouch = e.pointerType === 'touch' || e.pointerType === '2' || this.isTouch;
            pageX = e.clientX;
            pageY = e.clientY;
        }
        this.dotnetref = dotnetref;
        if (document.getElementById(id.replace('_stockChart_chart', '') + '_svg')) {
            this.setMouseXY(pageX, pageY, id);
            dotnetref.invokeMethodAsync('OnChartMouseMove', this.getEventArgs(e, id));
        }
        return false;
    };
    SfChart.prototype.mouseEnd = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        if (this.pinchtarget) {
            this.pinchtarget.setAttribute('style', this.pinchStyle + ' top: -100px; left: -100px;');
        }
        dotnetref.invokeMethodAsync('OnChartMouseEnd', this.getEventArgs(e, id));
        return false;
    };
    SfChart.prototype.chartOnMouseClick = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        dotnetref.invokeMethodAsync('OnChartMouseClick', this.getEventArgs(e, id));
        return false;
    };
    SfChart.prototype.chartRightClick = function (dotnetref, id, event) {
        this.dotnetref = dotnetref;
        event.preventDefault();
        event.stopPropagation();
        dotnetref.invokeMethodAsync('OnChartMouseRightClick', this.getEventArgs(event, id));
        return false;
    };
    SfChart.prototype.mouseLeave = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        dotnetref.invokeMethodAsync('OnChartMouseLeave', this.getEventArgs(e, id));
        return false;
    };
    SfChart.prototype.longPress = function (dotnetref, id, e) {
        this.dotnetref = dotnetref;
        var clientX = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientX : 0;
        var clientY = e && e.originalEvent.changedTouches ? e.originalEvent.changedTouches[0].clientY : 0;
        this.setMouseXY(clientX, clientY, id);
        var args = {
            type: 'TapHold',
            clientX: clientX,
            clientY: clientY,
            mouseX: this.mouseX,
            mouseY: this.mouseY,
            pointerType: '',
            target: '',
            changedTouches: {
                clientX: clientX,
                clientY: clientY
            },
            touches: [],
            pointerId: 0
        };
        dotnetref.invokeMethodAsync('OnChartLongPress', args);
        return false;
    };
    SfChart.prototype.domMouseMove = function (dotnetref, id, event) {
        if (!sf.base.isNullOrUndefined(Chart.svgId) && Chart.svgId.indexOf(id) > -1) {
            var evtArgs = Chart.getScrollEventArgs(event, true);
            dotnetref.invokeMethodAsync('ScrollMouseMove', evtArgs);
        }
        return false;
    };
    SfChart.prototype.domMouseUp = function (dotnetref, id, event) {
        if (!sf.base.isNullOrUndefined(Chart.svgId) && Chart.svgId.indexOf(id) > -1) {
            var evtArgs = Chart.getScrollEventArgs(event, true);
            dotnetref.invokeMethodAsync('ScrollMouseUp', evtArgs);
            Chart.svgId = null;
        }
        return false;
    };
    return SfChart;
}());
var Chart = {
    initialize: function (element, dotnetRef, isZooming, isScrollbar) {
        var instance = new SfChart(element.id, element, dotnetRef, isZooming, isScrollbar);
        instance.render();
    },
    destroy: function (element) {
        var currentInstance = element.blazor__instance;
        if (!sf.base.isNullOrUndefined(currentInstance)) {
            currentInstance.destroy();
        }
    },
    eventInterval: 80,
    dotnetref: {},
    getScrollEventArgs: function (e, lastScrollbar) {
        if (lastScrollbar === void 0) { lastScrollbar = false; }
        var clientX = e.changedTouches ? e.changedTouches[0].clientX :
            e.clientX;
        var clientY = e.changedTouches ? e.changedTouches[0].clientY :
            e.clientY;
        var mouseXY = this.setScrollMouseXY(clientX, clientY, e.target['id'], lastScrollbar);
        var touches = e.touches; //pointerId
        var touchList = [];
        if (e.type.indexOf('touch') > -1) {
            for (var i = 0, length_2 = touches.length; i < length_2; i++) {
                touchList.push({ pageX: touches[i].clientX, pageY: touches[i].clientY, pointerId: e.pointerId || 0 });
            }
        }
        var id = e.target.id;
        id = id.indexOf('scrollBar') > -1 ? id : this.svgId;
        return {
            type: e.type,
            clientX: e.clientX,
            clientY: e.clientY,
            mouseX: mouseXY.mouseX,
            mouseY: mouseXY.mouseY,
            pointerType: e.pointerType,
            target: id,
            changedTouches: {
                clientX: e.changedTouches ? e.changedTouches[0].clientX : 0,
                clientY: e.changedTouches ? e.changedTouches[0].clientY : 0
            },
            touches: touchList,
            pointerId: e.pointerId
        };
    },
    getScrollWheelArgs: function (e) {
        var mouseXY = this.setScrollMouseXY(e.clientX, e.clientY, e.currentTarget['id']);
        return {
            detail: e.detail,
            wheelDelta: e['wheelDelta'],
            target: e.currentTarget ? e.currentTarget['id'] : e.srcElement ? e.srcElement['id'] : e.target ? e.target['id'] : '',
            clientX: e.clientX,
            clientY: e.clientY,
            mouseX: mouseXY.mouseX,
            mouseY: mouseXY.mouseY,
            browserName: sf.base.Browser.info.name,
            isPointer: sf.base.Browser.isPointer
        };
    },
    svgId: null,
    setScrollMouseXY: function (pageX, pageY, id, lastScrollbar) {
        if (lastScrollbar === void 0) { lastScrollbar = false; }
        this.svgId = !lastScrollbar ? id : this.svgId;
        if (!lastScrollbar && id.indexOf('_scrollBar_svg') === -1) {
            var chartId_1 = id.split('_scrollBar')[0];
            var splitId = id.split('_');
            this.svgId = chartId_1 + '_scrollBar_svg' + splitId[splitId.length - 1];
            this.dotnetref = this.dotnetrefCollection.find(function (item) { return chartId_1 === item.id; }).dotnetref;
        }
        var svgRect = this.getElement(this.svgId).getBoundingClientRect();
        var mouseX = pageX - Math.max(svgRect.left, 0);
        var mouseY = pageY - Math.max(svgRect.top, 0);
        return { mouseX: mouseX, mouseY: mouseY };
    },
    scrollMouseDown: function (event) {
        var evtArgs = this.getScrollEventArgs(event);
        this.dotnetref.invokeMethodAsync('ScrollMouseDown', evtArgs);
        return false;
    },
    scrollMouseMove: function (event) {
        var _this = this;
        throttle(function () {
            var evtArgs = _this.getScrollEventArgs(event);
            _this.dotnetref.invokeMethodAsync('ScrollMouseMove', evtArgs);
        }, this.eventInterval);
        return false;
    },
    scrollMouseUp: function (event) {
        var evtArgs = this.getScrollEventArgs(event);
        this.dotnetref.invokeMethodAsync('ScrollMouseUp', evtArgs);
        this.svgId = null;
        return false;
    },
    scrollMouseWheel: function (event) {
        var _this = this;
        throttle(function () {
            var evtArgs = _this.getScrollWheelArgs(event);
            _this.dotnetref.invokeMethodAsync('ScrollMouseWheel', evtArgs);
        }, this.eventInterval);
        return false;
    },
    dotnetrefCollection: [],
    renderTooltip: function (tooltipOptions, elementId, tooltipModule, element) {
        var svgElement = document.getElementById(elementId + '_svg');
        var firstRender = svgElement && parseInt(svgElement.getAttribute('opacity'), 10) > 0 ? false : true;
        var options = JSON.parse(tooltipOptions);
        var currentInstance = element.blazor__instance;
        if (firstRender && !sf.base.isNullOrUndefined(currentInstance)) {
            currentInstance.tooltip = new sf.svgbase.Tooltip(options);
            currentInstance.tooltip.appendTo('#' + elementId);
            currentInstance.tooltip.tooltipRender = function () {
                tooltipModule.invokeMethodAsync('TooltipRender');
            };
            currentInstance.tooltip.animationComplete = function (args) {
                if (args.tooltip.fadeOuted) {
                    tooltipModule.invokeMethodAsync('TooltipAnimationComplete');
                }
            };
        }
        else if (!sf.base.isNullOrUndefined(currentInstance.tooltip)) {
            currentInstance.tooltip.location = new sf.svgbase.TooltipLocation(options.location.x, options.location.y);
            currentInstance.tooltip.content = options.content;
            currentInstance.tooltip.header = options.header;
            currentInstance.tooltip.offset = options.offset;
            currentInstance.tooltip.palette = options.palette;
            currentInstance.tooltip.shapes = options.shapes;
            currentInstance.tooltip.data = options.data;
            currentInstance.tooltip.template = options.template;
            currentInstance.tooltip.textStyle.color = options.textStyle.color || currentInstance.tooltip.textStyle.color;
            currentInstance.tooltip.textStyle.fontFamily = options.textStyle.fontFamily || currentInstance.tooltip.textStyle.fontFamily;
            currentInstance.tooltip.textStyle.fontStyle = options.textStyle.fontStyle || currentInstance.tooltip.textStyle.fontStyle;
            currentInstance.tooltip.textStyle.fontWeight = options.textStyle.fontWeight || currentInstance.tooltip.textStyle.fontWeight;
            currentInstance.tooltip.textStyle.opacity = options.textStyle.opacity || currentInstance.tooltip.textStyle.opacity;
            currentInstance.tooltip.textStyle.size = options.textStyle.size || currentInstance.tooltip.textStyle.size;
            currentInstance.tooltip.isNegative = options.isNegative;
            currentInstance.tooltip.clipBounds = new sf.svgbase.TooltipLocation(options.clipBounds.x, options.clipBounds.y);
            currentInstance.tooltip.arrowPadding = options.arrowPadding;
            currentInstance.tooltip.dataBind();
        }
    },
    fadeOut: function (element) {
        if (!element || sf.base.isNullOrUndefined(element.blazor__instance) ||
            (!sf.base.isNullOrUndefined(element.blazor__instance) && sf.base.isNullOrUndefined(element.blazor__instance.tooltip))) {
            return;
        }
        this.removeTooltipCommentElement(element);
        element.blazor__instance.tooltip.fadeOut();
    },
    removeTooltipCommentElement: function (chartInstance) {
        var tooltipDivElement = this.getElement(chartInstance.blazor__instance.tooltip.element.id);
        if (tooltipDivElement && !chartInstance.blazor__instance.isRemoveCommentElement && tooltipDivElement.childNodes.length > 1) {
            var tooltipElements = tooltipDivElement.childNodes;
            var commentElements = [];
            for (var i = 0; i < tooltipElements.length; i++) {
                if (tooltipElements[i].nodeName.match('#comment') || tooltipElements[i].nodeName.match('#text')) {
                    commentElements.push(tooltipElements[i]);
                }
            }
            for (var _i = 0, commentElements_1 = commentElements; _i < commentElements_1.length; _i++) {
                var element = commentElements_1[_i];
                sf.base.remove(element);
                chartInstance.blazor__instance.isRemoveCommentElement = true;
            }
        }
    },
    getParentElementBoundsById: function (id) {
        var element = document.getElementById(id);
        if (element) {
            element.style.width = '100%';
            element.style.height = '100%';
            var elementRect = element.getBoundingClientRect();
            return {
                width: elementRect.width || element.clientWidth || element.offsetWidth,
                height: elementRect.height || element.clientHeight || element.offsetHeight,
                left: elementRect.left,
                top: elementRect.top,
                right: elementRect.right,
                bottom: elementRect.bottom
            };
        }
        return { width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
    },
    getElementBoundsById: function (id, isSetId) {
        if (isSetId === void 0) { isSetId = true; }
        if (isSetId) {
            this.id = id;
        }
        var element = document.getElementById(id);
        if (element) {
            var elementRect = element.getBoundingClientRect();
            return {
                width: element.clientWidth || element.offsetWidth,
                height: element.clientHeight || element.offsetHeight,
                left: elementRect.left,
                top: elementRect.top,
                right: elementRect.right,
                bottom: elementRect.bottom
            };
        }
        return { width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
    },
    getBrowserDeviceInfo: function () {
        return {
            browserName: sf.base.Browser.info.name,
            isPointer: sf.base.Browser.isPointer,
            isDevice: sf.base.Browser.isDevice,
            isTouch: sf.base.Browser.isTouch,
            isIos: sf.base.Browser.isIos || sf.base.Browser.isIos7
        };
    },
    setZoomingCipPath: function (seriesCollection, indicator, clipUrl) {
        var seriesEle = document.getElementById(seriesCollection);
        var indicatorEle = document.getElementById(indicator);
        if (seriesEle) {
            seriesEle.setAttribute('clip-path', clipUrl);
        }
        if (indicatorEle) {
            seriesEle.setAttribute('clip-path', clipUrl);
        }
    },
    setZoomingElementAttributes: function (translate, category, seriesG, errorbarG, symbolG, textG, shapeG, element) {
        if (category === 'Indicator' && seriesG && seriesG.parentElement) {
            seriesG.parentElement.setAttribute('transform', translate);
        }
        if (seriesG) {
            seriesG.setAttribute('transform', translate);
        }
        if (errorbarG) {
            errorbarG.setAttribute('transform', translate);
        }
        if (symbolG) {
            symbolG.setAttribute('transform', translate);
        }
        if (textG) {
            textG.setAttribute('visibility', 'hidden');
        }
        if (shapeG) {
            shapeG.setAttribute('visibility', 'hidden');
        }
        if (element) {
            element.style.visibility = 'hidden';
        }
    },
    measureBreakText: function (text, size, color, fontFamily, fontWeight, fontStyle, opacity) {
        var font = {
            color: color, size: size, fontFamily: fontFamily,
            fontWeight: fontWeight, fontStyle: fontStyle, opacity: parseInt(opacity, 10)
        };
        return sf.svgbase.measureText(text, font);
    },
    getAllCharacters: function () {
        var charCollection = [];
        for (var i = 33; i < 591; i++) {
            charCollection.push(String.fromCharCode(i));
        }
        return charCollection;
    },
    measureText: function (text, fontWeight, fontStyle, fontFamily) {
        var textObject = document.getElementById('sfchartmeasuretext');
        if (textObject === null) {
            textObject = sf.base.createElement('text', { id: 'sfchartmeasuretext' });
            document.body.appendChild(textObject);
        }
        if (text === ' ') {
            text = '&nbsp;';
        }
        textObject.innerHTML = text;
        textObject.style.position = 'fixed';
        textObject.style.fontSize = '100px';
        textObject.style.fontWeight = fontWeight;
        textObject.style.fontStyle = fontStyle;
        textObject.style.fontFamily = fontFamily;
        textObject.style.visibility = 'hidden';
        textObject.style.top = '-100';
        textObject.style.left = '0';
        textObject.style.whiteSpace = 'nowrap';
        textObject.style.lineHeight = 'normal';
        return {
            Width: textObject.clientWidth,
            Height: textObject.clientHeight
        };
    },
    getCharCollectionSize: function (fontkeys) {
        var charSizeList = [];
        var charSize;
        var tempSizeList = {};
        var charList = this.getAllCharacters();
        var charLength = charList.length;
        var fontKeysLength = fontkeys.length;
        for (var i = 0; i < fontKeysLength; i++) {
            var fontValues = fontkeys[i].split('_');
            var fontWeight = fontValues[0];
            var fontStyle = fontValues[1];
            var fontFamily = fontValues[2];
            for (var j = 0; j < charLength; j++) {
                charSize = this.measureText(charList[j], fontWeight, fontStyle, fontFamily);
                tempSizeList[charList[j]] = { X: charSize.Width, Y: charSize.Height };
            }
            charSizeList.push(tempSizeList);
        }
        var result = JSON.stringify(charSizeList);
        return result;
    },
    getCharSizeByFontKeys: function (fontkeys) {
        var charSizeList = {};
        var fontKeysLength = fontkeys.length;
        var fontValues = [];
        var charSize;
        for (var i = 0; i < fontKeysLength; i++) {
            fontValues = fontkeys[i].split('_');
            charSize = this.measureText(fontValues[0], fontValues[1], fontValues[2], fontValues[3]);
            charSizeList[fontkeys[i]] = { X: charSize.Width, Y: charSize.Height };
        }
        var result = JSON.stringify(charSizeList);
        return result;
    },
    getElementRect: function (id) {
        var element = document.getElementById(id);
        var rect = element.getBoundingClientRect();
        sf.base.remove(element);
        return {
            Left: rect.left,
            Right: rect.right,
            Top: rect.top,
            Bottom: rect.bottom,
            Width: rect.width,
            Height: rect.height
        };
    },
    getElement: function (id) {
        return document.getElementById(id);
    },
    drawTrackBall: function (svgId, option, tagName, className, clipPath, transform) {
        var parentElement = this.getElement(svgId);
        if (parentElement) {
            var childElement = document.createElementNS('http://www.w3.org/2000/svg', tagName);
            var keys = Object.keys(option);
            var key = '';
            for (var i = 0; i < keys.length; i++) {
                key = (keys[i] === 'strokeWidth') ? 'stroke-width' : (keys[i] === 'strokeDashArray') ?
                    'stroke-dashArray' : (keys[i] === 'direction') ? 'd' : keys[i];
                childElement.setAttribute(key, option[keys[i]]);
            }
            childElement.setAttribute('class', className);
            childElement.setAttribute('clip-path', clipPath);
            childElement.setAttribute('transform', transform);
            parentElement.appendChild(childElement);
        }
    },
    removeHighLightedMarker: function (className) {
        var elements = document.getElementsByClassName(className);
        for (var i = 0, len = elements.length; i < len; i++) {
            sf.base.remove(elements[0]);
        }
    },
    setAttribute: function (id, attribute, value) {
        var element = this.getElement(id);
        if (element) {
            element.setAttribute(attribute, value);
        }
    },
    createTooltip: function (id, text, top, left, fontSize) {
        var tooltip = document.getElementById(id);
        var style = 'top:' + ((window.scrollY || 0) + top).toString() + 'px;' +
            'left:' + left.toString() + 'px;' +
            'color:black !important; ' +
            'background:#FFFFFF !important; ' +
            'position:absolute;border:1px solid #707070;font-size:' + fontSize + ';border-radius:2px; z-index:1';
        if (!tooltip) {
            tooltip = sf.base.createElement('div', {
                id: id, innerHTML: '&nbsp;' + text + '&nbsp;', styles: style
            });
            document.body.appendChild(tooltip);
        }
        else {
            tooltip.setAttribute('innerHTML', '&nbsp;' + text + '&nbsp;');
            tooltip.setAttribute('styles', style);
        }
    },
    removeElement: function (id) {
        var element = this.getElement(id);
        if (element) {
            sf.base.remove(element);
        }
    },
    applySelection: function (id, color) {
        var elements = document.getElementById(id);
        var childNodes;
        if (elements && elements.childNodes) {
            childNodes = elements.childNodes;
            for (var i = 1, length_3 = childNodes.length; i < length_3; i++) {
                if (childNodes[i] && childNodes[i].tagName !== 'rect' && childNodes[i].setAttribute) {
                    childNodes[i].setAttribute('fill', color);
                }
            }
        }
    },
    getAndSetTextContent: function (id, get, value) {
        var element = document.getElementById(id);
        if (element) {
            if (get) {
                return element.textContent;
            }
            else {
                element.textContent = value;
            }
        }
        return null;
    },
    doProgressiveAnimation: function (id, clipId, duration, delay, strokeDashArray) {
        var clipElement = this.getElement(clipId);
        var path = this.getElement(id);
        var animation = new sf.base.Animation({});
        var pathLength = path.getTotalLength();
        var currentTime;
        path.setAttribute('visibility', 'hidden');
        animation.animate(path, {
            duration: duration + delay,
            delay: delay,
            progress: function (args) {
                clipElement.setAttribute('visibility', 'visible');
                if (args.timeStamp >= args.delay) {
                    path.setAttribute('visibility', 'visible');
                    currentTime = Math.abs(Math.round(((args.timeStamp - args.delay) * pathLength) / args.duration));
                    path.setAttribute('stroke-dasharray', currentTime + ',' + pathLength);
                }
            },
            end: function () {
                path.setAttribute('stroke-dasharray', strokeDashArray);
            }
        });
    },
    linear: function (currentTime, startValue, endValue, duration) {
        return -endValue * Math.cos(currentTime / duration * (Math.PI / 2)) + endValue + startValue;
    },
    doLinearAnimation: function (id, duration, delay, isInverted) {
        var clipRect = this.getElement(id);
        var animation = new sf.base.Animation({});
        var effect = this.linear;
        var elementHeight = +clipRect.getAttribute('height');
        var elementWidth = +clipRect.getAttribute('width');
        var xCenter = +clipRect.getAttribute('x');
        var yCenter = isInverted ? +clipRect.getAttribute('height') + +clipRect.getAttribute('y') :
            +clipRect.getAttribute('y');
        var value;
        animation.animate(clipRect, {
            duration: duration,
            delay: delay,
            progress: function (args) {
                if (args.timeStamp >= args.delay) {
                    clipRect.setAttribute('visibility', 'visible');
                    if (isInverted) {
                        value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +
                            ') scale(1,' + (value / elementHeight) + ') translate(' + (-xCenter) + ' ' + (-yCenter) + ')');
                    }
                    else {
                        value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                        clipRect.setAttribute('transform', 'translate(' + xCenter + ' ' + yCenter +
                            ') scale(' + (value / elementWidth) + ', 1) translate(' + (-xCenter) + ' ' + (-yCenter) + ')');
                    }
                }
            },
            end: function () {
                clipRect.setAttribute('transform', 'translate(0,0)');
            }
        });
    },
    filterCommentElement: function (id) {
        var element = this.getElement(id);
        if (!element) {
            return null;
        }
        var groupElement = element.childNodes;
        var pathElement = [];
        for (var i = 0; i < groupElement.length; i++) {
            if (!groupElement[i].nodeName.match('#comment')) {
                pathElement.push(groupElement[i]);
            }
        }
        return pathElement;
    },
    doInitialAnimation: function (info) {
        for (var infoIndex = 0; infoIndex < info.length; infoIndex++) {
            switch (info[infoIndex].type) {
                case 'Rect':
                    var seriesClipPath = this.getElement(info[infoIndex].clipPathId);
                    var seriesPathElement = this.filterCommentElement(info[infoIndex].elementId);
                    for (var i = 0; i < info[infoIndex].pointIndex.length; i++) {
                        this.doRectAnimation(seriesPathElement[info[infoIndex].pointIndex[i]], seriesClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[i], info[infoIndex].pointY[i], info[infoIndex].pointWidth[i], info[infoIndex].pointHeight[i], info[infoIndex].isInvertedAxis);
                    }
                    break;
                case 'Progressive':
                    this.doProgressiveAnimation(info[infoIndex].elementId, info[infoIndex].clipPathId, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].strokeDashArray);
                    break;
                case 'Linear':
                    this.doLinearAnimation(info[infoIndex].elementId, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].isInvertedAxis);
                    break;
                case 'Marker':
                    var markerClipPath = this.getElement(info[infoIndex].clipPathId);
                    var markerElement = this.filterCommentElement(info[infoIndex].elementId);
                    for (var i = 0; i < info[infoIndex].pointIndex.length; i++) {
                        this.doMarkerAnimate(markerElement[info[infoIndex].pointIndex[i]], markerClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[i], info[infoIndex].pointY[i]);
                    }
                    break;
                case 'PolarRadar':
                    var polarseriesClipPath = this.getElement(info[infoIndex].clipPathId);
                    var polarseriesPathElement = this.filterCommentElement(info[infoIndex].elementId);
                    for (var i = 0; i < polarseriesPathElement.length; i++) {
                        this.doPolarRadarAnimation(polarseriesPathElement[i], polarseriesClipPath, info[infoIndex].duration, info[infoIndex].delay, info[infoIndex].pointX[0], info[infoIndex].pointY[0]);
                    }
                    break;
            }
            if (!sf.base.isNullOrUndefined(info[infoIndex].markerInfo)) {
                var markerClipPath = this.getElement(info[infoIndex].markerInfo.markerClipPathId);
                var markerElement = this.filterCommentElement(info[infoIndex].markerInfo.markerElementId);
                for (var i = 0; i < info[infoIndex].markerInfo.pointIndex.length; i++) {
                    this.doMarkerAnimate(markerElement[info[infoIndex].markerInfo.pointIndex[i]], markerClipPath, 200, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].markerInfo.pointX[i], info[infoIndex].markerInfo.pointY[i]);
                    if (info[infoIndex].markerInfo.lowPointIndex.length > 0) {
                        this.doMarkerAnimate(markerElement[info[infoIndex].markerInfo.lowPointIndex[i]], markerClipPath, 200, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].markerInfo.lowPointX[i], info[infoIndex].markerInfo.lowPointY[i]);
                    }
                }
            }
            if (!sf.base.isNullOrUndefined(info[infoIndex].dataLabelInfo)) {
                if (info[infoIndex].dataLabelInfo.templateId.length === 0) {
                    this.doDataLabelAnimation(info[infoIndex].dataLabelInfo.shapeGroupId, info[infoIndex].dataLabelInfo.textGroupId, '', info[infoIndex].clipPathId, 200, info[infoIndex].duration + info[infoIndex].delay);
                }
                else {
                    for (var i = 0; i < info[infoIndex].dataLabelInfo.templateId.length; i++) {
                        this.doDataLabelAnimation('', '', info[infoIndex].dataLabelInfo.templateId[i], '', 200, info[infoIndex].duration + info[infoIndex].delay);
                    }
                }
            }
            if (!sf.base.isNullOrUndefined(info[infoIndex].errorBarInfo)) {
                this.doErrorBarAnimation(info[infoIndex].errorBarInfo.errorBarElementId, info[infoIndex].errorBarInfo.errorBarClipPathId, info[infoIndex].duration + info[infoIndex].delay, info[infoIndex].isInvertedAxis);
            }
        }
    },
    doDynamicAnimation: function (pathInfo, rectInfo, textInfo) {
        for (var pathIndex = 0; pathIndex < pathInfo.length; pathIndex++) {
            if (!sf.base.isNullOrUndefined(pathInfo[pathIndex].previousDir) && pathInfo[pathIndex].previousDir !== '' && !sf.base.isNullOrUndefined(pathInfo[pathIndex].currentDir) && pathInfo[pathIndex].currentDir !== '') {
                this.pathAnimation(pathInfo[pathIndex].id, pathInfo[pathIndex].currentDir, true, pathInfo[pathIndex].previousDir, 300);
            }
        }
        for (var rectIndex = 0; rectIndex < rectInfo.length; rectIndex++) {
            this.animateRectElement(rectInfo[rectIndex].id, 0, 300, rectInfo[rectIndex].currentRect, rectInfo[rectIndex].previousRect);
        }
        for (var textIndex = 0; textIndex < textInfo.length; textIndex++) {
            this.animateRedrawElement(textInfo[textIndex].id, 300, textInfo[textIndex].preLocationX, textInfo[textIndex].preLocationY, textInfo[textIndex].curLocationX, textInfo[textIndex].curLocationY, textInfo[textIndex].x, textInfo[textIndex].y);
        }
    },
    doRectAnimation: function (element, clipPathElement, duration, delay, centerX, centerY, elementWidth, elementHeight, isInverted) {
        var effect = this.linear;
        var value;
        if (!sf.base.isNullOrUndefined(element)) {
            element.setAttribute('visibility', 'hidden');
            new sf.base.Animation({}).animate(element, {
                duration: duration,
                delay: delay,
                progress: function (args) {
                    clipPathElement.setAttribute('visibility', 'visible');
                    if (args.timeStamp >= args.delay) {
                        element.setAttribute('visibility', 'visible');
                        if (!isInverted) {
                            elementHeight = elementHeight ? elementHeight : 1;
                            value = effect(args.timeStamp - args.delay, 0, elementHeight, args.duration);
                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
                                ') scale(1,' + (value / elementHeight) + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');
                        }
                        else {
                            elementWidth = elementWidth ? elementWidth : 1;
                            value = effect(args.timeStamp - args.delay, 0, elementWidth, args.duration);
                            element.setAttribute('transform', 'translate(' + centerX + ' ' + centerY +
                                ') scale(' + (value / elementWidth) + ', 1) translate(' + (-centerX) + ' ' + (-centerY) + ')');
                        }
                    }
                },
                end: function () {
                    element.setAttribute('transform', 'translate(0,0)');
                }
            });
        }
    },
    doMarkerAnimate: function (element, clipPathElement, duration, delay, centerX, centerY) {
        var height = 0;
        if (!element) {
            return;
        }
        element.setAttribute('visibility', 'hidden');
        new sf.base.Animation({}).animate(element, {
            duration: duration,
            delay: delay,
            progress: function (args) {
                clipPathElement.setAttribute('visibility', 'visible');
                if (args.timeStamp > args.delay) {
                    element.setAttribute('visibility', 'visible');
                    height = ((args.timeStamp - args.delay) / args.duration);
                    element.setAttribute('transform', 'translate(' + centerX
                        + ' ' + centerY + ') scale(' + height + ') translate(' + (-centerX) + ' ' + (-centerY) + ')');
                }
            },
            end: function () {
                element.setAttribute('visibility', '');
            }
        });
    },
    doPolarRadarAnimation: function (element, clipPathElement, duration, delay, chartcenterX, chartcenterY) {
        var elementHeight = 0;
        element.setAttribute('visibility', 'hidden');
        new sf.base.Animation({}).animate(element, {
            duration: duration,
            delay: delay,
            progress: function (args) {
                clipPathElement.setAttribute('visibility', 'visible');
                if (args.timeStamp > args.delay) {
                    element.setAttribute('visibility', 'visible');
                    elementHeight = ((args.timeStamp - args.delay) / args.duration);
                    element.setAttribute('transform', 'translate(' + chartcenterX + ' ' + chartcenterY +
                        ') scale(' + elementHeight + ') translate(' + (-chartcenterX) + ' ' + (-chartcenterY) + ')');
                }
            },
            end: function () {
                element.setAttribute('visibility', 'visible');
                element.removeAttribute('transform');
            }
        });
    },
    templateAnimate: function (element, delay, duration, name, isRemove, clipElement) {
        new sf.base.Animation({}).animate(element, {
            duration: duration,
            delay: delay,
            name: name,
            progress: function (args) {
                if (clipElement) {
                    clipElement.setAttribute('visibility', 'visible');
                }
                args.element.style.visibility = 'visible';
            },
            end: function (args) {
                if (isRemove) {
                    sf.base.remove(args.element);
                }
                else {
                    args.element.style.visibility = 'visible';
                }
            }
        });
    },
    doDataLabelAnimation: function (shapeId, textId, tempId, clipId, duration, delay) {
        var shapeElements = this.filterCommentElement(shapeId);
        var textElements = this.filterCommentElement(textId);
        var clipPathElement = this.getElement(clipId);
        var tempElement = this.getElement(tempId);
        var centerX;
        var centerY;
        var length = tempElement ? 1 : textElements.length;
        var element;
        for (var i = 0; i < length; i++) {
            if (tempElement) {
                tempElement.style.visibility = 'hidden';
                this.templateAnimate(tempElement, delay, duration, 'ZoomIn');
            }
            else {
                element = textElements[i];
                centerX = (+element.getAttribute('x')) + ((+element.getAttribute('width')) / 2);
                centerY = (+element.getAttribute('y')) + ((+element.getAttribute('height')) / 2);
                this.doMarkerAnimate(textElements[i], clipPathElement, duration, delay, centerX, centerY);
                if (shapeElements[i]) {
                    element = shapeElements[i];
                    centerX = (+element.getAttribute('x')) + ((+element.getAttribute('width')) / 2);
                    centerY = (+element.getAttribute('y')) + ((+element.getAttribute('height')) / 2);
                    this.doMarkerAnimate(shapeElements[i], clipPathElement, duration, delay, centerX, centerY);
                }
            }
        }
    },
    pathAnimation: function (id, direction, redraw, previousDirection, animateDuration) {
        var _this = this;
        var element = this.getElement(id);
        if (!redraw || element == null) {
            return null;
        }
        var duration = 300;
        if (animateDuration) {
            duration = animateDuration;
        }
        var startDirections = previousDirection || element.getAttribute('d');
        var splitDirections = startDirections.split(/(?=[LMCZAQ])/);
        var endDirections = direction.split(/(?=[LMCZAQ])/);
        var currentDireciton;
        var startPath = [];
        var endPath = [];
        var c;
        var end;
        element.setAttribute('d', startDirections);
        new sf.base.Animation({}).animate(sf.base.createElement('div'), {
            duration: duration,
            progress: function (args) {
                currentDireciton = '';
                splitDirections.map(function (directions, index) {
                    startPath = directions.split(' ');
                    endPath = endDirections[index] ? endDirections[index].split(' ') : startPath;
                    if (startPath[0] === 'Z') {
                        currentDireciton += 'Z' + ' ';
                    }
                    else {
                        currentDireciton += startPath[0] + ' ' +
                            _this.linear(args.timeStamp, +startPath[1], (+endPath[1] - +startPath[1]), args.duration) + ' ' +
                            _this.linear(args.timeStamp, +startPath[2], (+endPath[2] - +startPath[2]), args.duration) + ' ';
                    }
                    if (startPath[0] === 'C' || startPath[0] === 'Q') {
                        c = 3;
                        end = startPath[0] === 'Q' ? 4 : 6;
                        while (c < end) {
                            currentDireciton += _this.linear(args.timeStamp, +startPath[c], (+endPath[c] - +startPath[c]), args.duration)
                                + ' ' + _this.linear(args.timeStamp, +startPath[++c], (+endPath[c] - +startPath[c]), args.duration) + ' ';
                            ++c;
                        }
                    }
                    if (startPath[0] === 'A') {
                        currentDireciton += 0 + ' ' + 0 + ' ' + 1 + ' ' +
                            _this.linear(args.timeStamp, +startPath[6], (+endPath[6] - +startPath[6]), args.duration) + ' ' +
                            _this.linear(args.timeStamp, +startPath[7], (+endPath[7] - +startPath[7]), args.duration) + ' ';
                    }
                });
                element.setAttribute('d', currentDireciton);
            },
            end: function () {
                element.setAttribute('d', direction);
            }
        });
    },
    getPreviousDirection: function (id) {
        var element = this.getElement(id);
        var previousDirection = element ? element.getAttribute('d') : null;
        return previousDirection;
    },
    getPreviousLocation: function (id, circlePath) {
        var element = this.getElement(id);
        var x = element ? +element.getAttribute(circlePath + 'x') : 0;
        var y = element ? +element.getAttribute(circlePath + 'y') : 0;
        return { X: x, Y: y };
    },
    animateRectElement: function (element, delay, duration, currentRect, previousRect) {
        var _this = this;
        var setStyle = function (rect) {
            element.setAttribute('x', rect.x + '');
            element.setAttribute('y', rect.y + '');
            element.setAttribute('width', rect.width + '');
            element.setAttribute('height', rect.height + '');
        };
        new sf.base.Animation({}).animate(sf.base.createElement('div'), {
            duration: duration,
            delay: delay,
            progress: function (args) {
                setStyle(new sf.svgbase.Rect(_this.linear(args.timeStamp, previousRect.x, currentRect.x - previousRect.x, args.duration), _this.linear(args.timeStamp, previousRect.y, currentRect.y - previousRect.y, args.duration), _this.linear(args.timeStamp, previousRect.width, currentRect.width - previousRect.width, args.duration), _this.linear(args.timeStamp, previousRect.height, currentRect.height - previousRect.height, args.duration)));
            },
            end: function () {
                setStyle(currentRect);
            }
        });
    },
    animateRedrawElement: function (elementId, duration, startX, startY, endX, endY, x, y) {
        var _this = this;
        if (x === void 0) { x = 'x'; }
        if (y === void 0) { y = 'y'; }
        var element = this.getElement(elementId);
        if (!element) {
            return null;
        }
        var isDiv = element.tagName === 'DIV';
        var setStyle = function (xValue, yValue) {
            if (isDiv) {
                element.style[x] = xValue + 'px';
                element.style[y] = yValue + 'px';
            }
            else {
                element.setAttribute(x, xValue + '');
                element.setAttribute(y, yValue + '');
            }
        };
        setStyle(startX, startY);
        new sf.base.Animation({}).animate(sf.base.createElement('div'), {
            duration: duration,
            progress: function (args) {
                setStyle(_this.linear(args.timeStamp, startX, endX - startX, args.duration), _this.linear(args.timeStamp, startY, endY - startY, args.duration));
            },
            end: function () {
                setStyle(endX, endY);
            }
        });
    },
    appendChildElement: function (parent, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, previousRect, animateDuration) {
        if (isAnimate === void 0) { isAnimate = false; }
        if (x === void 0) { x = 'x'; }
        if (y === void 0) { y = 'y'; }
        if (forceAnimate === void 0) { forceAnimate = false; }
        if (isRect === void 0) { isRect = false; }
        if (previousRect === void 0) { previousRect = null; }
        var existChild = parent.querySelector('#' + childElement.id);
        var element = existChild || this.getElement(childElement.id);
        var child = childElement;
        var duration = animateDuration ? animateDuration : 300;
        if (redraw && isAnimate && element) {
            start = start || (element.tagName === 'DIV' ?
                new sf.svgbase.TooltipLocation(+(element.style[x].split('px')[0]), +(element.style[y].split('px')[0])) :
                new sf.svgbase.TooltipLocation(+element.getAttribute(x), +element.getAttribute(y)));
            if (direction !== '' && direction !== null) {
                this.pathAnimation(childElement, childElement.getAttribute('d'), redraw, direction, duration);
            }
            else if (isRect && previousRect) {
                this.animateRectElement(child, 0, duration, new sf.svgbase.Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')), previousRect);
            }
            else {
                var end = child.tagName === 'DIV' ?
                    new sf.svgbase.TooltipLocation(+(child.style[x].split('px')[0]), +(child.style[y].split('px')[0])) :
                    new sf.svgbase.TooltipLocation(+child.getAttribute(x), +child.getAttribute(y));
                this.animateRedrawElement(child, duration, start, end, x, y);
            }
        }
        else if (redraw && isAnimate && !element && forceAnimate) {
            this.templateAnimate(child, 0, 600, 'FadeIn');
        }
    },
    processAppendChild: function (parentId, childId, locationX, locationY, rectX, rectY, rectWidth, rectHeight, redraw, isAnimate, x, y, direction, forceAnimate, isRect, animateDuration) {
        if (isAnimate === void 0) { isAnimate = false; }
        if (x === void 0) { x = 'x'; }
        if (y === void 0) { y = 'y'; }
        if (forceAnimate === void 0) { forceAnimate = false; }
        if (isRect === void 0) { isRect = false; }
        var parentElement = this.getElement(parentId);
        var childElement = this.getElement(childId);
        var start = new sf.svgbase.TooltipLocation(locationX, locationY);
        var rect = new sf.svgbase.Rect(rectX, rectY, rectWidth, rectHeight);
        this.appendChildElement(parentElement, childElement, redraw, isAnimate, x, y, start, direction, forceAnimate, isRect, rect, animateDuration);
    },
    createStyleElement: function (styleId, styleInnerHTML) {
        document.body.appendChild(sf.base.createElement('style', {
            id: styleId,
            innerHTML: styleInnerHTML
        }));
    },
    isLassoId: function (x, y) {
        var lassoEle = document.elementFromPoint(x, y);
        return lassoEle ? lassoEle.id : '';
    },
    doErrorBarAnimation: function (id, clipId, delay, isInverted) {
        var errorBarElements = this.filterCommentElement(id);
        var clipElement = this.getElement(clipId);
        if (!errorBarElements) {
            return null;
        }
        var j = 1;
        while (j < errorBarElements.length) {
            errorBarElements[j].style.visibility = 'hidden';
            this.templateAnimate(errorBarElements[j], delay, 350, isInverted ? 'SlideLeftIn' : 'SlideBottomIn', false, clipElement);
            j++;
        }
    },
    getTemplateSize: function (id) {
        var element = this.getElement(id);
        if (element) {
            return {
                width: element.offsetWidth,
                height: element.offsetHeight
            };
        }
        return null;
    },
    resizeBound: {},
    resize: {},
    chartResize: function (dotnetrefCollection, e) {
        var _this = this;
        if (this.resize) {
            clearTimeout(this.resize);
        }
        this.resize = setTimeout(function () {
            var count = dotnetrefCollection.length;
            var tempDotnetref;
            var id;
            var element;
            var offsetSizeCollection = {};
            for (var i = 0; i < count; i++) {
                tempDotnetref = dotnetrefCollection[i].dotnetref;
                id = dotnetrefCollection[i].id;
                if (id.indexOf('_stockChart_') < 0 && document.getElementById(id + "_svg")) {
                    element = document.getElementById(id + "_svg");
                    element.style.display = "none";
                }
            }
            for (var i = 0; i < count; i++) {
                tempDotnetref = dotnetrefCollection[i].dotnetref;
                id = dotnetrefCollection[i].id;
                if (id.indexOf('_stockChart_') < 0 && document.getElementById(id)) {
                    element = document.getElementById(id);
                    offsetSizeCollection[id] = { Dotnetref: tempDotnetref, Width: element.clientWidth || element.offsetWidth, Height: element.clientHeight || element.offsetHeight };
                }
            }
            for (var key in offsetSizeCollection) {
                tempDotnetref = offsetSizeCollection[key].Dotnetref;
                element = document.getElementById(key + "_svg");
                element.style.display = "";
                tempDotnetref.invokeMethodAsync('OnChartResize', JSON.stringify({ Width: offsetSizeCollection[key].Width, Height: offsetSizeCollection[key].Height }));
            }
            clearTimeout(_this.resize);
        }, 500);
        return false;
    },
    getDatalabelTemplateSize: function (templateIdCollection) {
        var templateSizeList = [];
        var templateSize;
        var templateIdLength = templateIdCollection.length;
        for (var i = 0; i < templateIdLength; i++) {
            templateSize = this.getElementBoundsById(templateIdCollection[i], false);
            templateSizeList.push({ X: templateSize.width, Y: templateSize.height });
        }
        return JSON.stringify(templateSizeList);
    },
    setSvgDimensions: function (chartSVG, width, height) {
        chartSVG.setAttribute("width", width);
        chartSVG.setAttribute("height", height);
    }
};

return Chart;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-colorpicker.js":
/*!*****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-colorpicker.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.ColorPicker = (function () {
'use strict';

var HSV_CONTAINER = '.e-hsv-container';
var COLOR_PICKER = '.e-split-colorpicker';
var COLOR_PALETTE = 'e-color-palette';
var PALETTE = '.e-palette';
var HSV_COLOR = '.e-hsv-color';
var SET_OFFSET = 'SetOffset';
var DROPDOWN_BTN = '.e-dropdown-btn';
var HANDLER = '.e-handler';
var MODEL = '.e-colorpicker.e-modal';
var EMPTY = '';
var CONTAINER = '.e-container';
var SPLIT_BUTTON = '.sf-colorpicker';
var INPUTS = '.e-selected-value';
var CONTROL_BTN = '.e-switch-ctrl-btn';
var PIXEL = 'px';
var SCROLL = 'scroll';
var DEFAULT = '100%';
var PALETTES = 'e-palette';
var TILE = "e-tile";
var SELECT = 'e-selected';
var CLICK = 'Click';
var CLOSE = 'Close';
/**
 * Client side scripts for Blazor color picker
 */
var SfColorPicker = /** @class */ (function () {
    function SfColorPicker(element, dotnetRef, inline) {
        this.element = element;
        this.dotnetRef = dotnetRef;
        this.element.blazor__instance = this;
        if (inline) {
            this.addScrollEvents(true);
            this.setPaletteWidth(this.element.querySelector(CONTAINER), false);
        }
    }
    SfColorPicker.prototype.getOffset = function (element) {
        var colorPicker = element.querySelector(HSV_CONTAINER);
        if (!colorPicker) {
            return { IsDevice: sf.base.Browser.isDevice };
        }
        var offset = colorPicker.getBoundingClientRect();
        var color = colorPicker.querySelector(HSV_COLOR);
        var handler = colorPicker.querySelector(HANDLER);
        if (handler) {
            handler.focus();
        }
        return { Left: offset.left, Top: offset.top, Width: offset.width, Height: offset.height, Right: offset.right, ClientLeft: color.offsetLeft, ClientTop: color.offsetTop, ClientWidth: color.offsetWidth, ClientHeight: color.offsetHeight,
            IsDevice: sf.base.Browser.isDevice };
    };
    SfColorPicker.prototype.setOffset = function (element, zIndex) {
        var offset = this.getOffset(element);
        if (zIndex && !sf.base.Browser.isDevice) {
            this.setZIndex(this.element, zIndex, COLOR_PICKER);
            this.setZIndex(this.element, zIndex, DROPDOWN_BTN);
        }
        if (offset) {
            this.dotnetRef.invokeMethodAsync(SET_OFFSET, offset);
        }
    };
    SfColorPicker.prototype.setZIndex = function (element, zIndex, cls) {
        var btnEle = element.querySelector(cls);
        if (btnEle) {
            btnEle.style.zIndex = zIndex + 1 + EMPTY;
        }
    };
    SfColorPicker.prototype.setPaletteWidth = function (container, modeSwitch, zIndex) {
        if (sf.base.Browser.isDevice && !sf.base.isNullOrUndefined(zIndex)) {
            var model = container.querySelector(MODEL);
            if (model) {
                model.style.zIndex = (zIndex - 1) + EMPTY;
                document.body.insertBefore(model, container.parentElement);
                model.style.display = EMPTY;
            }
        }
        if (container.querySelector(HSV_CONTAINER)) {
            container.style.width = EMPTY;
        }
        else {
            var width = parseInt(getComputedStyle(container).borderBottomWidth, 10);
            container.style.width = container.children[0].offsetWidth + width + width + PIXEL;
            var containers = container.querySelector(INPUTS);
            if (containers) {
                containers.style.width = DEFAULT;
                containers = container.querySelector(CONTROL_BTN);
                if (containers) {
                    containers.style.width = DEFAULT;
                }
            }
        }
        if (modeSwitch) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var colorPickerBtn = this.element.querySelector(SPLIT_BUTTON);
            if (colorPickerBtn && !sf.base.isNullOrUndefined(colorPickerBtn.blazor__instance)) {
                colorPickerBtn.blazor__instance.setPosition(true);
            }
        }
    };
    SfColorPicker.prototype.scrollHandler = function (e) {
        if (!this.element.parentElement) {
            sf.base.EventHandler.remove(e.target, SCROLL, this.scrollHandler);
            return;
        }
        this.setOffset(this.element);
    };
    SfColorPicker.prototype.addScrollEvents = function (add) {
        var elements = sf.popups.getScrollableParent(this.element);
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element = elements_1[_i];
            add ? sf.base.EventHandler.add(element, SCROLL, this.scrollHandler, this) :
                sf.base.EventHandler.remove(element, SCROLL, this.scrollHandler);
        }
    };
    SfColorPicker.prototype.focusIn = function (element, inline) {
        if (inline) {
            var container = element.querySelector(CONTAINER);
            if (container) {
                if (container.classList.contains(COLOR_PALETTE)) {
                    this.setFocus(PALETTE);
                }
                else {
                    this.setFocus(HANDLER);
                }
            }
        }
        else {
            this.setFocus(COLOR_PICKER);
        }
    };
    SfColorPicker.prototype.setFocus = function (cls) {
        var btn = this.element.querySelector(cls);
        if (btn) {
            btn.focus();
        }
    };
    SfColorPicker.prototype.paletteKeyDown = function (e, Rtl) {
        var target = e.target;
        if (!target.classList.contains(PALETTES)) {
            return;
        }
        var selectedEle;
        var idx;
        var colorvalue;
        var tiles = [].slice.call(sf.base.selectAll('.' + TILE, target));
        var prevSelectedEle = (tiles.filter(function (tile) { return tile.classList.contains('e-selected'); })).pop();
        var container = target.parentElement;
        switch (!e.altKey && e.keyCode) {
            case 39:
                e.preventDefault();
                selectedEle = prevSelectedEle ? tiles[this.tilePosition(tiles, prevSelectedEle, Rtl ? -1 : 1)]
                    : tiles[Rtl ? tiles.length - 1 : 0];
                colorvalue = selectedEle.getAttribute("aria-label");
                this.keySelectionChanges(selectedEle, container, colorvalue);
                break;
            case 37:
                e.preventDefault();
                selectedEle = prevSelectedEle ? tiles[this.tilePosition(tiles, prevSelectedEle, Rtl ? 1 : -1)]
                    : tiles[Rtl ? 0 : tiles.length - 1];
                colorvalue = selectedEle.getAttribute("aria-label");
                this.keySelectionChanges(selectedEle, container, colorvalue);
                break;
            case 38:
                e.preventDefault();
                idx = prevSelectedEle ? this.tilePosition(tiles, prevSelectedEle, -10) : 0;
                selectedEle = tiles[idx] ? tiles[idx] : tiles[idx - 10];
                colorvalue = selectedEle.getAttribute("aria-label");
                this.keySelectionChanges(selectedEle, container, colorvalue);
                break;
            case 40:
                e.preventDefault();
                idx = prevSelectedEle ? this.tilePosition(tiles, prevSelectedEle, 10) : tiles.length - 1;
                if (tiles[idx]) {
                    selectedEle = tiles[idx];
                }
                else {
                    idx %= tiles.length;
                    idx += tiles[tiles.length - 1].parentElement.childElementCount;
                    selectedEle = tiles[idx];
                }
                colorvalue = selectedEle.getAttribute("aria-label");
                this.keySelectionChanges(selectedEle, container, colorvalue);
                break;
            case 13:
                e.preventDefault();
                if (prevSelectedEle) {
                    var cValue = prevSelectedEle.getAttribute('aria-label');
                    this.dotnetRef.invokeMethodAsync(CLOSE);
                }
        }
    };
    
    SfColorPicker.prototype.tilePosition = function (items, element, cIdx) {
        items = Array.prototype.slice.call(items);
        var n = items.length;
        var emptyCount = 10 - items[n - 1].parentElement.childElementCount;
        var idx = items.indexOf(element);
        idx += cIdx;
        if (idx < 0) {
            idx += n + emptyCount;
        }
        else {
            idx %= n + emptyCount;
        }
        return idx;
    };
    
    SfColorPicker.prototype.keySelectionChanges = function (newEle, container, colorvalue) {
        this.removeTileSelection(container);
        this.addTileSelection(newEle);
        this.dotnetRef.invokeMethodAsync(CLICK, colorvalue);
    };
    
    SfColorPicker.prototype.removeTileSelection = function (container) {
        var selectedEle = [].slice.call(sf.base.selectAll('.' + SELECT, container.children[0]));
        selectedEle.forEach(function (ele) {
            ele.classList.remove(SELECT);
            ele.setAttribute('aria-selected', 'false');
        });
    };
    
    SfColorPicker.prototype.addTileSelection = function (ele) {
        ele.classList.add(SELECT);
        ele.setAttribute('aria-selected', 'true');
    };
    
    return SfColorPicker;
}());
// eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle, id-blacklist, id-match
var ColorPicker = {
    initialize: function (element, dotnetRef, inline) {
        if (!sf.base.isNullOrUndefined(element)) {
            new SfColorPicker(element, dotnetRef, inline);
            return element.blazor__instance.getOffset(element);
        }
        return null;
    },
    getOffset: function (element, container) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance) && !sf.base.isNullOrUndefined(container)) {
            element.blazor__instance.setPaletteWidth(container, true);
            return element.blazor__instance.getOffset(container);
        }
        return null;
    },
    focusIn: function (element, inline) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.focusIn(element, inline);
        }
    },
    destroy: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.addScrollEvents(false);
        }
    }
};

return ColorPicker;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-contextmenu.js":
/*!*****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-contextmenu.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.ContextMenu = (function () {
'use strict';

var MENUITEM$1 = 'e-menu-item';
var FOCUSED$1 = 'e-focused';
var SELECTED$1 = 'e-selected';
var CONTAINER = 'e-menu-container';
var MENU$1 = 'e-contextmenu';
var SUBMENU = 'e-ul';
var SEPARATOR = 'e-separator';
var DISABLED = 'e-disabled';
var HIDE = 'e-menu-hide';
var MENUPARENT = 'e-menu-parent';
var RTL = 'e-rtl';
var HAMBURGER = '.e-hamburger';
var SCROLLMENU$1 = '.e-menu-vscroll';
var NONE$1 = 'none';
var DOT$1 = '.';
var ESC = 27;
var ENTER = 13;
var UP = 38;
var DOWN = 40;
var LEFT = 37;
var RIGHT = 39;
/**
 * Keyboard action handler common for menu and context menu.
 * @hidden
 */
function keyActionHandler(container, target, keyCode, menuId) {
    if (keyCode === DOWN || keyCode === UP) {
        var index = void 0;
        var ul = void 0;
        var focusedLi = void 0;
        if (target.classList.contains(MENUPARENT)) {
            ul = target;
            focusedLi = ul.querySelector("" + DOT$1 + MENUITEM$1 + DOT$1 + FOCUSED$1);
            if (focusedLi) {
                index = Array.prototype.indexOf.call(ul.children, focusedLi);
                index = keyCode === DOWN ? (index === ul.childElementCount - 1 ? 0 : index + 1) :
                    (index === 0 ? ul.childElementCount - 1 : index - 1);
            }
            else {
                index = 0;
            }
            index = isValidLI(ul, index, keyCode === DOWN);
        }
        else if (target.classList.contains(MENUITEM$1)) {
            ul = target.parentElement;
            focusedLi = ul.querySelector("" + DOT$1 + MENUITEM$1 + DOT$1 + FOCUSED$1);
            index = Array.prototype.indexOf.call(ul.children, focusedLi ? focusedLi : target);
            index = keyCode === DOWN ? (index === ul.childElementCount - 1 ? 0 : index + 1) : (index === 0 ?
                ul.childElementCount - 1 : index - 1);
            index = isValidLI(ul, index, keyCode === DOWN);
        }
        if (ul && index !== -1) {
            ul.children[index].focus();
        }
    }
    else if (((container.classList.contains(RTL) ? keyCode === RIGHT : keyCode === LEFT) || keyCode === ESC ||
        (keyCode === ENTER && sf.base.closest(target, DOT$1 + CONTAINER))) && (target.classList.contains(SUBMENU) ||
        (target.classList.contains(MENUITEM$1) && !(target.parentElement.classList.contains(MENU$1))))) {
        var menuContainer = void 0;
        if (menuId) {
            menuContainer = sf.base.select(menuId);
        }
        var ul = target.classList.contains(SUBMENU) ? target : target.parentElement;
        var menu = sf.base.closest(ul, SCROLLMENU$1);
        var selectedLi = void 0;
        var previousUl = menu ? menu.previousElementSibling : ul.previousElementSibling;
        if (menuContainer && (!previousUl || keyCode === ENTER)) {
            selectedLi = sf.base.select("" + DOT$1 + MENUITEM$1 + DOT$1 + SELECTED$1, menuContainer);
            menu = sf.base.select(SCROLLMENU$1, container);
            // tslint:disable-next-line:no-any
            if (menu) {
                menuContainer.blazor__instance.destroyScroll(NONE$1);
            }
        }
        else {
            var hamburgerMenu = sf.base.closest(ul, HAMBURGER);
            if (hamburgerMenu) {
                selectedLi = sf.base.select("" + DOT$1 + MENUITEM$1 + DOT$1 + SELECTED$1, hamburgerMenu);
            }
            else {
                selectedLi = sf.base.select("" + DOT$1 + MENUITEM$1 + DOT$1 + SELECTED$1, previousUl);
            }
        }
        if (selectedLi) {
            selectedLi.focus();
        }
    }
}
function isValidLI(ul, index, isKeyDown, count) {
    if (count === void 0) { count = 0; }
    var cli = ul.children[index];
    if (count === ul.childElementCount) {
        return -1;
    }
    if (cli.classList.contains(SEPARATOR) || cli.classList.contains(DISABLED) || cli.classList.contains(HIDE)) {
        index = isKeyDown ? (index === ul.childElementCount - 1 ? 0 : index + 1) : (index === 0 ? ul.childElementCount - 1 : index - 1);
        count++;
    }
    cli = ul.children[index];
    if (cli.classList.contains(SEPARATOR) || cli.classList.contains(DISABLED) || cli.classList.contains(HIDE)) {
        index = isValidLI(ul, index, isKeyDown);
    }
    return index;
}

var TRANSPARENT = 'e-transparent';
var MENU = 'e-menu-parent';
var MENUITEM = 'e-menu-item';
var FOCUSED = 'e-focused';
var SELECTED = 'e-selected';
var CLOSE = 'CloseMenuAsync';
var KEYDOWN = 'keydown';
var SCROLLMENU = '.e-menu-vscroll';
var SCROLLNAV = '.e-scroll-nav';
var SPACE = ' ';
var HIDDEN = 'hidden';
var OPENMENU = 'OpenContextMenuAsync';
var PIXEL = 'px';
var MOUSEDOWN = 'mousedown touchstart';
var MOUSEOVER = 'mouseover';
var SCROLL = 'scroll';
var NONE = 'none';
var HASH = '#';
var EMPTY = '';
var DOT = '.';
var TARGET = 'Target';
var FILTER = 'Filter';
var SHOWON = 'ShowOn';
var CARET = 'e-caret';
/**
 * Client side scripts for Blazor context menu
 */
var SfContextMenu = /** @class */ (function () {
    function SfContextMenu(element, target, filter, showOn, dotnetRef) {
        this.element = element;
        this.target = target;
        this.filter = filter;
        this.showOn = showOn;
        this.dotnetRef = dotnetRef;
        this.element.blazor__instance = this;
        this.addContextMenuEvent();
        this.addEventListener();
    }
    SfContextMenu.prototype.addContextMenuEvent = function (add) {
        if (add === void 0) { add = true; }
        var target;
        if (this.target) {
            var targetElems = sf.base.selectAll(this.target);
            if (targetElems.length) {
                for (var i = 0, len = targetElems.length; i < len; i++) {
                    target = targetElems[i];
                    if (add) {
                        if (sf.base.Browser.isIos) {
                            new sf.base.Touch(target, { tapHold: this.touchHandler.bind(this) });
                        }
                        else {
                            sf.base.EventHandler.add(target, this.showOn, this.cmenuHandler, this);
                        }
                    }
                    else {
                        if (sf.base.Browser.isIos) {
                            var touchModule = sf.base.getInstance(target, sf.base.Touch);
                            if (touchModule) {
                                touchModule.destroy();
                            }
                        }
                        else {
                            sf.base.EventHandler.remove(target, this.showOn, this.cmenuHandler);
                        }
                    }
                }
                if (sf.base.isNullOrUndefined(this.targetElement)) {
                    this.targetElement = target;
                }
                if (add) {
                    sf.base.EventHandler.add(this.targetElement, SCROLL, this.scrollHandler, this);
                    for (var _i = 0, _a = sf.popups.getScrollableParent(this.targetElement); _i < _a.length; _i++) {
                        var parent_1 = _a[_i];
                        sf.base.EventHandler.add(parent_1, SCROLL, this.scrollHandler, this);
                    }
                }
                else {
                    var scrollableParents = void 0;
                    if (this.targetElement.parentElement) {
                        sf.base.EventHandler.remove(this.targetElement, SCROLL, this.scrollHandler);
                        scrollableParents = sf.popups.getScrollableParent(this.targetElement);
                    }
                    else {
                        scrollableParents = sf.popups.getScrollableParent(target);
                    }
                    for (var _b = 0, scrollableParents_1 = scrollableParents; _b < scrollableParents_1.length; _b++) {
                        var parent_2 = scrollableParents_1[_b];
                        sf.base.EventHandler.remove(parent_2, SCROLL, this.scrollHandler);
                    }
                    this.targetElement = null;
                }
            }
        }
    };
    SfContextMenu.prototype.scrollHandler = function () {
        if (sf.base.select(DOT + MENU, this.element)) {
            this.dotnetRef.invokeMethodAsync(CLOSE, 0, false, true, false);
        }
    };
    SfContextMenu.prototype.touchHandler = function (e) {
        this.cmenuHandler(e.originalEvent);
    };
    SfContextMenu.prototype.keyDownHandler = function (e) {
        var classList = e.target.classList;
        if (classList.contains(MENUITEM) || classList.contains(MENU)) {
            e.preventDefault();
        }
        keyActionHandler(this.element, e.target, e.keyCode, this.menuId);
    };
    SfContextMenu.prototype.cmenuHandler = function (e) {
        if (this.filter) {
            var canOpen = false;
            var filter = this.filter.split(SPACE);
            for (var i = 0, len = filter.length; i < len; i++) {
                if (sf.base.closest(e.target, filter[i])) {
                    canOpen = true;
                    break;
                }
            }
            if (!canOpen) {
                return;
            }
        }
        e.preventDefault();
        var left = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        var top = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
        this.dotnetRef.invokeMethodAsync(OPENMENU, Math.ceil(left), Math.ceil(top));
    };
    SfContextMenu.prototype.contextMenuPosition = function (left, top, rtl, subMenu, isCollision) {
        var cmenu = this.hideMenu(true);
        if (!cmenu) {
            return;
        }
        this.subMenuOpen = false;
        this.setBlankIconStyle(cmenu, rtl);
        var cmenuOffset = cmenu.getBoundingClientRect();
        var cmenuWidth = this.getMenuWidth(cmenu, cmenuOffset.width, rtl);
        if (subMenu && sf.base.Browser.isDevice) {
            cmenu.style.width = Math.ceil(cmenuWidth) + PIXEL;
            cmenu.style.visibility = EMPTY;
            return;
        }
        if (isCollision) {
            if (top + cmenuOffset.height > document.documentElement.clientHeight) {
                var newTop = document.documentElement.clientHeight - cmenuOffset.height - 20;
                if (newTop > document.documentElement.clientTop) {
                    top = newTop;
                }
            }
            if (left + cmenuWidth > document.documentElement.clientWidth) {
                var newLeft = document.documentElement.clientWidth - cmenuWidth - 20;
                if (newLeft > document.documentElement.clientLeft) {
                    left = newLeft;
                }
            }
        }
        this.element.style.top = Math.ceil(top + 1) + PIXEL;
        this.element.style.left = Math.ceil(left + 1) + PIXEL;
        cmenu.style.width = Math.ceil(cmenuWidth) + PIXEL;
        this.element.style.zIndex = sf.popups.getZindexPartial(this.element).toString();
        cmenu.style.visibility = EMPTY;
        cmenu.focus();
    };
    SfContextMenu.prototype.setBlankIconStyle = function (menu, isRtl) {
        var blankIconList = [].slice.call(menu.getElementsByClassName('e-blankicon'));
        var cssProp = isRtl ? { padding: 'paddingRight', cssSelector: 'padding-right', margin: 'marginLeft' } : { padding: 'paddingLeft', cssSelector: 'padding-left', margin: 'marginRight' };
        [].slice.call(menu.querySelectorAll('.e-menu-item[style*="' + cssProp.cssSelector + '"]:not(.e-blankicon)')).forEach(function (li) {
            // tslint:disable-next-line:no-any
            li.style[cssProp.padding] = EMPTY;
        });
        if (!blankIconList.length) {
            return;
        }
        var iconLi = menu.querySelector('.e-menu-item:not(.e-blankicon):not(.e-separator)');
        var icon = iconLi.querySelector('.e-menu-icon');
        if (!icon) {
            return;
        }
        var iconCssProps = getComputedStyle(icon);
        var iconSize = parseInt(iconCssProps.fontSize, 10);
        if (!!parseInt(iconCssProps.width, 10) && parseInt(iconCssProps.width, 10) > iconSize) {
            iconSize = parseInt(iconCssProps.width, 10);
        }
        // tslint:disable
        var size = iconSize + parseInt(iconCssProps[cssProp.margin], 10) + parseInt(getComputedStyle(iconLi)[cssProp.padding], 10) + "px";
        blankIconList.forEach(function (li) {
            li.style[cssProp.padding] = size;
        });
        // tslint:enable
    };
    SfContextMenu.prototype.getMenuWidth = function (cmenu, width, isRtl) {
        var caretIcon = cmenu.getElementsByClassName(CARET)[0];
        if (caretIcon) {
            width += parseInt(getComputedStyle(caretIcon)[isRtl ? 'marginRight' : 'marginLeft'], 10);
        }
        return width < 120 ? 120 : width;
    };
    SfContextMenu.prototype.addEventListener = function () {
        this.delegateMouseDownHandler = this.mouseDownHandler.bind(this);
        this.delegateMouseOverHandler = this.mouseOverHandler.bind(this);
        sf.base.EventHandler.add(document, MOUSEDOWN, this.delegateMouseDownHandler, this);
        sf.base.EventHandler.add(document, MOUSEOVER, this.delegateMouseOverHandler, this);
        sf.base.EventHandler.add(this.element, KEYDOWN, this.keyDownHandler, this);
    };
    SfContextMenu.prototype.removeEventListener = function () {
        sf.base.EventHandler.remove(document, MOUSEDOWN, this.delegateMouseDownHandler);
        sf.base.EventHandler.remove(document, MOUSEOVER, this.delegateMouseOverHandler);
        sf.base.EventHandler.remove(this.element, KEYDOWN, this.keyDownHandler);
    };
    SfContextMenu.prototype.mouseDownHandler = function (e) {
        if (!document.getElementById(this.element.id)) {
            this.removeEventListener();
            return;
        }
        if (!sf.base.closest(e.target, HASH + this.element.id) && (sf.base.isNullOrUndefined(this.menuId) ||
            !sf.base.closest(e.target, this.menuId)) && sf.base.select(DOT + MENU, this.element)) {
            this.dotnetRef.invokeMethodAsync(CLOSE, 0, false, true, false);
        }
    };
    SfContextMenu.prototype.mouseOverHandler = function (e) {
        if (!document.getElementById(this.element.id)) {
            this.removeEventListener();
            return;
        }
        var target = e.target;
        var menus = [].slice.call(sf.base.selectAll(DOT + MENU, this.element));
        if (!menus.length) {
            return;
        }
        var scrollNav = sf.base.closest(target, SCROLLNAV);
        if (this.subMenuOpen && (menus.length > 1 || (!sf.base.isNullOrUndefined(this.menuId) && !scrollNav))) {
            if ((!sf.base.closest(target, HASH + this.element.id) && (sf.base.isNullOrUndefined(this.menuId) || !sf.base.closest(target, this.menuId))) ||
                scrollNav) {
                var index = 1;
                if (!sf.base.isNullOrUndefined(this.menuId)) {
                    index = 0;
                    if (scrollNav) {
                        index = menus.indexOf(sf.base.select(DOT + MENU, scrollNav.parentElement)) + 1;
                        if (index === menus.length) {
                            return;
                        }
                    }
                }
                this.dotnetRef.invokeMethodAsync(CLOSE, index, false, true, false);
                if (!sf.base.isNullOrUndefined(this.menuId) && !sf.base.closest(target, SCROLLNAV)) {
                    this.destroyMenuScroll(null);
                }
            }
            if (!sf.base.isNullOrUndefined(this.menuId) && (sf.base.closest(target, HASH + this.element.id) || sf.base.closest(target, this.menuId)) &&
                sf.base.closest(target, DOT + MENUITEM) && !sf.base.closest(target, DOT + SELECTED)) {
                this.destroyMenuScroll(sf.base.closest(target, DOT + MENU));
            }
        }
        if (!this.openAsMenu) {
            var activeEle = document.activeElement;
            if (!sf.base.closest(activeEle, "" + HASH + this.element.id) && menus.length && activeEle.tagName == "BODY") {
                var lastChild = this.getLastMenu();
                if (lastChild) {
                    lastChild.focus();
                }
            }
        }
    };
    SfContextMenu.prototype.destroyMenuScroll = function (menu) {
        if (!sf.base.select(SCROLLMENU, this.element)) {
            return;
        }
        var menuElement = sf.base.select(this.menuId);
        if (menuElement) {
            // tslint:disable-next-line:no-any
            var menuInstance = menuElement.blazor__instance;
            if (!sf.base.isNullOrUndefined(menuInstance)) {
                menuInstance.destroyScroll(NONE, menu);
            }
        }
    };
    SfContextMenu.prototype.hideMenu = function (first) {
        var cMenu;
        if (first) {
            cMenu = sf.base.select(DOT + MENU, this.element);
            if (!cMenu || sf.base.isNullOrUndefined(this.element.parentElement)) {
                return null;
            }
            if (this.element.parentElement !== document.body) {
                document.body.appendChild(this.element);
            }
        }
        else {
            var menus = sf.base.selectAll(DOT + MENU, this.element);
            if (menus.length < 2) {
                return null;
            }
            cMenu = menus[menus.length - 1];
        }
        cMenu.style.width = EMPTY;
        cMenu.style.visibility = HIDDEN;
        cMenu.classList.remove(TRANSPARENT);
        return cMenu;
    };
    SfContextMenu.prototype.subMenuPosition = function (cmenu, isRtl, showOnClick, isNull, scrollHeight) {
        if (!cmenu) {
            return;
        }
        var menus = sf.base.selectAll(DOT + MENU, this.element);
        var parentLi = menus[menus.length - 2].querySelector("." + MENUITEM + "." + SELECTED);
        var parentOffset = parentLi.getBoundingClientRect();
        var containerOffset = this.element.getBoundingClientRect();
        var menu = cmenu.classList.contains(MENU) ? cmenu : sf.base.select(DOT + MENU, cmenu);
        this.setBlankIconStyle(menu, isRtl);
        var curUlOffset = menu.getBoundingClientRect();
        var cmenuWidth = this.getMenuWidth(menu, curUlOffset.width, isRtl);
        var left;
        var borderLeft;
        if (isRtl) {
            borderLeft = parseInt(getComputedStyle(menu).borderWidth, 10);
            left = parentOffset.left - cmenuWidth - containerOffset.left;
        }
        else {
            left = parentOffset.right - containerOffset.left;
        }
        var top = parentOffset.top - containerOffset.top;
        if (isRtl) {
            if (parentOffset.left - borderLeft - cmenuWidth < document.documentElement.clientLeft) {
                if (parentOffset.right + cmenuWidth < document.documentElement.clientWidth) {
                    left = parentOffset.right - containerOffset.left;
                }
            }
        }
        else if (parentOffset.right + cmenuWidth > document.documentElement.clientWidth) {
            var newLeft = parentOffset.left - cmenuWidth;
            if (newLeft > document.documentElement.clientLeft) {
                left = newLeft - containerOffset.left;
            }
        }
        var height = scrollHeight || curUlOffset.height;
        if (parentOffset.top + height > document.documentElement.clientHeight) {
            var newTop = document.documentElement.clientHeight - height - 20;
            if (newTop > document.documentElement.clientTop) {
                top = newTop - containerOffset.top;
            }
        }
        this.subMenuOpen = !showOnClick;
        cmenu.style.left = Math.ceil(left) + PIXEL;
        cmenu.style.top = Math.ceil(top) + PIXEL;
        cmenu.style.width = Math.ceil(cmenuWidth) + PIXEL;
        menu.style.visibility = EMPTY;
        var focusedLi = menu.querySelector("" + DOT + MENUITEM + DOT + FOCUSED);
        focusedLi ? focusedLi.focus() : menu.focus();
        if (isNull) {
            this.openAsMenu = true;
        }
    };
    SfContextMenu.prototype.getLastMenu = function () {
        var menus = sf.base.selectAll(DOT + MENU, this.element);
        return menus.length ? menus[menus.length - 1] : null;
    };
    SfContextMenu.prototype.onPropertyChanged = function (key, result) {
        switch (key) {
            case TARGET:
                this.addContextMenuEvent(false);
                this.target = result;
                this.addContextMenuEvent();
                break;
            case FILTER:
                this.filter = result;
                break;
            case SHOWON:
                this.addContextMenuEvent(false);
                this.showOn = result;
                this.addContextMenuEvent();
                break;
        }
    };
    SfContextMenu.prototype.destroy = function (refElement) {
        this.removeEventListener();
        this.addContextMenuEvent(false);
        if (refElement && refElement.parentElement && refElement.previousElementSibling !== this.element) {
            refElement.parentElement.insertBefore(this.element, refElement);
        }
        if ((!refElement || !refElement.parentElement) && this.element.parentElement && this.element.parentElement === document.body) {
            document.body.removeChild(this.element);
        }
    };
    SfContextMenu.prototype.updateProperty = function (showItemOnClick, menu) {
        if (menu) {
            this.menuId = HASH + menu.id;
        }
        this.subMenuOpen = !showItemOnClick;
    };
    return SfContextMenu;
}());
// tslint:disable-next-line:variable-name
var ContextMenu = {
    initialize: function (element, target, filter, showOn, dotnetRef) {
        if (!sf.base.isNullOrUndefined(element)) {
            new SfContextMenu(element, target, filter, showOn, dotnetRef);
        }
    },
    contextMenuPosition: function (element, left, top, isRtl, subMenu, isCollision) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.contextMenuPosition(left, top, isRtl, subMenu, isCollision);
        }
    },
    subMenuPosition: function (element, isRtl, showOnClick, isNull) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var cmenu = element.blazor__instance.hideMenu();
            element.blazor__instance.subMenuPosition(cmenu, isRtl, showOnClick, isNull);
        }
    },
    onPropertyChanged: function (element, key, result) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.onPropertyChanged(key, result);
        }
    },
    destroy: function (element, refElement) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.destroy(refElement);
        }
    }
};

return ContextMenu;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-datepicker.js":
/*!****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-datepicker.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.DatePicker = (function () {
'use strict';

var ROOT = 'e-datepicker';
var POPUPDIMENSION = '240px';
var HALFPOSITION = 2;
var POPUP_CONTAINER = 'e-popup-wrapper';
var POPUP = 'e-popup';
var OVERFLOW = 'e-date-overflow';
var TIME_OVERFLOW = 'e-time-overflow';
var CONENT = 'e-content';
var FOOTER_CONTAINER = 'e-footer-container';
var INPUT_HANDLER = 'InputKeyActionHandle';
var TBODY = 'tbody';
var TABLE = 'table';
var HIDE_POPUP = 'HidePopup';
var CLOSE_POPUP = 'ClosePopup';
var SHOW_POPUP = 'ShowPopup';
var MOUSE_TOUCH_EVENT = 'mousedown touchstart';
var SELECTED = 'e-selected';
var DAY = 'e-day';
var TODAY = 'e-today';
var BTN = 'e-btn';
var OFFSETVALUE = 4;
var OPENDURATION = 300;
var INPUTCONTAINER = 'e-input-group';
var SfDatePicker = /** @class */ (function () {
    function SfDatePicker(containerElement, element, dotnetRef, options) {
        this.containerElement = containerElement;
        this.element = element;
        this.options = options;
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
    }
    SfDatePicker.prototype.initialize = function () {
        this.defaultKeyConfigs = {
            altUpArrow: 'alt+uparrow',
            altDownArrow: 'alt+downarrow',
            escape: 'escape',
            enter: 'enter',
            controlUp: 'ctrl+38',
            controlDown: 'ctrl+40',
            moveDown: 'downarrow',
            moveUp: 'uparrow',
            moveLeft: 'leftarrow',
            moveRight: 'rightarrow',
            select: 'enter',
            home: 'home',
            end: 'end',
            pageUp: 'pageup',
            pageDown: 'pagedown',
            shiftPageUp: 'shift+pageup',
            shiftPageDown: 'shift+pagedown',
            controlHome: 'ctrl+home',
            controlEnd: 'ctrl+end',
            shiftTab: 'shift+tab',
            tab: 'tab'
        };
        this.defaultKeyConfigs = sf.base.extend(this.defaultKeyConfigs, this.options.keyConfigs);
        new sf.base.KeyboardEvents(this.element, {
            eventName: 'keydown',
            keyAction: this.inputKeyActionHandle.bind(this),
            keyConfigs: this.defaultKeyConfigs
        });
        this.index = this.options.showClearButton ? 2 : 1;
        sf.base.EventHandler.add(this.element, 'blur', this.inputBlurHandler, this);
    };
    SfDatePicker.prototype.inputKeyActionHandle = function (e) {
        var keyEventsArgs;
        if (this.popupObj && this.popupObj.element.classList.contains(POPUP) && this.options.isDatePopup) {
            var focusedDate = this.tableBodyElement.querySelector('tr td.e-focused-date');
            var selectedDate = this.tableBodyElement.querySelector('tr td.' + SELECTED);
            this.tableBodyElement.focus();
            keyEventsArgs = {
                Action: e.action, Key: e.key, Events: e, SelectDate: selectedDate ? selectedDate.id : null,
                FocusedDate: focusedDate ? focusedDate.id : null,
                classList: selectedDate ? selectedDate.classList.toString() : focusedDate ? focusedDate.classList.toString() : 'e-cell',
                Id: focusedDate ? focusedDate.id : selectedDate ? selectedDate.id : null,
                TargetClassList: this.calendarElement.classList.toString()
            };
        }
        else {
            keyEventsArgs = {
                Action: e.action, Key: e.key, Events: e
            };
        }
        if (!this.isDisposed) {
            this.dotNetRef.invokeMethodAsync(INPUT_HANDLER, keyEventsArgs);
        }
        if (e.action !== 'select' && this.popupObj && document.body.contains(this.popupObj.element)) {
            e.preventDefault();
        }
    };
    SfDatePicker.prototype.inputBlurHandler = function (e) {
        if (this.isCalendar() && document.activeElement === this.element) {
            this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
        }
    };
    // tslint:disable
    SfDatePicker.prototype.renderPopup = function (popupElement, popupHolderEle, openEventArgs, options) {
        this.options = options;
        this.popupHolder = popupHolderEle;
        if (popupElement) {
            var oldPopupEle = document.getElementById(popupElement.id);
            if (oldPopupEle) {
                sf.base.remove(oldPopupEle);
            }
        }
        this.createCalendar(popupElement, options);
        if (sf.base.Browser.isDevice) {
            this.mobilePopupContainer = sf.base.createElement('div', { className: 'e-datepick-mob-popup-wrap' });
            document.body.appendChild(this.mobilePopupContainer);
        }
        var appendToElement = openEventArgs.appendTo === 'model' && this.mobilePopupContainer ? this.mobilePopupContainer
            : document.body;
        appendToElement.appendChild(this.popupContainer);
        this.popupObj.refreshPosition(this.element);
        if (!options.isDatePopup) {
            this.setScrollPosition();
        }
        var openAnimation = {
            name: 'FadeIn',
            duration: sf.base.Browser.isDevice ? 0 : OPENDURATION,
        };
        if (this.options.zIndex === 1000) {
            this.popupObj.show(new sf.base.Animation(openAnimation), this.element);
        }
        else {
            this.popupObj.show(new sf.base.Animation(openAnimation), null);
        }
        this.setOverlayIndex(this.mobilePopupContainer, this.popupObj.element, this.modal, sf.base.Browser.isDevice);
        sf.base.EventHandler.add(document, MOUSE_TOUCH_EVENT, this.documentHandler, this);
    };
    SfDatePicker.prototype.setOverlayIndex = function (popupContainer, popupElement, modal, isDevice) {
        if (isDevice && !sf.base.isNullOrUndefined(popupElement) && !sf.base.isNullOrUndefined(modal) && !sf.base.isNullOrUndefined(popupContainer)) {
            var index = parseInt(popupElement.style.zIndex, 10) ? parseInt(popupElement.style.zIndex, 10) : 1000;
            modal.style.zIndex = (index - 1).toString();
            popupContainer.style.zIndex = index.toString();
        }
    };
    SfDatePicker.prototype.closePopup = function (closeEventArgs, options) {
        this.options = options;
        this.closeEventCallback(closeEventArgs);
    };
    SfDatePicker.prototype.createCalendar = function (popupElement, options) {
        var _this = this;
        this.popupContainer = popupElement;
        this.calendarElement = this.popupContainer.firstElementChild;
        this.tableBodyElement = sf.base.select(TBODY, this.calendarElement);
        var modelClassName = '' + ROOT + ' e-date-modal';
        var modelOverflow = OVERFLOW;
        if (!options.isDatePopup) {
            modelClassName = 'e-datetimepicker e-time-modal';
            modelOverflow = TIME_OVERFLOW;
        }
        else {
            this.calendarElement.querySelector(TABLE + ' ' + TBODY).className = '';
        }
        if (sf.base.Browser.isDevice) {
            this.modal = sf.base.createElement('div');
            this.modal.className = modelClassName;
            document.body.classList.add(modelOverflow);
            this.modal.style.display = 'block';
            document.body.appendChild(this.modal);
        }
        this.popupObj = new sf.popups.Popup(this.popupContainer, {
            width: options.isDatePopup ? 'auto' : this.setPopupWidth(this.options.width),
            relateTo: sf.base.Browser.isDevice ? document.body : this.containerElement,
            position: sf.base.Browser.isDevice ? { X: 'center', Y: 'center' } : { X: 'left', Y: 'bottom' },
            offsetY: OFFSETVALUE,
            targetType: 'container',
            enableRtl: options.enableRtl,
            zIndex: options.zIndex,
            collision: sf.base.Browser.isDevice ? { X: 'fit', Y: 'fit' } : { X: 'flip', Y: 'flip' },
            open: function () {
                if (document.activeElement !== _this.element && options.isDatePopup) {
                    _this.defaultKeyConfigs = sf.base.extend(_this.defaultKeyConfigs, options.keyConfigs);
                    _this.calendarElement.children[1].firstElementChild.focus();
                    new sf.base.KeyboardEvents(_this.calendarElement.children[1].firstElementChild, {
                        eventName: 'keydown',
                        keyAction: _this.CalendarKeyActionHandle.bind(_this),
                        keyConfigs: _this.defaultKeyConfigs
                    });
                    new sf.base.KeyboardEvents(_this.containerElement.children[_this.index], {
                        eventName: 'keydown',
                        keyAction: _this.CalendarKeyActionHandle.bind(_this),
                        keyConfigs: _this.defaultKeyConfigs
                    });
                }
            }, close: function () {
                _this.popupHolder.appendChild(_this.popupContainer);
                if (_this.popupObj) {
                    _this.popupObj.destroy();
                }
                if (!_this.isDisposed) {
                    // tslint:disable
                    _this.dotNetRef.invokeMethodAsync(CLOSE_POPUP).catch(function () { });
                }
                _this.popupObj = null;
            }, targetExitViewport: function () {
                if (!sf.base.Browser.isDevice && !_this.isDisposed) {
                    _this.dotNetRef.invokeMethodAsync(HIDE_POPUP, null);
                }
            }
        });
        if (!options.isDatePopup) {
            this.popupObj.element.style.maxHeight = POPUPDIMENSION;
        }
    };
    SfDatePicker.prototype.getPopupHeight = function () {
        var height = parseInt(POPUPDIMENSION, 10);
        var popupHeight = this.popupContainer.getBoundingClientRect().height;
        return popupHeight > height ? height : popupHeight;
    };
    SfDatePicker.prototype.setScrollPosition = function () {
        if ((this.popupContainer && this.popupContainer.querySelector('.e-navigation') || this.popupContainer.querySelector('.e-active'))
            && !this.options.isDatePopup) {
            var selectElement = this.popupContainer.querySelector('.e-navigation') || this.popupContainer.querySelector('.e-active');
            this.findScrollTop(selectElement);
        }
    };
    SfDatePicker.prototype.findScrollTop = function (element) {
        var listHeight = this.getPopupHeight();
        var nextEle = element.nextElementSibling;
        var height = nextEle ? nextEle.offsetTop : element.offsetTop;
        var liHeight = element.getBoundingClientRect().height;
        if ((height + element.offsetTop) > listHeight) {
            this.popupContainer.scrollTop = nextEle ? (height - (listHeight / HALFPOSITION + liHeight / HALFPOSITION)) : height;
        }
        else {
            this.popupContainer.scrollTop = 0;
        }
    };
    SfDatePicker.prototype.closeEventCallback = function (eventArgs) {
        var preventArgs = eventArgs;
        if (this.isCalendar() && !preventArgs.cancel && this.popupObj) {
            this.popupObj.hide();
        }
        if (sf.base.Browser.isDevice && this.modal) {
            this.modal.style.display = 'none';
            this.modal.outerHTML = '';
            this.modal = null;
        }
        if (sf.base.Browser.isDevice) {
            sf.base.removeClass([document.body], OVERFLOW);
            sf.base.removeClass([document.body], TIME_OVERFLOW);
            if (!sf.base.isNullOrUndefined(this.mobilePopupContainer)) {
                this.mobilePopupContainer.remove();
                this.mobilePopupContainer = null;
            }
        }
        sf.base.EventHandler.remove(document, MOUSE_TOUCH_EVENT, this.documentHandler);
        if (sf.base.Browser.isDevice && this.options.allowEdit && !this.options.readonly) {
            this.element.removeAttribute('readonly');
        }
    };
    SfDatePicker.prototype.documentHandler = function (e) {
        if ((!sf.base.isNullOrUndefined(this.popupObj) && (this.containerElement.contains(e.target) ||
            (this.popupObj.element && this.popupObj.element.contains(e.target)))) && e.type !== 'touchstart') {
            e.preventDefault();
        }
        var clearElement = this.containerElement.querySelector('.e-clear-icon');
        var selectedElement = this.tableBodyElement ? this.tableBodyElement.querySelector('.e-selected') : null;
        var dateValue = this.options.value ? this.options.value.toString() : null;
        var target = e.target;
        if (target == clearElement && selectedElement) {
            sf.base.removeClass([this.tableBodyElement.querySelector('.e-selected')], SELECTED);
        }
        if (!(sf.base.closest(target, '.' + ROOT + '.' + POPUP_CONTAINER))
            && !sf.base.closest(target, '.' + 'e-datetimepicker' + '.' + POPUP_CONTAINER)
            && !(sf.base.closest(target, '.' + INPUTCONTAINER) === this.containerElement)
            && (!target.classList.contains(DAY)) && !this.isDisposed) {
            this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
            this.element.focus();
        }
        else if (sf.base.closest(target, '.' + ROOT + '.' + POPUP_CONTAINER)) {
            if (target.classList.contains(DAY)
                && !sf.base.isNullOrUndefined(e.target.parentElement)
                && e.target.parentElement.classList.contains(SELECTED)
                && sf.base.closest(target, '.' + CONENT)
                && sf.base.closest(target, '.' + CONENT).classList.contains('e-' + this.options.depth.toLowerCase()) && !this.isDisposed) {
                this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
            }
            else if (sf.base.closest(target, '.' + FOOTER_CONTAINER)
                && target.classList.contains(TODAY)
                && target.classList.contains(BTN)
                && (+new Date(dateValue) === +this.generateTodayVal(new Date(dateValue))) && !this.isDisposed) {
                this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
            }
        }
    };
    SfDatePicker.prototype.generateTodayVal = function (value) {
        var tempValue = new Date();
        if (value) {
            tempValue.setHours(value.getHours());
            tempValue.setMinutes(value.getMinutes());
            tempValue.setSeconds(value.getSeconds());
            tempValue.setMilliseconds(value.getMilliseconds());
        }
        else {
            tempValue = new Date(tempValue.getFullYear(), tempValue.getMonth(), tempValue.getDate(), 0, 0, 0, 0);
        }
        return tempValue;
    };
    SfDatePicker.prototype.isCalendar = function () {
        return this.popupContainer && this.popupContainer.classList.contains('' + POPUP_CONTAINER);
    };
    SfDatePicker.prototype.CalendarKeyActionHandle = function (e) {
        switch (e.action) {
            case this.defaultKeyConfigs.escape:
                if (this.isCalendar()) {
                    this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
                }
                else {
                    this.element.blur();
                }
                break;
            case this.defaultKeyConfigs.enter:
                if (!this.isCalendar()) {
                    this.dotNetRef.invokeMethodAsync(SHOW_POPUP, e);
                }
                break;
            case this.defaultKeyConfigs.tab:
                this.dotNetRef.invokeMethodAsync(HIDE_POPUP, e);
        }
    };
    SfDatePicker.prototype.setWidth = function (width) {
        if (typeof width === 'number') {
            width = sf.base.formatUnit(width);
        }
        else if (typeof width === 'string') {
            width = (width.match(/px|%|em/)) ? width : sf.base.formatUnit(width);
        }
        else {
            width = '100%';
        }
        return width;
    };
    SfDatePicker.prototype.setPopupWidth = function (width) {
        width = this.setWidth(width);
        if (width.indexOf('%') > -1) {
            var containerStyle = this.containerElement.getBoundingClientRect();
            var inputWidth = containerStyle.width * parseFloat(width) / 100;
            width = inputWidth.toString() + 'px';
        }
        return width;
    };
    return SfDatePicker;
}());
// tslint:disable
var DatePicker = {
    initialize: function (containerElement, element, dotnetRef, options) {
        if (element) {
            new SfDatePicker(containerElement, element, dotnetRef, options);
        }
        if (element && element.blazor__instance) {
            element.blazor__instance.initialize();
        }
    },
    renderPopup: function (element, popupElement, popupHolderEle, openEventArgs, options) {
        if (element && element.blazor__instance && popupElement && popupHolderEle) {
            element.blazor__instance.renderPopup(popupElement, popupHolderEle, openEventArgs, options);
        }
    },
    updateScrollPosition: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.setScrollPosition();
        }
    },
    // tslint:disable
    closePopup: function (element, popupElement, popupHolderEle, closeEventArgs, options) {
        if (element && element.blazor__instance) {
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    },
    focusIn: function (inputEle) {
        if (inputEle) {
            inputEle.focus();
        }
    },
    focusOut: function (inputEle) {
        if (inputEle) {
            inputEle.blur();
        }
    },
    destroy: function (element, popupElement, popupHolderEle, closeEventArgs, options) {
        if (element && element.blazor__instance && popupElement && popupElement instanceof HTMLElement && popupHolderEle) {
            element.blazor__instance.isDisposed = true;
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    }
};

return DatePicker;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-daterangepicker.js":
/*!*********************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-daterangepicker.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.DateRangePicker = (function () {
'use strict';

var POPUPDIMENSION = '240px';
var HALFPOSITION = 2;
var POPUP = 'e-popup';
var OVERFLOW = 'e-range-overflow';
var FOOTER_CONTAINER = 'e-footer-container';
var INPUT_HANDLER = 'InputKeyActionHandle';
var LEFTCALENDER = 'e-left-calendar';
var RIGHTCALENDER = 'e-right-calendar';
var CALENDAR = 'e-calendar';
var NEXTICON = 'e-next';
var PREVICON = 'e-prev';
var HEADER = 'e-header';
var TITLE = 'e-title';
var ICONCONTAINER = 'e-icon-container';
var TBODY = 'tbody';
var TABLE = 'table';
var HIDE_POPUP = 'HidePopup';
var CLOSE_POPUP = 'ClosePopup';
var MOUSE_TOUCH_EVENT = 'mousedown touchstart';
var SELECTED = 'e-selected';
var OFFSETVALUE = 4;
var INPUTCONTAINER = 'e-input-group';
var INPUTFOCUS = 'e-input-focus';
var FOCUS_DATE = 'e-focused-date';
var RANGECONTAINER = 'e-date-range-container';
var PRESETS = 'e-presets';
var SfDateRangePicker = /** @class */ (function () {
    function SfDateRangePicker(containerElement, element, dotnetRef, options) {
        this.containerElement = containerElement;
        this.element = element;
        this.options = options;
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
    }
    // tslint:disable
    SfDateRangePicker.prototype.initialize = function () {
        this.isMobile = window.matchMedia('(max-width:550px)').matches;
        this.defaultKeyConfigs = {
            altUpArrow: 'alt+uparrow',
            altDownArrow: 'alt+downarrow',
            altRightArrow: 'alt+rightarrow',
            altLeftArrow: 'alt+leftarrow',
            escape: 'escape',
            enter: 'enter',
            controlUp: 'ctrl+38',
            controlDown: 'ctrl+40',
            moveDown: 'downarrow',
            moveUp: 'uparrow',
            moveLeft: 'leftarrow',
            moveRight: 'rightarrow',
            select: 'enter',
            home: 'home',
            end: 'end',
            pageUp: 'pageup',
            pageDown: 'pagedown',
            shiftPageUp: 'shift+pageup',
            shiftPageDown: 'shift+pagedown',
            controlHome: 'ctrl+home',
            controlEnd: 'ctrl+end',
            shiftTab: 'shift+tab'
        };
        new sf.base.KeyboardEvents(this.element, { eventName: 'keydown', keyAction: this.keyInputHandler.bind(this), keyConfigs: this.defaultKeyConfigs });
    };
    SfDateRangePicker.prototype.keyInputHandler = function (e) {
        var keyEventsArgs;
        if (this.popupObj && this.popupObj.element.classList.contains(POPUP)) {
            var ele = sf.base.closest(e.target, '.' + RIGHTCALENDER);
            ele = sf.base.isNullOrUndefined(ele) ? this.tableElement.querySelector('.' + LEFTCALENDER) : ele;
            var isLeftCalendar = ele.classList.contains(LEFTCALENDER);
            var focusedDate = this.tableElement.querySelector('tr td.' + FOCUS_DATE);
            var selectedDates = this.tableElement.querySelectorAll('tr td.' + SELECTED);
            var selectedDate = selectedDates[selectedDates.length - 1];
            var tableBodyEle = focusedDate && sf.base.closest(focusedDate, TBODY) || selectedDate && sf.base.closest(selectedDate, TBODY);
            if (!isLeftCalendar && this.leftCalendar.querySelectorAll('tr td.' + FOCUS_DATE).length > 0) {
                sf.base.removeClass(this.leftCalendar.querySelectorAll('tr td.' + FOCUS_DATE), FOCUS_DATE);
            }
            tableBodyEle && tableBodyEle.focus();
            keyEventsArgs = {
                Action: e.action,
                Key: e.key,
                Events: e,
                SelectDate: selectedDate ? selectedDate.id : null,
                FocusedDate: focusedDate ? focusedDate.id : null,
                classList: selectedDate ? selectedDate.classList.toString() :
                    focusedDate ? focusedDate.classList.toString() : 'e-cell',
                Id: focusedDate ? focusedDate.id : selectedDate ? selectedDate.id : null,
                TargetClassList: this.calendarElement.classList.toString(),
                IsLeftCalendar: isLeftCalendar
            };
        }
        else {
            keyEventsArgs = {
                Action: e.action,
                Key: e.key,
                Events: e
            };
        }
        if (!this.isDisposed) {
            this.dotNetRef.invokeMethodAsync(INPUT_HANDLER, keyEventsArgs);
        }
        if (e.action !== 'select' && this.popupObj && document.body.contains(this.popupObj.element)) {
            e.preventDefault();
        }
    };
    SfDateRangePicker.prototype.renderPopup = function (popupElement, popupHolderEle, openEventArgs, options) {
        this.options = options;
        this.popupHolder = popupHolderEle;
        var oldPopupEle = document.body.querySelector('.e-daterangepicker.e-popup-open');
        if (oldPopupEle) {
            sf.base.remove(oldPopupEle);
        }
        this.createCalendar(popupElement, options);
        if (sf.base.Browser.isDevice) {
            this.mobilePopupContainer = this.popupHolder.querySelector('.e-daterangepick-mob-popup-wrap');
            document.body.appendChild(this.mobilePopupContainer);
        }
        var appendToElement = openEventArgs.appendTo === 'model' && this.mobilePopupContainer ? this.mobilePopupContainer
            : document.body;
        appendToElement.appendChild(this.popupContainer);
        this.presetHeight();
        if (this.options.zIndex === 1000) {
            this.popupObj.show(null, this.element);
        }
        else {
            this.popupObj.show(null, null);
        }
        this.setOverlayIndex(this.mobilePopupContainer, this.popupObj.element, this.modal, sf.base.Browser.isDevice);
        if (sf.base.Browser.isDevice) {
            document.body.className += ' ' + OVERFLOW;
            this.popupHolder.style.display = 'block';
            this.popupHolder.style.visibility = 'visible';
        }
        sf.base.EventHandler.add(document, MOUSE_TOUCH_EVENT, this.documentHandler, this);
    };
    SfDateRangePicker.prototype.setOverlayIndex = function (popupContainer, popupElement, modal, isDevice) {
        if (isDevice && !sf.base.isNullOrUndefined(popupElement) && !sf.base.isNullOrUndefined(modal) && !sf.base.isNullOrUndefined(popupContainer)) {
            var index = parseInt(popupElement.style.zIndex, 10) ? parseInt(popupElement.style.zIndex, 10) : 1000;
            modal.style.zIndex = (index - 1).toString();
            popupContainer.style.zIndex = index.toString();
        }
    };
    SfDateRangePicker.prototype.closePopup = function (closeEventArgs, options) {
        this.options = options;
        this.closeEventCallback(closeEventArgs);
    };
    SfDateRangePicker.prototype.refreshPopup = function () {
        if (this.isPopupOpen()) {
            this.popupObj.refreshPosition();
        }
    };
    SfDateRangePicker.prototype.createCalendar = function (popupElement, options) {
        var _this = this;
        this.popupContainer = popupElement;
        if (options.isCustomWindow) {
            this.calendarElement = this.popupContainer.firstElementChild;
            this.tableElement = this.calendarElement;
            this.calendarElement.querySelector(TABLE + ' ' + TBODY).className = '';
        }
        var popupWidth = this.popupContainer.getBoundingClientRect().width;
        if (sf.base.Browser.isDevice) {
            this.modal = this.popupHolder.querySelector('.e-range-modal');
            this.modal.style.display = 'block';
            document.body.appendChild(this.modal);
        }
        if (options.isCustomWindow) {
            if (sf.base.Browser.isDevice) {
                this.deviceCalPrevIcon = this.calendarElement.querySelector('.' + CALENDAR + ' .' + PREVICON);
                this.deviceCalNextIcon = this.calendarElement.querySelector('.' + CALENDAR + ' .' + NEXTICON);
                if (this.calendarElement.querySelector('.' + CALENDAR + ' .' + ICONCONTAINER)) {
                    sf.base.remove(this.calendarElement.querySelector('.' + CALENDAR + ' .' + ICONCONTAINER));
                }
                this.calendarElement.querySelector('table').setAttribute('tabindex', '-1');
                this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER).appendChild(this.deviceCalNextIcon);
                this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER).appendChild(this.deviceCalPrevIcon);
                sf.base.prepend([this.deviceCalPrevIcon], this.calendarElement.querySelector('.' + CALENDAR + ' .' + HEADER));
                if (this.calendarElement.querySelector('.' + CALENDAR + ' .' + FOOTER_CONTAINER)) {
                    sf.base.remove(this.calendarElement.querySelector('.' + CALENDAR + ' .' + FOOTER_CONTAINER));
                }
            }
            else {
                this.leftCalPrevIcon = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + PREVICON);
                this.leftCalNextIcon = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + NEXTICON);
                this.leftTitle = this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + TITLE);
                if (this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + ICONCONTAINER)) {
                    sf.base.remove(this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + ICONCONTAINER));
                }
                this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER).appendChild(this.leftCalNextIcon);
                this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER).appendChild(this.leftCalPrevIcon);
                sf.base.prepend([this.leftCalPrevIcon], this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + HEADER));
                this.rightCalPrevIcon = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + PREVICON);
                this.rightCalNextIcon = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + NEXTICON);
                this.rightTitle = this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + TITLE);
                if (this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + ICONCONTAINER)) {
                    sf.base.remove(this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + ICONCONTAINER));
                }
                this.calendarElement.querySelector('table').setAttribute('tabindex', '-1');
                this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER).appendChild(this.rightCalNextIcon);
                this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER).appendChild(this.rightCalPrevIcon);
                sf.base.prepend([this.rightCalPrevIcon], this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + HEADER));
                if (this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + FOOTER_CONTAINER)) {
                    sf.base.remove(this.calendarElement.querySelector('.' + LEFTCALENDER + ' .' + FOOTER_CONTAINER));
                }
                if (this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + FOOTER_CONTAINER)) {
                    sf.base.remove(this.calendarElement.querySelector('.' + RIGHTCALENDER + ' .' + FOOTER_CONTAINER));
                }
            }
        }
        this.popupObj = new sf.popups.Popup(this.popupContainer, {
            relateTo: this.isMobile ? document.body : this.containerElement,
            position: (this.isMobile ?
                (!sf.base.isUndefined(options.presets && options.presets[0] && options.presets[0].start && options.presets[0].end && options.presets[0].label) ?
                    { X: 'left', Y: 'bottom' } : { X: 'center', Y: 'center' }) :
                options.enableRtl ? { X: 'left', Y: 'bottom' } : { X: 'right', Y: 'bottom' }),
            offsetX: this.isMobile || options.enableRtl ? 0 : -popupWidth,
            offsetY: OFFSETVALUE,
            collision: this.isMobile ?
                (!sf.base.isUndefined(options.presets && options.presets[0] && options.presets[0].start && options.presets[0].end && options.presets[0].label) ?
                    { X: 'fit' } : { X: 'fit', Y: 'fit' }) : { X: 'fit', Y: 'flip' },
            targetType: this.isMobile ? 'container' : 'relative',
            enableRtl: options.enableRtl,
            zIndex: options.zIndex,
            open: function () {
                _this.leftCalendar = _this.calendarElement.querySelector('.' + LEFTCALENDER);
                _this.rightCalendar = _this.calendarElement.querySelector('.' + RIGHTCALENDER);
                var dateRangeContainer = _this.popupObj && _this.popupObj.element.querySelector('.' + RANGECONTAINER);
                if (!_this.isMobile && dateRangeContainer) {
                    //this.defaultKeyConfigs = sf.base.extend(this.defaultKeyConfigs, this.keyConfigs);
                    new sf.base.KeyboardEvents(_this.leftCalendar, {
                        eventName: 'keydown',
                        keyAction: _this.keyInputHandler.bind(_this),
                        keyConfigs: _this.defaultKeyConfigs
                    });
                    new sf.base.KeyboardEvents(_this.rightCalendar, {
                        eventName: 'keydown',
                        keyAction: _this.keyInputHandler.bind(_this),
                        keyConfigs: _this.defaultKeyConfigs
                    });
                    var cancelBtnEle = _this.popupContainer.querySelector('.e-cancel.e-btn');
                    var applyBtnEle = _this.popupContainer.querySelector('.e-apply.e-btn');
                    new sf.base.KeyboardEvents(cancelBtnEle, {
                        eventName: 'keydown',
                        keyAction: _this.keyInputHandler.bind(_this),
                        keyConfigs: { tab: 'tab', altRightArrow: 'alt+rightarrow', altLeftArrow: 'alt+leftarrow' }
                    });
                    new sf.base.KeyboardEvents(applyBtnEle, {
                        eventName: 'keydown',
                        keyAction: _this.keyInputHandler.bind(_this),
                        keyConfigs: { altRightArrow: 'alt+rightarrow', altLeftArrow: 'alt+leftarrow' }
                    });
                    _this.leftCalendar.querySelector('table').focus();
                }
            }, close: function () {
                _this.popupHolder.appendChild(_this.popupContainer);
                if (_this.popupObj) {
                    _this.popupObj.destroy();
                }
                if (!_this.isDisposed) {
                    // tslint:disable
                    _this.dotNetRef.invokeMethodAsync(CLOSE_POPUP).catch(function () { });
                }
                _this.popupObj = null;
            }, targetExitViewport: function () {
                if (!sf.base.Browser.isDevice && !_this.isDisposed) {
                    _this.dotNetRef.invokeMethodAsync(HIDE_POPUP, null);
                }
            }
        });
    };
    SfDateRangePicker.prototype.closeEventCallback = function (eventArgs) {
        var preventArgs = eventArgs;
        if (!preventArgs.cancel && this.popupObj) {
            this.popupObj.hide();
        }
        if (sf.base.Browser.isDevice && this.modal) {
            this.modal.style.display = 'none';
            this.modal.outerHTML = '';
            this.modal = null;
        }
        if (sf.base.Browser.isDevice) {
            sf.base.removeClass([document.body], OVERFLOW);
            if (!sf.base.isNullOrUndefined(this.mobilePopupContainer)) {
                this.mobilePopupContainer.remove();
                this.mobilePopupContainer = null;
            }
        }
        sf.base.EventHandler.remove(document, MOUSE_TOUCH_EVENT, this.documentHandler);
    };
    SfDateRangePicker.prototype.documentHandler = function (e) {
        if (sf.base.isNullOrUndefined(this.popupObj)) {
            return;
        }
        var target = e.target;
        if (!this.containerElement.contains(target) ||
            (!sf.base.isNullOrUndefined(this.popupObj) && !sf.base.closest(target, '.e-daterangepicker.e-popup'))) {
            if (e.type !== 'touchstart' && e.type === 'mousedown') {
                e.preventDefault();
            }
        }
        if (!(sf.base.closest(target, '.e-daterangepicker.e-popup'))
            && !(sf.base.closest(target, '.' + INPUTCONTAINER) === this.containerElement)
            && !(sf.base.closest(target, '.e-daterangepicker.e-popup') && (!target.classList.contains('e-day')))) {
            if (this.isPopupOpen() && document.body.contains(this.popupObj.element)) {
                this.applyFunction(e);
            }
        }
    };
    SfDateRangePicker.prototype.applyFunction = function (eve) {
        var isValueChanged = false;
        if (eve.type !== 'touchstart') {
            eve.preventDefault();
        }
        if (document.activeElement !== this.element) {
            this.element.focus();
            sf.base.addClass([this.containerElement], [INPUTFOCUS]);
        }
        this.dotNetRef.invokeMethodAsync(HIDE_POPUP, null);
        if (!(sf.base.closest(eve.target, '.' + INPUTCONTAINER))
            && (!isValueChanged)) {
            if (document.activeElement === this.element) {
                sf.base.removeClass([this.containerElement], [INPUTFOCUS]);
                this.element.blur();
            }
        }
    };
    SfDateRangePicker.prototype.presetHeight = function () {
        var presets = this.popupObj && this.popupObj.element.querySelector('.' + PRESETS);
        var rangeContainer = this.popupObj && this.popupObj.element.querySelector('.' + RANGECONTAINER);
        if (!sf.base.isNullOrUndefined(presets) && !sf.base.isNullOrUndefined(rangeContainer)) {
            presets.style.height = rangeContainer.getBoundingClientRect().height + 'px';
        }
    };
    SfDateRangePicker.prototype.getPopupHeight = function () {
        var height = parseInt(POPUPDIMENSION, 10);
        var popupHeight = this.popupContainer.getBoundingClientRect().height;
        return popupHeight > height ? height : popupHeight;
    };
    SfDateRangePicker.prototype.setScrollPosition = function () {
        if (!sf.base.isNullOrUndefined(this.popupContainer.querySelector('.e-active')) && (this.options.presets)) {
            var selectElement = this.popupContainer.querySelector('.e-active');
            this.findScrollTop(selectElement);
        }
    };
    SfDateRangePicker.prototype.findScrollTop = function (element) {
        var listHeight = this.getPopupHeight();
        var nextEle = element.nextElementSibling;
        var height = nextEle ? nextEle.offsetTop : element.offsetTop;
        var liHeight = element.getBoundingClientRect().height;
        if ((height + element.offsetTop) > listHeight) {
            this.popupContainer.scrollTop = nextEle ? (height - (listHeight / HALFPOSITION + liHeight / HALFPOSITION)) : height;
        }
        else {
            this.popupContainer.scrollTop = 0;
        }
    };
    SfDateRangePicker.prototype.isPopupOpen = function () {
        if (!sf.base.isNullOrUndefined(this.popupObj) && this.popupObj.element.classList.contains(POPUP)) {
            return true;
        }
        return false;
    };
    SfDateRangePicker.prototype.removeFocusDate = function (popupElement, cellId) {
        var focusedDates = popupElement.querySelectorAll('tr td.e-focused-date');
        if (focusedDates.length > 0) {
            sf.base.removeClass(focusedDates, FOCUS_DATE);
        }
        var focusedDate = popupElement.querySelectorAll('tr td');
        for (var i = 0; i < focusedDate.length; i++) {
            if (focusedDate[i].getAttribute('id').split('_')[0] == cellId) {
                sf.base.removeClass(focusedDate, FOCUS_DATE);
                sf.base.addClass([focusedDate[i]], FOCUS_DATE);
                sf.base.closest(focusedDate[i], 'table').focus();
            }
        }
    };
    return SfDateRangePicker;
}());
// tslint:disable
var DateRangePicker = {
    initialize: function (containerElement, element, dotnetRef, options) {
        if (element) {
            new SfDateRangePicker(containerElement, element, dotnetRef, options);
        }
        if (element && element.blazor__instance) {
            element.blazor__instance.initialize();
        }
    },
    renderPopup: function (element, popupElement, popupHolderEle, openEventArgs, options) {
        if (element && element.blazor__instance && popupElement && popupHolderEle) {
            element.blazor__instance.renderPopup(popupElement, popupHolderEle, openEventArgs, options);
        }
    },
    updateScrollPosition: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.setScrollPosition();
        }
    },
    removeFocusDate: function (element, popupElement, cellId) {
        if (element && element.blazor__instance && popupElement) {
            element.blazor__instance.removeFocusDate(popupElement, cellId);
        }
    },
    // tslint:disable
    closePopup: function (element, popupElement, popupHolderEle, closeEventArgs, options) {
        if (element && element.blazor__instance) {
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    },
    refreshPopup: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.refreshPopup();
        }
    },
    focusIn: function (inputEle) {
        if (inputEle) {
            inputEle.focus();
        }
    },
    focusOut: function (inputEle) {
        if (inputEle) {
            inputEle.blur();
        }
    },
    destroy: function (element, popupElement, popupHolderEle, closeEventArgs, options) {
        if (element && element.blazor__instance && popupElement && popupElement instanceof HTMLElement && popupHolderEle) {
            element.blazor__instance.isDisposed = true;
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    }
};

return DateRangePicker;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-dialog.js":
/*!************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-dialog.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Dialog = (function () {
'use strict';

var TAB = 9;
var ENTER = 13;
var ESCAPE = 27;
var BTN = 'e-btn';
var HIDE = 'e-hide';
var FADE = 'e-fade';
var ICON = 'e-icons';
var POPUP = 'e-popup';
var DIALOG = 'e-dialog';
var DEVICE = 'e-device';
var PRIMARY = 'e-primary';
var DLG_MODAL = 'e-dlg-modal';
var DRAGGABLE = 'e-draggable';
var POPUP_OPEN = 'e-popup-open';
var DLG_TARGET = 'e-dlg-target';
var DLG_CONTENT = 'e-dlg-content';
var DLG_OVERLAY = 'e-dlg-overlay';
var DLG_RESIZABLE = 'e-dlg-resizable';
var DLG_FULLSCREEN = 'e-dlg-fullscreen';
var FOOTER_CONTENT = 'e-footer-content';
var SCROLL_DISABLED = 'e-scroll-disabled';
var DLG_REF_ELEMENT = 'e-dlg-ref-element';
var DLG_RESTRICT_LEFT = 'e-restrict-left';
var DLG_RESIZE_HANDLE = 'e-resize-handle';
var DLG_RESIZE_VIEWPORT = 'e-resize-viewport';
var DLG_CLOSE_ICON_BTN = 'e-dlg-closeicon-btn';
var DLG_HEADER_CONTENT = 'e-dlg-header-content';
var SfDialog = /** @class */ (function () {
    function SfDialog(element, options, dotnetRef) {
        this.hasFocusableNode = false;
        this.createdEnabled = false;
        this.element = element;
        this.dotNetRef = dotnetRef;
        this.updateContext(options);
        if (this.element) {
            this.element.blazor__instance = this;
        }
    }
    SfDialog.prototype.initialize = function () {
        this.dlgContainer = undefined;
        this.popupObj = null;
        this.calculatezIndex = (this.zIndex === 1000);
        this.render();
        if (this.createdEnabled) {
            this.dotNetRef.invokeMethodAsync('CreatedEvent', null);
        }
        this.element.classList.remove('e-blazor-hidden');
        if (this.visible) {
            this.dotNetRef.invokeMethodAsync('ShowDialog', null);
        }
        else {
            if (this.isModal) {
                this.dlgOverlay.style.display = 'none';
            }
        }
        this.setWidth();
        this.setMinHeight();
        if (this.enableResize) {
            this.setResize();
            if (this.animationSettings.effect === 'None') {
                this.getMinHeight();
            }
        }
        this.bindEvent(this.element);
    };
    SfDialog.prototype.updateContext = function (dlgObj) {
        sf.base.extend(this, this, dlgObj);
    };
    SfDialog.prototype.setWidth = function () {
        if (this.width === '100%') {
            this.element.style.width = '';
        }
        else {
            sf.base.setStyleAttribute(this.element, { 'width': sf.base.formatUnit(this.width) });
            if (this.width === 'auto') {
                this.refreshPosition();
            }
        }
    };
    SfDialog.prototype.setHeight = function () {
        sf.base.setStyleAttribute(this.element, { 'height': sf.base.formatUnit(this.height) });
    };
    SfDialog.prototype.setMinHeight = function () {
        if (this.minHeight !== '') {
            sf.base.setStyleAttribute(this.element, { 'minHeight': sf.base.formatUnit(this.minHeight) });
        }
    };
    SfDialog.prototype.render = function () {
        var _this = this;
        this.checkPositionData();
        this.targetEle = this.getTargetEle(this.target);
        if (sf.base.Browser.isDevice) {
            sf.base.addClass([this.element], DEVICE);
        }
        if (sf.base.isNullOrUndefined(this.headerContent)) {
            this.headerContent = this.element.querySelector('.' + DLG_HEADER_CONTENT);
        }
        if (sf.base.isNullOrUndefined(this.contentEle)) {
            this.contentEle = this.element.querySelector('.' + DLG_CONTENT);
        }
        this.setMaxHeight();
        if (this.zIndex === 1000) {
            this.setzIndex(this.element, false);
        }
        if (this.allowDragging && (!sf.base.isNullOrUndefined(this.headerContent))) {
            this.setAllowDragging();
        }
        if (this.isModal && sf.base.isNullOrUndefined(this.dlgContainer)) {
            this.dlgContainer = this.element.parentElement;
            this.dlgOverlay = this.element.parentElement.getElementsByClassName(DLG_OVERLAY)[0];
        }
        if (!sf.base.isNullOrUndefined(this.element.parentElement)) {
            var parentEle = this.isModal ? this.dlgContainer.parentElement : this.element.parentElement;
            this.refElement = sf.base.createElement('div', { className: DLG_REF_ELEMENT });
            parentEle.insertBefore(this.refElement, (this.isModal ? this.dlgContainer : this.element));
        }
        if (!sf.base.isNullOrUndefined(this.targetEle)) {
            this.isModal ? this.targetEle.appendChild(this.dlgContainer) : this.targetEle.appendChild(this.element);
        }
        this.popupObj = new sf.popups.Popup(this.element, {
            height: this.height,
            width: this.width,
            zIndex: this.zIndex,
            relateTo: this.getTargetEle(this.target),
            actionOnScroll: 'none',
            enableRtl: this.enableRtl,
            open: function () {
                if (_this.enableResize) {
                    _this.resetResizeIcon();
                }
                _this.dotNetRef.invokeMethodAsync('OpenEvent', _this.element.classList.toString());
            },
            close: function () {
                if (_this.isModal) {
                    sf.base.addClass([_this.dlgOverlay], FADE);
                    _this.dlgContainer.style.display = 'none';
                }
                _this.hasFocusableNode = false;
                _this.dotNetRef.invokeMethodAsync('CloseEvent', _this.element.classList.toString());
            }
        });
        this.positionChange();
        this.setEnableRTL();
    };
    SfDialog.prototype.checkPositionData = function () {
        if (!sf.base.isNullOrUndefined(this.position)) {
            if (!sf.base.isNullOrUndefined(this.position.X) && (typeof (this.position.X) !== 'number')) {
                var isNumber = this.isNumberValue(this.position.X);
                if (isNumber) {
                    this.position.X = parseFloat(this.position.X);
                }
            }
            if (!sf.base.isNullOrUndefined(this.position.Y) && (typeof (this.position.Y) !== 'number')) {
                var isNumber = this.isNumberValue(this.position.Y);
                if (isNumber) {
                    this.position.Y = parseFloat(this.position.Y);
                }
            }
        }
    };
    SfDialog.prototype.isNumberValue = function (value) {
        return /^[-+]?\d*\.?\d+$/.test(value);
    };
    SfDialog.prototype.getTargetEle = function (target) {
        var targetEle;
        if (!sf.base.isNullOrUndefined(target) && (typeof target) === 'string') {
            targetEle = document.querySelector(target);
        }
        return (sf.base.isNullOrUndefined(targetEle) ? document.body : targetEle);
    };
    SfDialog.prototype.setMaxHeight = function () {
        if (!this.allowMaxHeight) {
            return;
        }
        var display = this.element.style.display;
        this.element.style.display = 'none';
        this.element.style.maxHeight = (!sf.base.isNullOrUndefined(this.target)) && (this.targetEle.offsetHeight < window.innerHeight) ?
            (this.targetEle.offsetHeight - 20) + 'px' : (window.innerHeight - 20) + 'px';
        this.element.style.display = display;
        if (sf.base.Browser.isIE && this.height === 'auto' && !sf.base.isNullOrUndefined(this.contentEle)
            && this.element.offsetHeight < this.contentEle.offsetHeight) {
            this.element.style.height = 'inherit';
        }
    };
    SfDialog.prototype.setzIndex = function (zIndexElement, setPopupZindex) {
        this.zIndex = sf.popups.getZindexPartial(zIndexElement);
        if (setPopupZindex) {
            this.popupObj.zIndex = this.zIndex;
        }
    };
    SfDialog.prototype.updatezIndex = function () {
        this.popupObj.zIndex = this.zIndex;
        if (this.isModal) {
            this.setOverlayZindex(this.zIndex);
        }
        this.calculatezIndex = (this.element.style.zIndex !== this.zIndex.toString()) ? false : true;
    };
    SfDialog.prototype.updateTarget = function () {
        this.targetEle = this.getTargetEle(this.target);
        this.popupObj.relateTo = this.targetEle;
        if (this.dragObj) {
            this.dragObj.dragArea = this.targetEle;
        }
        this.setMaxHeight();
        if (this.isModal) {
            this.targetEle.appendChild(this.dlgContainer);
        }
        if (this.enableResize) {
            this.setResize();
        }
    };
    SfDialog.prototype.resetResizeIcon = function () {
        var dialogConHeight = this.getMinHeight();
        if (this.targetEle.offsetHeight < dialogConHeight) {
            var resizeIcon = this.element.querySelector('.' + this.resizeIconDirection);
            if (!sf.base.isNullOrUndefined(resizeIcon)) {
                resizeIcon.style.bottom = '-' + dialogConHeight.toString() + 'px';
            }
        }
    };
    SfDialog.prototype.getMouseEvtArgs = function (e) {
        return {
            altKey: e.altKey, button: e.button, buttons: e.buttons, clientX: e.clientX, clientY: e.clientY, ctrlKey: e.ctrlKey,
            detail: e.detail, metaKey: e.metaKey, screenX: e.screenX, screenY: e.screenY, shiftKey: e.shiftKey, type: e.type
        };
    };
    SfDialog.prototype.setAllowDragging = function () {
        var proxy = this;
        this.dragObj = new sf.base.Draggable(this.element, {
            clone: false,
            isDragScroll: true,
            abort: '.' + DLG_CLOSE_ICON_BTN,
            handle: '.' + DLG_HEADER_CONTENT,
            dragStart: function (e) {
                proxy.dotNetRef.invokeMethodAsync('DragStartEvent', {
                    target: { ID: e.target.id }, event: proxy.getMouseEvtArgs(e.event)
                });
                e.bindEvents(e.dragElement);
            },
            drag: function (e) {
                proxy.dotNetRef.invokeMethodAsync('DragEvent', {
                    target: { ID: e.target.id }, event: proxy.getMouseEvtArgs(e.event)
                });
            },
            dragStop: function (e) {
                if (proxy.isModal) {
                    if (!sf.base.isNullOrUndefined(proxy.position)) {
                        proxy.dlgContainer.classList.remove('e-dlg-' + proxy.position.X + '-' + proxy.position.Y);
                    }
                    proxy.element.style.position = 'relative';
                }
                proxy.dotNetRef.invokeMethodAsync('DragStopEvent', {
                    target: { ID: e.target.id }, event: proxy.getMouseEvtArgs(e.event)
                });
                proxy.element.classList.remove(DLG_RESTRICT_LEFT);
            }
        });
        if (!sf.base.isNullOrUndefined(this.targetEle)) {
            this.dragObj.dragArea = this.targetEle;
        }
    };
    SfDialog.prototype.positionChange = function () {
        if (this.isModal) {
            if (!isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y))) {
                this.setPopupPosition();
            }
            else if ((!isNaN(parseFloat(this.position.X)) && isNaN(parseFloat(this.position.Y)))
                || (isNaN(parseFloat(this.position.X)) && !isNaN(parseFloat(this.position.Y)))) {
                this.setPopupPosition();
            }
            else {
                this.element.style.top = '0px';
                this.element.style.left = '0px';
                this.dlgContainer.classList.add('e-dlg-' + this.position.X + '-' + this.position.Y);
            }
        }
        else {
            this.setPopupPosition();
        }
    };
    SfDialog.prototype.setPopupPosition = function () {
        this.popupObj.setProperties({ position: { X: this.position.X, Y: this.position.Y } });
    };
    SfDialog.prototype.setEnableRTL = function () {
        var resizeElement = this.element.querySelector('.' + DLG_RESIZE_HANDLE);
        if (!sf.base.isNullOrUndefined(resizeElement) && resizeElement.parentElement === this.element) {
            sf.popups.removeResize();
            this.setResize();
        }
    };
    SfDialog.prototype.setResize = function () {
        if (this.enableResize) {
            if (!sf.base.isNullOrUndefined(this.element.querySelector('.' + ICON + '.' + DLG_RESIZE_HANDLE))) {
                return;
            }
            var computedHeight = getComputedStyle(this.element).minHeight;
            var computedWidth = getComputedStyle(this.element).minWidth;
            if (this.isModal && this.enableRtl) {
                this.element.classList.add(DLG_RESTRICT_LEFT);
            }
            else if (this.isModal && (this.target === document.body || this.target === 'body')) {
                this.element.classList.add(DLG_RESIZE_VIEWPORT);
            }
            sf.popups.createResize({
                element: this.element,
                direction: this.resizeIconDirection,
                minHeight: parseInt(computedHeight.slice(0, computedWidth.indexOf('p')), 10),
                maxHeight: this.targetEle.clientHeight,
                minWidth: parseInt(computedWidth.slice(0, computedWidth.indexOf('p')), 10),
                maxWidth: this.targetEle.clientWidth,
                boundary: (this.target === 'body' || this.target === 'document.body') ? null : this.targetEle,
                resizeBegin: this.onResizeStart.bind(this),
                resizeComplete: this.onResizeComplete.bind(this),
                resizing: this.onResizing.bind(this),
                proxy: this
            });
            this.wireWindowResizeEvent();
        }
        else {
            sf.popups.removeResize();
            this.unWireWindowResizeEvent();
            if (this.isModal) {
                this.element.classList.remove(DLG_RESTRICT_LEFT);
            }
            else {
                this.element.classList.remove(DLG_RESIZE_VIEWPORT);
            }
        }
    };
    SfDialog.prototype.getMinHeight = function () {
        var computedHeaderHeight = '0px';
        var computedFooterHeight = '0px';
        if (!sf.base.isNullOrUndefined(this.element.querySelector('.' + DLG_HEADER_CONTENT))) {
            computedHeaderHeight = getComputedStyle(this.headerContent).height;
        }
        var footerEle = sf.base.select('.' + FOOTER_CONTENT, this.element);
        if (!sf.base.isNullOrUndefined(footerEle)) {
            computedFooterHeight = getComputedStyle(footerEle).height;
        }
        var headerHeight = parseInt(computedHeaderHeight.slice(0, computedHeaderHeight.indexOf('p')), 10);
        var footerHeight = parseInt(computedFooterHeight.slice(0, computedFooterHeight.indexOf('p')), 10);
        sf.popups.setMinHeight(headerHeight + 30 + (isNaN(footerHeight) ? 0 : footerHeight));
        return (headerHeight + 30 + footerHeight);
    };
    SfDialog.prototype.changePosition = function (dlgObj) {
        if (this.isModal && this.dlgContainer.classList.contains('e-dlg-' + this.position.X + '-' + this.position.Y)) {
            this.dlgContainer.classList.remove('e-dlg-' + this.position.X + '-' + this.position.Y);
        }
        this.updateContext(dlgObj);
        this.checkPositionData();
        this.positionChange();
    };
    SfDialog.prototype.setOverlayZindex = function (zIndexValue) {
        var zIndex;
        if (sf.base.isNullOrUndefined(zIndexValue)) {
            zIndex = parseInt(this.element.style.zIndex, 10) ? parseInt(this.element.style.zIndex, 10) : this.zIndex;
        }
        else {
            zIndex = zIndexValue;
        }
        this.dlgOverlay.style.zIndex = (zIndex - 1).toString();
        this.dlgContainer.style.zIndex = zIndex.toString();
    };
    SfDialog.prototype.focusContent = function (ele) {
        var element = this.getAutoFocusNode(ele);
        var node = !sf.base.isNullOrUndefined(element) ? element : ele;
        node.focus();
        this.hasFocusableNode = true;
    };
    SfDialog.prototype.getAutoFocusNode = function (container) {
        var node = container.querySelector('.' + DLG_CLOSE_ICON_BTN);
        var value = '[autofocus]';
        var items = container.querySelectorAll(value);
        var validNode = this.getValidFocusNode(items);
        this.primaryButtonEle = this.element.getElementsByClassName(PRIMARY)[0];
        if (!sf.base.isNullOrUndefined(validNode)) {
            node = validNode;
        }
        else {
            validNode = this.focusableElements(this.contentEle);
            if (!sf.base.isNullOrUndefined(validNode)) {
                return node = validNode;
            }
            else if (!sf.base.isNullOrUndefined(this.primaryButtonEle)) {
                return this.element.querySelector('.' + PRIMARY);
            }
        }
        return node;
    };
    SfDialog.prototype.getValidFocusNode = function (items) {
        var node;
        for (var u = 0; u < items.length; u++) {
            node = items[u];
            if ((node.clientHeight > 0 || (node.tagName.toLowerCase() === 'a' && node.hasAttribute('href'))) && node.tabIndex > -1 &&
                !node.disabled && !this.disableElement(node, '[disabled],[aria-disabled="true"],[type="hidden"]')) {
                return node;
            }
            else {
                node = null;
            }
        }
        return node;
    };
    SfDialog.prototype.disableElement = function (element, t) {
        var elementMatch = element ? element.matches || element.webkitMatchesSelector || element.msGetRegionContent : null;
        if (elementMatch) {
            for (; element; element = element.parentNode) {
                if (element instanceof Element && elementMatch.call(element, t)) {
                    return element;
                }
            }
        }
        return null;
    };
    SfDialog.prototype.focusableElements = function (content) {
        if (!sf.base.isNullOrUndefined(content)) {
            var value = 'input,select,textarea,button,a,[contenteditable="true"],[tabindex]';
            var items = content.querySelectorAll(value);
            return this.getValidFocusNode(items);
        }
        return null;
    };
    SfDialog.prototype.getMaxHeight = function (ele) {
        return ele.style.maxHeight;
    };
    SfDialog.prototype.OnPropertyChanged = function (dlgObj, props) {
        this.updateContext(dlgObj);
        for (var _i = 0, props_1 = props; _i < props_1.length; _i++) {
            var key = props_1[_i];
            switch (key) {
                case 'width':
                    sf.base.setStyleAttribute(this.element, { 'width': sf.base.formatUnit(this.width) });
                    break;
                case 'height':
                    this.setHeight();
                    break;
                case 'minHeight':
                    this.setMinHeight();
                    break;
                case 'target':
                    this.updateTarget();
                    break;
                case 'zIndex':
                    this.updatezIndex();
                    break;
                case 'allowDragging':
                    this.setAllowDragging();
                    break;
                case 'destroyDraggable':
                    this.destroyDraggable();
                    break;
                case 'enableRtl':
                    this.setEnableRTL();
                    break;
                case 'enableResize':
                    this.setResize();
                    break;
            }
        }
    };
    SfDialog.prototype.fullScreen = function (enable) {
        if (enable) {
            sf.base.addClass([this.element], DLG_FULLSCREEN);
            var display = this.element.style.display;
            this.element.style.display = 'none';
            this.element.style.maxHeight = (!sf.base.isNullOrUndefined(this.target)) ? (this.targetEle.offsetHeight) + 'px' : (window.innerHeight) + 'px';
            this.element.style.display = display;
            sf.base.addClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
            if (this.allowDragging && !sf.base.isNullOrUndefined(this.dragObj)) {
                this.dragObj.destroy();
                this.dragObj = undefined;
            }
        }
        else {
            sf.base.removeClass([this.element], DLG_FULLSCREEN);
            sf.base.removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
            if (this.allowDragging && (!sf.base.isNullOrUndefined(this.headerContent))) {
                this.setAllowDragging();
            }
        }
    };
    SfDialog.prototype.show = function (isFullScreen, maxHeight, dlgObj) {
        this.updateContext(dlgObj);
        if (!this.element.classList.contains(POPUP_OPEN) || !sf.base.isNullOrUndefined(isFullScreen)) {
            if (!sf.base.isNullOrUndefined(isFullScreen)) {
                this.fullScreen(isFullScreen);
            }
            if (this.element.style.maxHeight !== maxHeight) {
                this.allowMaxHeight = false;
                this.element.style.maxHeight = maxHeight;
            }
            this.storeActiveElement = document.activeElement;
            this.element.tabIndex = -1;
            if (this.isModal && sf.base.isNullOrUndefined(this.dlgOverlay)) {
                this.dlgOverlay = this.element.parentElement.querySelector('.' + DLG_OVERLAY);
            }
            if (this.isModal && !sf.base.isNullOrUndefined(this.dlgOverlay)) {
                this.dlgOverlay.style.display = 'block';
                this.dlgContainer.style.display = 'flex';
                sf.base.removeClass([this.dlgOverlay], FADE);
                if (!sf.base.isNullOrUndefined(this.targetEle)) {
                    if (this.targetEle === document.body) {
                        this.dlgContainer.style.position = 'fixed';
                    }
                    else {
                        this.dlgContainer.style.position = 'absolute';
                    }
                    this.dlgOverlay.style.position = 'absolute';
                    this.element.style.position = 'relative';
                    sf.base.addClass([this.targetEle], [DLG_TARGET, SCROLL_DISABLED]);
                }
                else {
                    sf.base.addClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
                }
            }
            var openAnimation = {
                name: this.animationSettings.effect + 'In',
                duration: this.animationSettings.duration,
                delay: this.animationSettings.delay
            };
            var zIndexElement = (this.isModal) ? this.element.parentElement : this.element;
            if (this.calculatezIndex) {
                this.setzIndex(zIndexElement, true);
                sf.base.setStyleAttribute(this.element, { 'zIndex': this.zIndex });
                if (this.isModal) {
                    this.setOverlayZindex(this.zIndex);
                }
            }
            this.animationSettings.effect === 'None' ? this.popupObj.show() : this.popupObj.show(openAnimation);
        }
    };
    SfDialog.prototype.hide = function () {
        if (this.isModal) {
            !sf.base.isNullOrUndefined(this.targetEle) ? sf.base.removeClass([this.targetEle], [DLG_TARGET, SCROLL_DISABLED]) :
                sf.base.removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
        }
        var closeAnimation = {
            name: this.animationSettings.effect + 'Out',
            duration: this.animationSettings.duration,
            delay: this.animationSettings.delay
        };
        this.animationSettings.effect === 'None' ? this.popupObj.hide() : this.popupObj.hide(closeAnimation);
    };
    SfDialog.prototype.refreshPosition = function () {
        if (this.isModal) {
            this.element.style.top = this.element.style.left = "0px";
            this.dlgContainer.classList.add('e-dlg-' + this.position.X + '-' + this.position.Y);
        }
        else {
            this.popupObj.refreshPosition();
        }
    };
    SfDialog.prototype.destroyDraggable = function () {
        if (!sf.base.isNullOrUndefined(this.dragObj)) {
            this.dragObj.destroy();
            this.dragObj = undefined;
        }
    };
    SfDialog.prototype.destroy = function (dlgObj, isClientApp) {
        this.updateContext(dlgObj);
        var attrs = ['role', 'aria-modal', 'aria-labelledby', 'aria-describedby', 'aria-grabbed', 'tabindex', 'style'];
        if (!sf.base.isNullOrUndefined(this.cssClass) && this.cssClass !== '') {
            var classes = this.cssClass.split(' ');
            sf.base.removeClass([this.element], classes);
        }
        if (sf.base.Browser.isDevice) {
            sf.base.removeClass([this.element], DEVICE);
        }
        sf.base.removeClass([this.getTargetEle(this.target)], [DLG_TARGET, SCROLL_DISABLED]);
        this.unBindEvent(this.element);
        if (this.element.classList.contains(DLG_FULLSCREEN)) {
            sf.base.removeClass([document.body], [DLG_TARGET, SCROLL_DISABLED]);
        }
        if (this.isModal) {
            sf.base.removeClass([(!sf.base.isNullOrUndefined(this.targetEle) ? this.targetEle : document.body)], SCROLL_DISABLED);
        }
        if (this.element.classList.contains(DLG_RESIZABLE)) {
            this.element.classList.remove(DLG_RESIZABLE);
        }
        if (this.element.classList.contains(DRAGGABLE)) {
            this.dragObj.destroy();
            this.dragObj = undefined;
        }
        if (this.element.classList.contains(POPUP)) {
            this.popupObj.destroy();
            this.popupObj = undefined;
        }
        if (!sf.base.isNullOrUndefined(this.refElement) && !sf.base.isNullOrUndefined(this.refElement.parentElement)) {
            this.refElement.parentElement.insertBefore((this.isModal ? this.dlgContainer : this.element), this.refElement);
            sf.base.detach(this.refElement);
            this.refElement = undefined;
        }
        if (isClientApp) {
            for (var i = 0; i < this.element.children.length; i++) {
                this.element.children[i].classList.add(HIDE);
            }
        }
        else {
            if (!sf.base.isNullOrUndefined(this.element.children)) {
                for (var i = 0; i <= this.element.children.length; i++) {
                    i = i - i;
                    sf.base.detach(this.element.children[i]);
                }
            }
        }
        for (var i = 0; i < attrs.length; i++) {
            this.element.removeAttribute(attrs[i]);
        }
        if (this.isModal) {
            sf.base.detach(this.element.nextElementSibling);
            var parent_1 = this.element.parentElement;
            parent_1.removeAttribute('class');
            parent_1.removeAttribute('style');
            this.element.classList.remove(DLG_MODAL);
        }
        this.element.classList.remove(DIALOG);
    };
    SfDialog.prototype.bindEvent = function (element) {
        sf.base.EventHandler.add(element, 'keydown', this.keyDown, this);
    };
    SfDialog.prototype.unBindEvent = function (element) {
        sf.base.EventHandler.remove(element, 'keydown', this.keyDown);
    };
    SfDialog.prototype.wireWindowResizeEvent = function () {
        window.addEventListener('resize', this.windowResizeHandler.bind(this));
    };
    SfDialog.prototype.unWireWindowResizeEvent = function () {
        window.removeEventListener('resize', this.windowResizeHandler.bind(this));
    };
    /* Event handlers begin */
    SfDialog.prototype.popupCloseHandler = function () {
        var activeEle = document.activeElement;
        if (!sf.base.isNullOrUndefined(activeEle) && !sf.base.isNullOrUndefined(activeEle.blur)) {
            activeEle.blur();
        }
        if (!sf.base.isNullOrUndefined(this.storeActiveElement) && !sf.base.isNullOrUndefined(this.storeActiveElement.focus)) {
            this.storeActiveElement.focus();
        }
    };
    SfDialog.prototype.windowResizeHandler = function () {
        sf.popups.setMaxWidth(this.targetEle.clientWidth);
        sf.popups.setMaxHeight(this.targetEle.clientHeight);
        this.setMaxHeight();
    };
    SfDialog.prototype.onResizeStart = function (args, dialogObj) {
        var evtArgs = this.getMouseEvtArgs(args);
        this.dotNetRef.invokeMethodAsync('ResizeStartEvent', evtArgs);
    };
    SfDialog.prototype.onResizing = function (args, dialogObj) {
        this.dotNetRef.invokeMethodAsync('ResizingEvent', this.getMouseEvtArgs(args));
    };
    SfDialog.prototype.onResizeComplete = function (args, dialogObj) {
        this.dotNetRef.invokeMethodAsync('ResizeStopEvent', this.getMouseEvtArgs(args));
    };
    SfDialog.prototype.getFocusElement = function (target) {
        var value = 'input,select,textarea,button:enabled,a,[contenteditable="true"],[tabindex]';
        var items = target.querySelectorAll(value);
        return items[items.length - 1];
    };
    SfDialog.prototype.keyDown = function (e) {
        var _this = this;
        if (e.keyCode === TAB && this.isModal) {
            var btn = void 0;
            var btns = void 0;
            var footer = this.element.querySelector('.' + FOOTER_CONTENT);
            if (!sf.base.isNullOrUndefined(footer)) {
                btns = footer.querySelectorAll('button');
                if (!sf.base.isNullOrUndefined(btn) && btns.length > 0) {
                    btn = btns[btns.length - 1];
                }
                if (sf.base.isNullOrUndefined(btn) && footer.childNodes.length > 0) {
                    btn = this.getFocusElement(footer);
                }
            }
            if (sf.base.isNullOrUndefined(footer) && !sf.base.isNullOrUndefined(this.contentEle)) {
                btn = this.getFocusElement(this.contentEle);
            }
            if (!sf.base.isNullOrUndefined(btn) && document.activeElement === btn && !e.shiftKey) {
                e.preventDefault();
                this.focusableElements(this.element).focus();
            }
            if (document.activeElement === this.focusableElements(this.element) && e.shiftKey) {
                e.preventDefault();
                if (!sf.base.isNullOrUndefined(btn)) {
                    btn.focus();
                }
            }
        }
        if (e.keyCode === ESCAPE && this.closeOnEscape) {
            this.dotNetRef.invokeMethodAsync('CloseDialog', {
                altKey: e.altKey, ctrlKey: e.ctrlKey, code: e.code, key: e.key, location: e.location,
                repeat: e.repeat, shiftKey: e.shiftKey, metaKey: e.metaKey, type: e.type
            });
        }
        if (this.hasFocusableNode) {
            var element = document.activeElement;
            var isTagName = (['input', 'textarea'].indexOf(element.tagName.toLowerCase()) > -1);
            var isContentEdit = false;
            if (!isTagName) {
                isContentEdit = element.hasAttribute('contenteditable') && element.getAttribute('contenteditable') === 'true';
            }
            if ((e.keyCode === ENTER && !e.ctrlKey && element.tagName.toLowerCase() !== 'textarea' &&
                isTagName && !sf.base.isNullOrUndefined(this.primaryButtonEle)) || (e.keyCode === ENTER && e.ctrlKey &&
                (element.tagName.toLowerCase() === 'textarea' || isContentEdit)) && !sf.base.isNullOrUndefined(this.primaryButtonEle)) {
                setTimeout(function () {
                    _this.element.querySelector('.' + FOOTER_CONTENT + ' button.' + BTN + '.' + PRIMARY).click();
                });
            }
        }
    };
    return SfDialog;
}());
// eslint-disable-next-line
var Dialog = {
    initialize: function (element, options, dotnetRef) {
        if (element) {
            new SfDialog(element, options, dotnetRef);
            element.blazor__instance.initialize();
        }
    },
    getClassList: function (element) {
        return element && element.classList.toString();
    },
    getMaxHeight: function (element) {
        return element ? element.blazor__instance.getMaxHeight(element) : null;
    },
    changePosition: function (dlgObj) {
        if (!sf.base.isNullOrUndefined(dlgObj.element)) {
            dlgObj.element.blazor__instance.changePosition(dlgObj);
        }
    },
    focusContent: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.focusContent(element);
        }
    },
    refreshPosition: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.refreshPosition();
        }
    },
    popupCloseHandler: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.popupCloseHandler();
        }
    },
    propertyChanged: function (dlgObj, changedProps) {
        if (!sf.base.isNullOrUndefined(dlgObj.element)) {
            dlgObj.element.blazor__instance.OnPropertyChanged(dlgObj, changedProps);
        }
    },
    show: function (isFullScreen, maxHeight, dlgObj) {
        if (dlgObj.element) {
            dlgObj.element.blazor__instance.show(isFullScreen, maxHeight, dlgObj);
        }
    },
    hide: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.hide();
        }
    },
    destroy: function (dlgObj, isClientApp) {
        var ele = dlgObj && dlgObj.element;
        if (!sf.base.isNullOrUndefined(ele) && !sf.base.isNullOrUndefined(ele.blazor__instance)) {
            ele.blazor__instance.destroy(dlgObj, isClientApp);
        }
    }
};

return Dialog;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-drop-down-button.js":
/*!**********************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-drop-down-button.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.DropDownButton = (function () {
'use strict';

/* eslint-disable @typescript-eslint/no-explicit-any */
var HIDDEN = 'hidden';
var TRANSPARENT = 'e-transparent';
var EMPTY = '';
var PIXEL = 'px';
var DOT = '.';
var HASH = '#';
var BTN_CLICK = 'ButtonClickAsync';
var DROPDOWN = 'e-dropdown-menu';
var COLOR_PICKER = 'e-colorpicker-container';
var HSV_MODEL = 'e-hsv-model';
var MODEL = '.e-colorpicker.e-modal';
var CONTAINER = '.e-container';
var ITEM = 'e-item';
var FOCUSED = 'e-focused';
var WRAPPER = 'e-split-btn-wrapper';
var ELEMENT = 'e-dropdown-btn';
var MOUSEDOWN = 'mousedown touchstart';
var KEYDOWN = 'keydown';
var CLICK = 'click';
var SCROLL = 'scroll';
var ESC = 27;
var UP = 38;
var DOWN = 40;
var ENTER = 13;
var TAB = 9;
var RTL = 'e-rtl';
/**
 * Dropdown Button Blazor introp module
 */
var SfDropDownButton = /** @class */ (function () {
    function SfDropDownButton(element, popup, dotnetRef) {
        this.element = element;
        this.dotNetRef = dotnetRef;
        this.popup = popup;
        this.element.blazor__instance = this;
        this.addScrollEvents(true);
    }
    SfDropDownButton.prototype.openPopup = function (blankIcon) {
        this.popup.style.visibility = HIDDEN;
        document.body.appendChild(this.popup);
        if (blankIcon) {
            sf.splitbuttons.setBlankIconStyle(this.popup);
        }
        this.popup.classList.remove(TRANSPARENT);
        var zIndex = sf.popups.getZindexPartial(this.element);
        var isColorPicker = this.element.parentElement.classList.contains(COLOR_PICKER);
        if (isColorPicker) {
            this.element.parentElement.blazor__instance.setPaletteWidth(this.popup.querySelector(CONTAINER), false, zIndex);
        }
        this.setPosition(isColorPicker);
        sf.base.EventHandler.remove(document, MOUSEDOWN, this.mouseDownHandler);
        this.addEventListener();
        this.popup.style.zIndex = zIndex + EMPTY;
        this.popup.style.visibility = EMPTY;
        if (isColorPicker) {
            this.element.parentElement.blazor__instance.setOffset(this.popup, zIndex);
        }
        if (this.popup.firstElementChild) {
            if (this.popup.firstElementChild.firstElementChild && isColorPicker) {
                this.popup.firstElementChild.firstElementChild.focus();
            }
            else {
                this.popup.firstElementChild.focus();
            }
        }
    };
    SfDropDownButton.prototype.setPosition = function (isColorPicker) {
        var left;
        var top;
        var btnOffset = this.element.getBoundingClientRect();
        var popupOffset = this.popup.getBoundingClientRect();
        if (isColorPicker && sf.base.Browser.isDevice) {
            left = ((document.documentElement.clientWidth / 2) - (popupOffset.width / 2)) + pageXOffset;
            top = ((document.documentElement.clientHeight / 2) - (popupOffset.height / 2)) + pageYOffset;
        }
        else {
            left = btnOffset.left + pageXOffset;
            top = btnOffset.bottom + pageYOffset;
            if (btnOffset.bottom + popupOffset.height > document.documentElement.clientHeight) {
                if (top - btnOffset.height - popupOffset.height > document.documentElement.clientTop) {
                    top = top - btnOffset.height - popupOffset.height;
                }
            }
            if (btnOffset.left + popupOffset.width > document.documentElement.clientWidth) {
                if (btnOffset.right - popupOffset.width > document.documentElement.clientLeft) {
                    left = (left + btnOffset.width) - popupOffset.width;
                }
            }
        }
        this.popup.style.left = Math.ceil(left) + PIXEL;
        this.popup.style.top = Math.ceil(top) + PIXEL;
    };
    SfDropDownButton.prototype.mouseDownHandler = function (e) {
        if (this.popup.parentElement) {
            var target = e.target;
            var prevent = true;
            if (!sf.base.Browser.isDevice && target.classList.contains(HSV_MODEL)) {
                var ref = target.parentElement.getBoundingClientRect();
                var btn = this.element.getBoundingClientRect();
                prevent = (e.clientX >= ref.left && e.clientX <= ref.right && e.clientY >= ref.top && e.clientY <= ref.bottom) ||
                    (e.clientX >= btn.left && e.clientX <= btn.right && e.clientY >= btn.top && e.clientY <= btn.bottom);
            }
            if (!prevent || (!sf.base.closest(target, HASH + this.getDropDownButton().id) && !sf.base.closest(e.target, HASH + this.popup.id) &&
                !sf.base.closest(e.target, MODEL))) {
                this.dotNetRef.invokeMethodAsync(BTN_CLICK, null);
                this.removeEventListener();
            }
        }
        else {
            this.removeEventListener();
        }
    };
    SfDropDownButton.prototype.keydownHandler = function (e) {
        var element = this.getElement();
        var isColorPicker = this.element.parentElement.classList.contains(COLOR_PICKER);
        var Rtl = this.element.parentElement.classList.contains(RTL);
        if (isColorPicker) {
            this.element.parentElement.blazor__instance.paletteKeyDown(e, Rtl);
        }
        if (e.altKey) {
            if (e.keyCode === UP) {
                e.stopPropagation();
                e.preventDefault();
                this.dotNetRef.invokeMethodAsync(BTN_CLICK, null);
                element.focus();
                this.removeEventListener();
            }
        }
        else {
            var ul = this.popup.firstElementChild;
            if (e.keyCode === ESC || e.keyCode === TAB && !isColorPicker) {
                e.stopPropagation();
                this.dotNetRef.invokeMethodAsync(BTN_CLICK, null);
                if (e.keyCode === ESC) {
                    e.preventDefault();
                }
                element.focus();
                this.removeEventListener();
            }
            if (!ul || !ul.classList.contains(DROPDOWN)) {
                return;
            }
            if (e.keyCode === ENTER) {
                e.preventDefault();
                if (e.target.classList.contains(ITEM) && e.target.classList.contains(FOCUSED)) {
                    element.focus();
                    this.removeEventListener();
                }
                else {
                    e.stopPropagation();
                }
                return;
            }
            if (e.keyCode === UP || e.keyCode === DOWN) {
                if (e.target.classList.contains(DROPDOWN)) {
                    e.stopPropagation();
                }
                e.preventDefault();
                sf.splitbuttons.upDownKeyHandler(ul, e.keyCode);
            }
        }
    };
    SfDropDownButton.prototype.getElement = function () {
        return (this.element.classList.contains(WRAPPER) ? this.element.firstElementChild : this.element);
    };
    SfDropDownButton.prototype.getDropDownButton = function () {
        return this.element.classList.contains(WRAPPER) ?
            this.element.getElementsByClassName(ELEMENT)[0] : this.element;
    };
    SfDropDownButton.prototype.clickHandler = function (e) {
        if (sf.base.closest(e.target, DOT + ITEM)) {
            this.removeEventListener();
            this.getElement().focus();
        }
    };
    SfDropDownButton.prototype.scrollHandler = function (e) {
        if (!this.popup || !document.getElementById(this.popup.id)) {
            var ddb = this.getDropDownButton();
            if (!ddb || !document.getElementById(ddb.id)) {
                sf.base.EventHandler.remove(e.target, SCROLL, this.scrollHandler);
            }
            return;
        }
        var isColorPicker = this.element.parentElement.classList.contains(COLOR_PICKER);
        this.setPosition(isColorPicker);
        if (isColorPicker) {
            this.element.parentElement.blazor__instance.setOffset(this.popup);
        }
    };
    SfDropDownButton.prototype.addEventListener = function (setFocus) {
        sf.base.EventHandler.add(document, MOUSEDOWN, this.mouseDownHandler, this);
        sf.base.EventHandler.add(this.popup, CLICK, this.clickHandler, this);
        sf.base.EventHandler.add(this.popup, KEYDOWN, this.keydownHandler, this);
        if (setFocus && this.popup.firstElementChild) {
            var focusEle = this.popup.querySelector(DOT + FOCUSED);
            focusEle ? focusEle.focus() : this.popup.firstElementChild.focus();
        }
    };
    SfDropDownButton.prototype.removeEventListener = function (reposition) {
        sf.base.EventHandler.remove(document, MOUSEDOWN, this.mouseDownHandler);
        if (this.popup.parentElement) {
            sf.base.EventHandler.remove(this.popup, CLICK, this.clickHandler);
            sf.base.EventHandler.remove(this.popup, KEYDOWN, this.keydownHandler);
            if (reposition) {
                var ddb = this.getDropDownButton();
                if (ddb && document.getElementById(ddb.id)) {
                    this.addScrollEvents(false);
                    this.element.appendChild(this.popup);
                }
            }
        }
    };
    SfDropDownButton.prototype.addScrollEvents = function (add) {
        var elements = sf.popups.getScrollableParent(this.element);
        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
            var element = elements_1[_i];
            add ? sf.base.EventHandler.add(element, SCROLL, this.scrollHandler, this) :
                sf.base.EventHandler.remove(element, SCROLL, this.scrollHandler);
        }
    };
    return SfDropDownButton;
}());
// eslint-disable-next-line @typescript-eslint/naming-convention, no-underscore-dangle, id-blacklist, id-match
var DropDownButton = {
    openPopup: function (element, popup, dotnetRef, blankIcon) {
        if (!sf.base.isNullOrUndefined(element)) {
            if (sf.base.isNullOrUndefined(element.blazor__instance)) {
                new SfDropDownButton(element, popup, dotnetRef);
            }
            else {
                element.blazor__instance.popup = popup;
            }
            element.blazor__instance.openPopup(blankIcon);
        }
    },
    addEventListener: function (element) {
        element.blazor__instance.removeEventListener();
        element.blazor__instance.addEventListener(true);
    },
    removeEventListener: function (element) {
        element.blazor__instance.removeEventListener(true);
    }
};

return DropDownButton;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-dropdownlist.js":
/*!******************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-dropdownlist.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.DropDownList = (function () {
'use strict';

var POPUP_CONTENT = 'e-content';
var LIST_ITEM = 'e-list-item';
var CLOSE_POPUP = 'ClosePopup';
var ITEM_FOCUS = 'e-item-focus';
var DDL_DEVICE = 'e-ddl-device';
var MOBILE_FILTER = 'e-ddl-device-filter';
var POPUP_FULL_SCREEN = 'e-popup-full-page';
var INPUT_FOCUS = 'e-input-focus';
var FIXED_HEAD = 'e-fixed-head';
var GROUP = 'e-list-group-item';
var SELECTED = 'e-active';
var HOVER = 'e-hover';
var HIDE = 'Hide';
var ICON_ANIM = 'e-icon-anim';
var VIRTUAL_HANDLER = 'VirtualScrollHandler';
var SfDropDownList = /** @class */ (function () {
    // tslint:disable
    function SfDropDownList(containerElement, element, dotnetRef, options) {
        this.activeIndex = null;
        this.prevSelectPoints = {};
        this.containerElement = containerElement;
        this.element = element;
        this.options = options;
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
    }
    SfDropDownList.prototype.initialize = function () {
        this.keyConfigure = {
            tab: 'tab',
            enter: '13',
            escape: '27',
            end: '35',
            home: '36',
            down: '40',
            up: '38',
            pageUp: '33',
            pageDown: '34',
            open: 'alt+40',
            close: 'shift+tab',
            hide: 'alt+38',
            space: '32'
        };
        if (!sf.base.Browser.isDevice) {
            new sf.base.KeyboardEvents(this.containerElement, {
                keyAction: this.keyActionHandler.bind(this), keyConfigs: this.keyConfigure, eventName: 'keydown'
            });
        }
        if (this.options.moduleName === 'SfComboBox') {
            sf.base.EventHandler.add(this.element, 'keydown', this.onFilterDown, this);
        }
    };
    SfDropDownList.prototype.setAutoFillSelection = function (currentValue) {
        if (!this.isAndroidAutoFill(currentValue)) {
            this.autoFillSelection(currentValue);
        }
    };
    SfDropDownList.prototype.onFilterDown = function (e) {
        if (!(e.keyCode === 13 || e.keyCode === 40 || e.keyCode === 38 || e.keyCode === 9)) {
            this.prevSelectPoints = this.getSelectionPoints();
        }
    };
    SfDropDownList.prototype.getSelectionPoints = function () {
        var input = this.element;
        return { start: Math.abs(input.selectionStart), end: Math.abs(input.selectionEnd) };
    };
    SfDropDownList.prototype.autoFillSelection = function (currentValue) {
        var selection = this.getSelectionPoints();
        var value = this.element.value.substr(0, selection.start);
        if (value && (value.toLowerCase() === currentValue.substr(0, selection.start).toLowerCase())) {
            var inputValue = value + currentValue.substr(value.length, currentValue.length);
            this.element.value = inputValue;
            this.element.setSelectionRange(selection.start, this.element.value.length);
        }
        else {
            this.element.value = currentValue;
            this.element.setSelectionRange(0, this.element.value.length);
        }
    };
    
    SfDropDownList.prototype.isAndroidAutoFill = function (value) {
        if (sf.base.Browser.isAndroid) {
            var currentPoints = this.getSelectionPoints();
            var prevEnd = this.prevSelectPoints.end;
            var curEnd = currentPoints.end;
            var prevStart = this.prevSelectPoints.start;
            var curStart = currentPoints.start;
            if (prevEnd !== 0 && ((prevEnd === value.length && prevStart === value.length) ||
                (prevStart > curStart && prevEnd > curEnd) || (prevEnd === curEnd && prevStart === curStart))) {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    };
    SfDropDownList.prototype.removeFillSelection = function () {
        var selection = this.getSelectionPoints();
        this.element.setSelectionRange(selection.end, selection.end);
    };
    SfDropDownList.prototype.keyActionHandler = function (e) {
        var keyEventsArgs = {
            Action: e.action,
            Key: e.key,
            Events: e,
            Type: e.type
        };
        if (!this.isDisposed) {
            this.dotNetRef.invokeMethodAsync('KeyActionHandler', keyEventsArgs);
        }
        if (e.action !== 'tab' && e.action !== 'close' && e.action !== 'space' && e.action !== 'enter' && e.action !== 'open'
            && (this.options.moduleName === 'SfDropDownList' || e.action !== 'home' && e.action !== 'end')) {
            e.preventDefault();
        }
    };
    SfDropDownList.prototype.getOffsetValue = function (popupEle) {
        var popupStyles = getComputedStyle(popupEle);
        var borderTop = parseInt(popupStyles.borderTopWidth, 10);
        var borderBottom = parseInt(popupStyles.borderBottomWidth, 10);
        return this.setPopupPosition(borderTop + borderBottom);
    };
    SfDropDownList.prototype.setPopupPosition = function (border) {
        var offsetValue;
        var popupOffset = border;
        var selectedLI = this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED);
        var firstItem = this.isEmptyList() ? this.list : this.liCollections[0];
        var lastItem = this.isEmptyList() ? this.list : this.liCollections[this.getItems().length - 1];
        var liHeight = firstItem.getBoundingClientRect().height;
        var listHeight = this.list.offsetHeight / 2;
        var height = sf.base.isNullOrUndefined(selectedLI) ? firstItem.offsetTop : selectedLI.offsetTop;
        var lastItemOffsetValue = lastItem.offsetTop;
        if (lastItemOffsetValue - listHeight < height && !sf.base.isNullOrUndefined(this.liCollections) &&
            this.liCollections.length > 0 && !sf.base.isNullOrUndefined(selectedLI)) {
            var count = this.list.offsetHeight / liHeight;
            var paddingBottom = parseInt(getComputedStyle(this.list).paddingBottom, 10);
            offsetValue = (count - (this.liCollections.length - this.activeIndex)) * liHeight - popupOffset + paddingBottom;
            this.list.scrollTop = selectedLI.offsetTop;
        }
        else if (height > listHeight) {
            offsetValue = listHeight - liHeight / 2;
            this.list.scrollTop = height - listHeight + liHeight / 2;
        }
        else {
            offsetValue = height;
        }
        var inputHeight = this.containerElement.offsetHeight;
        offsetValue = offsetValue + liHeight + popupOffset - ((liHeight - inputHeight) / 2);
        return -offsetValue;
    };
    SfDropDownList.prototype.getItems = function () {
        return this.list ? this.list.querySelectorAll('.' + LIST_ITEM) : [];
    };
    // tslint:disable
    SfDropDownList.prototype.renderPopup = function (popupElement, popupHolderEle, openEventArgs, isModifiedPopup, options, dataItem) {
        this.options = options;
        this.popupHolder = popupHolderEle;
        this.list = popupHolderEle.querySelector('.' + POPUP_CONTENT) || sf.base.select('.' + POPUP_CONTENT);
        this.liCollections = this.getItems();
        var offsetValue = 0;
        var left;
        var listHeight = sf.base.formatUnit(this.options.popupHeight);
        var searchBoxContainer;
        this.wireListEvents();
        if (popupElement) {
            var oldPopupEle = document.getElementById(popupElement.id);
            if (oldPopupEle) {
                sf.base.remove(oldPopupEle);
            }
        }
        document.body.appendChild(popupElement);
        popupElement.style.visibility = 'hidden';
        if (this.options.allowFiltering) {
            if (this.options.moduleName === 'SfDropDownList') {
                this.filterInput = popupElement.querySelector('input.e-input');
                searchBoxContainer = this.filterInput.parentElement;
                new sf.base.KeyboardEvents(this.filterInput, {
                    keyAction: this.keyActionHandler.bind(this),
                    keyConfigs: this.keyConfigure,
                    eventName: 'keydown'
                });
            }
            else {
                this.filterInput = this.element;
            }
        }
        if (this.options.popupHeight !== 'auto') {
            var searchBoxHeight = 0;
            if (!sf.base.isNullOrUndefined(searchBoxContainer)) {
                searchBoxHeight = (searchBoxContainer.parentElement).getBoundingClientRect().height;
                listHeight = (parseInt(listHeight, 10) - (searchBoxHeight)).toString() + 'px';
            }
            if (popupElement.querySelector('.e-ddl-header')) {
                var header = popupElement.querySelector('.e-ddl-header');
                var height = Math.round(header.getBoundingClientRect().height);
                listHeight = (parseInt(listHeight, 10) - (height + searchBoxHeight)).toString() + 'px';
            }
            if (popupElement.querySelector('.e-ddl-footer')) {
                var footer = popupElement.querySelector('.e-ddl-footer');
                var height = Math.round(footer.getBoundingClientRect().height);
                listHeight = (parseInt(listHeight, 10) - (height + searchBoxHeight)).toString() + 'px';
            }
            this.list.style.maxHeight = (parseInt(listHeight, 10) - 2).toString() + 'px'; // due to box-sizing property
            popupElement.style.maxHeight = sf.base.formatUnit(this.options.popupHeight);
        }
        else {
            popupElement.style.height = 'auto';
        }
        if (this.list && this.list.querySelector('.' + SELECTED)) {
            this.setScrollPosition();
        }
        if (sf.base.Browser.isDevice && (!this.options.allowFiltering && (this.options.moduleName === 'SfDropDownList' ||
            (this.options.moduleName === 'SfComboBox')))) {
            offsetValue = this.getOffsetValue(popupElement);
            var firstItem = this.isEmptyList() ? this.list : this.liCollections[0];
            left = -(parseInt(getComputedStyle(firstItem).textIndent, 10) -
                parseInt(getComputedStyle(this.element).paddingLeft, 10) +
                parseInt(getComputedStyle(this.element.parentElement).borderLeftWidth, 10));
        }
        this.popupCreation(popupElement, offsetValue, left);
        this.checkCollision(popupElement);
        if (sf.base.Browser.isDevice) {
            this.popupObj.element.classList.add(DDL_DEVICE);
            if (this.options.moduleName === 'SfDropDownList' || (this.options.moduleName === 'SfComboBox'
                && !this.options.allowFiltering)) {
                this.popupObj.collision = { X: 'fit', Y: 'fit' };
            }
            if (this.options.allowFiltering && this.options.moduleName === 'SfDropDownList') {
                this.popupObj.element.classList.add(MOBILE_FILTER);
                this.popupObj.position = { X: 0, Y: 0 };
                this.popupObj.dataBind();
                sf.base.attributes(this.popupObj.element, { style: 'left:0px;right:0px;top:0px;bottom:0px;' });
                sf.base.addClass([document.body, this.popupObj.element], POPUP_FULL_SCREEN);
                this.setSearchBoxPosition();
            }
        }
        popupElement.style.visibility = 'visible';
        sf.base.addClass([popupElement], 'e-popup-close');
        if (sf.base.Browser.isDevice) {
            if ((this.options.moduleName === 'SfDropDownList' &&
                !this.options.allowFiltering) || (this.options.moduleName === 'SfComboBox' && !this.options.allowFiltering)) {
                var scrollParentElements = this.popupObj.getScrollableParent(this.containerElement);
                for (var _i = 0, scrollParentElements_1 = scrollParentElements; _i < scrollParentElements_1.length; _i++) {
                    var element = scrollParentElements_1[_i];
                    sf.base.EventHandler.add(element, 'scroll', this.scrollHandler, this);
                }
            }
            if (this.isFilterLayout()) {
                sf.base.EventHandler.add(this.list, 'scroll', this.listScroll, this);
            }
        }
        if (openEventArgs !== null && openEventArgs.popup !== null && isModifiedPopup) {
            for (var _a = 0, _b = Object.keys(openEventArgs.popup); _a < _b.length; _a++) {
                var prop = _b[_a];
                switch (prop) {
                    case 'collision':
                        if (openEventArgs.popup.collision && (this.popupObj.collision.X !== openEventArgs.popup.collision.X.toLowerCase() || this.popupObj.collision.Y !== openEventArgs.popup.collision.Y.toLowerCase())) {
                            this.popupObj.collision = { X: openEventArgs.popup.collision.X.toLowerCase(), Y: openEventArgs.popup.collision.Y.toLowerCase() };
                        }
                        break;
                    case 'position':
                        if (this.popupObj.position && (this.popupObj.position.X !== openEventArgs.popup.position.X || this.popupObj.position.Y !== openEventArgs.popup.position.Y)) {
                            this.popupObj.position = { X: openEventArgs.popup.position.X, Y: openEventArgs.popup.position.Y };
                        }
                        break;
                    case 'relateTo':
                        if (this.popupObj.relateTo !== openEventArgs.popup.relateTo) {
                            this.popupObj.relateTo = openEventArgs.popup.relateTo;
                        }
                        break;
                    case 'targetType':
                        if (this.popupObj.targetType !== openEventArgs.popup.targetType.toLowerCase()) {
                            this.popupObj.targetType = openEventArgs.popup.targetType;
                        }
                        break;
                    case 'offsetX':
                        if (this.popupObj.offsetX !== openEventArgs.popup.offsetX) {
                            this.popupObj.offsetX = openEventArgs.popup.offsetX;
                        }
                        break;
                    case 'offsetY':
                        if (this.popupObj.offsetY !== openEventArgs.popup.offsetY) {
                            this.popupObj.offsetY = openEventArgs.popup.offsetY;
                        }
                        break;
                }
            }
            this.popupObj.dataBind();
            this.popupObj.refreshPosition(this.popupObj.relateTo, true);
        }
        if (this.options.enableVirtualization) {
            sf.base.EventHandler.add(this.list, 'scroll', this.virtualScroll, this);
        }
        sf.base.attributes(this.containerElement, { 'aria-expanded': 'true' });
        var inputParent = this.options.allowFiltering ? this.filterInput.parentElement : this.containerElement;
        sf.base.addClass([inputParent], [INPUT_FOCUS]);
        var animModel = { name: 'FadeIn', duration: 100 };
        this.popupObj.show(new sf.base.Animation(animModel), (this.options.zIndex === 1000) ? this.element : null);
    };
    SfDropDownList.prototype.wireListEvents = function () {
        sf.base.EventHandler.add(this.list, 'mouseover', this.onMouseOver, this);
        sf.base.EventHandler.add(this.list, 'mouseout', this.onMouseLeave, this);
    };
    
    SfDropDownList.prototype.unWireListEvents = function () {
        sf.base.EventHandler.remove(this.list, 'mouseover', this.onMouseOver);
        sf.base.EventHandler.remove(this.list, 'mouseout', this.onMouseLeave);
    };
    
    SfDropDownList.prototype.onMouseOver = function (e) {
        var currentLi = sf.base.closest(e.target, '.' + LIST_ITEM);
        this.setHover(currentLi);
    };
    
    SfDropDownList.prototype.onMouseLeave = function (e) {
        this.removeHover();
    };
    
    SfDropDownList.prototype.listScroll = function () {
        this.filterInput.blur();
    };
    SfDropDownList.prototype.scrollHandler = function () {
        if (!this.isDisposed) {
            this.dotNetRef.invokeMethodAsync(HIDE);
        }
    };
    SfDropDownList.prototype.setFloatingHeader = function (e) {
        var list = this.popupContainer && this.popupContainer.querySelector('.e-content');
        if (list && list.classList.contains('e-nodata') && this.fixedHeaderElement) {
            sf.base.remove(this.fixedHeaderElement);
            this.fixedHeaderElement = null;
        }
        else if (this.list && this.list.querySelector('li')) {
            if (sf.base.isNullOrUndefined(this.fixedHeaderElement)) {
                this.fixedHeaderElement = sf.base.createElement('div', { className: FIXED_HEAD });
                if (!this.list.querySelector('li').classList.contains(GROUP)) {
                    this.fixedHeaderElement.style.display = 'none';
                }
                sf.base.prepend([this.fixedHeaderElement], this.list);
                this.setFixedHeader();
            }
            this.scrollStop(e);
        }
    };
    SfDropDownList.prototype.setFixedHeader = function () {
        this.list.parentElement.style.display = 'block';
        var borderWidth = 0;
        if (this.list && this.list.parentElement) {
            borderWidth = parseInt(document.defaultView.getComputedStyle(this.list.parentElement, null).getPropertyValue('border-width'), 10);
        }
        var liWidth = this.liCollections[0].offsetWidth - borderWidth;
        this.fixedHeaderElement.style.width = liWidth.toString() + 'px';
        sf.base.setStyleAttribute(this.fixedHeaderElement, { zIndex: 10 });
        var firstLi = this.list.querySelector('.' + GROUP);
        this.fixedHeaderElement.innerHTML = firstLi.innerHTML;
    };
    SfDropDownList.prototype.scrollStop = function (e) {
        var target = e.target;
        var liCollections = this.list.querySelectorAll('li');
        var liHeight = parseInt(getComputedStyle(liCollections[0], null).getPropertyValue('height'), 10);
        var topIndex = Math.round(target.scrollTop / liHeight);
        for (var i = topIndex; i > -1; i--) {
            if (!sf.base.isNullOrUndefined(liCollections[i]) && liCollections[i].classList.contains(GROUP)) {
                var currentLi = liCollections[i];
                this.fixedHeaderElement.innerHTML = currentLi.innerHTML;
                this.fixedHeaderElement.style.top = e.target.scrollTop + 'px';
                this.fixedHeaderElement.style.display = 'block';
                break;
            }
            else {
                this.fixedHeaderElement.style.display = 'none';
                this.fixedHeaderElement.style.top = 'none';
            }
        }
    };
    SfDropDownList.prototype.isFilterLayout = function () {
        return this.options.moduleName === 'SfDropDownList' && this.options.allowFiltering;
    };
    SfDropDownList.prototype.setSearchBoxPosition = function () {
        var searchBoxHeight = this.filterInput.parentElement.getBoundingClientRect().height;
        this.popupObj.element.style.maxHeight = '100%';
        this.popupObj.element.style.width = '100%';
        this.list.style.maxHeight = (window.innerHeight - searchBoxHeight) + 'px';
        this.list.style.height = (window.innerHeight - searchBoxHeight) + 'px';
    };
    SfDropDownList.prototype.checkCollision = function (popupEle) {
        if (!sf.base.Browser.isDevice || (sf.base.Browser.isDevice && !(this.options.moduleName === 'SfDropDownList'))) {
            var collision = sf.popups.isCollide(popupEle);
            if (collision.length > 0) {
                popupEle.style.marginTop = -parseInt(getComputedStyle(popupEle).marginTop, 10) + 'px';
            }
        }
    };
    SfDropDownList.prototype.destroy = function () {
        sf.base.EventHandler.remove(document, 'mousedown', this.onDocumentClick);
    };
    SfDropDownList.prototype.refreshPopup = function () {
        if (this.isPopupOpen()) {
            this.popupObj.refreshPosition(this.containerElement);
            var list = this.popupObj.element.querySelector('.e-content');
            if (list.classList.contains('e-nodata') && this.fixedHeaderElement) {
                sf.base.remove(this.fixedHeaderElement);
                this.fixedHeaderElement = null;
            }
        }
    };
    SfDropDownList.prototype.popupCreation = function (popupElement, offsetValue, left) {
        var _this = this;
        this.popupContainer = popupElement;
        this.popupObj = new sf.popups.Popup(this.popupContainer, {
            width: this.setWidth(), targetType: 'relative',
            relateTo: this.containerElement, collision: { X: 'flip', Y: 'flip' }, offsetY: offsetValue,
            enableRtl: this.options.enableRtl, offsetX: left, position: { X: 'left', Y: 'bottom' },
            zIndex: this.options.zIndex,
            close: function () {
                sf.base.EventHandler.remove(_this.list, 'scroll', _this.setFloatingHeader);
                sf.base.removeClass([_this.containerElement], ICON_ANIM);
                _this.fixedHeaderElement = null;
                _this.popupHolder.appendChild(_this.popupContainer);
                _this.unWireListEvents();
                var scrollableParentElements = _this.popupObj.getScrollableParent(_this.containerElement);
                for (var _i = 0, scrollableParentElements_1 = scrollableParentElements; _i < scrollableParentElements_1.length; _i++) {
                    var element = scrollableParentElements_1[_i];
                    sf.base.EventHandler.remove(element, 'scroll', _this.scrollHandler);
                }
                if (sf.base.Browser.isDevice && _this.isFilterLayout()) {
                    sf.base.removeClass([document.body, _this.popupObj.element], POPUP_FULL_SCREEN);
                    sf.base.EventHandler.remove(_this.list, 'scroll', _this.listScroll);
                }
                if (_this.options.enableVirtualization) {
                    sf.base.EventHandler.remove(_this.list, 'scroll', _this.virtualScroll);
                }
                if (_this.popupObj) {
                    _this.popupObj.destroy();
                }
                if (!_this.isDisposed && document.body.contains(_this.element)) {
                    // tslint:disable
                    _this.dotNetRef.invokeMethodAsync(CLOSE_POPUP).catch(function () { });
                }
                _this.popupObj = null;
            },
            open: function () {
                sf.base.EventHandler.add(document, 'mousedown', _this.onDocumentClick, _this);
                if (_this.options.allowFiltering && _this.filterInput) {
                    _this.filterInput.focus();
                }
                if (_this.list.querySelector('li') && _this.list.querySelector('li').classList.contains(GROUP)) {
                    sf.base.EventHandler.add(_this.list, 'scroll', _this.setFloatingHeader, _this);
                }
            },
            targetExitViewport: function () {
                if (!sf.base.Browser.isDevice && !_this.isDisposed) {
                    _this.dotNetRef.invokeMethodAsync(HIDE);
                }
            }
        });
    };
    SfDropDownList.prototype.virtualScroll = function () {
        if (this.popupObj && this.popupObj.element) {
            var borderWidth = parseInt(getComputedStyle(this.popupObj.element).borderWidth, 10);
            borderWidth = borderWidth == 0 ? 1 : borderWidth;
            var isPopupOpen = this.popupObj.element.classList.contains('e-popup-open');
            if (((this.list.scrollTop + this.list.offsetHeight) + borderWidth >= this.list.scrollHeight) && isPopupOpen && !this.isDisposed) {
                this.dotNetRef.invokeMethodAsync(VIRTUAL_HANDLER);
            }
        }
    };
    SfDropDownList.prototype.isEmptyList = function () {
        return !sf.base.isNullOrUndefined(this.liCollections) && this.liCollections.length === 0;
    };
    SfDropDownList.prototype.setWidth = function () {
        var width = sf.base.formatUnit(this.options.popupWidth);
        if (width.indexOf('%') > -1) {
            var inputWidth = this.containerElement.offsetWidth * parseFloat(width) / 100;
            width = inputWidth.toString() + 'px';
        }
        if (sf.base.Browser.isDevice && (!this.options.allowFiltering)) {
            var firstItem = this.isEmptyList() ? this.list : this.liCollections[0];
            width = (parseInt(width, 10) + (parseInt(getComputedStyle(firstItem).textIndent, 10) -
                parseInt(getComputedStyle(this.element).paddingLeft, 10) +
                parseInt(getComputedStyle(this.element.parentElement).borderLeftWidth, 10)) * 2) + 'px';
        }
        return width;
    };
    SfDropDownList.prototype.onDocumentClick = function (e) {
        var target = e.target;
        if (!(!sf.base.isNullOrUndefined(this.popupObj) && sf.base.closest(target, '#' + this.popupObj.element.id)) &&
            !this.containerElement.contains(e.target)) {
            if (this.containerElement.classList.contains(INPUT_FOCUS) || this.isPopupOpen() && !this.isDisposed) {
                this.dotNetRef.invokeMethodAsync(HIDE);
            }
        }
        else if (target !== this.element && !(this.options.allowFiltering && target === this.filterInput)
            && !(this.options.moduleName === 'SfComboBox' &&
                !this.options.allowFiltering && sf.base.Browser.isDevice && target === this.containerElement.querySelector('.e-ddl-icon'))) {
            e.preventDefault();
        }
    };
    SfDropDownList.prototype.closePopup = function (closeEventArgs, options) {
        this.options = options;
        if (this.isPopupOpen() && !closeEventArgs.cancel && this.popupObj) {
            var animModel = {
                name: 'FadeOut',
                duration: 20,
                delay: 0
            };
            this.popupObj.hide(new sf.base.Animation(animModel));
        }
    };
    SfDropDownList.prototype.setScrollPosition = function (e) {
        if (!sf.base.isNullOrUndefined(e)) {
            switch (e.action) {
                case 'pageDown':
                case 'down':
                case 'end':
                    this.scrollBottom();
                    break;
                default:
                    this.scrollTop();
                    break;
            }
        }
        else {
            this.scrollBottom(true);
        }
    };
    SfDropDownList.prototype.scrollBottom = function (isInitial) {
        if (this.list && (this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED))) {
            var selectedLI = (this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED));
            var currentOffset = this.list.offsetHeight;
            var groupBy = this.list.querySelector('li').classList.contains(GROUP);
            var nextBottom = selectedLI.offsetTop + selectedLI.offsetHeight - this.list.scrollTop;
            var nextOffset = this.list.scrollTop + nextBottom - currentOffset;
            nextOffset = isInitial ? nextOffset + parseInt(getComputedStyle(this.list).paddingTop, 10) * 2 : nextOffset;
            var boxRange = selectedLI.offsetTop + selectedLI.offsetHeight - this.list.scrollTop;
            boxRange = groupBy && !sf.base.isNullOrUndefined(this.fixedHeaderElement) ?
                boxRange - this.fixedHeaderElement.offsetHeight : boxRange;
            if (this.activeIndex === 0) {
                this.list.scrollTop = 0;
            }
            else if (nextBottom > currentOffset || !(boxRange > 0 && this.list.offsetHeight > boxRange)) {
                this.list.scrollTop = nextOffset;
            }
        }
    };
    SfDropDownList.prototype.scrollTop = function () {
        if (this.list && (this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED))) {
            var selectedLI = (this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED));
            var nextOffset = selectedLI.offsetTop - this.list.scrollTop;
            var groupBy = this.list.querySelector('li').classList.contains(GROUP);
            nextOffset = groupBy && !sf.base.isNullOrUndefined(this.fixedHeaderElement) ?
                nextOffset - this.fixedHeaderElement.offsetHeight : nextOffset;
            var boxRange = (selectedLI.offsetTop + selectedLI.offsetHeight - this.list.scrollTop);
            if (this.activeIndex === 0) {
                this.list.scrollTop = 0;
            }
            else if (nextOffset < 0) {
                this.list.scrollTop = this.list.scrollTop + nextOffset;
            }
            else if (!(boxRange > 0 && this.list.offsetHeight > boxRange)) {
                this.list.scrollTop = selectedLI.offsetTop - (groupBy && !sf.base.isNullOrUndefined(this.fixedHeaderElement) ?
                    this.fixedHeaderElement.offsetHeight : 0);
            }
        }
    };
    SfDropDownList.prototype.setHover = function (li) {
        if (li && !li.classList.contains(HOVER)) {
            this.removeHover();
            sf.base.addClass([li], HOVER);
        }
    };
    
    SfDropDownList.prototype.removeHover = function () {
        if (this.list) {
            var hoveredItem = this.list.querySelectorAll('.' + HOVER);
            if (hoveredItem && hoveredItem.length) {
                sf.base.removeClass(hoveredItem, HOVER);
            }
        }
    };
    SfDropDownList.prototype.isPopupOpen = function () {
        return this.popupObj && document.body.contains(this.popupObj.element);
    };
    return SfDropDownList;
}());
// tslint:disable
var DropDownList = {
    initialize: function (containerElement, element, dotnetRef, options) {
        if (element) {
            new SfDropDownList(containerElement, element, dotnetRef, options);
            if (element.blazor__instance) {
                element.blazor__instance.initialize();
            }
        }
    },
    renderPopup: function (element, popupElement, popupHolderEle, openEventArgs, isModifiedPopup, options, dataItem) {
        if (element && element.blazor__instance && popupElement && popupHolderEle) {
            element.blazor__instance.renderPopup(popupElement, popupHolderEle, openEventArgs, isModifiedPopup, options, dataItem);
        }
    },
    refreshPopup: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.refreshPopup();
        }
    },
    closePopup: function (element, closeEventArgs, options) {
        if (element && element.blazor__instance) {
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    },
    updateScrollPosition: function (element, args) {
        if (element && element.blazor__instance) {
            element.blazor__instance.setScrollPosition(args);
        }
    },
    getPageCount: function (popupEle) {
        var list = popupEle && popupEle.querySelector('.e-content');
        if (list) {
            var liHeight = list.classList.contains('e-nodata') ? null :
                getComputedStyle(list.querySelectorAll('.e-list-item')[0], null).getPropertyValue('height');
            return Math.round(list.getBoundingClientRect().height / parseInt(liHeight, 10));
        }
        return 0;
    },
    setAutoFillSelection: function (element, currentValue) {
        if (element && element.blazor__instance) {
            element.blazor__instance.setAutoFillSelection(currentValue);
        }
    },
    removeFillSelection: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.removeFillSelection();
        }
    },
    focusIn: function (inputEle) {
        inputEle && inputEle.focus();
    },
    focusOut: function (inputEle) {
        inputEle && inputEle.blur();
    },
    destroy: function (element, popupElement, popupHolderEle, closeEventArgs, options) {
        if (element && element.blazor__instance) {
            if (popupElement && popupElement instanceof HTMLElement && popupHolderEle) {
                element.blazor__instance.isDisposed = true;
                element.blazor__instance.closePopup(closeEventArgs, options);
            }
            element.blazor__instance.destroy();
        }
    },
};

return DropDownList;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-filemanager.js":
/*!*****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-filemanager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.FileManager = (function () {
'use strict';

var TOOLBAR_ID = '_toolbar';
var ROW = 'e-row';
var BLUR = 'e-blur';
var HOVER = 'e-hover';
var ACTIVE = 'e-active';
var CLONE = 'e-fe-clone';
var FULLROW = 'e-fullrow';
var FOLDER = 'e-fe-folder';
var LARGE_ICON = 'e-large-icon';
var DROP_FILE = 'e-fe-drop-file';
var LARGE_ICONS = 'e-large-icons';
var DROP_FOLDER = 'e-fe-drop-folder';
var TD_ELEMENT = 'TD';
var FOCUSED = 'e-focused';
var FOCUS = 'e-focus';
var SfFileManager = /** @class */ (function () {
    function SfFileManager(element, ref, properties) {
        this.element = element;
        this.properties = properties;
        this.treeviewEle = element.querySelector('.e-navigation .e-treeview');
        this.dotnetRef = ref;
        if (!sf.base.isNullOrUndefined(this.element)) {
            this.ctrlId = this.element.id;
            // eslint-disable-next-line
            this.element.blazor__instance = this;
        }
        this.bindKeyboardEvent();
        this.bindTreeViewKeyBoardEvent();
        this.wireEvents();
    }
    SfFileManager.prototype.unWireMobileEvents = function () {
        this.clickObj.destroy();
    };
    SfFileManager.prototype.wireMobileEvents = function () {
        var fileElement;
        // eslint-disable-next-line
        var proxy = this;
        if (this.properties.view === 'Details') {
            fileElement = this.element.querySelector('.e-view-container .e-grid .e-gridcontent');
        }
        else {
            fileElement = this.element.querySelector('.e-view-container .e-large-icons');
        }
        this.clickObj = new sf.base.Touch(fileElement, {
            tapHold: function (e) {
                var targetElement;
                var rowId;
                if (proxy.properties.view === 'Details') {
                    targetElement = sf.base.closest(e.originalEvent.target, '.e-row');
                    rowId = targetElement ? targetElement.getAttribute('aria-rowindex') : null;
                }
                else {
                    targetElement = sf.base.closest(e.originalEvent.target, 'li.e-list-item');
                    rowId = targetElement ? targetElement.getAttribute('data-uid') : null;
                }
                if (targetElement != null && rowId != null) {
                    proxy.dotnetRef.invokeMethodAsync('ChangeMobileMultiSelection', rowId);
                }
            }
        });
    };
    SfFileManager.prototype.wireEvents = function () {
        var gridElem = this.element.querySelector('#' + this.properties.id + '_grid');
        if (gridElem) {
            sf.base.EventHandler.add(gridElem, 'dblclick', this.gridBlur, this);
        }
    };
    SfFileManager.prototype.unWireEvents = function () {
        var gridElem = this.element.querySelector('#' + this.properties.id + '_grid');
        if (gridElem) {
            sf.base.EventHandler.remove(gridElem, 'dblclick', this.gridBlur);
        }
    };
    SfFileManager.prototype.adjustHeight = function () {
        var toolbar = sf.base.select('#' + this.element.id + TOOLBAR_ID, this.element);
        var toolBarHeight = toolbar ? toolbar.offsetHeight : 0;
        var breadcrumbBarHeight = this.element.querySelector('.e-address').offsetHeight;
        var gridHeight = this.element.clientHeight - toolBarHeight - breadcrumbBarHeight;
        return sf.base.formatUnit(this.element.clientHeight - toolBarHeight) + ' ' + sf.base.formatUnit(gridHeight);
    };
    SfFileManager.prototype.createDragObj = function () {
        var _this = this;
        var dragEle;
        var dragTarget;
        if (this.properties.view === 'LargeIcons') {
            dragEle = this.element.querySelector('.e-large-icons ul');
            dragTarget = '.' + LARGE_ICON;
        }
        else {
            dragEle = this.element.querySelector('.e-grid.e-control');
            dragTarget = '.' + ROW;
        }
        if (this.properties.draggable) {
            if (this.dragObj) {
                this.dragObj.destroy();
            }
            if (dragEle) {
                this.dragObj = new sf.base.Draggable(dragEle, {
                    cursorAt: { left: 44, top: 18 },
                    enableTailMode: true,
                    dragArea: this.element,
                    dragTarget: '.' + FULLROW,
                    drag: this.draggingHandler.bind(this),
                    dragStart: function (args) {
                        _this.dragStartHandler(args);
                    },
                    dragStop: this.dragStopHandler.bind(this),
                    enableAutoScroll: true,
                    helper: this.dragHelper.bind(this)
                });
            }
        }
        else if (!this.properties.draggable) {
            this.dragObj.destroy();
        }
        if (this.treeviewEle) {
            if (this.treeDragObj) {
                this.treeDragObj.destroy();
            }
            this.treeDragObj = new sf.base.Draggable(this.treeviewEle, {
                cursorAt: { left: 44, top: 18 },
                enableTailMode: true,
                dragArea: this.element,
                dragTarget: dragTarget,
                drag: this.draggingHandler.bind(this),
                dragStart: function (args) {
                    _this.dragStartHandler(args);
                },
                dragStop: this.dragStopHandler.bind(this),
                enableAutoScroll: true,
                helper: this.dragHelper.bind(this)
            });
        }
        else if (!this.properties.draggable) {
            this.treeDragObj.destroy();
        }
    };
    SfFileManager.prototype.dragHelper = function (args) {
        var dragTarget = args.sender.target;
        this.getModule(dragTarget);
        if (this.activeModule === 'largeiconsview' || this.activeModule === 'navigationpane') {
            this.dragLi = sf.base.closest(dragTarget, '.e-list-item');
        }
        else if (this.activeModule === 'detailsview') {
            this.dragLi = sf.base.closest(dragTarget, 'tr.e-row');
            if (this.dragLi.getAttribute('aria-selected') == 'false') {
                dragTarget.click();
            }
        }
        if (!this.dragLi) {
            return null;
        }
        this.createVirtualDragElement();
        return this.virtualDragElement;
    };
    SfFileManager.prototype.createVirtualDragElement = function () {
        this.updateViewElement();
        this.updateDragValues();
        this.cloneIcon = sf.base.createElement('div', {
            className: 'e-fe-icon ' + this.dragType
        });
        this.cloneName = sf.base.createElement('div', {
            className: 'e-fe-name',
            innerHTML: this.dragName
        });
        var virtualEle = sf.base.createElement('div', {
            className: 'e-fe-content'
        });
        virtualEle.appendChild(this.cloneIcon);
        virtualEle.appendChild(this.cloneName);
        var ele = sf.base.createElement('div', {
            className: CLONE
        });
        ele.appendChild(virtualEle);
        if (this.dragCount > 1) {
            var badge = sf.base.createElement('span', {
                className: 'e-fe-count',
                innerHTML: (this.dragCount).toString(10)
            });
            ele.appendChild(badge);
        }
        this.virtualDragElement = ele;
        this.element.appendChild(this.virtualDragElement);
    };
    SfFileManager.prototype.getModule = function (element) {
        if (element) {
            if (sf.base.closest(element, '.' + ROW)) {
                this.activeModule = 'detailsview';
            }
            else if (sf.base.closest(element, '.' + LARGE_ICON)) {
                this.activeModule = 'largeiconsview';
            }
            else {
                this.activeModule = 'navigationpane';
            }
        }
    };
    SfFileManager.prototype.getXYValue = function (e, direction) {
        var touchList = e.changedTouches;
        var value;
        if (direction === 'X') {
            value = touchList ? touchList[0].clientX : e.clientX;
        }
        else {
            value = touchList ? touchList[0].clientY : e.clientY;
        }
        if (!value && e.type === 'focus' && e.target) {
            var rect = e.target.getBoundingClientRect();
            value = rect ? (direction === 'X' ? rect.left : rect.top) : null;
        }
        return Math.ceil(value);
    };
    SfFileManager.prototype.removeDestroyElement = function () {
        this.dragObj.intDestroy(this.dragStartArgs.event);
        this.dragCancel();
    };
    SfFileManager.prototype.TriggerDragEvent = function (cancel) {
        if (cancel) {
            this.removeDestroyElement();
        }
    };
    SfFileManager.prototype.UpdateGridFocus = function (index) {
        if (this.properties.view == "Details") {
            this.updateViewElement();
            var focusedItem = this.viewElem.querySelectorAll(".e-focused");
            var itemElement = this.viewElem.querySelector('[aria-rowindex="' + index.toString() + '"]');
            if (focusedItem) {
                for (var i = 0; i < focusedItem.length; i++) {
                    if (sf.base.closest(focusedItem[i], 'tr').getAttribute('aria-rowindex') != index.toString()) {
                        sf.base.closest(focusedItem[i], 'tr').removeAttribute('tabindex');
                        sf.base.removeClass([focusedItem[i]], [FOCUS, FOCUSED]);
                    }
                }
            }
            if (!sf.base.isNullOrUndefined(itemElement)) {
                this.viewElem.setAttribute('tabindex', '-1');
                itemElement.setAttribute('tabindex', '0');
                sf.base.addClass([itemElement], [FOCUS, FOCUSED]);
            }
        }
    };
    SfFileManager.prototype.TriggerDragStartEvent = function (cancel) {
        if (cancel) {
            this.removeDestroyElement();
        }
        else {
            this.dragStartArgs.bindEvents(this.dragStartArgs.dragElement);
            var dragArgs = this.dragStartArgs;
            dragArgs.cancel = false;
            this.getModule(this.dragStartArgs.target);
            var rootId = this.element.querySelector('.e-navigation .e-treeview ul li').getAttribute('data-uid');
            if (!this.properties.draggable || ((this.activeModule === 'navigationpane') &&
                (sf.base.closest(this.dragStartArgs.target, 'li').getAttribute('data-uid') === rootId))) {
                dragArgs.cancel = true;
            }
            this.removeBlur();
            if (dragArgs.cancel) {
                this.removeDestroyElement();
            }
            else if (!dragArgs.cancel) {
                this.updateViewElement();
                this.blurActive();
                this.updateDragValues();
            }
        }
    };
    SfFileManager.prototype.dragStartHandler = function (args) {
        this.dragStartArgs = args;
        this.UpdateXY(args);
        this.dotnetRef.invokeMethodAsync('DragStartCall', this.dragLeft, this.dragTop);
    };
    SfFileManager.prototype.blurActive = function () {
        var i = 0;
        var activeElements = this.viewElem.querySelectorAll('.' + ACTIVE);
        while (i < activeElements.length) {
            activeElements[i].classList.add(BLUR);
            i++;
        }
    };
    SfFileManager.prototype.updateViewElement = function () {
        if (this.properties.view === 'LargeIcons') {
            this.viewElem = this.element.querySelector('.' + LARGE_ICONS);
        }
        else {
            this.viewElem = this.element.querySelector('.e-gridcontent');
        }
    };
    SfFileManager.prototype.getIconClass = function (element) {
        var iconValue = '';
        iconValue = element.querySelector('.e-list-img') ? 'e-fe-image' : element.querySelector('.e-list-icon').classList[1];
        return iconValue;
    };
    SfFileManager.prototype.updateDragValues = function () {
        var activeElements;
        if (this.activeModule === 'largeiconsview') {
            activeElements = this.viewElem.querySelectorAll('.' + ACTIVE);
            this.dragName = activeElements.length > 0 ? activeElements[0].querySelector('.e-list-text').textContent : '';
            this.dragType = activeElements.length > 0 ? this.getIconClass(activeElements[0]) : '';
        }
        else if (this.activeModule === 'detailsview') {
            activeElements = this.viewElem.querySelectorAll('tr[aria-selected="true"]');
            if (activeElements != null && activeElements.length > 0) {
                this.dragName = activeElements.length > 0 ? activeElements[0].querySelector('.e-fe-text').textContent : '';
                this.dragType = activeElements.length > 0 ? activeElements[0].querySelector('.e-fe-icon').classList[1] : '';
            }
        }
        else if (this.activeModule === 'navigationpane') {
            this.dragName = this.dragLi.querySelector('.e-list-text').textContent;
            this.dragType = 'e-fe-folder';
        }
        if (activeElements != null) {
            this.dragCount = activeElements.length;
        }
    };
    SfFileManager.prototype.getTargetModule = function (element) {
        if (element) {
            if (sf.base.closest(element, '.e-gridcontent')) {
                this.targetModule = 'detailsview';
            }
            else if (sf.base.closest(element, '.' + LARGE_ICONS)) {
                this.targetModule = 'largeiconsview';
            }
            else if (element.classList.contains('e-fullrow') ||
                element.classList.contains('e-icon-expandable')) {
                this.targetModule = 'navigationpane';
            }
            else if (sf.base.closest(element, '.e-address-list-item')) {
                this.targetModule = 'breadcrumbbar';
            }
            else {
                this.targetModule = '';
            }
        }
    };
    SfFileManager.prototype.draggingHandler = function (args) {
        var canDrop = false;
        this.updateDragValues();
        this.cloneIcon.setAttribute('class', 'e-fe-icon ' + this.dragType);
        this.cloneName.innerHTML = this.dragName;
        var node = null;
        this.blurActive();
        this.getTargetModule(args.target);
        this.removeDropTarget();
        this.removeBlur('hover');
        if (this.targetModule === 'navigationpane') {
            node = sf.base.closest(args.target, 'li');
            node.classList.add(HOVER, DROP_FOLDER);
            canDrop = true;
        }
        else if (this.targetModule === 'detailsview') {
            node = sf.base.closest(args.target, 'tr');
            if (node && node.querySelector('.' + FOLDER) && !node.classList.contains(BLUR)) {
                node.classList.add(DROP_FOLDER);
            }
            else if (node && !node.querySelector('.' + FOLDER) && !node.classList.contains(BLUR)) {
                node.classList.add(DROP_FILE);
            }
            canDrop = true;
        }
        else if (this.targetModule === 'largeiconsview') {
            node = sf.base.closest(args.target, 'li');
            if (node && node.querySelector('.' + FOLDER) && !node.classList.contains(BLUR)) {
                node.classList.add(HOVER, DROP_FOLDER);
            }
            canDrop = true;
        }
        else if (this.targetModule === 'breadcrumbbar') {
            canDrop = true;
        }
        this.element.classList.remove('e-fe-drop', 'e-no-drop');
        this.element.classList.add(canDrop ? 'e-fe-drop' : 'e-no-drop');
        this.UpdateXY(args);
        this.dotnetRef.invokeMethodAsync('DraggingCall', this.dragLeft, this.dragTop);
    };
    SfFileManager.prototype.UpdateXY = function (args) {
        this.dragLeft = this.getXYValue(args.event, 'X');
        this.dragTop = this.getXYValue(args.event, 'Y');
    };
    SfFileManager.prototype.dragStopHandler = function (args) {
        var dragArgs = args;
        var isLayout = false;
        dragArgs.cancel = false;
        this.removeDropTarget();
        this.element.classList.remove('e-fe-drop', 'e-no-drop');
        this.dragCancel();
        this.getTargetModule(args.target);
        if (this.targetModule === '' && args.target.classList.contains('e-view-container')) {
            isLayout = true;
        }
        this.removeBlur('hover');
        var targetElement;
        var dataValue;
        if (this.targetModule === 'largeiconsview' || this.targetModule === 'navigationpane' || this.targetModule === 'breadcrumbbar') {
            targetElement = sf.base.closest(args.target, 'li');
            var attr = this.targetModule === 'breadcrumbbar' ? 'data-utext' : 'data-uid';
            dataValue = targetElement ? targetElement.getAttribute(attr) : null;
        }
        else if (this.targetModule === 'detailsview') {
            targetElement = sf.base.closest(args.target, 'tr');
            dataValue = targetElement ? targetElement.getAttribute('aria-rowindex') : null;
        }
        if (dataValue == null) {
            isLayout = true;
        }
        var treeid = this.treeviewEle ? this.dragLi.getAttribute('data-uid') : null;
        if (this.activeModule === 'detailsview') {
            treeid = this.dragLi.getAttribute('aria-rowindex');
        }
        this.UpdateXY(args);
        // eslint:disable-next-line
        this.dotnetRef.invokeMethodAsync('DragStopCall', treeid, dataValue, this.targetModule, this.activeModule, isLayout, this.dragLeft, this.dragTop);
        this.dragCount = 0;
        this.dragName = '';
        this.dragType = '';
    };
    SfFileManager.prototype.dragCancel = function () {
        this.removeBlur();
        var virtualEle = sf.base.select('.' + CLONE, this.element);
        if (virtualEle) {
            sf.base.detach(virtualEle);
        }
    };
    SfFileManager.prototype.gridBlur = function (e) {
        var target = e.target;
        if (target.tagName === 'TD') {
            target.blur();
        }
    };
    SfFileManager.prototype.removeItemClass = function (value) {
        var ele = this.element.querySelectorAll('.' + value);
        for (var i = 0; i < ele.length; i++) {
            ele[i].classList.remove(value);
        }
    };
    SfFileManager.prototype.removeDropTarget = function () {
        this.removeItemClass(DROP_FOLDER);
        this.removeItemClass(DROP_FILE);
    };
    SfFileManager.prototype.removeBlur = function (hover) {
        var blurEle = (!hover) ? this.element.querySelectorAll('.' + BLUR) :
            this.element.querySelectorAll('.' + HOVER);
        var i = 0;
        while (i < blurEle.length) {
            blurEle[i].classList.remove(!hover ? BLUR : HOVER);
            i++;
        }
    };
    SfFileManager.prototype.bindTreeViewKeyBoardEvent = function () {
        var treeviewElem = this.element.querySelector(".e-navigation");
        var keyConfigs = {
            altEnter: 'alt+enter',
            esc: 'escape',
            del: 'delete',
            ctrlX: 'ctrl+x',
            ctrlC: 'ctrl+c',
            ctrlV: 'ctrl+v',
            f2: 'f2',
            shiftF10: 'shift+f10'
        };
        if (treeviewElem) {
            var keyboardDownModule = new sf.base.KeyboardEvents(treeviewElem, {
                keyAction: this.treeviewKeydownHandler.bind(this),
                keyConfigs: keyConfigs,
                eventName: 'keydown'
            });
        }
    };
    SfFileManager.prototype.bindKeyboardEvent = function () {
        if (this.properties.view === 'Details') {
            var keyConfigs = {
                altEnter: 'alt+enter',
                esc: 'escape',
                tab: 'tab',
                moveDown: 'downarrow',
                ctrlEnd: 'ctrl+end',
                ctrlHome: 'ctrl+home',
                ctrlDown: 'ctrl+downarrow',
                ctrlLeft: 'ctrl+leftarrow',
                ctrlRight: 'ctrl+rightarrow',
                shiftEnd: 'shift+end',
                shiftHome: 'shift+home',
                shiftDown: 'shift+downarrow',
                shiftUp: 'shift+uparrow',
                ctrlUp: 'ctrl+uparrow',
                csEnd: 'ctrl+shift+end',
                csHome: 'ctrl+shift+home',
                csDown: 'ctrl+shift+downarrow',
                csUp: 'ctrl+shift+uparrow',
                space: 'space',
                ctrlSpace: 'ctrl+space',
                shiftSpace: 'shift+space',
                csSpace: 'ctrl+shift+space',
                end: 'end',
                home: 'home',
                moveUp: 'uparrow',
                del: 'delete',
                ctrlX: 'ctrl+x',
                ctrlC: 'ctrl+c',
                ctrlV: 'ctrl+v',
                ctrlShiftN: 'ctrl+shift+n',
                shiftdel: 'shift+delete',
                ctrlD: 'ctrl+d',
                f2: 'f2',
                ctrlA: 'ctrl+a',
                enter: 'enter'
            };
            var gridElem = this.element.querySelector('#' + this.properties.id + '_grid');
            if (gridElem) {
                this.bindKeyboardEvents(keyConfigs, gridElem);
            }
        }
        else if (this.properties.view === 'LargeIcons') {
            var keyConfigs = {
                altN: 'alt+n',
                f5: 'f5',
                ctrlShift1: 'ctrl+shift+1',
                ctrlShift2: 'ctrl+shift+2',
                ctrlU: 'ctrl+u',
                end: 'end',
                home: 'home',
                tab: 'tab',
                moveDown: 'downarrow',
                moveLeft: 'leftarrow',
                moveRight: 'rightarrow',
                moveUp: 'uparrow',
                ctrlEnd: 'ctrl+end',
                ctrlHome: 'ctrl+home',
                ctrlDown: 'ctrl+downarrow',
                ctrlLeft: 'ctrl+leftarrow',
                ctrlRight: 'ctrl+rightarrow',
                ctrlUp: 'ctrl+uparrow',
                shiftEnd: 'shift+end',
                shiftHome: 'shift+home',
                shiftDown: 'shift+downarrow',
                shiftLeft: 'shift+leftarrow',
                shiftRight: 'shift+rightarrow',
                shiftUp: 'shift+uparrow',
                csEnd: 'ctrl+shift+end',
                csHome: 'ctrl+shift+home',
                csDown: 'ctrl+shift+downarrow',
                csLeft: 'ctrl+shift+leftarrow',
                csRight: 'ctrl+shift+rightarrow',
                csUp: 'ctrl+shift+uparrow',
                space: 'space',
                ctrlSpace: 'ctrl+space',
                shiftSpace: 'shift+space',
                csSpace: 'ctrl+shift+space',
                ctrlA: 'ctrl+a',
                enter: 'enter',
                altEnter: 'alt+enter',
                esc: 'escape',
                del: 'delete',
                ctrlX: 'ctrl+x',
                ctrlC: 'ctrl+c',
                ctrlV: 'ctrl+v',
                f2: 'f2',
                shiftdel: 'shift+delete',
                back: 'backspace',
                ctrlD: 'ctrl+d'
            };
            var largeIcons = this.element.querySelector('#' + this.properties.id + '_largeicons');
            if (largeIcons) {
                this.bindKeyboardEvents(keyConfigs, largeIcons);
            }
        }
    };
    SfFileManager.prototype.bindKeyboardEvents = function (keyConfigs, element) {
        this.keyboardModule = new sf.base.KeyboardEvents(element, {
            keyAction: this.keyupHandler.bind(this),
            keyConfigs: keyConfigs,
            eventName: 'keyup'
        });
        this.keyboardDownModule = new sf.base.KeyboardEvents(element, {
            keyAction: this.keydownHandler.bind(this),
            keyConfigs: keyConfigs,
            eventName: 'keydown'
        });
    };
    SfFileManager.prototype.getRowValue = function () {
        var largeIconEle = this.element.querySelector('#' + this.element.id + '_largeicons');
        var itemList = largeIconEle.querySelectorAll('.e-list-item');
        var perRow = 1;
        if (itemList) {
            for (var i = 0, len = itemList.length - 1; i < len; i++) {
                if (itemList[i].getBoundingClientRect().top === itemList[i + 1].getBoundingClientRect().top) {
                    perRow++;
                }
                else {
                    break;
                }
            }
        }
        return perRow;
    };
    // eslint-disable-next-line
    SfFileManager.prototype.keyupHandler = function (e) {
        e.preventDefault();
        var perRow = 0;
        if (this.properties.view === 'LargeIcons') {
            perRow = this.getRowValue();
        }
        var action = e.action;
        var actionValue = null;
        switch (action) {
            case 'altN':
                actionValue = 'NewFolder';
                break;
            case 'f5':
                actionValue = 'Refresh';
                break;
            case 'ctrlShift1':
                actionValue = 'DetailsView';
                break;
            case 'ctrlShift2':
                actionValue = 'LargeIconsView';
                break;
            case 'ctrlU':
                actionValue = 'Upload';
                break;
            case 'altEnter':
                actionValue = 'Details';
                break;
            case 'del':
            case 'shiftdel':
                actionValue = 'Delete';
                break;
            case 'enter':
                actionValue = 'Open';
                break;
            case 'ctrlC':
                actionValue = 'Copy';
                break;
            case 'ctrlV':
                actionValue = 'Paste';
                break;
            case 'ctrlX':
                actionValue = 'Cut';
                break;
            case 'ctrlD':
                actionValue = 'Download';
                break;
            case 'f2':
                actionValue = 'Rename';
                break;
            case 'ctrlA':
                actionValue = 'SelectAll';
                break;
            case 'home':
                actionValue = 'Home';
                break;
            case 'end':
                actionValue = 'End';
                break;
            case 'moveDown':
                actionValue = 'MoveDown_' + perRow.toString();
                break;
            case 'moveLeft':
                actionValue = 'MoveLeft';
                break;
            case 'moveRight':
                actionValue = 'MoveRight';
                break;
            case 'moveUp':
                actionValue = 'MoveUp_' + perRow.toString();
                break;
            case 'esc':
                actionValue = 'Esc';
                break;
            case 'ctrlLeft':
                actionValue = 'ControlLeft';
                break;
            case 'ctrlRight':
                actionValue = 'ControlRight';
                break;
            case 'ctrlEnd':
                actionValue = 'ControlEnd';
                break;
            case 'ctrlHome':
                actionValue = 'ControlHome';
                break;
            case 'shiftHome':
                actionValue = 'ShiftHome';
                break;
            case 'shiftEnd':
                actionValue = 'ShiftEnd';
                break;
            case 'shiftLeft':
                actionValue = 'ShiftLeft';
                break;
            case 'shiftRight':
                actionValue = 'ShiftRight';
                break;
            case 'csHome':
                actionValue = 'ControlShiftHome';
                break;
            case 'csEnd':
                actionValue = 'ControlShiftEnd';
                break;
            case 'csLeft':
                actionValue = 'ControlShiftLeft';
                break;
            case 'csRight':
                actionValue = 'ControlShiftRight';
                break;
            case 'ctrlUp':
                actionValue = 'ControlUp_' + perRow.toString();
                break;
            case 'shiftUp':
                actionValue = 'ShiftUp_' + perRow.toString();
                break;
            case 'csUp':
                actionValue = 'ControlShiftUp_' + perRow.toString();
                break;
            case 'ctrlDown':
                actionValue = 'ControlDown_' + perRow.toString();
                break;
            case 'shiftDown':
                actionValue = 'ShiftDown_' + perRow.toString();
                break;
            case 'csDown':
                actionValue = 'ControlShiftDown_' + perRow.toString();
                break;
            case 'space':
                actionValue = 'Space';
                break;
            case 'csSpace':
                actionValue = 'ControlShiftSpace';
                break;
            case 'shiftSpace':
                actionValue = 'ShiftSpace';
                break;
            case 'ctrlSpace':
                actionValue = 'ControlSpace';
                break;
            case 'tab':
                actionValue = 'Tab';
                break;
        }
        if (actionValue) {
            this.dotnetRef.invokeMethodAsync('PerformKeyboardAction', actionValue);
        }
    };
    SfFileManager.prototype.treeviewKeydownHandler = function (e) {
        e.preventDefault();
        if (this.element.querySelector('.e-dialog.e-popup-open') == null) {
            var action = e.action;
            var actionValue = null;
            switch (action) {
                case 'altEnter':
                    actionValue = 'Details';
                    break;
                case 'esc':
                    actionValue = 'Esc';
                    break;
                case 'del':
                    actionValue = 'Delete';
                    break;
                case 'ctrlC':
                    actionValue = 'Copy';
                    break;
                case 'ctrlV':
                    actionValue = 'Paste';
                    break;
                case 'ctrlX':
                    actionValue = 'Cut';
                    break;
                case 'shiftF10':
                    actionValue = 'Download';
                    break;
                case 'f2':
                    actionValue = 'Rename';
                    break;
            }
            if (actionValue) {
                this.dotnetRef.invokeMethodAsync('PerformTreeViewKeyboardAction', actionValue);
            }
        }
    };
    SfFileManager.prototype.keydownHandler = function (e) {
        if (this.element.querySelector('.e-dialog.e-popup-open') == null) {
            switch (e.action) {
                case 'end':
                case 'home':
                case 'space':
                case 'ctrlSpace':
                case 'shiftSpace':
                case 'csSpace':
                case 'ctrlA':
                case 'enter':
                case 'altEnter':
                case 'ctrlEnd':
                case 'shiftEnd':
                case 'csEnd':
                case 'ctrlHome':
                case 'shiftHome':
                case 'csHome':
                case 'ctrlDown':
                case 'shiftDown':
                case 'csDown':
                case 'ctrlLeft':
                case 'shiftLeft':
                case 'csLeft':
                case 'esc':
                case 'del':
                case 'shiftdel':
                case 'ctrlC':
                case 'ctrlV':
                case 'ctrlX':
                case 'f2':
                case 'moveDown':
                case 'moveUp':
                case 'ctrlD':
                case 'altN':
                case 'f5':
                case 'ctrlShift1':
                case 'ctrlShift2':
                case 'ctrlU':
                    e.preventDefault();
                    break;
                default:
                    break;
            }
        }
    };
    return SfFileManager;
}());
// eslint:disable-next-line
var FileManager = {
    initialize: function (element, dotnetRef, properties, isMobile) {
        new SfFileManager(element, dotnetRef, properties);
        if (properties.draggable) {
            element.blazor__instance.createDragObj();
        }
        element.blazor__instance.isMobile = isMobile;
        return element.blazor__instance.adjustHeight();
    },
    dragStartActionContinue: function (element, cancel) {
        if (element) {
            element.blazor__instance.TriggerDragStartEvent(cancel);
        }
    },
    wireMobileEvents: function (element) {
        element.blazor__instance.wireMobileEvents();
    },
    dragActionContinue: function (element, cancel) {
        if (element) {
            element.blazor__instance.TriggerDragEvent(cancel);
        }
    },
    focusItem: function (element, selector) {
        if (element) {
            if (element.blazor__instance.properties.view === 'LargeIcons') {
                var focusElement = element.querySelector('.e-list-item.e-large-icon[data-uid="' + selector + '"]');
                if (focusElement) {
                    focusElement.focus();
                }
            }
        }
    },
    updateProperties: function (element, properties) {
        element.blazor__instance.properties = properties;
        element.blazor__instance.unWireEvents();
        element.blazor__instance.wireEvents();
        if (element.blazor__instance.isMobile) {
            element.blazor__instance.unWireMobileEvents();
            element.blazor__instance.wireMobileEvents();
        }
        return element.blazor__instance.adjustHeight();
    },
    uploadOpen: function (element, id, popupTarget) {
        var uploadElement = (!sf.base.isNullOrUndefined(popupTarget) ? document.querySelector(popupTarget) : element).querySelector('#' + id);
        if (uploadElement) {
            uploadElement.click();
        }
    },
    triggerBlur: function (element) {
        if (element && document.activeElement.tagName === TD_ELEMENT) {
            document.activeElement.blur();
        }
    },
    updateFocus: function (element, index) {
        if (element) {
            element.blazor__instance.UpdateGridFocus(index);
        }
    },
    updateView: function (element, view) {
        if (element) {
            element.blazor__instance.properties.view = view;
            element.blazor__instance.keyboardDownModule.destroy();
            element.blazor__instance.keyboardModule.destroy();
            element.blazor__instance.bindKeyboardEvent();
            if (element.blazor__instance.isMobile) {
                element.blazor__instance.unWireMobileEvents();
                element.blazor__instance.wireMobileEvents();
            }
        }
        if (element.blazor__instance.properties.draggable) {
            element.blazor__instance.createDragObj();
        }
    },
    updateGridRow: function (gridEle, index) {
        if (gridEle) {
            var selectedElements = gridEle.querySelectorAll('tr.e-row[tabindex="0"]');
            for (var i = 0; i < selectedElements.length; i++) {
                selectedElements[i].removeAttribute('tabindex');
            }
            var element1 = gridEle.querySelector('[aria-rowindex="' + index + '"]');
            if (element1) {
                element1.setAttribute('tabindex', '0');
                element1.focus();
            }
        }
    },
    focusToolbar: function (element, selector) {
        var focusElement = element.querySelector(selector);
        if (element && focusElement) {
            focusElement.children[0].focus();
        }
    },
    // eslint-disable-next-line
    saveFile: function (filename, url, element) {
        // eslint-disable-next-line
        var data = { 'action': 'download', 'path': filename.path, 'names': filename.names, 'data': filename.data };
        var form = sf.base.createElement('form', {
            id: element.id + '_downloadForm',
            attrs: { action: url, method: 'post', name: 'downloadForm', 'download': '' }
        });
        var input = sf.base.createElement('input', {
            id: element.id + '_hiddenForm',
            attrs: { name: 'downloadInput', value: JSON.stringify(data), type: 'hidden' }
        });
        form.appendChild(input);
        document.body.appendChild(form);
        document.forms.namedItem('downloadForm').submit();
        document.body.removeChild(form);
    },
    getTargetElement: function (view, x, y) {
        var element = document.elementFromPoint(x, y);
        var targetElement;
        var menuModel;
        var treeElement = sf.base.closest(element, 'li[role="treeitem"]');
        if (!element) {
            menuModel = { IsFile: false, RowIndex: null, IsFolder: false, IsLayout: false, IsTree: false };
        }
        else {
            if ((element.classList.contains('e-yscroll') && element.classList.contains('e-content')) ||
                (element.classList.contains('e-list-parent') && element.classList.contains('e-ul')) ||
                element.classList.contains('e-view-container') || element.classList.contains('e-large-icons')
                || sf.base.closest(element, '.e-empty.e-view-container')) {
                menuModel = { IsFile: false, RowIndex: null, IsFolder: false, IsLayout: true, IsTree: false };
            }
            else if (treeElement) {
                var dataid = parseInt(treeElement.getAttribute('data-uid'), 10);
                menuModel = { IsFile: false, RowIndex: dataid, IsFolder: true, IsLayout: false, IsTree: true };
            }
            else {
                if (view === 'Details') {
                    targetElement = sf.base.closest(element, 'tr');
                    var isFile = !(targetElement.querySelector('.e-fe-grid-icon .e-fe-icon').classList.contains('e-fe-folder'));
                    var rowIndex = parseInt(targetElement.getAttribute('aria-rowindex'), 10);
                    menuModel = { IsFile: isFile, RowIndex: rowIndex, IsFolder: !isFile, IsLayout: false, IsTree: false };
                }
                else if (view === 'LargeIcons') {
                    targetElement = sf.base.closest(element, 'li');
                    var iconEle = targetElement.querySelector('.e-list-icon');
                    var isFile = iconEle ? !(iconEle.classList.contains('e-fe-folder')) : true;
                    var rowIndex = parseInt(targetElement.getAttribute('data-uid'), 10);
                    menuModel = { IsFile: isFile, RowIndex: rowIndex, IsFolder: !isFile, IsLayout: false, IsTree: false };
                }
            }
        }
        return menuModel;
    }
};

return FileManager;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-grid.js":
/*!**********************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-grid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Grid = (function () {
'use strict';

/**
 * The function used to update Dom using requestAnimationFrame.
 * @param  {Function} fn - Function that contains the actual action
 * @return {Promise<T>}
 * @hidden
 */
function getUpdateUsingRaf(updateFunction, callBack) {
    requestAnimationFrame(function () {
        try {
            callBack(null, updateFunction());
        }
        catch (e) {
            callBack(e);
        }
    });
}
/** @hidden */
var scrollWidth = null;
/** @hidden */
function getScrollBarWidth() {
    if (scrollWidth !== null) {
        return scrollWidth;
    }
    var divNode = document.createElement('div');
    var value = 0;
    divNode.style.cssText = 'width:100px;height: 100px;overflow: scroll;position: absolute;top: -9999px;';
    document.body.appendChild(divNode);
    value = (divNode.offsetWidth - divNode.clientWidth) | 0;
    document.body.removeChild(divNode);
    return scrollWidth = value;
}
function getSiblingsHeight(element) {
    var previous = getHeightFromDirection(element, 'previous');
    var next = getHeightFromDirection(element, 'next');
    return previous + next;
}
function getHeightFromDirection(element, direction) {
    var sibling = element[direction + 'ElementSibling'];
    var result = 0;
    var classList$$1 = ['e-gridheader', 'e-gridfooter', 'e-groupdroparea', 'e-gridpager', 'e-toolbar'];
    while (sibling) {
        if (classList$$1.some(function (value) { return sibling.classList.contains(value); })) {
            result += sibling.offsetHeight;
        }
        sibling = sibling[direction + 'ElementSibling'];
    }
    return result;
}
/** @hidden */
function parentsUntil(elem, selector, isID) {
    var parent = elem;
    while (parent) {
        if (isID ? parent.id === selector : parent.classList.contains(selector)) {
            break;
        }
        parent = parent.parentElement;
    }
    return parent;
}
/** @hidden */
var Global;
(function (Global) {
    Global.timer = null;
})(Global || (Global = {}));
/** @hidden */
function getElementIndex(element, elements) {
    var index = -1;
    for (var i = 0, len = elements.length; i < len; i++) {
        if (elements[i].isEqualNode(element)) {
            index = i;
            break;
        }
    }
    return index;
}
/** @hidden */
function inArray(value, collection) {
    for (var i = 0, len = collection.length; i < len; i++) {
        if (collection[i] === value) {
            return i;
        }
    }
    return -1;
}
function getPosition(e) {
    var position = {};
    position.x = (sf.base.isNullOrUndefined(e.clientX) ? e.changedTouches[0].clientX :
        e.clientX);
    position.y = (sf.base.isNullOrUndefined(e.clientY) ? e.changedTouches[0].clientY :
        e.clientY);
    return position;
}
/**
 * @hidden
 */
function iterateArrayOrObject(collection, predicate) {
    var result = [];
    for (var i = 0, len = collection.length; i < len; i++) {
        var pred = predicate(collection[i], i);
        if (!sf.base.isNullOrUndefined(pred)) {
            result.push(pred);
        }
    }
    return result;
}
/** @hidden */
function isActionPrevent(element) {
    var dlg = element.querySelector('#' + element.id + 'EditConfirm');
    return (element.querySelectorAll('.e-updatedtd').length) && (dlg ? dlg.classList.contains('e-popup-close') : true);
}
/**
 * @hidden
 */
function isGroupAdaptive(grid) {
    return (grid.options.enableVirtualization && grid.options.groupCount > 0 && (grid.options.offline || grid.options.url === ''));
}
/** @hidden */
var rowHeight;
/** @hidden */
function getRowHeight(element) {
    if (rowHeight !== undefined) {
        return rowHeight;
    }
    var table = sf.base.createElement('table', { className: 'e-table', styles: 'visibility: hidden' });
    table.innerHTML = '<tr><td class="e-rowcell">A<td></tr>';
    element.appendChild(table);
    var rect = table.querySelector('td').getBoundingClientRect();
    element.removeChild(table);
    rowHeight = Math.ceil(rect.height);
    return rowHeight;
}
function removeElement(target, selector) {
    var elements = [].slice.call(target.querySelectorAll(selector));
    for (var i = 0; i < elements.length; i++) {
        sf.base.remove(elements[i]);
    }
}
/** @hidden */
function addRemoveActiveClasses(cells, add) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    for (var i = 0, len = cells.length; i < len; i++) {
        if (add) {
            sf.base.classList(cells[i], args.slice(), []);
            cells[i].setAttribute('aria-selected', 'true');
        }
        else {
            sf.base.classList(cells[i], [], args.slice());
            cells[i].removeAttribute('aria-selected');
        }
    }
}

/**
 * The `Scroll` module is used to handle scrolling behaviour.
 */
var Scroll = /** @class */ (function () {
    /**
     * Constructor for the Grid scrolling.
     * @hidden
     */
    function Scroll(parent) {
        //To maintain scroll state on grid actions.
        this.previousValues = { top: 0, left: 0 };
        this.oneTimeReady = true;
        this.parent = parent;
        this.addEventListener();
        this.setHeight();
        this.setPadding();
    }
    /**
     * @hidden
     */
    Scroll.prototype.setHeight = function () {
        var mHdrHeight = 0;
        var content = this.parent.element.querySelector('.e-content');
        if (this.parent.options.frozenRows && this.parent.options.height !== 'auto') {
            var tbody = this.parent.element.querySelector('.e-headercontent').querySelector('tbody');
            mHdrHeight = tbody ? tbody.offsetHeight : 0;
            content.style.height = sf.base.formatUnit((parseInt(this.parent.options.height) - mHdrHeight));
        }
    };
    /**
     * @hidden
     */
    Scroll.prototype.setPadding = function () {
        if (this.parent.options.height == "auto" && this.parent.options.frozenName == "None" &&
            this.parent.options.frozenColumns == 0) {
            return;
        }
        var content = this.parent.element.querySelector('.e-gridheader');
        var scrollWidth = Scroll.getScrollBarWidth() - this.getThreshold();
        var cssProps = this.getCssProperties();
        content.style[cssProps.padding] = scrollWidth > 0 ? scrollWidth + 'px' : '0px';
        content.querySelector('.e-headercontent').style[cssProps.border] = scrollWidth > 0 ? '1px' : '0px';
        var footer = this.parent.element.querySelector('.e-gridfooter');
        if (footer) {
            var footerContent = footer.querySelector('.e-summarycontent');
            footerContent.style[cssProps.border] = scrollWidth > 0 ? '1px' : '0px';
            footer.style[cssProps.padding] = scrollWidth > 0 ? scrollWidth + 'px' : '0px';
        }
    };
    /**
     * @hidden
     */
    Scroll.prototype.removePadding = function (rtl) {
        var cssProps = this.getCssProperties(rtl);
        var hDiv = this.parent.getHeaderContent().querySelector('.e-headercontent');
        hDiv.style[cssProps.border] = '';
        hDiv.parentElement.style[cssProps.padding] = '';
        var footerDiv = this.parent.getFooterContent();
    };
    /**
     * Refresh makes the Grid adoptable with the height of parent container.
     *
     * > The [`height`](grid/#height/) must be set to 100%.
     * @return
     */
    Scroll.prototype.refresh = function () {
        if (this.parent.options.height !== '100%') {
            return;
        }
        var content = this.parent.element.querySelector(".e-gridcontent");
        var height = getSiblingsHeight(content);
        content.style.height = 'calc(100% - ' + height + 'px)'; //Set the height to the '.e-gridcontent';
    };
    Scroll.prototype.getThreshold = function () {
        /* Some browsers places the scroller outside the content,
         * hence the padding should be adjusted.*/
        var appName = sf.base.Browser.info.name;
        if (appName === 'mozilla') {
            return 0.5;
        }
        return 1;
    };
    /**
     * @hidden
     */
    Scroll.prototype.addEventListener = function () {
        this.wireEvents();
        // this.parent.on(onEmpty, this.wireEvents, this);
        // this.parent.on(contentReady, this.wireEvents, this);
        // this.parent.on(uiUpdate, this.onPropertyChanged, this);
        // this.parent.on(textWrapRefresh, this.wireEvents, this);
        // this.parent.on(headerRefreshed, this.setScrollLeft, this);
    };
    // private setScrollLeft(): void {
    //     if (this.parent.options.frozenColumns) {
    //         (<HTMLElement>(<SfGrid>this.parent).headerModule.getMovableHeader()).scrollLeft = this.previousValues.left;
    //     }
    // }
    Scroll.prototype.onContentScroll = function (scrollTarget) {
        var _this = this;
        var element = scrollTarget;
        var isHeader = element.classList.contains('e-headercontent');
        return function (e) {
            if (_this.content.querySelector('tbody') === null) {
                return;
            }
            var target = e.target;
            var left = target.scrollLeft;
            var sLimit = target.scrollWidth;
            var isFooter = target.classList.contains('e-summarycontent');
            if (_this.previousValues.left === left) {
                _this.previousValues.top = !isHeader ? _this.previousValues.top : target.scrollTop;
                return;
            }
            element.scrollLeft = left;
            var footer = _this.parent.options.frozenColumns != 0 ? _this.parent.element.querySelector('.e-movablefootercontent') :
                _this.parent.element.querySelector('.e-summarycontent');
            if (footer) {
                footer.scrollLeft = left;
            }
            if (isFooter) {
                _this.header.scrollLeft = left;
            }
            _this.previousValues.left = left;
        };
    };
    Scroll.prototype.onFreezeContentScroll = function (scrollTarget) {
        var _this = this;
        var element = scrollTarget;
        return function (e) {
            if (_this.content.querySelector('tbody') === null) {
                return;
            }
            var target = e.target;
            var top = target.scrollTop;
            if (_this.previousValues.top === top) {
                return;
            }
            element.scrollTop = top;
            _this.previousValues.top = top;
        };
    };
    Scroll.prototype.onCustomScrollbar = function (mCont, mHdr) {
        var _this = this;
        var content = mCont;
        var header = mHdr;
        var mfooter;
        return function (e) {
            if (_this.content.querySelector('tbody') === null) {
                return;
            }
            var target = e.target;
            var left = target.scrollLeft;
            if (_this.previousValues.left === left) {
                return;
            }
            if (_this.parent.options.aggregatesCount) {
                mfooter = _this.parent.element.querySelector('.e-movablefootercontent');
            }
            content.scrollLeft = left;
            header.scrollLeft = left;
            if (mfooter) {
                mfooter.scrollLeft = left;
            }
            _this.previousValues.left = left;
        };
    };
    Scroll.prototype.onWheelScroll = function (scrollTarget) {
        var _this = this;
        var element = scrollTarget;
        return function (e) {
            if (_this.content.querySelector('tbody') === null) {
                return;
            }
            var top = element.scrollTop + (e.deltaMode === 1 ? e.deltaY * 30 : e.deltaY);
            if (_this.previousValues.top === top) {
                return;
            }
            e.preventDefault();
            _this.parent.getContent().querySelector('.e-frozencontent').scrollTop = top;
            element.scrollTop = top;
            _this.previousValues.top = top;
        };
    };
    Scroll.prototype.onTouchScroll = function (scrollTarget) {
        var _this = this;
        var element = scrollTarget;
        return function (e) {
            if (e.pointerType === 'mouse') {
                return;
            }
            var isFrozen = _this.parent.options.frozenColumns > 0;
            var pageXY = _this.getPointXY(e);
            var left = element.scrollLeft + (_this.pageXY.x - pageXY.x);
            var mHdr = isFrozen ?
                _this.parent.getHeaderContent().querySelector('.e-movableheader') :
                _this.parent.getHeaderContent().querySelector('.e-headercontent');
            var mCont = isFrozen ?
                _this.parent.getContent().querySelector('.e-movablecontent') :
                _this.parent.getContent().querySelector('.e-content');
            if (_this.previousValues.left === left || (left < 0 || (mHdr.scrollWidth - mHdr.clientWidth) < left)) {
                return;
            }
            if (event.cancelable) {
                e.preventDefault();
            }
            mHdr.scrollLeft = left;
            mCont.scrollLeft = left;
            if (isFrozen) {
                var scrollBar = _this.parent.element.querySelector('.e-movablescrollbar');
                scrollBar.scrollLeft = left;
            }
            _this.pageXY.x = pageXY.x;
            _this.previousValues.left = left;
            // let cont: Element;
            // let mHdr: Element;
            // let pageXY: { x: number, y: number } = this.getPointXY(e);
            // let top: number = element.scrollTop + (this.pageXY.y - pageXY.y);
            // let left: number = element.scrollLeft + (this.pageXY.x - pageXY.x);
            // if (this.parent.getHeaderContent().contains(e.target as Element)) {
            //     mHdr = this.parent.options.frozenColumns ?
            //         this.parent.getHeaderContent().querySelector('.e-movableheader') :
            //         this.parent.getHeaderContent().querySelector('.e-headercontent') as Element;
            //     if (this.previousValues.left === left || (left < 0 || (mHdr.scrollWidth - mHdr.clientWidth) < left)) {
            //         return;
            //     }
            //     e.preventDefault();
            //     mHdr.scrollLeft = left;
            //     element.scrollLeft = left;
            //     this.pageXY.x = pageXY.x;
            //     this.previousValues.left = left;
            // } else {
            //     cont = this.parent.getContent().querySelector('.e-frozencontent');
            //     if (this.previousValues.top === top && (top < 0 || (cont.scrollHeight - cont.clientHeight) < top)
            //         || (top < 0 || (cont.scrollHeight - cont.clientHeight) < top)) {
            //         return;
            //     }
            //     e.preventDefault();
            //     cont.scrollTop = top;
            //     element.scrollTop = top;
            //     this.pageXY.y = pageXY.y;
            //     this.previousValues.top = top;
            // }
        };
    };
    Scroll.prototype.setPageXY = function () {
        var _this = this;
        return function (e) {
            if (e.pointerType === 'mouse') {
                return;
            }
            _this.pageXY = _this.getPointXY(e);
        };
    };
    Scroll.prototype.getPointXY = function (e) {
        var pageXY = { x: 0, y: 0 };
        if (e.touches && e.touches.length) {
            pageXY.x = e.touches[0].pageX;
            pageXY.y = e.touches[0].pageY;
        }
        else {
            pageXY.x = e.pageX;
            pageXY.y = e.pageY;
        }
        return pageXY;
    };
    Scroll.prototype.wireEvents = function () {
        var _this = this;
        if (this.oneTimeReady) {
            var frzCols = this.parent.options.frozenColumns;
            this.content = this.parent.getContent();
            this.header = this.parent.getHeaderContent();
            var mCont = this.content.querySelector('.e-movablecontent');
            var fCont = this.content.querySelector('.e-frozencontent');
            var mHdr = this.header.querySelector('.e-movableheader');
            var mScrollBar = this.content.parentElement.querySelector('.e-movablescrollbar');
            if (this.parent.options.frozenColumns) {
                sf.base.EventHandler.add(frzCols ? mHdr : this.header, 'touchstart pointerdown', this.setPageXY(), this);
                sf.base.EventHandler.add(frzCols ? mHdr : this.header, 'touchmove pointermove', this.onTouchScroll(frzCols ? mCont : this.content), this);
            }
            if (frzCols) {
                sf.base.EventHandler.add(mScrollBar, 'scroll', this.onCustomScrollbar(mCont, mHdr), this);
                sf.base.EventHandler.add(mCont, 'scroll', this.onCustomScrollbar(mScrollBar, mHdr), this);
                sf.base.EventHandler.add(mHdr, 'scroll', this.onCustomScrollbar(mScrollBar, mCont), this);
                sf.base.EventHandler.add(mCont, 'scroll', this.onFreezeContentScroll(fCont), this);
                sf.base.EventHandler.add(fCont, 'scroll', this.onFreezeContentScroll(mCont), this);
                sf.base.EventHandler.add(mHdr, 'scroll', this.onContentScroll(mCont), this);
                sf.base.EventHandler.add(fCont, 'wheel', this.onWheelScroll(mCont), this);
                sf.base.EventHandler.add(mHdr, 'touchstart pointerdown', this.setPageXY(), this);
                sf.base.EventHandler.add(mHdr, 'touchmove pointermove', this.onTouchScroll(mCont), this);
                sf.base.EventHandler.add(mCont, 'touchstart pointerdown', this.setPageXY(), this);
                sf.base.EventHandler.add(mCont, 'touchmove pointermove', this.onTouchScroll(mHdr), this);
            }
            else {
                sf.base.EventHandler.add(this.content, 'scroll', this.onContentScroll(this.header), this);
                sf.base.EventHandler.add(this.header, 'scroll', this.onContentScroll(this.content), this);
            }
            if (this.parent.options.aggregatesCount) {
                var footer = this.parent.options.frozenColumns ? this.parent.element.querySelector('.e-movablefootercontent') :
                    this.parent.element.querySelector('.e-summarycontent');
                if (!sf.base.isNullOrUndefined(footer)) {
                    sf.base.EventHandler.add(footer, 'scroll', this.onContentScroll(this.content), this);
                }
            }
            this.refresh();
            this.oneTimeReady = false;
        }
        var table = this.parent.getContent().querySelector(".e-table");
        var sLeft;
        var sHeight;
        var clientHeight;
        getUpdateUsingRaf(function () {
            sLeft = _this.header.scrollLeft;
            sHeight = table.scrollHeight;
            clientHeight = _this.parent.getContent().clientHeight;
        }, function () {
            if (!_this.parent.options.enableVirtualization) {
                if (sHeight < clientHeight) {
                    sf.base.addClass(table.querySelectorAll('tr:last-child td'), 'e-lastrowcell');
                    if (_this.parent.options.frozenColumns) {
                        sf.base.addClass(_this.parent.getContent().querySelector('.e-movablecontent').querySelectorAll('tr:last-child td'), 'e-lastrowcell');
                    }
                }
                if ((_this.parent.options.frozenColumns > 0 || _this.parent.options.frozenColumns > 0) && _this.header.querySelector('.e-movableheader')) {
                    _this.header.querySelector('.e-movableheader').scrollLeft = _this.previousValues.left;
                }
                else {
                    _this.header.scrollLeft = _this.previousValues.left;
                }
                _this.content.scrollLeft = _this.previousValues.left;
                _this.content.scrollTop = _this.previousValues.top;
            }
            if (!_this.parent.options.enableColumnVirtualization) {
                _this.content.scrollLeft = sLeft;
            }
            if (_this.parent.options.frozenColumns && _this.header.querySelector('.e-movableheader')) {
                _this.header.querySelector('.e-movableheader').scrollLeft =
                    _this.content.querySelector('.e-movablecontent').scrollLeft;
            }
        });
    };
    /**
     * @hidden
     */
    Scroll.prototype.getCssProperties = function (rtl) {
        var css = {};
        var enableRtl = sf.base.isNullOrUndefined(rtl) ? this.parent.options.enableRtl : rtl;
        css.border = enableRtl ? 'borderLeftWidth' : 'borderRightWidth';
        css.padding = enableRtl ? 'paddingLeft' : 'paddingRight';
        return css;
    };
    /**
     * @hidden
     */
    Scroll.prototype.destroy = function () {
        var gridElement = this.parent.element;
        if (!gridElement || (!gridElement.querySelector('.e-gridheader') && !gridElement.querySelector('.e-gridcontent'))) {
            return;
        }
        //Remove padding
        this.removePadding();
        //Remove Dom event
        sf.base.EventHandler.remove(this.parent.getContent(), 'scroll', this.onContentScroll);
    };
    /**
     * Function to get the scrollbar width of the browser.
     * @return {number}
     * @hidden
     */
    Scroll.getScrollBarWidth = function () {
        return getScrollBarWidth();
    };
    return Scroll;
}());

/**
 * Frozen rows and column handling
 */
var Freeze = /** @class */ (function () {
    function Freeze(parent) {
        this.parent = parent;
        this.frozenHeader = parent.element.querySelector('.e-frozenheader');
        this.movableHeader = parent.element.querySelector('.e-movableheader');
        this.addEventListener();
    }
    Freeze.prototype.addEventListener = function () {
        if (this.parent.options.frozenColumns) {
            this.setFrozenHeight();
            this.refreshFreeze({ case: 'textwrap' });
            this.refreshFreeze({ case: 'refreshHeight' });
        }
    };
    Freeze.prototype.refreshFreeze = function (obj) {
        if (obj.case === 'textwrap' || obj.case === 'refreshHeight') {
            var fRows = void 0;
            var mRows = void 0;
            var frRows = void 0;
            var fHdr = this.getFrozenHeader();
            var mHdr = this.getMovableHeader();
            var cont = this.parent.getContent();
            var wrapMode = this.parent.options.wrapMode;
            if (obj.case === 'textwrap') {
                if (wrapMode !== 'Header' || obj.isModeChg) {
                    fRows = cont.querySelector('.e-frozencontent').querySelectorAll('tr');
                    if (this.parent.options.frozenName === "LeftRight") {
                        frRows = cont.querySelector('.e-frozen-right-content').querySelectorAll('tr');
                    }
                    mRows = cont.querySelector('.e-movablecontent').querySelectorAll('tr');
                    this.setWrapHeight(fRows, mRows, obj.isModeChg, true, false, frRows);
                }
                if (wrapMode === 'Both' || obj.isModeChg) {
                    fRows = fHdr.querySelectorAll('tr');
                    mRows = mHdr.querySelectorAll('tr');
                    if (this.parent.options.frozenName == "LeftRight") {
                        frRows = this.parent.element.querySelectorAll('.e-frozenheader')[1].querySelectorAll('tr');
                    }
                }
                else {
                    fRows = fHdr.querySelector(wrapMode === 'Content' ?
                        'tbody' : 'thead').querySelectorAll('tr');
                    mRows = mHdr.querySelector(wrapMode === 'Content' ?
                        'tbody' : 'thead').querySelectorAll('tr');
                }
                if (!this.parent.getHeaderContent().querySelectorAll('.e-stackedheadercell').length) {
                    this.setWrapHeight(fRows, mRows, obj.isModeChg, false, false, frRows);
                }
                this.refreshStackedHdrHgt();
            }
            else if (obj.case === 'refreshHeight') {
                if (this.parent.options.frozenName === "LeftRight") {
                    frRows = cont.querySelector('.e-frozen-right-content').querySelectorAll('tr');
                }
                this.setWrapHeight(cont.querySelector('.e-frozencontent').querySelectorAll('tr'), cont.querySelector('.e-movablecontent').querySelectorAll('tr'), obj.isModeChg, false, false, frRows);
                if (!this.parent.getHeaderContent().querySelectorAll('.e-stackedheadercell').length) {
                    if (this.parent.options.frozenName == "LeftRight") {
                        frRows = this.parent.element.querySelectorAll('.e-frozenheader')[1].querySelectorAll('tr');
                    }
                    this.setWrapHeight(fHdr.querySelectorAll('tr'), mHdr.querySelectorAll('tr'), obj.isModeChg, false, false, frRows);
                }
            }
        }
    };
    Freeze.prototype.updateResizeHandler = function () {
        var elements = [].slice.call(this.parent.getHeaderContent().querySelectorAll('.e-rhandler'));
        for (var i = 0; i < elements.length; i++) {
            elements[i].style.height = elements[i].parentElement.offsetHeight + 'px';
        }
    };
    Freeze.prototype.setWrapHeight = function (fRows, mRows, isModeChg, isContReset, isStackedHdr, frRows) {
        var fRowHgt;
        var mRowHgt;
        var frRowHgt;
        var isWrap = this.parent.options.allowTextWrap;
        var wrapMode = this.parent.options.wrapMode;
        var tHead = this.parent.getHeaderContent().querySelector('thead');
        var tBody = this.parent.getHeaderContent().querySelector('tbody');
        var height = [];
        var width = [];
        var rightHeight = [];
        for (var i = 0, len = fRows.length; i < len; i++) { //separate loop for performance issue 
            if (!sf.base.isNullOrUndefined(fRows[i]) && !sf.base.isNullOrUndefined(mRows[i])) {
                if (frRows) {
                    rightHeight[i] = frRows[i].getBoundingClientRect().height;
                }
                height[i] = fRows[i].getBoundingClientRect().height; //https://pagebuildersandwich.com/increased-plugins-performance-200/
                width[i] = mRows[i].getBoundingClientRect().height;
            }
        }
        for (var i = 0, len = fRows.length; i < len; i++) {
            if (isModeChg && ((wrapMode === 'Header' && isContReset) || ((wrapMode === 'Content' && tHead.contains(fRows[i]))
                || (wrapMode === 'Header' && tBody.contains(fRows[i])))) || isStackedHdr) {
                if (frRows[i]) {
                    frRows[i].style.height = null;
                }
                fRows[i].style.height = null;
                mRows[i].style.height = null;
            }
            fRowHgt = height[i];
            mRowHgt = width[i];
            frRowHgt = rightHeight[i] ? rightHeight[i] : 0;
            var maxHeight = Math.max(fRowHgt, mRowHgt, frRowHgt);
            mRows[i].style.height = maxHeight + 'px';
            fRows[i].style.height = maxHeight + 'px';
            if (frRows) {
                frRows[i].style.height = maxHeight + 'px';
            }
            //TODO: check below commented code is not working hence used above
            // if (!isNullOrUndefined(fRows[i]) && fRows[i].childElementCount && ((isWrap && fRowHgt < mRowHgt) ||
            //     (!isWrap && fRowHgt < mRowHgt))) {p
            //     fRows[i].style.height = mRowHgt + 'px';
            // }
            // if (mRows && !isNullOrUndefined(mRows[i]) && mRows[i].childElementCount && ((isWrap && fRowHgt > mRowHgt) ||
            //     (!isWrap && fRowHgt > mRowHgt))) {
            //     mRows[i].style.height = fRowHgt + 'px';
            // }
        }
        if (isWrap) {
            this.setFrozenHeight();
        }
    };
    Freeze.prototype.setFrozenHeight = function () {
        if (this.parent.options.isPreventScrollEvent) {
            return;
        }
        //let movableContentHeight: number = this.parent.element.querySelector('.e-movablecontent').getBoundingClientRect().height;
        var frozenContentHeight = !sf.base.isNullOrUndefined(this.parent.element.querySelector('.e-frozencontent')) ? this.parent.element.querySelector('.e-frozencontent').getElementsByClassName('e-table')[0].offsetHeight : 0;
        var movableContent = this.parent.element.querySelector('.e-movablecontent');
        var frozenContent = this.parent.element.querySelectorAll('.e-frozencontent');
        var frozenscrollbarX = this.parent.element.querySelectorAll('.e-frozenscrollbar');
        var movablescrollbarX = this.parent.element.querySelector('.e-movablescrollbar');
        var movableChildScrollBarX = this.parent.element.querySelector('.e-movablechild');
        var content = this.parent.element.querySelector('.e-content');
        var frozenColumnWidth = 0;
        if (movablescrollbarX && this.parent.options.height !== '100%' && this.parent.options.height !== 'auto') {
            var parentHeight = parseInt(this.parent.options.height.split ? this.parent.options.height.split("px")[0] : this.parent.options.height, 10);
            var contentHeight = parentHeight - movablescrollbarX.offsetHeight;
            content.style.height = contentHeight + "px";
            if (frozenContentHeight < contentHeight) {
                frozenContentHeight = contentHeight - 1;
            }
        }
        if (frozenContent.length > 0) {
            if (this.parent.options.height === '100%') {
                var scrollBarHeight = this.parent.element.querySelector('.e-scrollbar').offsetHeight;
                var content_1 = this.parent.getContent();
                content_1.style.height = 'calc(100% - ' + scrollBarHeight + 'px)';
            }
            for (var i_1 = 0; i_1 < frozenContent.length; i_1++) {
                frozenContent[i_1].style.height = frozenContentHeight + 1 + 'px';
                frozenContent[i_1].style.borderBottom = '';
                if (frozenscrollbarX[i_1].classList.contains('e-frozen-right-scrollbar')) {
                    frozenscrollbarX[i_1].style.width = frozenContent[i_1].offsetWidth + getScrollBarWidth() + 'px';
                    frozenColumnWidth += frozenContent[i_1].offsetWidth + getScrollBarWidth();
                }
                else {
                    frozenscrollbarX[i_1].style.width = frozenContent[i_1].offsetWidth + 'px';
                    frozenColumnWidth += frozenContent[i_1].offsetWidth;
                }
            }
        }
        if (this.parent.options.enableVirtualization && frozenscrollbarX) {
            var columns = this.parent.options.columns;
            var taotalColumnWidth = 0;
            for (var i = 0; i < columns.length; i++) {
                taotalColumnWidth += parseInt(columns[i].width.split ? columns[i].width.split("px")[0] : columns[i].width.toString(), 10);
            }
            movableChildScrollBarX.style.width = (taotalColumnWidth - frozenColumnWidth) + "px";
        }
        else {
            movableContent.style.height = frozenContentHeight + 1 + 'px';
            movablescrollbarX.style.width = movableContent.offsetWidth + 'px';
            if (this.parent.options.height === '100%' || this.parent.options.width === '100%') {
                movableChildScrollBarX.style.width = movableContent.getElementsByClassName('e-table')[0].offsetWidth + getScrollBarWidth() + 'px';
            }
            else {
                movableChildScrollBarX.style.width = movableContent.getElementsByClassName('e-table')[0].offsetWidth + 'px';
            }
        }
        //if (movableContent.scrollWidth - movableContent.clientWidth) {
        //TODO: why we need commented code?
        // frozenContent.style.height = movableContentHeight - height + 'px';
        // frozenContent.style.borderBottom = '';
        // } else {
        //     frozenContent.style.height = movableContentHeight + 'px';
        //     if ((frozenContent.scrollHeight <= frozenContent.clientHeight) ||
        //         (movableContent.scrollHeight <= movableContent.clientHeight)) {
        //         this.parent.scrollModule.removePadding();
        //     }
        //     frozenContent.style.borderBottom = '0px';
        // }
    };
    Freeze.prototype.updateStackedFrozenHeight = function (fTr, mTr) {
        var fRowSpan;
        var mRowSpan;
        for (var i = 0, len = fTr.length; i < len; i++) {
            fRowSpan = this.getRowSpan(fTr[i]);
            mRowSpan = this.getRowSpan(mTr[i]);
            if (fRowSpan.min > 1) {
                this.updateStackedHdrRowHgt(i, fRowSpan.max, fTr[i], mTr);
            }
            else if (mRowSpan.min > 1) {
                this.updateStackedHdrRowHgt(i, mRowSpan.max, mTr[i], fTr);
            }
        }
    };
    
    Freeze.prototype.refreshStackedHdrHgt = function () {
        var fRTr;
        var fTr = this.getFrozenHeader().querySelectorAll('.e-columnheader');
        var mTr = this.getMovableHeader().querySelectorAll('.e-columnheader');
        if (this.parent.options.frozenName == "LeftRight") {
            fRTr = this.parent.element.querySelectorAll('.e-frozenheader')[1].querySelectorAll('.e-columnheader');
            this.updateStackedFrozenHeight(fRTr, mTr);
        }
        else {
            this.updateStackedFrozenHeight(fTr, mTr);
        }
        if (this.parent.options.allowResizing) {
            this.updateResizeHandler();
        }
    };
    Freeze.prototype.getRowSpan = function (row) {
        var rSpan;
        var minRowSpan;
        var maxRowSpan;
        for (var i = 0, len = row.childElementCount; i < len; i++) {
            if (i === 0) {
                minRowSpan = row.children[0].rowSpan;
            }
            rSpan = row.children[i].rowSpan;
            minRowSpan = Math.min(rSpan, minRowSpan);
            maxRowSpan = Math.max(rSpan, minRowSpan);
        }
        return { min: minRowSpan, max: maxRowSpan };
    };
    Freeze.prototype.updateStackedHdrRowHgt = function (idx, maxRowSpan, row, rows) {
        var height = 0;
        for (var i = 0; i < maxRowSpan; i++) {
            height += rows[idx + i].style.height ?
                parseInt(rows[idx + i].style.height, 10) : rows[idx + i].offsetHeight;
        }
        row.style.height = height + 'px';
    };
    Freeze.prototype.getFrozenHeader = function () {
        return this.frozenHeader;
    };
    Freeze.prototype.getMovableHeader = function () {
        return this.movableHeader;
    };
    Freeze.prototype.refreshRowHeight = function () {
        if (this.parent.options.rowHeight != 0) {
            return;
        }
        if (this.parent.options.frozenColumns || this.parent.options.frozenRows) {
            this.clearWrapHeight();
            this.refreshStackedHdrHgt();
            this.refreshFreeze({ case: 'refreshHeight' });
            if (this.parent.options.allowResizing) {
                this.updateResizeHandler();
            }
        }
    };
    Freeze.prototype.clearWrapHeight = function () {
        var fn = function (fRows, mRows) {
            for (var i = 0, len = fRows.length; i < len; i++) {
                if (!sf.base.isNullOrUndefined(fRows[i]) && !sf.base.isNullOrUndefined(mRows[i])) {
                    fRows[i].style.height = null;
                    mRows[i].style.height = null;
                }
            }
        };
        var fRows;
        var mRows;
        if (this.parent.options.frozenColumns) {
            if (this.parent.options.frozenRows) {
                fRows = this.parent.element.querySelector('.e-frozenheader').querySelectorAll('tr');
                mRows = this.parent.element.querySelector('.e-movableheader').querySelectorAll('tr');
                fn(fRows, mRows);
            }
            fRows = this.parent.element.querySelector('.e-frozencontent').querySelectorAll('tr');
            mRows = this.parent.element.querySelector('.e-movablecontent').querySelectorAll('tr');
            fn(fRows, mRows);
        }
        if (this.parent.options.frozenRows && this.parent.options.frozenColumns == 0) {
            fRows = this.parent.element.querySelector('.e-headercontent').querySelectorAll('tr');
            mRows = this.parent.element.querySelector('.e-content').querySelectorAll('tr');
            fn(fRows, mRows);
        }
    };
    return Freeze;
}());

/**
 * ColumnWidthService
 * @hidden
 */
var ColumnWidthService = /** @class */ (function () {
    function ColumnWidthService(parent) {
        this.parent = parent;
    }
    ColumnWidthService.prototype.setMinwidthBycalculation = function (tWidth) {
        var difference = 0;
        var collection = this.parent.getColumns().filter(function (a) {
            return sf.base.isNullOrUndefined(a.width) || a.width === 'auto' || a.width === '';
        });
        if (collection.length) {
            if (!sf.base.isNullOrUndefined(this.parent.options.width) && this.parent.options.width !== 'auto') {
                difference = (typeof this.parent.options.width === 'string' ? parseInt(this.parent.options.width, 10) : this.parent.options.width) - tWidth;
            }
            else {
                difference = this.parent.element.getBoundingClientRect().width - tWidth;
            }
            var tmWidth = 0;
            for (var _i = 0, collection_1 = collection; _i < collection_1.length; _i++) {
                var cols = collection_1[_i];
                tmWidth += !sf.base.isNullOrUndefined(cols.minWidth) ?
                    ((typeof cols.minWidth === 'string' ? parseInt(cols.minWidth, 10) : cols.minWidth)) : 0;
            }
            var minWidthValues = {};
            for (var i = 0; i < collection.length; i++) {
                if (tWidth === 0 && this.parent.options.allowResizing && this.isWidthUndefined() && (i !== collection.length - 1)) {
                    this.setUndefinedColumnWidth(collection);
                }
                if (tWidth !== 0 && difference < tmWidth) {
                    minWidthValues[collection[i].field] = collection[i].minWidth + 'px';
                }
                else if (tWidth !== 0 && difference > tmWidth) {
                    minWidthValues[collection[i].field] = '';
                }
            }
            this.parent.dotNetRef.invokeMethodAsync('SetMinWidth', minWidthValues);
        }
    };
    ColumnWidthService.prototype.setUndefinedColumnWidth = function (collection) {
        for (var k = 0; k < collection.length; k++) {
            if (k !== collection.length - 1) {
                collection[k].width = 200;
                this.setWidth(200, this.parent.getColumnIndexByField(collection[k].field));
            }
        }
    };
    ColumnWidthService.prototype.setColumnWidth = function (column, index, module, allowStopEvent) {
        if (allowStopEvent === void 0) { allowStopEvent = true; }
        if (this.parent.getColumns().length < 1) {
            return;
        }
        var columnIndex = sf.base.isNullOrUndefined(index) ? this.parent.getNormalizedColumnIndex(column.uid) : index;
        var cWidth = this.getWidth(column);
        var tgridWidth = this.getTableWidth(this.parent.getColumns());
        if (cWidth !== null) {
            this.setWidth(cWidth, columnIndex);
            if (this.parent.options.width !== 'auto' && this.parent.options.width.toString().indexOf('%') === -1) {
                this.setMinwidthBycalculation(tgridWidth);
            }
            if ((this.parent.options.allowResizing && module === 'resize') || (this.parent.options.frozenColumns && this.parent.options.allowResizing)) {
                this.setWidthToTable();
            }
            if (allowStopEvent) {
                if (cWidth.toString().indexOf("px") > 0) {
                    cWidth = cWidth.toString().replace("px", "");
                }
                this.parent.dotNetRef.invokeMethodAsync("ColumnWidthChanged", { index: columnIndex, width: cWidth, columnUid: column.uid });
            }
        }
    };
    ColumnWidthService.prototype.setWidth = function (width, index, clear) {
        var _this = this;
        var chrome = 'chrome';
        var webstore = 'webstore';
        if (typeof (width) === 'string' && width.indexOf('%') !== -1 &&
            !(Boolean(window[chrome]) && Boolean(window[chrome][webstore])) && this.parent.options.allowGrouping) {
            var elementWidth = this.parent.element.offsetWidth;
            width = parseInt(width, 10) / 100 * (elementWidth);
        }
        var header = this.parent.getHeaderTable();
        var content = this.parent.getContentTable();
        var fWidth = sf.base.formatUnit(width);
        var headerCol;
        var frzCols = this.parent.options.frozenColumns;
        var mHdr = this.parent.getHeaderContent().querySelector('.e-movableheader');
        var mCont = this.parent.getContent().querySelector('.e-movablecontent');
        var movableCount = 0;
        if (this.parent.options.frozenRightCount != 0 || this.parent.options.frozenLeftCount != 0) {
            this.parent.updateColumnLevelFrozen();
            var frozenIndex = this.parent.frozenColumnModel.findIndex(function (x) { return x.uid == _this.parent.columnModel[index].uid; });
            var target;
            if (this.parent.options.frozenName == "Left") {
                target = frozenIndex < this.parent.options.frozenLeftCount ? header : mHdr;
            }
            if (this.parent.options.frozenName == "Right") {
                movableCount = this.parent.options.columns.length - this.parent.options.frozenRightCount;
                target = frozenIndex >= movableCount ? header : mHdr;
            }
            else if (this.parent.options.frozenName == "LeftRight") {
                movableCount = this.parent.options.columns.length - this.parent.options.frozenRightCount - this.parent.options.frozenLeftCount;
                var frHdr = this.parent.getHeaderContent().querySelector('.e-frozen-right-header');
                target = frozenIndex < this.parent.options.frozenLeftCount ? header : frozenIndex < (this.parent.options.frozenLeftCount + movableCount) ? mHdr : frHdr;
            }
            headerCol = this.getColumnLevelFrozenColgroup(frozenIndex, this.parent.options.frozenLeftCount, movableCount, target);
            if (!headerCol) {
                return;
            }
        }
        else {
            if (frzCols && index >= frzCols && mHdr && mHdr.querySelector('colgroup')) {
                headerCol = mHdr.querySelector('colgroup').children[index - frzCols];
            }
            else if (this.parent.options.enableColumnVirtualization && frzCols && mHdr.scrollLeft > 0) {
                var colGroup = mHdr.querySelector('colgroup');
                headerCol = colGroup.children[(colGroup.children.length - 1) - index];
            }
            else {
                headerCol = header.querySelector('colgroup').children[index];
            }
        }
        if (headerCol && !clear) {
            headerCol.style.width = fWidth;
        }
        else if (headerCol && clear) {
            headerCol.style.width = ' ';
        }
        var contentCol;
        if (this.parent.options.frozenRightCount != 0 || this.parent.options.frozenLeftCount != 0) {
            var target;
            var frozenIndex = this.parent.frozenColumnModel.findIndex(function (x) { return x.uid == _this.parent.columnModel[index].uid; });
            if (this.parent.options.frozenName == "Left") {
                target = frozenIndex < this.parent.options.frozenLeftCount ? content : mCont;
            }
            if (this.parent.options.frozenName == "Right") {
                movableCount = this.parent.options.columns.length - this.parent.options.frozenRightCount;
                target = frozenIndex >= movableCount ? content : mCont;
            }
            if (this.parent.options.frozenName == "LeftRight") {
                var frCont = this.parent.getContent().querySelector('.e-frozen-right-content');
                target = frozenIndex < this.parent.options.frozenLeftCount ? content : frozenIndex < (this.parent.options.frozenLeftCount + movableCount) ? mCont : frCont;
            }
            contentCol = this.getColumnLevelFrozenColgroup(frozenIndex, this.parent.options.frozenLeftCount, movableCount, target);
        }
        else {
            if (frzCols && index >= frzCols) {
                contentCol = this.parent.getContent().querySelector('.e-movablecontent')
                    .querySelector('colgroup').children[index - frzCols];
            }
            else if (this.parent.options.enableColumnVirtualization && frzCols && mCont.scrollLeft > 0) {
                var colGroup = this.parent.getContent().querySelector('.e-movablecontent')
                    .querySelector('colgroup');
                contentCol = colGroup.children[(colGroup.children.length - 1) - index];
            }
            else {
                contentCol = content.querySelector('colgroup').children[index];
            }
        }
        if (contentCol && !clear) {
            contentCol.style.width = fWidth;
        }
        else if (contentCol && clear) {
            contentCol.style.width = ' ';
        }
        if (this.parent.options.aggregatesCount != 0) {
            var footerCol = void 0;
            if (frzCols && index >= frzCols) {
                var fmContent = this.parent.getFooterContent().querySelector('.e-movablefootercontent');
                var fmColgroup = !sf.base.isNullOrUndefined(fmContent) ? fmContent.querySelector('colgroup') : null;
                footerCol = !sf.base.isNullOrUndefined(fmColgroup) ? fmColgroup.children[index - frzCols] : null;
            }
            else {
                var tcolGroup = this.parent.getFooterContent().querySelector('colgroup');
                footerCol = !sf.base.isNullOrUndefined(tcolGroup) ? tcolGroup.children[index] : null;
            }
            if (contentCol && footerCol && !clear) {
                footerCol.style.width = fWidth;
            }
            else if (contentCol && footerCol && clear) {
                footerCol.style.width = ' ';
            }
        }
        var edit = this.parent.element.querySelectorAll('.e-table.e-inline-edit');
        var editTableCol = [];
        for (var i = 0; i < edit.length; i++) {
            if (parentsUntil(edit[i], 'e-grid').id === this.parent.element.id) {
                for (var j = 0; j < edit[i].querySelector('colgroup').children.length; j++) {
                    editTableCol.push(edit[i].querySelector('colgroup').children[j]);
                }
            }
        }
        if (edit.length && editTableCol.length) {
            editTableCol[index].style.width = fWidth;
        }
        if (this.parent.options.frozenColumns != 0 && !this.parent.options.enableColumnVirtualization) {
            this.parent.freezeModule.setFrozenHeight();
        }
    };
    ColumnWidthService.prototype.getColumnLevelFrozenColgroup = function (index, left, movable, ele) {
        if (!ele || !ele.querySelector('colgroup')) {
            return null;
        }
        var columns = this.parent.frozenColumnModel;
        var headerCol;
        var colGroup = [].slice.call(ele.querySelector('colgroup').children);
        if (columns[index].freeze === 'Left' && columns[index].isFrozen) {
            headerCol = colGroup[index];
        }
        else if (columns[index].freeze === 'Right' && columns[index].isFrozen) {
            headerCol = colGroup[index - (left + movable)];
        }
        else {
            headerCol = colGroup[index - left];
        }
        return headerCol;
    };
    
    ColumnWidthService.prototype.isWidthUndefined = function () {
        var isWidUndefCount = this.parent.getColumns().filter(function (col) {
            return sf.base.isNullOrUndefined(col.width) && sf.base.isNullOrUndefined(col.minWidth);
        }).length;
        return (this.parent.getColumns().length === isWidUndefCount);
    };
    ColumnWidthService.prototype.getWidth = function (column) {
        //TODO: move it to c# side
        // if (isNullOrUndefined(column.width) && this.parent.options.allowResizing
        //     && isNullOrUndefined(column.minWidth) && !this.isWidthUndefined()) {
        //     column.width = 200;
        // }
        // if (this.parent.options.frozenColumns && isNullOrUndefined(column.width) &&
        //     column.index < this.parent.options.frozenColumns) {
        //     column.width = 200;
        // }
        if (!column.width) {
            return null;
        }
        var width = parseInt(column.width.toString(), 10);
        if (column.minWidth && width < parseInt(column.minWidth.toString(), 10)) {
            return column.minWidth;
        }
        else if ((column.maxWidth && width > parseInt(column.maxWidth.toString(), 10))) {
            return column.maxWidth;
        }
        else {
            return column.width;
        }
    };
    ColumnWidthService.prototype.getTableWidth = function (columns) {
        var tWidth = 0;
        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
            var column = columns_1[_i];
            var cWidth = this.getWidth(column);
            if (column.width === 'auto') {
                cWidth = 0;
            }
            if (column.visible !== false && cWidth !== null) {
                tWidth += parseInt(cWidth.toString(), 10);
            }
        }
        return tWidth;
    };
    ColumnWidthService.prototype.calcMovableOrFreezeColWidth = function (tableType) {
        var columns = this.parent.frozenColumnModel.length != 0 ? this.parent.frozenColumnModel.slice() : this.parent.getColumns().slice();
        var left = this.parent.options.frozenLeftCount || this.parent.options.frozenColumns;
        var movable = columns.length - this.parent.options.frozenColumns;
        if (tableType === 'movable') {
            columns.splice(0, this.parent.options.frozenColumns);
        }
        else if (tableType === 'freeze-left') {
            columns.splice(left, columns.length);
        }
        else if (tableType === 'freeze-right') {
            columns.splice(0, left + movable);
        }
        return sf.base.formatUnit(this.getTableWidth(columns));
    };
    ColumnWidthService.prototype.setWidthToFrozenLeftTable = function () {
        var freezeWidth = this.calcMovableOrFreezeColWidth('freeze-left');
        this.parent.getHeaderTable().style.width = freezeWidth;
        this.parent.getContentTable().style.width = freezeWidth;
        if (this.parent.getFooterContent() && this.parent.getFooterContent().querySelector('.e-frozenfootercontent').firstElementChild) {
            this.parent.getFooterContent().querySelector('.e-frozenfootercontent').firstElementChild.style.width = freezeWidth;
        }
    };
    ColumnWidthService.prototype.setWidthToFrozenRightTable = function () {
        var freezeWidth = this.calcMovableOrFreezeColWidth('freeze-right');
        if (!this.parent.options.enableColumnVirtualization) {
            this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelector('.e-table').style.width = freezeWidth;
            this.parent.getContent().querySelector('.e-frozen-right-content').querySelector('.e-table').style.width = freezeWidth;
        }
        if (this.parent.getFooterContent() && this.parent.getFooterContent().querySelector('.e-frozenfootercontent').firstElementChild) {
            this.parent.getFooterContent().querySelector('.e-frozenfootercontent').firstElementChild.style.width = freezeWidth;
        }
    };
    ColumnWidthService.prototype.setWidthToMovableTable = function () {
        var movableWidth = '';
        var isColUndefined = this.parent.getColumns().filter(function (a) { return sf.base.isNullOrUndefined(a.width); }).length >= 1;
        var isWidthAuto = this.parent.getColumns().filter(function (a) { return (a.width === 'auto'); }).length >= 1;
        if (typeof this.parent.options.width === 'number' && !isColUndefined && !isWidthAuto) {
            movableWidth = sf.base.formatUnit(this.parent.options.width - parseInt(this.calcMovableOrFreezeColWidth('freeze').split('px')[0], 10) - 5);
        }
        else if (!isColUndefined && !isWidthAuto) {
            movableWidth = this.calcMovableOrFreezeColWidth('movable');
        }
        if (this.parent.getHeaderContent().querySelector('.e-movableheader').firstElementChild && !this.parent.options.enableColumnVirtualization) {
            this.parent.getHeaderContent().querySelector('.e-movableheader').firstElementChild.style.width
                = movableWidth;
        }
        if (this.parent.getFooterContent() && this.parent.getFooterContent().querySelector('.e-movablefootercontent').firstElementChild) {
            this.parent.getFooterContent().querySelector('.e-movablefootercontent').firstElementChild.style.width = movableWidth;
        }
        if (!this.parent.options.enableColumnVirtualization) {
            this.parent.getContent().querySelector('.e-movablecontent').firstElementChild.style.width =
                movableWidth;
        }
    };
    ColumnWidthService.prototype.setWidthToFrozenEditTable = function () {
        var freezeWidth = this.calcMovableOrFreezeColWidth('freeze');
        this.parent.element.querySelectorAll('.e-table.e-inline-edit')[0].style.width = freezeWidth;
    };
    ColumnWidthService.prototype.setWidthToMovableEditTable = function () {
        var movableWidth = this.calcMovableOrFreezeColWidth('movable');
        this.parent.element.querySelectorAll('.e-table.e-inline-edit')[1].style.width = movableWidth;
    };
    ColumnWidthService.prototype.setWidthToTable = function (columns, tableWidth) {
        if (columns === void 0) { columns = null; }
        if (tableWidth === void 0) { tableWidth = false; }
        var tWidth = sf.base.formatUnit(this.getTableWidth(columns != null ? columns : this.parent.getColumns()));
        if (this.parent.options.frozenColumns) {
            if (this.parent.options.frozenRightCount != 0 || this.parent.options.frozenLeftCount != 0) {
                if (this.parent.options.frozenLeftCount != 0) {
                    this.setWidthToFrozenLeftTable();
                }
                if (this.parent.options.frozenRightCount != 0) {
                    this.setWidthToFrozenRightTable();
                }
                this.setWidthToMovableTable();
            }
            else {
                this.setWidthToFrozenLeftTable();
                this.setWidthToMovableTable();
            }
        }
        else {
            if (this.parent.options.hasDetailTemplate) {
                //this.setColumnWidth(new Column({ width: '30px' }));
                this.setWidth('30', 0);
            }
            if (tableWidth) {
                tWidth = "";
            }
            this.parent.getHeaderTable().style.width = tWidth;
            this.parent.getContentTable().style.width = tWidth;
            if (this.parent.options.aggregatesCount != 0) {
                this.parent.getFooterContent().querySelector(".e-table").style.width = tWidth;
            }
        }
        var edit = this.parent.element.querySelector('.e-table.e-inline-edit');
        if (edit && this.parent.options.frozenColumns) {
            this.setWidthToFrozenEditTable();
            this.setWidthToMovableEditTable();
        }
        else if (edit) {
            edit.style.width = tWidth;
        }
    };
    return ColumnWidthService;
}());

/**
 * Header drag and drop handling
 */
var HeaderDragDrop = /** @class */ (function () {
    function HeaderDragDrop(parent) {
        var _this = this;
        this.dragStart = function (e) {
            var gObj = _this.parent;
            document.body.classList.add('e-prevent-select');
            var popup = gObj.element.querySelector('.e-gridpopup');
            if (popup) {
                popup.style.display = 'none';
            }
            _this.parent.reorderModule.dragStart({ target: e.target, column: _this.column, event: e.event });
            _this.parent.groupModule.columnDragStart({ target: e.target, column: _this.column });
            e.bindEvents(e.dragElement);
        };
        this.drag = function (e) {
            var gObj = _this.parent;
            var target = e.target;
            if (target) {
                var closest$$1 = sf.base.closest(target, '.e-grid');
                var cloneElement = _this.parent.element.querySelector('.e-cloneproperties');
                if (!closest$$1 || closest$$1.getAttribute('id') !== gObj.element.getAttribute('id')) {
                    sf.base.classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);
                    if (gObj.options.allowReordering) {
                        gObj.element.querySelector('.e-reorderuparrow').style.display = 'none';
                        gObj.element.querySelector('.e-reorderdownarrow').style.display = 'none';
                    }
                    if (!gObj.options.groupReordering) {
                        return;
                    }
                }
                if (gObj.options.allowReordering) {
                    _this.parent.reorderModule.drag({ target: e.target, column: _this.column, event: e.event });
                }
                if (gObj.options.allowGrouping) {
                    _this.parent.groupModule.columnDrag({ target: e.target });
                }
            }
        };
        this.dragStop = function (e) {
            var gObj = _this.parent;
            document.body.classList.remove('e-prevent-select');
            var cancel;
            var popup = gObj.element.querySelector('.e-gridpopup');
            if (popup) {
                popup.style.display = 'none';
            }
            if ((!parentsUntil(e.target, 'e-headercell') && !parentsUntil(e.target, 'e-groupdroparea')) ||
                (!gObj.options.allowReordering && parentsUntil(e.target, 'e-headercell')) ||
                (!e.helper.getAttribute('e-mappinguid') && parentsUntil(e.target, 'e-groupdroparea'))) {
                sf.base.remove(e.helper);
                cancel = true;
            }
            if (gObj.options.allowReordering) {
                _this.parent.reorderModule.dragStop({ target: e.target, event: e.event, column: _this.column, cancel: cancel });
            }
        };
        this.drop = function (e) {
            var gObj = _this.parent;
            var uid = e.droppedElement.getAttribute('e-mappinguid');
            var closest$$1 = sf.base.closest(e.target, '.e-grid');
            sf.base.remove(e.droppedElement);
            if (closest$$1 && closest$$1.getAttribute('id') !== gObj.element.getAttribute('id') ||
                !(gObj.options.allowReordering || gObj.options.allowGrouping)) {
                return;
            }
            if (gObj.options.allowReordering) {
                _this.parent.reorderModule.headerDrop({ target: e.target });
            }
            if (gObj.options.allowGrouping && gObj.options.showDropArea) {
                _this.parent.groupModule.columnDrop({
                    target: e.target, droppedElement: e.droppedElement
                });
            }
            //gObj.notify(events.headerDrop, { target: e.target, uid: uid, droppedElement: e.droppedElement });
        };
        this.helper = function (e) {
            var gObj = _this.parent;
            var target = e.sender.target;
            var parentEle = parentsUntil(target, 'e-headercell');
            if (!(gObj.options.allowReordering || gObj.options.allowGrouping) || (!sf.base.isNullOrUndefined(parentEle)
                && parentEle.querySelectorAll('.e-checkselectall').length > 0)) {
                return false;
            }
            var visualElement = sf.base.createElement('div', { className: 'e-cloneproperties e-dragclone e-headerclone' });
            var element = target.classList.contains('e-headercell') ? target : parentEle;
            if (!element || (!gObj.options.allowReordering && element.classList.contains('e-stackedheadercell'))) {
                return false;
            }
            var height = element.offsetHeight;
            var headercelldiv = element.querySelector('.e-headercelldiv') || element.querySelector('.e-stackedheadercelldiv');
            var col;
            if (headercelldiv) {
                if (element.querySelector('.e-stackedheadercelldiv')) {
                    col = gObj.getStackedHeaderColumnByHeaderText(headercelldiv.innerText.trim(), gObj.options.columns);
                }
                else {
                    col = gObj.getColumnByUid(headercelldiv.getAttribute('e-mappinguid'));
                }
                _this.column = col;
                if (_this.column.lockColumn) {
                    return false;
                }
                visualElement.setAttribute('e-mappinguid', headercelldiv.getAttribute("e-mappinguid"));
            }
            // if (col && !isNullOrUndefined(col.headerTemplate)) {
            //     if (!isNullOrUndefined(col.headerTemplate)) {
            //         let result: Element[];
            //         let colIndex: number = gObj.getColumnIndexByField(col.field);
            //         result = col.getHeaderTemplate()(extend({ 'index': colIndex }, col), gObj, 'headerTemplate');
            //         appendChildren(visualElement, result);
            //     } else {
            //         visualElement.innerHTML = col.headerTemplate;
            //     }
            // } else {
            visualElement.innerHTML = headercelldiv ? col.headerText : element.firstElementChild.innerHTML;
            //}
            visualElement.style.width = element.offsetWidth + 'px';
            visualElement.style.height = element.offsetHeight + 'px';
            visualElement.style.lineHeight = (height - 6).toString() + 'px';
            gObj.element.appendChild(visualElement);
            return visualElement;
        };
        this.parent = parent;
        if (this.parent.options.allowGrouping || this.parent.options.allowReordering) {
            this.initializeHeaderDrag();
            this.initializeHeaderDrop();
        }
    }
    HeaderDragDrop.prototype.initializeHeaderDrag = function () {
        var gObj = this.parent;
        if (!(this.parent.options.allowReordering || (this.parent.options.allowGrouping && this.parent.options.showDropArea))) {
            return;
        }
        var headerRows = [].slice.call(gObj.getHeaderContent().querySelectorAll('.e-columnheader'));
        for (var i = 0, len = headerRows.length; i < len; i++) {
            var drag = new sf.base.Draggable(headerRows[i], {
                dragTarget: '.e-headercell',
                distance: 5,
                helper: this.helper,
                dragStart: this.dragStart,
                drag: this.drag,
                dragStop: this.dragStop,
                abort: '.e-rhandler',
                isPreventSelect: false
            });
        }
    };
    HeaderDragDrop.prototype.initializeHeaderDrop = function () {
        var gObj = this.parent;
        var drop = new sf.base.Droppable(gObj.getHeaderContent(), {
            accept: '.e-dragclone',
            drop: this.drop
        });
    };
    return HeaderDragDrop;
}());

/**
 * ColumnDrop Handling
 */
var ContentDragDrop = /** @class */ (function () {
    function ContentDragDrop(parent) {
        var _this = this;
        this.drop = function (e) {
            _this.parent.groupModule.columnDrop({
                target: e.target, droppedElement: e.droppedElement
            });
            sf.base.remove(e.droppedElement);
        };
        this.parent = parent;
        if (this.parent.options.allowGrouping) {
            this.initializeContentDrop();
        }
    }
    ContentDragDrop.prototype.initializeContentDrop = function () {
        var gObj = this.parent;
        var drop = new sf.base.Droppable(gObj.getContent(), {
            accept: '.e-dragclone',
            drop: this.drop
        });
    };
    return ContentDragDrop;
}());

/**
 * Column reorder handling
 */
var Reorder = /** @class */ (function () {
    function Reorder(parent) {
        this.parent = parent;
        if (parent.options.allowReordering) {
            this.createReorderElement();
        }
    }
    Reorder.prototype.chkDropPosition = function (srcElem, destElem) {
        var col = this.parent.getColumnByUid(destElem.firstElementChild.getAttribute('e-mappinguid'));
        var bool = col ? !col.lockColumn : true;
        return (srcElem.parentElement.isEqualNode(destElem.parentElement) || (this.parent.options.frozenColumns
            && Array.prototype.indexOf.call(sf.base.closest(srcElem, 'thead').children, srcElem.parentElement)
                === Array.prototype.indexOf.call(sf.base.closest(destElem, 'thead').children, destElem.parentElement)))
            && this.targetParentContainerIndex(srcElem, destElem) > -1 && bool;
    };
    Reorder.prototype.chkDropAllCols = function (srcElem, destElem) {
        var isFound;
        var headers = this.getHeaderCells();
        var header;
        while (!isFound && headers.length > 0) {
            header = headers.pop();
            isFound = srcElem !== header && this.targetParentContainerIndex(srcElem, destElem) > -1;
        }
        return isFound;
    };
    Reorder.prototype.findColParent = function (col, cols, parent) {
        parent = parent;
        for (var i = 0, len = cols.length; i < len; i++) {
            if (col === cols[i]) {
                return true;
            }
            else if (cols[i].columns) {
                var cnt = parent.length;
                parent.push(cols[i]);
                if (!this.findColParent(col, cols[i].columns, parent)) {
                    parent.splice(cnt, parent.length - cnt);
                }
                else {
                    return true;
                }
            }
        }
        return false;
    };
    Reorder.prototype.getColumnsModel = function (cols) {
        var columnModel = [];
        var subCols = [];
        for (var i = 0, len = cols.length; i < len; i++) {
            columnModel.push(cols[i]);
            if (cols[i].columns) {
                subCols = subCols.concat(cols[i].columns);
            }
        }
        if (subCols.length) {
            columnModel = columnModel.concat(this.getColumnsModel(subCols));
        }
        return columnModel;
    };
    Reorder.prototype.headerDrop = function (e) {
        var gObj = this.parent;
        var dropElement = this.element.querySelector('.e-headercelldiv') || this.element.querySelector('.e-stackedheadercelldiv');
        var uId = dropElement.getAttribute('e-mappinguid');
        var column = gObj.getColumnByUid(uId);
        if (!sf.base.closest(e.target, 'th') || (!sf.base.isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn))) {
            return;
        }
        var destElem = sf.base.closest(e.target, '.e-headercell');
        var destElemDiv = destElem.querySelector('.e-headercelldiv') || destElem.querySelector('.e-stackedheadercelldiv');
        var destElemUid = destElemDiv.getAttribute('e-mappinguid');
        if (!sf.base.isNullOrUndefined(destElemUid)) {
            var destColumn = gObj.getColumnByUid(destElemUid);
            if (sf.base.isNullOrUndefined(destColumn) || !destColumn.allowReordering || destColumn.lockColumn) {
                return;
            }
        }
        if (destElem && !(!this.chkDropPosition(this.element, destElem) || !this.chkDropAllCols(this.element, destElem))) {
            if (this.parent.options.enableColumnVirtualization) {
                var columns = this.parent.options.columns;
                var sourceUid_1 = this.element.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');
                var col = this.parent.getColumns(true).filter(function (col) { return col.uid === sourceUid_1; });
                var colMatchIndex_1 = null;
                var column_1 = col[0];
                var destUid_1 = destElem.querySelector('.e-headercelldiv').getAttribute('e-mappinguid');
                var bool = columns.some(function (col, index) {
                    if (col.uid === destUid_1) {
                        colMatchIndex_1 = index;
                        return col.uid === destUid_1;
                    }
                    return false;
                });
                if (!sf.base.isNullOrUndefined(colMatchIndex_1)) {
                    this.moveColumns(colMatchIndex_1, column_1);
                }
            }
            else {
                var newIndex = this.targetParentContainerIndex(this.element, destElem);
                var uid = this.element.firstElementChild.getAttribute('e-mappinguid');
                this.destElement = destElem;
                if (uid) {
                    this.moveColumns(newIndex, this.parent.getColumnByUid(uid));
                }
                else {
                    var headers = this.getHeaderCells();
                    var oldIdx = getElementIndex(this.element, headers);
                    var columns = this.getColumnsModel(this.parent.options.columns);
                    var column_2 = columns[oldIdx];
                    this.moveColumns(newIndex, column_2);
                }
            }
        }
    };
    Reorder.prototype.isActionPrevent = function (gObj) {
        return isActionPrevent(gObj.element);
    };
    Reorder.prototype.moveColumns = function (destIndex, column, reorderByColumn, preventRefresh) {
        var gObj = this.parent;
        if (this.isActionPrevent(gObj)) {
            //gObj.notify(events.preventBatch, { instance: this, handler: this.moveColumns, arg1: destIndex, arg2: column });
            return;
        }
        var parent = this.getColParent(column, this.parent.options.columns);
        var cols = parent ? parent.columns : this.parent.options.columns;
        var srcIdx = inArray(column, cols);
        if (((this.parent.options.frozenColumns && parent)) && !reorderByColumn) {
            for (var i = 0; i < cols.length; i++) {
                if (cols[i].field === column.field) {
                    srcIdx = i;
                    break;
                }
            }
            var col = this.parent.getColumnByUid(this.destElement.firstElementChild.getAttribute('e-mappinguid'));
            if (col) {
                for (var i = 0; i < cols.length; i++) {
                    if (cols[i].field === col.field) {
                        destIndex = i;
                        break;
                    }
                }
            }
            else {
                for (var i = 0; i < cols.length; i++) {
                    if (cols[i].headerText === this.destElement.innerText.trim()) {
                        destIndex = i;
                    }
                }
            }
        }
        if (!gObj.options.allowReordering || srcIdx === destIndex || srcIdx === -1 || destIndex === -1) {
            return;
        }
        cols.splice(destIndex, 0, cols.splice(srcIdx, 1)[0]);
        gObj.getColumns(true);
        //gObj.notify(events.columnPositionChanged, { fromIndex: destIndex, toIndex: srcIdx });
        if (preventRefresh !== false) {
            //TODO: reorder from here
            setTimeout(function () {
                gObj.dotNetRef.invokeMethodAsync("ColumnReordered", {
                    requestType: 'reorder', fromIndex: destIndex, toIndex: srcIdx, toColumnUid: column.uid
                });
            }, 10);
        }
    };
    Reorder.prototype.targetParentContainerIndex = function (srcElem, destElem) {
        var headers = this.getHeaderCells();
        if (this.parent.options.frozenName !== 'None') {
            this.parent.updateColumnLevelFrozen();
        }
        var cols = this.parent.options.columns;
        var flatColumns = this.parent.options.frozenName == 'None' ? this.getColumnsModel(cols) : this.parent.frozenReorderColumnModel.slice();
        var parent = this.getColParent(flatColumns[getElementIndex(srcElem, headers)], cols);
        cols = parent ? parent.columns : cols;
        return inArray(flatColumns[getElementIndex(destElem, headers)], cols);
    };
    Reorder.prototype.getHeaderCells = function () {
        var frozenColumns = this.parent.options.frozenColumns;
        if (frozenColumns && this.parent.options.frozenName === 'None') {
            var fTh = void 0;
            var mTh = void 0;
            var fHeaders = [];
            var fRows = [].slice.call(this.parent.element.querySelector(".e-frozenheader").querySelectorAll('.e-columnheader'));
            if (frozenColumns && this.parent.options.frozenName === 'None') {
                var mRows = [].slice.call(this.parent.getHeaderContent()
                    .querySelector('.e-movableheader').querySelectorAll('.e-columnheader'));
                for (var i = 0; i < fRows.length; i++) {
                    fTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));
                    mTh = [].slice.call(mRows[i].getElementsByClassName('e-headercell'));
                    var isAvail = void 0;
                    for (var k = 0; k < fTh.length; k++) {
                        for (var j = 0; j < mTh.length; j++) {
                            if (mTh[j].innerText === fTh[k].innerText) {
                                isAvail = true;
                                break;
                            }
                        }
                        if (!isAvail) {
                            fHeaders = fHeaders.concat([fTh[k]]);
                        }
                    }
                    for (var j = 0; j < mTh.length; j++) {
                        fHeaders.push(mTh[j]);
                    }
                }
            }
            else {
                for (var i = 0; i < fRows.length; i++) {
                    mTh = [].slice.call(fRows[i].getElementsByClassName('e-headercell'));
                    for (var k = 0; k < mTh.length; k++) {
                        var isAvail = void 0;
                        for (var j = k + 1; j < mTh.length; j++) {
                            if (mTh[j].innerText === mTh[k].innerText) {
                                isAvail = true;
                                break;
                            }
                        }
                        if (!isAvail) {
                            fHeaders = fHeaders.concat([mTh[k]]);
                        }
                    }
                }
            }
            return fHeaders;
        }
        else {
            return [].slice.call(this.parent.element.getElementsByClassName('e-headercell'));
        }
    };
    Reorder.prototype.getColParent = function (column, columns) {
        var parents = [];
        this.findColParent(column, columns, parents);
        return parents[parents.length - 1];
    };
    Reorder.prototype.reorderSingleColumn = function (fromFName, toFName) {
        var fColumn = this.parent.getColumnByField(fromFName);
        var toColumn = this.parent.getColumnByField(toFName);
        if ((!sf.base.isNullOrUndefined(fColumn) && (!fColumn.allowReordering || fColumn.lockColumn)) ||
            (!sf.base.isNullOrUndefined(toColumn) && (!toColumn.allowReordering || fColumn.lockColumn))) {
            return;
        }
        var column = this.parent.getColumnByField(toFName);
        var parent = this.getColParent(column, this.parent.options.columns);
        var columns = parent ? parent.columns : this.parent.options.columns;
        var destIndex = inArray(column, columns);
        if (destIndex > -1) {
            this.moveColumns(destIndex, this.parent.getColumnByField(fromFName), true);
        }
    };
    Reorder.prototype.reorderMultipleColumns = function (fromFNames, toFName) {
        var toIndex = this.parent.getColumnIndexByField(toFName);
        var toColumn = this.parent.getColumnByField(toFName);
        if (toIndex < 0 || (!sf.base.isNullOrUndefined(toColumn) && (!toColumn.allowReordering || toColumn.lockColumn))) {
            return;
        }
        for (var i = 0; i < fromFNames.length; i++) {
            var column = this.parent.getColumnByField(fromFNames[i]);
            if (!sf.base.isNullOrUndefined(column) && (!column.allowReordering || column.lockColumn)) {
                return;
            }
        }
        for (var i = 0; i < fromFNames.length; i++) {
            var column = this.parent.getColumnByIndex(toIndex);
            var parent_1 = this.getColParent(column, this.parent.options.columns);
            var columns = parent_1 ? parent_1.columns : this.parent.options.columns;
            var destIndex = inArray(column, columns);
            if (destIndex > -1) {
                this.moveColumns(destIndex, this.parent.getColumnByField(fromFNames[i]), true, false);
            }
            if (this.parent.getColumnIndexByField(fromFNames[i + 1]) >= destIndex) {
                toIndex++; //R to L
            }
        }
        var cols = this.parent.getColumns();
        this.parent.dotNetRef.invokeMethodAsync("ColumnReordered", {
            fromColumnUid: fromFNames.map(function (name) { return cols.filter(function (col) { return col.field === name; })[0].uid; }),
            toColumnUid: toColumn.uid,
            isMultipleReorder: true,
            requestType: 'reorder',
            type: 'actionBegin'
        });
    };
    Reorder.prototype.moveTargetColumn = function (column, toIndex) {
        if (toIndex > -1) {
            this.moveColumns(toIndex, column, true);
        }
    };
    Reorder.prototype.reorderSingleColumnByTarget = function (fieldName, toIndex) {
        var column = this.parent.getColumnByField(fieldName);
        this.moveTargetColumn(column, toIndex);
    };
    Reorder.prototype.reorderMultipleColumnByTarget = function (fieldName, toIndex) {
        for (var i = 0; i < fieldName.length; i++) {
            this.reorderSingleColumnByTarget(fieldName[i], toIndex);
        }
    };
    /**
     * Changes the position of the Grid columns by field names.
     * @param  {string | string[]} fromFName - Defines the origin field names.
     * @param  {string} toFName - Defines the destination field name.
     * @return {void}
     */
    Reorder.prototype.reorderColumns = function (fromFName, toFName) {
        if (typeof fromFName === 'string') {
            this.reorderSingleColumn(fromFName, toFName);
            this.fromCol = fromFName;
        }
        else {
            this.reorderMultipleColumns(fromFName, toFName);
            this.fromCol = fromFName[0];
        }
    };
    /**
     * Changes the position of the Grid columns by field index.
     * @param  {number} fromIndex - Defines the origin field index.
     * @param  {number} toIndex - Defines the destination field index.
     * @return {void}
     */
    Reorder.prototype.reorderColumnByIndex = function (fromIndex, toIndex) {
        var column = this.parent.getColumnByIndex(fromIndex);
        this.moveTargetColumn(column, toIndex);
    };
    /**
     * Changes the position of the Grid columns by field index.
     * @param  {string | string[]} fieldName - Defines the field name.
     * @param  {number} toIndex - Defines the destination field index.
     * @return {void}
     */
    Reorder.prototype.reorderColumnByTargetIndex = function (fieldName, toIndex) {
        typeof fieldName === 'string' ? this.reorderSingleColumnByTarget(fieldName, toIndex) :
            this.reorderMultipleColumnByTarget(fieldName, toIndex);
    };
    Reorder.prototype.createReorderElement = function () {
        var header = this.parent.element.querySelector('.e-headercontent');
        this.upArrow = header.appendChild(sf.base.createElement('div', { className: 'e-icons e-icon-reorderuparrow e-reorderuparrow', attrs: { style: 'display:none' } }));
        this.downArrow = header.appendChild(sf.base.createElement('div', { className: 'e-icons e-icon-reorderdownarrow e-reorderdownarrow', attrs: { style: 'display:none' } }));
    };
    /**
     * The function used to trigger onActionComplete
     * @return {void}
     * @hidden
     */
    // public onActionComplete(e: NotifyArgs): void {
    //     if (isBlazor() && !this.parent.isJsComponent) {
    //         e.rows = null;
    //     }
    //     this.parent.trigger(events.actionComplete, extend(e, { type: events.actionComplete }));
    //     let target: Element = this.fromCol && this.parent.getColumnHeaderByField(this.fromCol);
    //     if (target) {
    //         this.parent.focusModule.onClick({ target }, true);
    //     }
    // }
    /**
     * To destroy the reorder
     * @return {void}
     * @hidden
     */
    Reorder.prototype.destroy = function () {
        var gridElement = this.parent.element;
        if (this.upArrow) {
            sf.base.remove(this.upArrow);
        }
        if (this.downArrow) {
            sf.base.remove(this.downArrow);
        }
        //call ejdrag and drop destroy
    };
    Reorder.prototype.keyPressHandler = function (e) {
        var gObj = this.parent;
        switch (e.action) {
            case 'ctrlLeftArrow':
            case 'ctrlRightArrow':
                // let element: HTMLElement = gObj.focusModule.currentInfo.element;
                // if (element && element.classList.contains('e-headercell')) {
                //     let column: Column = gObj.getColumnByUid(element.firstElementChild.getAttribute('e-mappinguid'));
                //     let visibleCols: Column[] = gObj.getVisibleColumns();
                //     let index: number = visibleCols.indexOf(column);
                //     let toCol: Column = e.action === 'ctrlLeftArrow' ? visibleCols[index - 1] : visibleCols[index + 1];
                //     if (toCol && toCol.field && column.field) {
                //         this.reorderColumns(column.field, toCol.field);
                //     }
                // }
                break;
        }
    };
    Reorder.prototype.drag = function (e) {
        var gObj = this.parent;
        var target = e.target;
        if (!e.column.allowReordering || e.column.lockColumn) {
            return;
        }
        var closest$$1 = sf.base.closest(target, '.e-headercell:not(.e-stackedHeaderCell)');
        var cloneElement = gObj.element.querySelector('.e-cloneproperties');
        var isLeft = this.x > getPosition(e.event).x + gObj.getContent().firstElementChild.scrollLeft;
        sf.base.removeClass(gObj.element.querySelector(".e-headercontent").querySelectorAll('.e-reorderindicate'), ['e-reorderindicate']);
        this.setDisplay('none');
        this.stopTimer();
        sf.base.classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);
        this.updateScrollPostion(e.event);
        if (closest$$1 && !closest$$1.isEqualNode(this.element)) {
            target = closest$$1;
            //consider stacked, detail header cell 
            if (!(!this.chkDropPosition(this.element, target) || !this.chkDropAllCols(this.element, target))) {
                this.updateArrowPosition(target, isLeft);
                sf.base.classList(target, ['e-allowDrop', 'e-reorderindicate'], []);
            }
            else if (!(gObj.options.allowGrouping && parentsUntil(e.target, 'e-groupdroparea'))) {
                sf.base.classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);
            }
        }
        //gObj.trigger(events.columnDrag, { target: target, draggableType: 'headercell', column: e.column });
    };
    Reorder.prototype.updateScrollPostion = function (e) {
        var _this = this;
        var frzCols = this.parent.options.frozenColumns;
        var x = getPosition(e).x;
        var cliRect = this.parent.element.getBoundingClientRect();
        var cliRectBaseLeft = frzCols ? this.parent.element.querySelector('.e-movableheader')
            .getBoundingClientRect().left : cliRect.left;
        var cliRectBaseRight = cliRect.right;
        var scrollElem = frzCols ? this.parent.getContent().querySelector('.e-movablecontent')
            : this.parent.getContent();
        if (this.parent.options.frozenName !== 'None') {
            this.updateFrozenScrollPosition(x, cliRect);
        }
        else {
            if (x > cliRectBaseLeft && x < cliRectBaseLeft + 35) {
                this.timer = window.setInterval(function () { _this.setScrollLeft(scrollElem, true); }, 50);
            }
            else if (x < cliRectBaseRight && x > cliRectBaseRight - 35) {
                this.timer = window.setInterval(function () { _this.setScrollLeft(scrollElem, false); }, 50);
            }
        }
    };
    Reorder.prototype.updateFrozenScrollPosition = function (x, cliRect) {
        var scrollElem = this.parent.getContent().querySelector('.e-movablecontent');
        var mhdrCliRect = this.parent.element.querySelector('.e-movableheader').getBoundingClientRect();
        var left = this.parent.options.frozenLeftCount;
        var right = this.parent.options.frozenRightCount;
        var cliRectBaseRight = right ? mhdrCliRect.right : cliRect.right;
        var cliRectBaseLeft = left ? mhdrCliRect.left : cliRect.left;
        if (x > cliRectBaseLeft && x < cliRectBaseLeft + 35) {
            this.timer = window.setInterval(function () { this.setScrollLeft(scrollElem, true); }, 50);
        }
        else if (x < cliRectBaseRight && x > cliRectBaseRight - 35) {
            this.timer = window.setInterval(function () { this.setScrollLeft(scrollElem, false); }, 50);
        }
    };
    Reorder.prototype.setScrollLeft = function (scrollElem, isLeft) {
        var scrollLeft = scrollElem.scrollLeft;
        scrollElem.scrollLeft = scrollElem.scrollLeft + (isLeft ? -5 : 5);
        if (scrollLeft !== scrollElem.scrollLeft) {
            this.setDisplay('none');
        }
    };
    Reorder.prototype.stopTimer = function () {
        window.clearInterval(this.timer);
    };
    Reorder.prototype.updateArrowPosition = function (target, isLeft) {
        var cliRect = target.getBoundingClientRect();
        var cliRectBase = this.parent.element.getBoundingClientRect();
        if ((isLeft && cliRect.left < cliRectBase.left) || (!isLeft && cliRect.right > cliRectBase.right)) {
            return;
        }
        this.upArrow.style.top = cliRect.top + cliRect.height - cliRectBase.top + 'px';
        this.downArrow.style.top = cliRect.top - cliRectBase.top - 4 + 'px';
        this.upArrow.style.left = this.downArrow.style.left = (isLeft ? cliRect.left : cliRect.right) - cliRectBase.left - 4 + 'px';
        this.setDisplay('');
    };
    Reorder.prototype.dragStart = function (e) {
        var gObj = this.parent;
        document.body.classList.add('e-prevent-select');
        var target = e.target;
        this.element = target.classList.contains('e-headercell') ? target :
            parentsUntil(target, 'e-headercell');
        if (!e.column.allowReordering || e.column.lockColumn) {
            return;
        }
        this.x = getPosition(e.event).x + gObj.getContent().firstElementChild.scrollLeft;
        // gObj.trigger(events.columnDragStart, {
        //     target: target as Element, draggableType: 'headercell', column: e.column
        // });
    };
    Reorder.prototype.dragStop = function (e) {
        var gObj = this.parent;
        document.body.classList.remove('e-prevent-select');
        this.setDisplay('none');
        this.stopTimer();
        if (!e.cancel) {
            //gObj.trigger(events.columnDrop, { target: e.target, draggableType: 'headercell', column: e.column });
        }
        sf.base.removeClass(gObj.element.querySelector(".e-headercontent").querySelectorAll('.e-reorderindicate'), ['e-reorderindicate']);
    };
    Reorder.prototype.setDisplay = function (display) {
        this.upArrow.style.display = display;
        this.downArrow.style.display = display;
    };
    /**
     * For internal use only - Get the module name.
     * @private
     */
    Reorder.prototype.getModuleName = function () {
        return 'reorder';
    };
    return Reorder;
}());

var resizeClassList = {
    root: 'e-rhandler',
    suppress: 'e-rsuppress',
    icon: 'e-ricon',
    helper: 'e-rhelper',
    header: 'th.e-headercell',
    cursor: 'e-rcursor'
};
/**
 * Resize handler
 */
var Resize = /** @class */ (function () {
    function Resize(parent) {
        this.tapped = false;
        this.isDblClk = true;
        this.parent = parent;
        this.widthService = new ColumnWidthService(this.parent);
    }
    /**
     * Resize by field names.
     * @param  {string|string[]} fName - Defines the field name.
     * @return {void}
     */
    Resize.prototype.autoFitColumns = function (fName) {
        var columnName = (fName === undefined || fName === null || fName.length <= 0) ?
            this.parent.getColumns().map(function (x) { return x.field; }) : (typeof fName === 'string') ? [fName] : fName;
        this.findColumn(columnName);
    };
    Resize.prototype.autoFit = function () {
        var newarray = this.parent.getColumns().filter(function (c) { return c.autoFit === true; })
            .map(function (c) { return c.field || c.headerText; });
        if (newarray.length > 0) {
            this.autoFitColumns(newarray);
        }
    };
    /* tslint:disable-next-line:max-func-body-length */
    Resize.prototype.resizeColumn = function (fName, index, id) {
        var gObj = this.parent;
        var tWidth = 0;
        var headerTable;
        var contentTable;
        var footerTable;
        var headerDivTag = 'e-gridheader';
        var contentDivTag = 'e-gridcontent';
        var footerDivTag = 'e-gridfooter';
        var indentWidth = 0;
        var uid = id ? id : this.parent.getUidByColumnField(fName);
        var columnIndex = this.parent.getNormalizedColumnIndex(uid);
        var headerTextClone;
        var contentTextClone;
        var footerTextClone;
        var columnIndexByField = this.parent.getColumnIndexByField(fName);
        var frzCols = gObj.options.frozenColumns;
        if (!sf.base.isNullOrUndefined(gObj.getFooterContent())) {
            footerTable = gObj.getFooterContent().querySelector('.e-table');
        }
        if (frzCols) {
            if (index < frzCols) {
                headerTable = gObj.getHeaderTable();
                contentTable = gObj.getContentTable();
                headerTextClone = headerTable.querySelector('[e-mappinguid="' + uid + '"]').parentElement.cloneNode(true);
                contentTextClone = contentTable.querySelectorAll("td:nth-child(" + (columnIndex + 1) + ")");
                if (footerTable) {
                    footerTextClone = footerTable.querySelectorAll("td:nth-child(" + (columnIndex + 1) + ")");
                }
            }
            else {
                headerTable = gObj.getHeaderContent().querySelector('.e-movableheader').children[0];
                contentTable = gObj.getContent().querySelector('.e-movablecontent').children[0];
                headerTextClone = headerTable.querySelector('[e-mappinguid="' + uid + '"]').parentElement.cloneNode(true);
                contentTextClone = contentTable.querySelectorAll("td:nth-child(" + ((columnIndex - frzCols) + 1) + ")");
                if (footerTable) {
                    footerTable = gObj.getFooterContent().querySelector('.e-movablefootercontent').children[0];
                    footerTextClone = footerTable.querySelectorAll("td:nth-child(" + ((columnIndex - frzCols) + 1) + ")");
                }
            }
        }
        else {
            headerTable = gObj.getHeaderTable();
            contentTable = gObj.getContentTable();
            headerTextClone = headerTable.querySelector('[e-mappinguid="' + uid + '"]').parentElement.cloneNode(true);
            contentTextClone = contentTable.querySelectorAll("td:nth-child(" + (columnIndex + 1) + "):not(.e-groupcaption)");
            if (footerTable) {
                footerTextClone = footerTable.querySelectorAll("td:nth-child(" + (columnIndex + 1) + "):not(.e-groupcaption)");
            }
        }
        var indentWidthClone = headerTable.querySelector('tr').querySelectorAll('.e-grouptopleftcell');
        if (indentWidthClone.length > 0) {
            for (var i = 0; i < indentWidthClone.length; i++) {
                indentWidth += indentWidthClone[i].offsetWidth;
            }
        }
        var detailsElement = contentTable.querySelector('.e-detailrowcollapse') ||
            contentTable.querySelector('.e-detailrowexpand');
        if ((this.parent.options.hasDetailTemplate) && detailsElement) {
            indentWidth += detailsElement.offsetWidth;
        }
        var headerText = [headerTextClone];
        var contentText = [];
        var footerText = [];
        if (footerTable) {
            for (var i = 0; i < footerTextClone.length; i++) {
                footerText[i] = footerTextClone[i].cloneNode(true);
            }
        }
        for (var i = 0; i < contentTextClone.length; i++) {
            contentText[i] = contentTextClone[i].cloneNode(true);
        }
        var wHeader = this.createTable(headerTable, headerText, headerDivTag);
        var wContent = this.createTable(contentTable, contentText, contentDivTag);
        var wFooter = null;
        if (footerText.length) {
            wFooter = this.createTable(footerTable, footerText, footerDivTag);
        }
        var columnbyindex = gObj.getColumns()[columnIndexByField];
        var result;
        var width = columnbyindex.width = sf.base.formatUnit(Math.max(wHeader, wContent, wFooter));
        this.widthService.setColumnWidth(gObj.getColumns()[columnIndexByField]);
        result = gObj.getColumns().some(function (x) { return (x.width === null || x.width === undefined || x.width.length <= 0) && x.visible; });
        if (result === false) {
            var element = gObj.getColumns();
            for (var i = 0; i < element.length; i++) {
                if (element[i].visible) {
                    tWidth = tWidth + parseFloat(element[i].width);
                }
            }
        }
        var calcTableWidth = tWidth + indentWidth;
        if (tWidth > 0 && !gObj.options.frozenColumns) {
            //TODO: why this?
            if (this.parent.options.hasDetailTemplate) {
                //this.widthService.setColumnWidth(new Column({ width: '30px' }));
                this.widthService.setWidth('30', 0);
            }
            headerTable.style.width = sf.base.formatUnit(calcTableWidth);
            contentTable.style.width = sf.base.formatUnit(calcTableWidth);
            if (!sf.base.isNullOrUndefined(footerTable)) {
                footerTable.style.width = sf.base.formatUnit(calcTableWidth);
            }
        }
        var tableWidth = headerTable.offsetWidth;
        var contentwidth = (gObj.getContent().scrollWidth);
        if (contentwidth > tableWidth) {
            headerTable.classList.add('e-tableborder');
            contentTable.classList.add('e-tableborder');
        }
        else {
            headerTable.classList.remove('e-tableborder');
            contentTable.classList.remove('e-tableborder');
        }
        if (!sf.base.isNullOrUndefined(footerTable)) {
            footerTable.classList.add('e-tableborder');
        }
        this.parent.freezeModule.refreshRowHeight();
        if (width.toString().indexOf("px") > 0) {
            width = width.replace("px", "");
        }
        this.parent.options.isResizedGrid = true;
        this.parent.dotNetRef.invokeMethodAsync("ColumnWidthChanged", { width: width, columnUid: uid });
    };
    /**
     * To destroy the resize
     * @return {void}
     * @hidden
     */
    Resize.prototype.destroy = function () {
        var gridElement = this.parent.element;
        if (!gridElement || (!gridElement.querySelector('.e-gridheader') && !gridElement.querySelector('.e-gridcontent'))) {
            return;
        }
        this.widthService = null;
        this.unwireEvents();
        //this.removeEventListener();
    };
    /**
     * For internal use only - Get the module name.
     * @private
     */
    Resize.prototype.getModuleName = function () {
        return 'resize';
    };
    Resize.prototype.findColumn = function (fName) {
        var _loop_1 = function (i) {
            var fieldName = fName[i];
            var columnIndex = this_1.parent.getColumnIndexByField(fieldName);
            var column = this_1.parent.getColumns()[columnIndex];
            if (columnIndex > -1 && !sf.base.isNullOrUndefined(column) && column.visible === true) {
                if (!(this_1.parent.options.allowGrouping && ((!sf.base.isNullOrUndefined(this_1.parent.options.initGroupingField) &&
                    this_1.parent.options.initGroupingField.some(function (x) { return x == column.field; })) && !this_1.parent.options.showGroupedColumn))) {
                    this_1.resizeColumn(fieldName, columnIndex);
                }
            }
        };
        var this_1 = this;
        for (var i = 0; i < fName.length; i++) {
            _loop_1(i);
        }
    };
    /**
     * To create table for autofit
     * @hidden
     */
    Resize.prototype.createTable = function (table, text, tag) {
        var myTableDiv = sf.base.createElement('div');
        myTableDiv.className = this.parent.element.className;
        myTableDiv.style.cssText = 'display: inline-block;visibility:hidden;position:absolute';
        var mySubDiv = sf.base.createElement('div');
        mySubDiv.className = tag;
        var myTable = sf.base.createElement('table');
        myTable.className = table.className;
        myTable.classList.add('e-resizetable');
        myTable.style.cssText = 'table-layout: auto;width: auto';
        var myTr = sf.base.createElement('tr');
        for (var i = 0; i < text.length; i++) {
            var tr = myTr.cloneNode();
            tr.className = table.querySelector('tr').className;
            tr.appendChild(text[i]);
            myTable.appendChild(tr);
        }
        mySubDiv.appendChild(myTable);
        myTableDiv.appendChild(mySubDiv);
        document.body.appendChild(myTableDiv);
        var offsetWidthValue = myTable.getBoundingClientRect().width;
        document.body.removeChild(myTableDiv);
        return Math.ceil(offsetWidthValue);
    };
    /**
     * @hidden
     */
    // public addEventListener(): void {
    //     if (this.parent.isDestroyed) {
    //         return;
    //     }
    //     this.parent.on(events.headerRefreshed, this.refreshHeight, this);
    //     this.parent.on(events.initialEnd, this.wireEvents, this);
    //     this.parent.on(events.contentReady, this.autoFit, this);
    // }
    /**
     * @hidden
     */
    // public removeEventListener(): void {
    //     if (this.parent.isDestroyed) {
    //         return;
    //     }
    //     this.parent.off(events.headerRefreshed, this.refreshHeight);
    //     this.parent.off(events.initialEnd, this.wireEvents);
    // }
    /**
     * @hidden
     */
    Resize.prototype.render = function () {
        this.unwireEvents();
        this.wireEvents();
        this.setHandlerHeight();
    };
    Resize.prototype.refreshHeight = function () {
        var element = this.getResizeHandlers();
        for (var i = 0; i < element.length; i++) {
            if (element[i].parentElement.offsetHeight > 0) {
                element[i].style.height = element[i].parentElement.offsetHeight + 'px';
            }
        }
        this.setHandlerHeight();
    };
    Resize.prototype.wireEvents = function () {
        sf.base.EventHandler.add(this.parent.getHeaderContent(), sf.base.Browser.touchStartEvent, this.resizeStart, this);
        sf.base.EventHandler.add(this.parent.getHeaderContent(), 'dblclick', this.callAutoFit, this);
    };
    Resize.prototype.unwireEvents = function () {
        sf.base.EventHandler.remove(this.parent.getHeaderContent(), sf.base.Browser.touchStartEvent, this.resizeStart);
        sf.base.EventHandler.remove(this.parent.getHeaderContent(), 'dblclick', this.callAutoFit);
    };
    Resize.prototype.getResizeHandlers = function () {
        return this.parent.options.frozenColumns ?
            [].slice.call(this.parent.getHeaderContent().querySelectorAll('.' + resizeClassList.root))
            : [].slice.call(this.parent.getHeaderContent().querySelector(".e-table").querySelectorAll('.' + resizeClassList.root));
    };
    Resize.prototype.setHandlerHeight = function () {
        var element = [].slice.call(this.parent.getHeaderContent().querySelector(".e-table").querySelectorAll('.' + resizeClassList.suppress));
        for (var i = 0; i < element.length; i++) {
            element[i].style.height = element[i].parentElement.offsetHeight + 'px';
        }
    };
    Resize.prototype.callAutoFit = function (e) {
        if (e.target.classList.contains('e-rhandler')) {
            var col = this.getTargetColumn(e);
            if (col.columns) {
                return;
            }
            this.resizeColumn(col.field, this.parent.getNormalizedColumnIndex(col.uid), col.uid);
            var header = sf.base.closest(e.target, resizeClassList.header);
            header.classList.add('e-resized');
        }
    };
    Resize.prototype.resizeStart = function (e) {
        if (e.target.classList.contains('e-rhandler')) {
            var columnList = [];
            var columnData = {};
            if (!this.helper) {
                if (this.getScrollBarWidth() === 0) {
                    for (var _i = 0, _a = this.refreshColumnWidth(); _i < _a.length; _i++) {
                        var col = _a[_i];
                        this.widthService.setColumnWidth(col, null, null, false);
                        columnData = { width: col.width == "" ? 0 : col.width, columnUid: col.uid };
                        columnList.push(columnData);
                    }
                    this.widthService.setWidthToTable();
                }
                this.refreshStackedColumnWidth();
                this.element = e.target;
                //TODO: rowheight
                // if (this.parent.getVisibleFrozenColumns()) {
                //     let mtbody: Element = this.parent.getContent().querySelector('.e-movablecontent').querySelector('tbody');
                //     let ftbody: Element = this.parent.getContent().querySelector('.e-frozencontent').querySelector('tbody');
                //     let mtr: NodeListOf<HTMLElement> = mtbody.querySelectorAll('tr');
                //     let ftr: NodeListOf<HTMLElement> = ftbody.querySelectorAll('tr');
                //     for (let i: number = 0; i < mtr.length; i++) {
                //         if (this.parent.rowHeight) {
                //             mtr[i].style.height = this.parent.rowHeight + 'px';
                //             ftr[i].style.height = this.parent.rowHeight + 'px';
                //         } else {
                //             mtr[i].style.removeProperty('height');
                //             ftr[i].style.removeProperty('height');
                //         }
                //     }
                // }
                this.parentElementWidth = this.parent.element.getBoundingClientRect().width;
                this.appendHelper();
                this.column = this.getTargetColumn(e);
                this.pageX = this.getPointX(e);
                if (this.parent.options.enableRtl) {
                    this.minMove = parseFloat(this.column.width.toString())
                        - (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0);
                }
                else {
                    this.minMove = (this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0)
                        - parseFloat(sf.base.isNullOrUndefined(this.column.width) ? '' : this.column.width.toString());
                }
                this.minMove += this.pageX;
            }
            if (sf.base.Browser.isDevice && !this.helper.classList.contains(resizeClassList.icon)) {
                this.helper.classList.add(resizeClassList.icon);
                sf.base.EventHandler.add(document, sf.base.Browser.touchStartEvent, this.removeHelper, this);
                sf.base.EventHandler.add(this.helper, sf.base.Browser.touchStartEvent, this.resizeStart, this);
            }
            else {
                // let args: ResizeArgs = {
                //     e: isBlazor() && !this.parent.isJsComponent ? null : e,
                //     column: this.column
                // };
                // this.parent.trigger(events.resizeStart, args, (args: ResizeArgs) => {
                //     if (args.cancel || this.parent.isEdit) {
                //         this.cancelResizeAction();
                //         return;
                //     }
                sf.base.EventHandler.add(document, sf.base.Browser.touchEndEvent, this.resizeEnd, this);
                sf.base.EventHandler.add(this.parent.element, sf.base.Browser.touchMoveEvent, this.resizing, this);
                this.updateCursor('add');
                this.parent.dotNetRef.invokeMethodAsync("ResizeStarted", {
                    columnUid: this.column.uid, columnList: columnList
                });
                // });
            }
        }
    };
    Resize.prototype.cancelResizeAction = function (removeEvents) {
        if (removeEvents) {
            sf.base.EventHandler.remove(this.parent.element, sf.base.Browser.touchMoveEvent, this.resizing);
            sf.base.EventHandler.remove(document, sf.base.Browser.touchEndEvent, this.resizeEnd);
            this.updateCursor('remove');
        }
        if (sf.base.Browser.isDevice) {
            sf.base.EventHandler.remove(document, sf.base.Browser.touchStartEvent, this.removeHelper);
            sf.base.EventHandler.remove(this.helper, sf.base.Browser.touchStartEvent, this.resizeStart);
        }
        sf.base.detach(this.helper);
        this.refresh();
    };
    Resize.prototype.getWidth = function (width, minWidth, maxWidth) {
        if (minWidth && width < minWidth) {
            return minWidth;
        }
        else if ((maxWidth && width > maxWidth)) {
            return maxWidth;
        }
        else {
            return width;
        }
    };
    Resize.prototype.updateResizeEleHeight = function () {
        var elements = [].slice.call(this.parent.getHeaderContent().querySelectorAll('.e-rhandler'));
        for (var i = 0; i < elements.length; i++) {
            elements[i].style.height = elements[i].parentElement.offsetHeight + 'px';
        }
    };
    Resize.prototype.getColData = function (column, mousemove) {
        return {
            width: parseFloat(sf.base.isNullOrUndefined(this.widthService.getWidth(column)) || this.widthService.getWidth(column) === 'auto' ? '0'
                : this.widthService.getWidth(column).toString()) + mousemove,
            minWidth: column.minWidth ? parseFloat(column.minWidth.toString()) : null,
            maxWidth: column.maxWidth ? parseFloat(column.maxWidth.toString()) : null
        };
    };
    Resize.prototype.resizing = function (e) {
        if (sf.base.isNullOrUndefined(this.column)) {
            return;
        }
        var offsetWidth = 0;
        if (sf.base.isNullOrUndefined(this.column)) {
            offsetWidth = parentsUntil(this.element, 'th').offsetWidth;
        }
        if (this.parent.options.allowTextWrap) {
            this.updateResizeEleHeight();
            this.setHelperHeight();
        }
        var pageX = this.getPointX(e);
        var mousemove = this.parent.options.enableRtl ? -(pageX - this.pageX) : (pageX - this.pageX);
        if (this.column.freeze === 'Right' && this.column.isFrozen) {
            mousemove = this.parent.options.enableRtl ? (pageX - this.pageX) : (this.pageX - pageX);
        }
        var colData = this.getColData(this.column, mousemove);
        if (!colData.width) {
            colData.width = sf.base.closest(this.element, 'th').offsetWidth;
        }
        var width = this.getWidth(colData.width, colData.minWidth, colData.maxWidth);
        if (this.column.freeze !== 'Right') {
            if ((!this.parent.options.enableRtl && this.minMove >= pageX) || (this.parent.options.enableRtl && this.minMove <= pageX)) {
                width = this.column.minWidth ? parseFloat(this.column.minWidth.toString()) : 0;
                this.pageX = pageX = this.minMove;
            }
        }
        if (width !== parseFloat(sf.base.isNullOrUndefined(this.column.width) || this.column.width === 'auto' ?
            offsetWidth.toString() : this.column.width.toString())) {
            this.pageX = pageX;
            this.column.width = sf.base.formatUnit(width);
            // let args: ResizeArgs = {
            //     e: e,
            //     column: this.column
            // };
            //this.parent.trigger(events.onResize, args);
            // if (args.cancel) {
            //     this.cancelResizeAction(true);
            //     return;
            // }
            var columns = [this.column];
            var finalColumns = [this.column];
            if (this.column.columns) {
                columns = this.getSubColumns(this.column, []);
                columns = this.calulateColumnsWidth(columns, false, mousemove);
                finalColumns = this.calulateColumnsWidth(columns, true, mousemove);
            }
            for (var _i = 0, finalColumns_1 = finalColumns; _i < finalColumns_1.length; _i++) {
                var col = finalColumns_1[_i];
                this.widthService.setColumnWidth(col, null, 'resize', false);
            }
            this.updateHelper();
        }
        this.isDblClk = false;
    };
    Resize.prototype.calulateColumnsWidth = function (columns, isUpdate, mousemove) {
        var finalColumns = [];
        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
            var col = columns_1[_i];
            var totalWidth = 0;
            for (var i = 0; i < columns.length; i++) {
                totalWidth += parseFloat(columns[i].width.toString());
            }
            var colData = this.getColData(col, (parseFloat(col.width)) * mousemove / totalWidth);
            var colWidth = this.getWidth(colData.width, colData.minWidth, colData.maxWidth);
            if ((colWidth !== parseFloat(col.width.toString()))) {
                if (isUpdate) {
                    col.width = sf.base.formatUnit(colWidth < 1 ? 1 : colWidth);
                }
                finalColumns.push(col);
            }
        }
        return finalColumns;
    };
    Resize.prototype.getSubColumns = function (column, subColumns) {
        for (var _i = 0, _a = column.columns; _i < _a.length; _i++) {
            var col = _a[_i];
            if (col.visible !== false && col.allowResizing) {
                if (col.columns) {
                    this.getSubColumns(col, subColumns);
                }
                else {
                    subColumns.push(col);
                }
            }
        }
        return subColumns;
    };
    Resize.prototype.resizeEnd = function (e) {
        if (!this.helper) {
            return;
        }
        sf.base.EventHandler.remove(this.parent.element, sf.base.Browser.touchMoveEvent, this.resizing);
        sf.base.EventHandler.remove(document, sf.base.Browser.touchEndEvent, this.resizeEnd);
        this.updateCursor('remove');
        sf.base.detach(this.helper);
        // let args: ResizeArgs = {
        //     e: isBlazor() && !this.parent.isJsComponent ? null : e,
        //     column: this.column
        // };
        var content = this.parent.getContent();
        // let cTable: HTMLElement = content.querySelector('.e-movablecontent') ? content.querySelector('.e-movablecontent') : content;
        // if (cTable.scrollHeight >= cTable.clientHeight) {
        //     this.parent.scrollModule.setPadding();
        //     cTable.style.overflowY = 'scroll';
        // }
        //this.parent.trigger(events.resizeStop, args);
        sf.base.closest(this.element, '.e-headercell').classList.add('e-resized');
        if (parentsUntil(this.element, 'e-frozenheader')) {
            this.isFrozenColResized = true;
        }
        else {
            this.isFrozenColResized = false;
        }
        if (this.parent.options.frozenColumns) {
            this.parent.freezeModule.refreshRowHeight();
            this.parent.freezeModule.setFrozenHeight();
        }
        if (this.parent.options.allowTextWrap) {
            this.updateResizeEleHeight();
        }
        var width = this.column.width.toString();
        width = width.replace("px", "");
        this.parent.dotNetRef.invokeMethodAsync("ColumnWidthChanged", { width: width, columnUid: this.column.uid, allowStopEvent: true });
        this.refresh();
        this.doubleTapEvent(e);
        this.isDblClk = true;
    };
    Resize.prototype.getPointX = function (e) {
        if (e.touches && e.touches.length) {
            return e.touches[0].pageX;
        }
        else {
            return e.pageX;
        }
    };
    Resize.prototype.refreshColumnWidth = function () {
        var columns = this.parent.getColumns();
        for (var _i = 0, _a = [].slice.apply(this.parent.getHeaderContent().querySelectorAll('th.e-headercell')); _i < _a.length; _i++) {
            var ele = _a[_i];
            for (var _b = 0, columns_2 = columns; _b < columns_2.length; _b++) {
                var column = columns_2[_b];
                if (ele.querySelector('[e-mappinguid]') &&
                    ele.querySelector('[e-mappinguid]').getAttribute('e-mappinguid') === column.uid && column.visible) {
                    column.width = ele.getBoundingClientRect().width ? ele.getBoundingClientRect().width : column.width;
                    break;
                }
            }
        }
        return columns;
    };
    Resize.prototype.refreshStackedColumnWidth = function () {
        for (var _i = 0, _a = this.parent.getStackedColumns(this.parent.options.columns); _i < _a.length; _i++) {
            var stackedColumn = _a[_i];
            stackedColumn.width = this.getStackedWidth(stackedColumn, 0);
        }
    };
    Resize.prototype.getStackedWidth = function (column, width) {
        for (var _i = 0, _a = column.columns; _i < _a.length; _i++) {
            var col = _a[_i];
            if (col.visible !== false) {
                if (col.columns) {
                    this.getStackedWidth(col, width);
                }
                else {
                    width += col.width;
                }
            }
        }
        return width;
    };
    Resize.prototype.getTargetColumn = function (e) {
        var cell = sf.base.closest(e.target, resizeClassList.header);
        cell = cell.querySelector('.e-headercelldiv') || cell.querySelector('.e-stackedheadercelldiv');
        var uid = cell.getAttribute('e-mappinguid');
        return this.parent.getColumnByUid(uid);
    };
    Resize.prototype.updateCursor = function (action) {
        var headerRows = [].slice.call(this.parent.getHeaderContent().querySelectorAll('th'));
        headerRows.push(this.parent.element);
        for (var _i = 0, headerRows_1 = headerRows; _i < headerRows_1.length; _i++) {
            var row = headerRows_1[_i];
            row.classList[action](resizeClassList.cursor);
        }
    };
    Resize.prototype.refresh = function () {
        this.column = null;
        this.pageX = null;
        this.element = null;
        this.helper = null;
    };
    Resize.prototype.appendHelper = function () {
        this.helper = sf.base.createElement('div', {
            className: resizeClassList.helper
        });
        this.parent.element.appendChild(this.helper);
        this.setHelperHeight();
    };
    Resize.prototype.setHelperHeight = function () {
        var height = this.parent.getContent().offsetHeight - ((this.parent.options.enableVirtualization && this.parent.options.frozenColumns) ? 0 : this.getScrollBarWidth());
        var rect = sf.base.closest(this.element, resizeClassList.header);
        var tr = [].slice.call(this.parent.getHeaderContent().querySelectorAll('tr'));
        var frzCols = this.parent.options.frozenColumns;
        if (frzCols && rect.parentElement.children.length && !rect.parentElement.children[0].classList.contains('e-stackedheadercell')) {
            if (parentsUntil(rect, 'e-movableheader')) {
                tr = [].slice.call(this.parent.getHeaderContent().querySelector('.e-movableheader').querySelectorAll('tr'));
            }
            else if (parentsUntil(rect, 'e-frozen-right-header')) {
                tr = [].slice.call(this.parent.getHeaderContent().querySelector('.e-frozen-right-header').querySelectorAll('tr'));
            }
            else {
                tr = [].slice.call(this.parent.getHeaderContent().querySelector('.e-frozen-left-header').querySelectorAll('tr'));
            }
        }
        for (var i = tr.indexOf(rect.parentElement); i < tr.length; i++) {
            height += tr[i].offsetHeight;
        }
        var pos = this.calcPos(rect);
        if (parentsUntil(rect, 'e-frozen-right-header')) {
            pos.left += (this.parent.options.enableRtl ? rect.offsetWidth - 2 : 0 - 1);
        }
        else {
            pos.left += (this.parent.options.enableRtl ? 0 - 1 : rect.offsetWidth - 2);
        }
        this.helper.style.cssText = 'height: ' + height + 'px; top: ' + pos.top + 'px; left:' + Math.floor(pos.left) + 'px;';
    };
    Resize.prototype.getScrollBarWidth = function (height) {
        var ele = this.parent.options.frozenColumns ? this.parent.getContent().querySelector('.e-movablecontent')
            : this.parent.getContent();
        return (ele.scrollHeight > ele.clientHeight && height) ||
            ele.scrollWidth > ele.clientWidth ? getScrollBarWidth() : 0;
    };
    Resize.prototype.removeHelper = function (e) {
        var cls = e.target.classList;
        if (!(cls.contains(resizeClassList.root) || cls.contains(resizeClassList.icon)) && this.helper) {
            sf.base.EventHandler.remove(document, sf.base.Browser.touchStartEvent, this.removeHelper);
            sf.base.EventHandler.remove(this.helper, sf.base.Browser.touchStartEvent, this.resizeStart);
            sf.base.detach(this.helper);
            this.refresh();
        }
    };
    Resize.prototype.updateHelper = function () {
        var rect = sf.base.closest(this.element, resizeClassList.header);
        var left = Math.floor(this.calcPos(rect).left + (this.parent.options.enableRtl ? 0 - 1 : rect.offsetWidth - 2));
        var borderWidth = 2; // to maintain the helper inside of grid element.
        if (parentsUntil(rect, 'e-frozen-right-header')) {
            left = Math.floor(this.calcPos(rect).left + (this.parent.options.enableRtl ? rect.offsetWidth - 2 : 0 - 1));
        }
        if (left > this.parentElementWidth) {
            left = this.parentElementWidth - borderWidth;
        }
        if (this.parent.options.frozenColumns) {
            var table = sf.base.closest(rect, '.e-table');
            var fLeft = table.offsetLeft;
            if (left < fLeft) {
                left = fLeft;
            }
        }
        this.helper.style.left = left + 'px';
    };
    Resize.prototype.calcPos = function (elem) {
        var parentOffset = {
            top: 0,
            left: 0
        };
        var offset = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var offsetParent = parentsUntil(elem, 'e-grid') || doc.documentElement;
        while (offsetParent &&
            (offsetParent === doc.body || offsetParent === doc.documentElement) &&
            offsetParent.style.position === 'static') {
            offsetParent = offsetParent.parentNode;
        }
        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = offsetParent.getBoundingClientRect();
        }
        return {
            top: offset.top - parentOffset.top,
            left: offset.left - parentOffset.left
        };
    };
    Resize.prototype.doubleTapEvent = function (e) {
        if (this.getUserAgent() && this.isDblClk) {
            if (!this.tapped) {
                this.tapped = setTimeout(this.timeoutHandler(), 300);
            }
            else {
                clearTimeout(this.tapped);
                this.callAutoFit(e);
                this.tapped = null;
            }
        }
    };
    Resize.prototype.getUserAgent = function () {
        var userAgent = sf.base.Browser.userAgent.toLowerCase();
        return /iphone|ipod|ipad/.test(userAgent);
    };
    Resize.prototype.timeoutHandler = function () {
        this.tapped = null;
    };
    return Resize;
}());

/**
 *
 * The `Group` module is used to handle group action.
 */
var Group = /** @class */ (function () {
    /**
     * Constructor for Grid group module
     * @hidden
     */
    function Group(parent) {
        var _this = this;
        this.visualElement = sf.base.createElement('div', {
            className: 'e-cloneproperties e-dragclone e-gdclone',
            styles: 'line-height:23px', attrs: { action: 'grouping' }
        });
        this.helper = function (e) {
            var gObj = _this.parent;
            var target = e.sender.target;
            var element = target.classList.contains('e-groupheadercell') ? target :
                parentsUntil(target, 'e-groupheadercell');
            if (!element || (!target.classList.contains('e-drag') && _this.parent.options.groupReordering)) {
                return false;
            }
            _this.column = gObj.getColumnByField(element.firstElementChild.getAttribute('ej-mappingname'));
            _this.visualElement.textContent = element.textContent;
            _this.visualElement.style.width = element.offsetWidth + 2 + 'px';
            _this.visualElement.style.height = element.offsetHeight + 2 + 'px';
            _this.visualElement.setAttribute('e-mappinguid', _this.column.uid);
            gObj.element.appendChild(_this.visualElement);
            return _this.visualElement;
        };
        this.dragStart = function (e) {
            _this.parent.element.classList.add('e-ungroupdrag');
            document.body.classList.add('e-prevent-select');
            e.bindEvents(e.dragElement);
        };
        this.drag = function (e) {
            // if (this.groupSettings.allowReordering) {
            //     this.animateDropper(e);
            // }
            var target = e.target;
            var cloneElement = _this.parent.element.querySelector('.e-cloneproperties');
            // this.parent.trigger(events.columnDrag, { target: target, draggableType: 'headercell', column: this.column });
            if (!_this.parent.options.groupReordering) {
                sf.base.classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);
                if (!(parentsUntil(target, 'e-gridcontent') || parentsUntil(target, 'e-headercell'))) {
                    sf.base.classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);
                }
            }
        };
        this.dragStop = function (e) {
            document.body.classList.remove('e-prevent-select');
            _this.parent.element.classList.remove('e-ungroupdrag');
            var preventDrop = !(parentsUntil(e.target, 'e-gridcontent') || parentsUntil(e.target, 'e-gridheader'));
            // if (this.groupSettings.allowReordering && preventDrop) {     //TODO: reordering
            //     remove(e.helper);
            //     if (parentsUntil(e.target, 'e-groupdroparea')) {
            //         this.rearrangeGroup(e);
            //     } else if (!(parentsUntil(e.target, 'e-grid'))) {
            //         let field: string = this.parent.getColumnByUid(e.helper.getAttribute('e-mappinguid')).field;
            //         if (this.groupSettings.columns.indexOf(field) !== -1) {
            //             this.ungroupColumn(field);
            //         }
            //     }
            //     return;
            // } else
            if (preventDrop) {
                sf.base.remove(e.helper);
                return;
            }
        };
        //TODO: reordering
        // private animateDropper: Function = (e: { target: HTMLElement, event: MouseEventArgs, helper: Element }) => {
        //     let uid: string = this.parent.element.querySelector('.e-cloneproperties').getAttribute('e-mappinguid');
        //     let dragField: string = this.parent.getColumnByUid(uid).field;
        //     let parent: Element = parentsUntil(e.target, 'e-groupdroparea');
        //     let dropTarget: Element = parentsUntil(e.target, 'e-group-animator');
        //     // tslint:disable-next-line
        //     let grouped: string[] = [].slice.call(this.element.querySelectorAll('.e-groupheadercell'))
        //         .map((e: Element) => e.querySelector('div').getAttribute('ej-mappingname'));
        //     let cols: string[] = JSON.parse(JSON.stringify(grouped));
        //     if (dropTarget || parent) {
        //         if (dropTarget) {
        //             let dropField: string = dropTarget.querySelector('div[ej-mappingname]').getAttribute('ej-mappingname');
        //             let dropIndex: number = +(dropTarget.getAttribute('index'));
        //             if (dropField !== dragField) {
        //                 let dragIndex: number = cols.indexOf(dragField);
        //                 if (dragIndex !== -1) {
        //                     cols.splice(dragIndex, 1);
        //                 }
        //                 let flag: boolean = dropIndex !== -1 && dragIndex === dropIndex;
        //                 cols.splice(dropIndex + (flag ? 1 : 0), 0, dragField);
        //             }
        //         } else if (parent && cols.indexOf(dragField) === -1) {
        //             cols.push(dragField);
        //         }
        //         this.element.innerHTML = '';
        //         if (cols.length && !this.element.classList.contains('e-grouped')) {
        //             this.element.classList.add('e-grouped');
        //         }
        //         this.reorderingColumns = cols;
        //         for (let c: number = 0; c < cols.length; c++) {
        //             this.addColToGroupDrop(cols[c]);
        //         }
        //     } else {
        //         this.addLabel();
        //         this.removeColFromGroupDrop(dragField);
        //     }
        // }
        // private rearrangeGroup(e: { target: HTMLElement, event: MouseEventArgs, helper: Element }): void {
        //     this.sortRequired = false;
        //     this.updateModel();
        // }
        this.preventTouchOnWindow = function (e) {
            e.preventDefault();
        };
        this.drop = function (e) {
            var gObj = _this.parent;
            var column = gObj.getColumnByUid(e.droppedElement.getAttribute('e-mappinguid'));
            gObj.element.querySelector('.e-groupdroparea').classList.remove('e-hover');
            sf.base.remove(e.droppedElement);
            if (gObj.options.allowGrouping) {
                sf.base.EventHandler.remove(window, 'touchmove', _this.preventTouchOnWindow);
            }
            _this.parent.element.querySelector('.e-groupdroparea').removeAttribute("aria-dropeffect");
            _this.parent.element.querySelector('[aria-grabbed=true]').setAttribute("aria-grabbed", 'false');
            if (sf.base.isNullOrUndefined(column) || column.allowGrouping === false
                || parentsUntil(gObj.getColumnHeaderByUid(column.uid), 'e-grid').getAttribute('id') !==
                    gObj.element.getAttribute('id')) {
                return;
            }
            gObj.dotNetRef.invokeMethodAsync("GroupColumn", column.field, 'Group');
        };
        this.parent = parent;
        if (this.parent.options.allowGrouping && this.parent.options.showDropArea) {
            this.initDragAndDrop();
        }
    }
    Group.prototype.columnDrag = function (e) {
        if (this.parent.options.groupReordering) {
            // this.animateDropper(e);
        }
        var gObj = this.parent;
        var cloneElement = this.parent.element.querySelector('.e-cloneproperties');
        sf.base.classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);
        sf.base.EventHandler.add(window, 'touchmove', this.preventTouchOnWindow);
        if (!parentsUntil(e.target, 'e-groupdroparea') &&
            !(this.parent.options.allowReordering && parentsUntil(e.target, 'e-headercell'))) {
            sf.base.classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);
        }
        e.target.classList.contains('e-groupdroparea') ?
            gObj.element.querySelector('.e-groupdroparea').classList.add('e-hover') :
            gObj.element.querySelector('.e-groupdroparea').classList.remove('e-hover');
    };
    Group.prototype.columnDragStart = function (e) {
        if (e.target.classList.contains('e-stackedheadercell')) {
            return;
        }
        var dropArea = this.parent.element.querySelector('.e-groupdroparea');
        if (dropArea) {
            dropArea.setAttribute("aria-dropeffect", "copy");
        }
        var element = e.target.classList.contains('e-headercell') ? e.target : parentsUntil(e.target, 'e-headercell');
        element.setAttribute("aria-grabbed", 'true');
    };
    Group.prototype.columnDrop = function (e) {
        var gObj = this.parent;
        if (e.droppedElement.getAttribute('action') === 'grouping') {
            var column = gObj.getColumnByUid(e.droppedElement.getAttribute('e-mappinguid'));
            if (sf.base.isNullOrUndefined(column) || column.allowGrouping === false
                || parentsUntil(gObj.getColumnHeaderByUid(column.uid), 'e-grid').getAttribute('id') !==
                    gObj.element.getAttribute('id')) {
                return;
            }
            gObj.dotNetRef.invokeMethodAsync("GroupColumn", column.field, 'Ungroup');
        }
    };
    // private keyPressHandler(e: KeyboardEventArgs): void {
    //     let gObj: SfGrid = this.parent;
    //     if (e.action !== 'ctrlSpace' && (!this.groupSettings.columns.length ||
    //         ['altDownArrow', 'altUpArrow', 'ctrlDownArrow', 'ctrlUpArrow', 'enter'].indexOf(e.action) === -1)) {
    //         return;
    //     }
    //     e.preventDefault();
    //     switch (e.action) {
    //         case 'altDownArrow':
    //         case 'altUpArrow':
    //             let selected: number[] = gObj.allowSelection ? gObj.getSelectedRowIndexes() : [];
    //             if (selected.length) {
    //                 let rows: HTMLCollection = gObj.getContentTable().querySelector('tbody').children;
    //                 let dataRow: HTMLTableRowElement = gObj.getDataRows()[selected[selected.length - 1]] as HTMLTableRowElement;
    //                 let grpRow: Element;
    //                 for (let i: number = dataRow.rowIndex; i >= 0; i--) {
    //                     if (!rows[i].classList.contains('e-row') && !rows[i].classList.contains('e-detailrow')) {
    //                         grpRow = rows[i];
    //                         break;
    //                     }
    //                 }
    //                 this.expandCollapseRows(grpRow.querySelector(e.action === 'altUpArrow' ?
    //                     '.e-recordplusexpand' : '.e-recordpluscollapse'));
    //             }
    //             break;
    //         case 'ctrlDownArrow':
    //             this.expandAll();
    //             break;
    //         case 'ctrlUpArrow':
    //             this.collapseAll();
    //             break;
    //         case 'enter':
    //             if (this.parent.isEdit || (closest(e.target as Element, '#' + this.parent.element.id + '_searchbar') !== null)) { return; }
    //             let element: HTMLElement = this.focus.getFocusedElement();
    //             let row: Element = element ? element.parentElement.querySelector('[class^="e-record"]') : null;
    //             if (!row) { break; }
    //             this.expandCollapseRows(row);
    //             break;
    //         case 'ctrlSpace':
    //             let elem: HTMLElement = gObj.focusModule.currentInfo.element;
    //             if (elem && elem.classList.contains('e-headercell')) {
    //                 let column: Column = gObj.getColumnByUid(elem.firstElementChild.getAttribute('e-mappinguid'));
    //                 column.field && gObj.groupSettings.columns.indexOf(column.field) < 0 ?
    //                     this.groupColumn(column.field) : this.ungroupColumn(column.field);
    //             }
    //             break;
    //     }
    // }
    Group.prototype.initDragAndDrop = function () {
        this.initializeGHeaderDrop();
        this.initializeGHeaderDrag();
    };
    Group.prototype.initializeGHeaderDrag = function () {
        var ele = this.parent.element.querySelector('.e-groupdroparea');
        if (!ele) {
            return;
        }
        var drag = new sf.base.Draggable(ele, {
            dragTarget: this.parent.options.groupReordering ? '.e-drag' : '.e-groupheadercell',
            distance: this.parent.options.groupReordering ? -10 : 5,
            helper: this.helper,
            dragStart: this.dragStart,
            drag: this.drag,
            dragStop: this.dragStop,
            isPreventSelect: false
        });
    };
    Group.prototype.initializeGHeaderDrop = function () {
        var gObj = this.parent;
        var ele = this.parent.element.querySelector('.e-groupdroparea');
        if (!ele) {
            return;
        }
        var drop = new sf.base.Droppable(ele, {
            accept: '.e-dragclone',
            drop: this.drop
        });
    };
    /**
     * For internal use only - Get the module name.
     * @private
     */
    Group.prototype.getModuleName = function () {
        return 'group';
    };
    Group.prototype.getGHeaderCell = function (field) {
        if (this.element && this.element.querySelector('[ej-mappingname="' + field + '"]')) {
            return this.element.querySelector('[ej-mappingname="' + field + '"]').parentElement;
        }
        return null;
    };
    return Group;
}());

/**
 * The `ColumnChooser` module is used to show or hide columns dynamically.
 */
var ColumnChooser = /** @class */ (function () {
    function ColumnChooser(parent) {
        this.mediaCol = [];
        this.media = {};
        this.mediaBindInstance = {};
        this.mediaColVisibility = {};
        this.noOfTimesInvokedByMedia = 0;
        this.mediaChange = true;
        this.mediaColumnList = [];
        this.parent = parent;
    }
    /**
     * Get columnChooser Position.
     * @return {void}
     * @hidden
     */
    ColumnChooser.prototype.renderColumnChooser = function () {
        var dlgelement = this.parent.element.querySelector("#" + this.parent.element.id + "_ccdlg");
        dlgelement.style.maxHeight = '430px';
        var elementVisible = dlgelement.style.display;
        dlgelement.style.display = 'block';
        var newpos = sf.popups.calculateRelativeBasedPosition(this.parent.element.querySelector(".e-cc-toolbar"), dlgelement);
        dlgelement.style.display = elementVisible;
        var top = newpos.top + this.parent.element.querySelector(".e-cc-toolbar").getBoundingClientRect().height;
        var dlgWidth = 250;
        var left;
        if (this.parent.options.enableRtl) {
            left = this.parent.element.querySelector(".e-columnchooser-btn").offsetLeft;
        }
        else {
            left = ((newpos.left - dlgWidth) + this.parent.element.querySelector(".e-cc-toolbar").clientWidth) + 2;
        }
        this.parent.dotNetRef.invokeMethodAsync("GetChooserPosition", left.toString(), top.toString());
    };
    ColumnChooser.prototype.setMediaColumns = function () {
        var gcol = this.parent.getColumns();
        if (!sf.base.isNullOrUndefined(gcol)) {
            for (var index = 0; index < gcol.length; index++) {
                if (gcol[index].hideAtMedia !== '' && (sf.base.isNullOrUndefined(gcol[index].visible) || gcol[index].visible)) {
                    this.pushMediaColumn(gcol[index], index);
                }
            }
            this.parent.dotNetRef.invokeMethodAsync('SetMediaColumnVisibility', {
                mediaColVisibility: this.mediaColVisibility
            });
            this.mediaColVisibility = {};
        }
    };
    ColumnChooser.prototype.pushMediaColumn = function (col, index) {
        this.mediaCol.push(col);
        this.media[col.uid] = window.matchMedia(col.hideAtMedia);
        this.mediaQueryUpdate(index, this.media[col.uid], true);
        this.mediaBindInstance[index] = this.mediaQueryUpdate.bind(this, index);
        this.media[col.uid].addListener(this.mediaBindInstance[index]);
    };
    ColumnChooser.prototype.mediaQueryUpdate = function (columnIndex, e, invokedManually) {
        var col = this.parent.getColumns()[columnIndex];
        var columnList = this.parent.getColumns();
        if (this.mediaCol.some(function (mediaColumn) { return mediaColumn.uid === col.uid; })) {
            this.mediaColVisibility[col.uid] = e.matches;
            if (!invokedManually) {
                this.noOfTimesInvokedByMedia++;
                this.mediaChange = this.mediaColumnList.length === 0 ? true : false;
                if (this.mediaChange) {
                    for (var i = 0; i < columnList.length; i++) {
                        if (columnList[i].hideAtMedia.split(" ").slice(-1).toLocaleString() === e.media.split(" ").slice(-1).toLocaleString()) {
                            this.mediaColumnList.push(columnList[i]);
                        }
                    }
                }
                //TODO: This fix might could not work for complex HideMedia queries.
                // we have to handle this by using Resize EventHandler Debounce.
                if ((this.mediaColumnList.length > 0 && this.noOfTimesInvokedByMedia === this.mediaColumnList.length)
                    || (this.mediaCol.length > 0 && this.mediaColumnList.length === 0)) {
                    this.parent.dotNetRef.invokeMethodAsync('SetMediaColumnVisibility', {
                        mediaColVisibility: this.mediaColVisibility,
                        invokedByMedia: true
                    });
                    this.noOfTimesInvokedByMedia = 0;
                    this.mediaColVisibility = {};
                    this.mediaColumnList = [];
                }
            }
        }
    };
    ColumnChooser.prototype.updateMediaColumns = function (mediaColumnsUid) {
        var keys = Object.keys(mediaColumnsUid);
        var _loop_1 = function (i) {
            var idxToSplice = -1;
            if (this_1.mediaCol.some(function (mCol) {
                idxToSplice++;
                return mCol.uid === keys[i];
            })) {
                this_1.mediaCol.splice(idxToSplice, 1);
            }
            else {
                this_1.pushMediaColumn(this_1.parent.getColumnByUid(keys[i]), this_1.parent.getColumnIndexByUid(keys[i]));
            }
        };
        var this_1 = this;
        for (var i = 0; i < keys.length; i++) {
            _loop_1(i);
        }
    };
    ColumnChooser.prototype.removeMediaListener = function () {
        for (var i = 0; i < this.mediaCol.length; i++) {
            this.media[this.mediaCol[i].uid].removeListener(this.mediaBindInstance[this.mediaCol[i].index]);
        }
    };
    return ColumnChooser;
}());

/**
 * The `ColumnMenu` module is used to show or hide columns dynamically.
 */
var ColumnMenu = /** @class */ (function () {
    function ColumnMenu(parent) {
        this.key = null;
        this.uid = null;
        this.parent = parent;
    }
    /**
     * Get columnMenu Position.
     * @return {void}
     * @hidden
     */
    ColumnMenu.prototype.renderColumnMenu = function (uid, isFilter, key) {
        this.key = key;
        this.uid = uid;
        var e = this.parent.getColumnHeaderByUid(uid).querySelector('.e-columnmenu');
        var columnMenuElement = document.getElementsByClassName("e-" + this.parent.element.id + "-column-menu")[0];
        columnMenuElement.style.position = 'absolute';
        var element = columnMenuElement.getElementsByTagName('ul')[0];
        if (!sf.base.isNullOrUndefined(element)) {
            var pos = { top: 0, left: 0 };
            element.style.visibility = 'hidden';
            columnMenuElement.style.display = 'block';
            var elePos = element.getBoundingClientRect();
            element.classList.add('e-transparent');
            element.style.visibility = '';
            columnMenuElement.style.display = '';
            var headerCell = this.getHeaderCell(e);
            if (sf.base.Browser.isDevice) {
                pos.top = ((window.innerHeight / 2) - (elePos.height / 2));
                pos.left = ((window.innerWidth / 2) - (elePos.width / 2));
            }
            else {
                if (this.parent.options.enableRtl) {
                    pos = sf.popups.calculatePosition(headerCell, 'left', 'bottom');
                }
                else {
                    pos = sf.popups.calculatePosition(headerCell, 'right', 'bottom');
                    pos.left -= elePos.width;
                }
            }
            if (isFilter) {
                sf.base.EventHandler.add(element, 'mouseover', this.appendFilter, this);
            }
            return { Left: Math.sign(pos.left) !== -1 ? Math.ceil(pos.left) : 0, Top: Math.ceil(pos.top) };
        }
        else {
            return { Left: 1, Top: 1 };
        }
    };
    
    ColumnMenu.prototype.setPosition = function () {
        var columnMenuElement = document.getElementsByClassName("e-" + this.parent.element.id + "-column-menu")[0];
        var element = !sf.base.isNullOrUndefined(columnMenuElement) ? columnMenuElement.getElementsByTagName('ul')[0] : null;
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(this.uid)) {
            var e = this.parent.getColumnHeaderByUid(this.uid).querySelector('.e-columnmenu');
            var headerCell = this.getHeaderCell(e);
            var btnOffset = headerCell.getBoundingClientRect();
            var left = btnOffset.left + pageXOffset;
            var top_1 = btnOffset.bottom + pageYOffset;
            var popupOffset = element.getBoundingClientRect();
            var docElement = document.documentElement;
            if (btnOffset.bottom + popupOffset.height > docElement.clientHeight) {
                if (top_1 - btnOffset.height - popupOffset.height > docElement.clientTop) {
                    top_1 = top_1 - btnOffset.height - popupOffset.height;
                }
            }
            if (btnOffset.left + popupOffset.width > docElement.clientWidth) {
                if (btnOffset.right - popupOffset.width > docElement.clientLeft) {
                    left = (left + btnOffset.width) - popupOffset.width;
                }
            }
            left = left - element.getBoundingClientRect().width + btnOffset.width;
            columnMenuElement.style.left = Math.ceil(left + 1) + 'px';
            columnMenuElement.style.top = Math.ceil(top_1 + 1) + 'px';
        }
    };
    ColumnMenu.prototype.appendFilter = function (e) {
        var _this = this;
        var showdialog = false;
        setTimeout(function () {
            if ((sf.base.closest(e.target, '#' + _this.key)) && (_this.parent.element.querySelector('.e-filter-popup') || !_this.parent.element.querySelector('.e-filter-popup'))
                || e.target.parentElement.id == _this.key && (_this.parent.element.querySelector('.e-filter-popup') || !_this.parent.element.querySelector('.e-filter-popup'))) {
                showdialog = true;
            }
            else if (!sf.base.closest(e.target, '#' + _this.key) && _this.parent.element.querySelector('.e-filter-popup')) {
                showdialog = false;
            }
            _this.parent.dotNetRef.invokeMethodAsync("FilterMouseOverHandler", _this.uid, showdialog);
        }, 10);
    };
    ColumnMenu.prototype.getHeaderCell = function (e) {
        return sf.base.closest(e, 'th.e-headercell');
    };
    return ColumnMenu;
}());

/**
 * The `Filter` module is used to set the Filter Dialog position dynamically.
 */
var Filter = /** @class */ (function () {
    function Filter(parent) {
        this.parent = parent;
    }
    /**
     * Get Filter Popup Position.
     * @return {void}
     * @hidden
     */
    Filter.prototype.filterPopupRender = function (dlgID, ColUid, type, isColumnMenu) {
        var dlgelement = this.parent.element.querySelector("#" + dlgID);
        if (!sf.base.isNullOrUndefined(dlgelement)) {
            if (isColumnMenu) {
                sf.base.EventHandler.add(dlgelement, 'mousedown', this.mouseDownHandler, this);
                dlgelement.style.maxHeight = type == 'excel' ? '800px' : '350px';
                var element = document.getElementsByClassName("e-" + this.parent.element.id + "-column-menu")[0].getElementsByTagName('ul')[0];
                var li = element.querySelector('.' + 'e-icon-filter').parentElement;
                var ul = this.parent.element.querySelector('.' + 'e-filter-popup');
                var gridPos = this.parent.element.getBoundingClientRect();
                var liPos = li.getBoundingClientRect();
                var left = liPos.left - gridPos.left;
                var top_1 = liPos.top - gridPos.top;
                var elementVisible = dlgelement.style.display;
                dlgelement.style.display = 'block';
                if (gridPos.height < top_1) {
                    top_1 = top_1 - ul.offsetHeight + liPos.height;
                }
                else if (gridPos.height < top_1 + ul.offsetHeight) {
                    top_1 = gridPos.height - ul.offsetHeight;
                }
                if (window.innerHeight < ul.offsetHeight + top_1 + gridPos.top) {
                    top_1 = window.innerHeight - ul.offsetHeight - gridPos.top;
                }
                left += (this.parent.options.enableRtl ? -ul.offsetWidth : liPos.width);
                if (gridPos.width <= left + ul.offsetWidth) {
                    left -= liPos.width + ul.offsetWidth;
                }
                else if (left < 0) {
                    left += ul.offsetWidth + liPos.width;
                }
                dlgelement.style.display = elementVisible;
                this.parent.dotNetRef.invokeMethodAsync("GetFilterIconPosition", left.toString(), top_1.toString());
            }
            else {
                var FilterElement = [].slice.call(this.parent.element.querySelector('.e-headercontent').querySelectorAll('div[e-mappinguid=' + ColUid + ']'));
                var targetElement = FilterElement[1];
                dlgelement.style.maxHeight = type == 'excel' ? '800px' : '350px';
                var elementVisible = dlgelement.style.display;
                dlgelement.style.display = 'block';
                var newpos = sf.popups.calculateRelativeBasedPosition(targetElement, dlgelement);
                dlgelement.style.display = elementVisible;
                var dlgWidth = 250;
                var left = newpos.left - dlgWidth + targetElement.clientWidth;
                var top_2 = newpos.top + targetElement.getBoundingClientRect().height - 5;
                if (left < 1)
                    left = dlgWidth + left - 16;
                else
                    left = left - 4;
                var parentElementOffsetWidth = this.parent.element.offsetWidth;
                if ((parentElementOffsetWidth - left) < dlgWidth) {
                    var actualWidthAllocated = parentElementOffsetWidth - left;
                    var requiredWidth = dlgWidth - actualWidthAllocated;
                    left = left - requiredWidth;
                }
                this.parent.dotNetRef.invokeMethodAsync("GetFilterIconPosition", left.toString(), top_2.toString());
            }
        }
    };
    Filter.prototype.mouseDownHandler = function (args) {
        if ((args && sf.base.closest(args.target, '.e-filter-popup')
            || (args.currentTarget && args.currentTarget.activeElement &&
                parentsUntil(args.currentTarget.activeElement, 'e-filter-popup'))
            || parentsUntil(args.target, 'e-popup') ||
            (parentsUntil(args.target, 'e-popup-wrapper'))) && !sf.base.Browser.isDevice) {
            this.parent.dotNetRef.invokeMethodAsync("PreventColumnMenuClose", true);
        }
    };
    return Filter;
}());

/**
 * Editing
 */
var Edit = /** @class */ (function () {
    function Edit(parent) {
        this.parent = parent;
    }
    Edit.prototype.createTooltip = function (results, isAdd) {
        var toolTipPos = {};
        var arrowPosition;
        for (var i = 0; i < results.length; i++) {
            var gcontent = this.parent.getContent();
            if (this.parent.options.frozenColumns) {
                gcontent = this.parent.getContent().querySelector('.e-movablecontent');
            }
            var name_1 = results[i]['fieldName'];
            var message = results[i]['message'];
            name_1 = name_1.replace(/[.]/g, "___");
            var element = this.parent.element.querySelector("#" + name_1) ||
                document.querySelector("#" + name_1);
            var isScroll = gcontent.scrollHeight > gcontent.clientHeight || gcontent.scrollWidth > gcontent.clientWidth;
            var isInline = this.parent.options.editMode !== 'Dialog';
            if (!element) {
                return;
            }
            var td = sf.base.closest(element, '.e-rowcell');
            var row = sf.base.closest(element, '.e-row');
            var fCont = this.parent.getContent().querySelector('.e-frozencontent');
            var isFHdr = void 0;
            var isFHdrLastRow = false;
            var validationForBottomRowPos = void 0;
            var isBatchModeLastRow = false;
            var viewPortRowCount = Math.round(this.parent.getContent().clientHeight / this.parent.getRowHeight()) - 1;
            var rows = [].slice.call(this.parent.getContent().querySelectorAll('.e-row'));
            if (this.parent.options.editMode === 'Batch') {
                if (viewPortRowCount > 1 && rows.length >= viewPortRowCount
                    && rows[rows.length - 1].getAttribute('aria-rowindex') === row.getAttribute('aria-rowindex')) {
                    isBatchModeLastRow = true;
                }
            }
            if (isInline) {
                if (this.parent.options.frozenRows) {
                    // TODO: FrozenRows
                    // let fHeraderRows: HTMLCollection = this.parent.getFrozenColumns() ?
                    //     this.parent.getFrozenVirtualHeader().querySelector('tbody').children
                    //     : this.parent.getHeaderTable().querySelector('tbody').children;
                    // isFHdr = fHeraderRows.length > (parseInt(row.getAttribute('aria-rowindex'), 10) || 0);
                    // isFHdrLastRow = isFHdr && parseInt(row.getAttribute('aria-rowindex'), 10) === fHeraderRows.length - 1;
                }
                if (isFHdrLastRow || (viewPortRowCount > 1 && rows.length >= viewPortRowCount &&
                    (this.parent.options.newRowPosition === 'Bottom' && isAdd || (!sf.base.isNullOrUndefined(td)
                        && td.classList.contains('e-lastrowcell') && !row.classList.contains('e-addedrow')))) || isBatchModeLastRow) {
                    validationForBottomRowPos = true;
                }
            }
            var table = isInline ?
                (isFHdr ? this.parent.getHeaderTable() : this.parent.getContentTable()) :
                document.querySelector('#' + this.parent.element.id + '_dialogEdit_wrapper').querySelector('.e-dlg-content');
            var client = table.getBoundingClientRect();
            var left = isInline ?
                this.parent.element.getBoundingClientRect().left : client.left;
            var input = sf.base.closest(element, 'td');
            var inputClient = input ? input.getBoundingClientRect() : element.parentElement.getBoundingClientRect();
            var div = this.parent.element.querySelector("#" + name_1 + "_Error") ||
                document.querySelector("#" + name_1 + "_Error");
            div.style.top =
                ((isFHdr ? inputClient.top + inputClient.height : inputClient.bottom - client.top
                    - (this.parent.options.frozenColumns ? fCont.scrollTop : 0)) + table.scrollTop + 9) + 'px';
            div.style.left =
                (inputClient.left - left + table.scrollLeft + inputClient.width / 2) + 'px';
            div.style.maxWidth = inputClient.width - 4 + 'px';
            if (isInline && client.left < left) {
                div.style.left = parseInt(div.style.left, 10) - client.left + left + 'px';
            }
            var arrow = void 0;
            if (validationForBottomRowPos) {
                arrow = div.querySelector('.e-tip-bottom');
            }
            else {
                arrow = div.querySelector('.e-tip-top');
            }
            if ((this.parent.options.frozenColumns || this.parent.options.frozenRows) && this.parent.options.editMode !== 'Dialog') {
                var getEditCell = this.parent.options.editMode === 'Normal' ?
                    sf.base.closest(element, '.e-editcell') : sf.base.closest(element, '.e-table');
                getEditCell.style.position = 'relative';
                div.style.position = 'absolute';
            }
            div.style.display = "block";
            div.querySelector(".e-error").innerText = message;
            if (!validationForBottomRowPos && isInline && gcontent.getBoundingClientRect().bottom < inputClient.bottom + inputClient.height) {
                gcontent.scrollTop = gcontent.scrollTop + div.offsetHeight + arrow.scrollHeight;
            }
            var lineHeight = parseInt(document.defaultView.getComputedStyle(div, null).getPropertyValue('font-size'), 10);
            if (div.getBoundingClientRect().width < inputClient.width &&
                div.querySelector('label').getBoundingClientRect().height / (lineHeight * 1.2) >= 2) {
                div.style.width = div.style.maxWidth;
            }
            if ((this.parent.options.frozenColumns || this.parent.options.frozenRows)
                && (this.parent.options.editMode === 'Normal' || this.parent.options.editMode === 'Batch')) {
                div.style.left = input.offsetLeft + (input.offsetWidth / 2 - div.offsetWidth / 2) + 'px';
            }
            else {
                div.style.left = (parseInt(div.style.left, 10) - div.offsetWidth / 2) + 'px';
            }
            if (isInline && !isScroll && !this.parent.options.allowPaging || this.parent.options.frozenColumns
                || this.parent.options.frozenRows) {
                gcontent.style.position = 'static';
                var pos = sf.popups.calculateRelativeBasedPosition(input, div);
                div.style.top = pos.top + inputClient.height + 9 + 'px';
            }
            if (validationForBottomRowPos) {
                if (isScroll && !this.parent.options.frozenColumns && this.parent.options.height !== 'auto' && !this.parent.options.frozenRows
                //&& !this.parent.enableVirtualization
                ) {
                    var scrollWidth = gcontent.scrollWidth > gcontent.offsetWidth ? getScrollBarWidth() : 0;
                    div.style.bottom = (parseInt(this.parent.options.height) - gcontent.querySelector('table').offsetHeight
                        - scrollWidth) + inputClient.height + 9 + 'px';
                }
                else {
                    div.style.bottom = inputClient.height + 9 + 'px';
                }
                //TODO: NEW LINES ADDED SHOULD CHECK
                // if (rows.length < viewPortRowCount && this.parent.editSettings.newRowPosition === 'Bottom' && (this.editModule.args
                //     && this.editModule.args.requestType === 'add')) {
                //     let rowsCount: number = this.parent.frozenRows ? this.parent.frozenRows + (rows.length - 1) : rows.length - 1;
                //     let rowsHeight: number = rowsCount * this.parent.getRowHeight();
                //     let position: number = this.parent.getContent().clientHeight - rowsHeight;
                //     div.style.bottom = position + 9 + 'px';
                // }
                div.style.top = null;
            }
            // div.style.display = 'none';
            arrowPosition = validationForBottomRowPos ? 'bottom' : 'top';
            toolTipPos[name_1] = "top: " + div.style.top + "; bottom: " + div.style.bottom + "; left: " + div.style.left + "; \n            max-width: " + div.style.maxWidth + "; width: " + div.style.width + "; text-align: center; position: " + div.style.position + ";";
        }
        this.parent.dotNetRef.invokeMethodAsync("ShowValidationPopup", toolTipPos, arrowPosition);
    };
    return Edit;
}());

/**
 * The `Clipboard` module is used to handle clipboard copy action.
 */
var Clipboard = /** @class */ (function () {
    function Clipboard(parent) {
        this.copyContent = '';
        this.isSelect = false;
        this.parent = parent;
        this.clipBoardTextArea = sf.base.createElement('textarea', {
            className: 'e-clipboard',
            styles: 'opacity: 0',
            attrs: { tabindex: '-1', 'aria-label': 'clipboard', 'aria-hidden': 'true' }
        });
        this.parent.element.appendChild(this.clipBoardTextArea);
    }
    Clipboard.prototype.pasteHandler = function () {
        var _this = this;
        var grid = this.parent;
        var target = sf.base.closest(document.activeElement, '.e-rowcell');
        if (!target || !grid.options.allowEditing || grid.options.editMode !== 'Batch' ||
            grid.options.selectionMode !== 'Cell' || grid.options.cellSelectionMode === 'Flow') {
            return;
        }
        this.activeElement = document.activeElement;
        this.clipBoardTextArea.value = '';
        var x = window.scrollX;
        var y = window.scrollY;
        this.clipBoardTextArea.focus();
        setTimeout(function () {
            _this.activeElement.focus();
            window.scrollTo(x, y);
            _this.paste(_this.clipBoardTextArea.value, _this.getSelectedRowCellIndexes()[0].rowIndex, _this.getSelectedRowCellIndexes()[0].cellIndexes[0]);
        }, 10);
    };
    Clipboard.prototype.paste = function (data, rowIndex, colIndex) {
        var grid = this.parent;
        var cIdx = colIndex;
        var rIdx = rowIndex;
        var col;
        var value;
        var isAvail;
        if (!grid.options.allowEditing || grid.options.editMode !== 'Batch' ||
            grid.options.selectionMode !== 'Cell' || grid.options.cellSelectionMode === 'Flow') {
            return;
        }
        var rows = data.split('\n');
        var cols;
        var dataRows = grid.getDataRows();
        var mRows;
        var isFrozen = this.parent.options.frozenColumns;
        if (isFrozen) {
            mRows = grid.getMovableDataRows();
        }
        for (var r = 0; r < rows.length; r++) {
            cols = rows[r].split('\t');
            cIdx = colIndex;
            if ((r === rows.length - 1 && rows[r] === '') || sf.base.isUndefined(grid.getRowByIndex(rIdx))) {
                cIdx++;
                break;
            }
            for (var c = 0; c < cols.length; c++) {
                isAvail = grid.getCellFromIndex(rIdx, cIdx);
                if (isFrozen) {
                    var fTr = dataRows[rIdx];
                    var mTr = mRows[rIdx];
                    isAvail = !fTr.querySelector('[aria-colindex="' + cIdx + '"]') ?
                        mTr.querySelector('[aria-colindex="' + cIdx + '"]') : true;
                }
                if (!isAvail) {
                    cIdx++;
                    break;
                }
                col = grid.getColumnByIndex(cIdx);
                value = cols[c];
                if (col.allowEditing && !col.isPrimaryKey && !col.template) {
                    // let args: BeforePasteEventArgs = {
                    //     column: col,
                    //     data: value,
                    //     rowIndex: rIdx
                    // };
                    // this.parent.trigger(events.beforePaste, args);
                    //rIdx = args.rowIndex;
                    //if (!args.cancel) {
                    if (grid.editModule) {
                        {
                            grid.dotNetRef.invokeMethodAsync("UpdateCell", rIdx, col.field, value);
                        }
                    }
                    //}
                }
                cIdx++;
            }
            rIdx++;
        }
        //grid.selectionModule.selectCellsByRange(
        //  { rowIndex: rowIndex, cellIndex: colIndex }, { rowIndex: rIdx - 1, cellIndex: cIdx - 1 });
        var cell = this.parent.getCellFromIndex(rIdx - 1, cIdx - 1);
        if (cell) {
            sf.base.classList(cell, ['e-focus', 'e-focused'], []);
        }
    };
    Clipboard.prototype.setCopyData = function (withHeader) {
        if (window.getSelection().toString() === '') {
            var isFrozen = this.parent.options.frozenColumns;
            this.clipBoardTextArea.value = this.copyContent = '';
            var mRows = void 0;
            var rows = this.parent.getRows();
            if (isFrozen) {
                mRows = this.parent.getMovableDataRows();
            }
            if (this.parent.options.selectionMode !== 'Cell') {
                //let selectedIndexes: Object[] = this.parent.getSelectedRowIndexes().sort((a: number, b: number) => { return a - b; });
                var selectedIndexes = this.parent.getSelectedRowIndexes();
                if (withHeader) {
                    var headerTextArray = [];
                    for (var i = 0; i < this.parent.getVisibleColumns().length; i++) {
                        headerTextArray[i] = this.parent.getVisibleColumns()[i].headerText;
                    }
                    this.getCopyData(headerTextArray, false, '\t', withHeader);
                    this.copyContent += '\n';
                }
                for (var i = 0; i < selectedIndexes.length; i++) {
                    if (i > 0) {
                        this.copyContent += '\n';
                    }
                    var cells = [].slice.call(rows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)'));
                    if (isFrozen) {
                        cells.push.apply(cells, [].slice.call(mRows[selectedIndexes[i]].querySelectorAll('.e-rowcell:not(.e-hide)')));
                    }
                    this.getCopyData(cells, false, '\t', withHeader);
                }
            }
            else {
                var obj = this.checkBoxSelection();
                if (obj.status) {
                    if (withHeader) {
                        var headers = [];
                        for (var i = 0; i < obj.colIndexes.length; i++) {
                            headers.push(this.parent.getColumnHeaderByIndex(obj.colIndexes[i]));
                        }
                        this.getCopyData(headers, false, '\t', withHeader);
                        this.copyContent += '\n';
                    }
                    for (var i = 0; i < obj.rowIndexes.length; i++) {
                        if (i > 0) {
                            this.copyContent += '\n';
                        }
                        var cells = [].slice.call(rows[obj.rowIndexes[i]].
                            querySelectorAll('.e-cellselectionbackground'));
                        if (isFrozen) {
                            cells.push.apply(cells, [].slice.call(mRows[obj.rowIndexes[i]].querySelectorAll('.e-cellselectionbackground')));
                        }
                        this.getCopyData(cells, false, '\t', withHeader);
                    }
                }
                else {
                    this.getCopyData([].slice.call(this.parent.element.querySelectorAll('.e-cellselectionbackground')), true, '\n', withHeader);
                }
            }
            // let args: BeforeCopyEventArgs = {
            //     data: this.copyContent,
            //     cancel: false,
            // };
            // this.parent.trigger(events.beforeCopy, args);
            // if (args.cancel) {
            //     return;
            // }
            this.clipBoardTextArea.value = this.copyContent;
            if (!sf.base.Browser.userAgent.match(/ipad|ipod|iphone/i)) {
                this.clipBoardTextArea.select();
            }
            else {
                this.clipBoardTextArea.setSelectionRange(0, this.clipBoardTextArea.value.length);
            }
            this.isSelect = true;
        }
    };
    Clipboard.prototype.getCopyData = function (cells, isCell, splitKey, withHeader) {
        var isElement = typeof cells[0] !== 'string';
        for (var j = 0; j < cells.length; j++) {
            if (withHeader && isCell) {
                this.copyContent += this.parent.getColumns()[parseInt(cells[j].getAttribute('aria-colindex'), 10)].headerText + '\n';
            }
            if (isElement) {
                if (!cells[j].classList.contains('e-hide')) {
                    if ((!cells[j].classList.contains('e-gridchkbox')) &&
                        Object.keys(cells[j].querySelectorAll('.e-check')).length) {
                        this.copyContent += true;
                    }
                    else if ((!cells[j].classList.contains('e-gridchkbox')) &&
                        Object.keys(cells[j].querySelectorAll('.e-uncheck')).length) {
                        this.copyContent += false;
                    }
                    else {
                        this.copyContent += cells[j].innerText;
                    }
                }
            }
            else {
                this.copyContent += cells[j];
            }
            if (j < cells.length - 1) {
                this.copyContent += splitKey;
            }
        }
    };
    Clipboard.prototype.copy = function (withHeader) {
        if (document.queryCommandSupported('copy')) {
            var clipboardFocus = document.activeElement;
            this.setCopyData(withHeader);
            document.execCommand('copy');
            this.clipBoardTextArea.blur();
            clipboardFocus.focus();
        }
        if (this.isSelect) {
            window.getSelection().removeAllRanges();
            this.isSelect = false;
        }
    };
    Clipboard.prototype.getSelectedRowCellIndexes = function () {
        var gridObj = this.parent;
        var rowCellIndxes = [];
        var rows = gridObj.getRows();
        var mrows;
        if (gridObj.options.frozenColumns) {
            mrows = gridObj.getMovableDataRows();
        }
        var _loop_1 = function (i) {
            var tempCells = rows[i].querySelectorAll('.e-cellselectionbackground');
            if (gridObj.options.frozenColumns && !tempCells.length) {
                tempCells = mrows[i].querySelectorAll('.e-cellselectionbackground');
            }
            if (tempCells.length) {
                var cellIndexes_1 = [];
                tempCells.forEach(function (element) {
                    cellIndexes_1.push(parseInt(element.getAttribute('aria-colindex')));
                });
                rowCellIndxes.push({ rowIndex: i, cellIndexes: cellIndexes_1 });
            }
        };
        for (var i = 0; i < rows.length; i++) {
            _loop_1(i);
        }
        return rowCellIndxes;
    };
    Clipboard.prototype.checkBoxSelection = function () {
        var gridObj = this.parent;
        var rowCellIndxes;
        var obj = { status: false };
        if (gridObj.options.selectionMode === 'Cell') {
            rowCellIndxes = this.getSelectedRowCellIndexes();
            var str = void 0;
            var rowIndexes = [];
            var i = void 0;
            for (i = 0; i < rowCellIndxes.length; i++) {
                if (rowCellIndxes[i].cellIndexes.length) {
                    rowIndexes.push(rowCellIndxes[i].rowIndex);
                }
                if (rowCellIndxes[i].cellIndexes.length) {
                    if (!str) {
                        str = JSON.stringify(rowCellIndxes[i].cellIndexes.sort());
                    }
                    if (str !== JSON.stringify(rowCellIndxes[i].cellIndexes.sort())) {
                        break;
                    }
                }
            }
            rowIndexes.sort(function (a, b) { return a - b; });
            if (i === rowCellIndxes.length && rowIndexes[rowIndexes.length - 1] - rowIndexes[0] === rowIndexes.length - 1) {
                obj = { status: true, rowIndexes: rowIndexes, colIndexes: rowCellIndxes[0].cellIndexes };
            }
        }
        return obj;
    };
    return Clipboard;
}());

var CustomToolTip = /** @class */ (function () {
    function CustomToolTip(parent) {
        this.parent = parent;
        this.wireEvents();
    }
    CustomToolTip.prototype.wireEvents = function () {
        sf.base.EventHandler.add(this.parent.getContent(), 'scroll', this.scrollHandler, this);
        sf.base.EventHandler.add(this.parent.element, 'mousemove', this.mouseMoveHandler, this);
        sf.base.EventHandler.add(this.parent.element, 'mouseout', this.mouseMoveHandler, this);
        sf.base.EventHandler.add(this.parent.element, 'keydown', this.onKeyPressed, this);
    };
    CustomToolTip.prototype.unWireevents = function () {
        sf.base.EventHandler.remove(this.parent.getContent(), 'scroll', this.scrollHandler);
        sf.base.EventHandler.remove(this.parent.element, 'mousemove', this.mouseMoveHandler);
        sf.base.EventHandler.remove(this.parent.element, 'mouseout', this.mouseMoveHandler);
        sf.base.EventHandler.remove(this.parent.element, 'keydown', this.onKeyPressed);
    };
    CustomToolTip.prototype.open = function (target) {
        this.close();
        this.ctrlId = sf.base.getUniqueID(this.parent.element.getAttribute('id'));
        if (sf.base.isNullOrUndefined(this.toolTipElement)) {
            this.toolTipElement = sf.base.createElement('div', {
                className: "e-tooltip-wrap e-popup e-lib e-control e-popup-open",
                styles: 'width: "auto", height: "auto", position: "absolute"',
                attrs: { role: "tooltip", 'aria-hidden': 'false', 'id': this.ctrlId + '_content' }
            });
        }
        sf.base.attributes(target, { 'aria-describedby': this.ctrlId + "_content", 'data-tooltip-id': this.ctrlId + "_content" });
        this.renderToolTip();
        this.setPosition(target);
    };
    CustomToolTip.prototype.renderToolTip = function () {
        var content = sf.base.createElement('div', { className: "e-tip-content" });
        content.innerHTML = this.content;
        this.toolTipElement.appendChild(content);
        var arrow = sf.base.createElement('div', { className: "e-arrow-tip e-tip-bottom", styles: 'top: 99.9%' });
        arrow.appendChild(sf.base.createElement('div', { className: "e-arrow-tip-outer e-tip-bottom" }));
        arrow.appendChild(sf.base.createElement('div', { className: "e-arrow-tip-inner e-tip-bottom", styles: 'top: -6px' }));
        this.toolTipElement.appendChild(arrow);
        document.body.appendChild(this.toolTipElement);
    };
    CustomToolTip.prototype.setPosition = function (target) {
        var tooltipPostion = { top: 0, left: 0 };
        var arrow = this.toolTipElement.querySelector('.e-arrow-tip');
        var popUpPosition = sf.popups.calculatePosition(target, 'Center', 'Top');
        tooltipPostion.top -= this.toolTipElement.offsetHeight + arrow.offsetHeight;
        tooltipPostion.left -= this.toolTipElement.offsetWidth / 2;
        this.toolTipElement.style.top = popUpPosition.top + tooltipPostion.top + 'px';
        this.toolTipElement.style.left = popUpPosition.left + tooltipPostion.left + 'px';
    };
    CustomToolTip.prototype.close = function () {
        if (this.toolTipElement) {
            var prevTarget = this.parent.element.querySelector("[aria-describedby=\"" + this.ctrlId + '_content' + "\"]");
            if (!sf.base.isNullOrUndefined(prevTarget)) {
                prevTarget.removeAttribute('aria-describedby');
                prevTarget.removeAttribute('data-tooltip-id');
                document.getElementById(this.ctrlId + '_content').remove();
                this.toolTipElement = null;
            }
            else if (!sf.base.isNullOrUndefined(this.parent.element.querySelector("form"))) {
                document.getElementById(this.ctrlId + '_content').remove();
                this.toolTipElement = null;
            }
        }
    };
    CustomToolTip.prototype.getTooltipStatus = function (element) {
        var width;
        var headerTable = this.parent.getHeaderTable();
        var contentTable = this.parent.getContentTable();
        var headerDivTag = 'e-gridheader';
        var contentDivTag = 'e-gridcontent';
        var htable = this.createTable(headerTable, headerDivTag, 'header');
        var ctable = this.createTable(contentTable, contentDivTag, 'content');
        var table = element.classList.contains('e-headercell') ? htable : ctable;
        var ele = element.classList.contains('e-headercell') ? 'th' : 'tr';
        table.querySelector(ele).className = element.className;
        table.querySelector(ele).innerHTML = element.innerHTML;
        width = table.querySelector(ele).getBoundingClientRect().width;
        document.body.removeChild(htable);
        document.body.removeChild(ctable);
        if (width > element.getBoundingClientRect().width) {
            return true;
        }
        return false;
    };
    CustomToolTip.prototype.mouseMoveHandler = function (e) {
        if (this.isEllipsisTooltip()) {
            var element = parentsUntil(e.target, 'e-ellipsistooltip');
            if (this.prevElement !== element || e.type === 'mouseout') {
                this.close();
            }
            var tagName = e.target.tagName;
            var elemNames = ['A', 'BUTTON', 'INPUT'];
            if (element && e.type !== 'mouseout' && !(sf.base.Browser.isDevice && elemNames.indexOf(tagName) !== -1)) {
                if (element.getAttribute('aria-describedby')) {
                    return;
                }
                if (this.getTooltipStatus(element)) {
                    if (element.getElementsByClassName('e-headertext').length) {
                        this.content = element.getElementsByClassName('e-headertext')[0].innerText;
                    }
                    else {
                        this.content = element.innerText;
                    }
                    this.prevElement = element;
                    this.open(element);
                }
            }
        }
        this.hoverFrozenRows(e);
    };
    CustomToolTip.prototype.hoverFrozenRows = function (e) {
        if (this.parent.options.frozenColumns) {
            var row = parentsUntil(e.target, 'e-row');
            var frozenHover = [].slice.call(this.parent.element.querySelectorAll('.e-frozenhover'));
            if (frozenHover.length && e.type === 'mouseout') {
                for (var i = 0; i < frozenHover.length; i++) {
                    frozenHover[i].classList.remove('e-frozenhover');
                }
            }
            else if (row) {
                var rows = [].slice.call(this.parent.element.querySelectorAll('tr[aria-rowindex="' + row.getAttribute('aria-rowindex') + '"]'));
                rows.splice(rows.indexOf(row), 1);
                if (row.getAttribute('aria-selected') != 'true') {
                    for (var i = 0; i < rows.length; i++) {
                        rows[i].classList.add('e-frozenhover');
                    }
                }
                else {
                    for (var i = 0; i < rows.length; i++) {
                        rows[i].classList.remove('e-frozenhover');
                    }
                }
            }
        }
    };
    CustomToolTip.prototype.isEllipsisTooltip = function () {
        var cols = this.parent.getColumns();
        if (this.parent.options.clipMode === 'EllipsisWithTooltip') {
            return true;
        }
        for (var i = 0; i < cols.length; i++) {
            if (cols[i].clipMode === 'EllipsisWithTooltip') {
                return true;
            }
        }
        return false;
    };
    CustomToolTip.prototype.scrollHandler = function () {
        if (this.isEllipsisTooltip()) {
            this.close();
        }
    };
    /**
     * To create table for ellipsiswithtooltip
     * @hidden
     */
    CustomToolTip.prototype.createTable = function (table, tag, type) {
        var myTableDiv = sf.base.createElement('div');
        myTableDiv.className = this.parent.element.className;
        myTableDiv.style.cssText = 'display: inline-block;visibility:hidden;position:absolute';
        var mySubDiv = sf.base.createElement('div');
        mySubDiv.className = tag;
        var myTable = sf.base.createElement('table');
        myTable.className = table.className;
        myTable.style.cssText = 'table-layout: auto;width: auto';
        var ele = (type === 'header') ? 'th' : 'td';
        var myTr = sf.base.createElement('tr');
        var mytd = sf.base.createElement(ele);
        myTr.appendChild(mytd);
        myTable.appendChild(myTr);
        mySubDiv.appendChild(myTable);
        myTableDiv.appendChild(mySubDiv);
        document.body.appendChild(myTableDiv);
        return myTableDiv;
    };
    CustomToolTip.prototype.onKeyPressed = function (e) {
        if (e.key === 'Tab' || e.key === 'ShiftTab') {
            this.close();
        }
    };
    CustomToolTip.prototype.destroy = function () {
        this.close();
        this.unWireevents();
    };
    return CustomToolTip;
}());

/**
 *
 * Reorder module is used to handle row reordering.
 * @hidden
 */
var RowDD = /** @class */ (function () {
    /**
     * Constructor for the Grid print module
     * @hidden
     */
    function RowDD(parent) {
        var _this = this;
        this.isOverflowBorder = true;
        /* tslint:disable-next-line:max-line-length */
        // tslint:disable-next-line:max-func-body-length
        this.helper = function (e) {
            var gObj = _this.parent;
            var target = _this.draggable.currentStateTarget;
            if (!(e.sender.target.classList.contains("e-input") || e.sender.target.tagName == "INPUT" || e.sender.target.tagName == "TEXTAREA")) {
                e.sender.target.blur(); //https://github.com/dotnet/aspnetcore/issues/17926
            }
            var visualElement = sf.base.createElement('div', {
                className: 'e-cloneproperties e-draganddrop e-grid e-dragclone',
                styles: 'height:"auto", z-index:2, width:' + gObj.element.offsetWidth
            });
            var table = sf.base.createElement('table', { styles: 'width:' + gObj.element.offsetWidth });
            var tbody = sf.base.createElement('tbody');
            if (document.getElementsByClassName('e-griddragarea').length ||
                (gObj.options.rowDropTarget && (!e.sender.target.classList.contains('e-selectionbackground')
                    && gObj.options.selectionType !== 'Single')) ||
                (!gObj.options.rowDropTarget && !parentsUntil(e.sender.target, 'e-rowdragdrop')) ||
                gObj.options.rowDropTarget && gObj.options.selectionType === 'Single' && _this.draggable.currentStateTarget.parentElement.getAttribute('aria-rowindex') === null) {
                return false;
            }
            if (gObj.options.rowDropTarget &&
                gObj.options.selectionMode === 'Row' && gObj.options.selectionType === 'Single' &&
                _this.draggable.currentStateTarget.parentElement.getAttribute('aria-rowindex') !== null) {
                gObj.dotNetRef.invokeMethodAsync("SelectRow", parseInt(_this.draggable.currentStateTarget.parentElement.getAttribute('aria-rowindex'), 10));
            }
            _this.startedRow = sf.base.closest(target, 'tr').cloneNode(true);
            var selectedRows = gObj.getSelectedRows();
            removeElement(_this.startedRow, '.e-indentcell');
            removeElement(_this.startedRow, '.e-detailrowcollapse');
            removeElement(_this.startedRow, '.e-detailrowexpand');
            _this.removeCell(_this.startedRow, 'e-gridchkbox');
            var exp = new RegExp('e-active', 'g'); //high contrast issue
            _this.startedRow.innerHTML = _this.startedRow.innerHTML.replace(exp, '');
            tbody.appendChild(_this.startedRow);
            if (gObj.getSelectedRows().length > 1 && _this.startedRow.hasAttribute('aria-selected')) {
                var dropCountEle = sf.base.createElement('span', {
                    className: 'e-dropitemscount', innerHTML: '' + selectedRows.length,
                });
                visualElement.appendChild(dropCountEle);
            }
            var ele = sf.base.closest(target, 'tr').querySelector('.e-icon-rowdragicon');
            if (ele) {
                ele.classList.add('e-dragstartrow');
            }
            table.appendChild(tbody);
            visualElement.appendChild(table);
            gObj.element.appendChild(visualElement);
            return visualElement;
        };
        this.dragStart = function (e) {
            var gObj = _this.parent;
            document.body.classList.add('e-prevent-select');
            if (document.getElementsByClassName('e-griddragarea').length) {
                return;
            }
            var spanCssEle = _this.parent.element.querySelector('.e-dropitemscount');
            if (_this.parent.getSelectedRows().length > 1 && spanCssEle) {
                spanCssEle.style.left = _this.parent.element.querySelector('.e-cloneproperties table')
                    .offsetWidth - 5 + 'px';
            }
            var fromIdx = parseInt(_this.startedRow.getAttribute('aria-rowindex'), 10);
            _this.parent.dotNetRef.invokeMethodAsync("RowDragStartEvent", fromIdx);
            e.bindEvents(e.dragElement);
            _this.dragStartData = _this.rowData;
            var dropElem = document.getElementById(gObj.options.rowDropTarget);
            if (gObj.options.rowDropTarget && dropElem && dropElem.blazor__instance &&
                (typeof dropElem.blazor__instance.getModuleName === 'function') &&
                dropElem.blazor__instance.getModuleName() === 'grid') {
                dropElem.blazor__instance.getContent().classList.add('e-allowRowDrop');
            }
        };
        this.drag = function (e) {
            var gObj = _this.parent;
            var cloneElement = _this.parent.element.querySelector('.e-cloneproperties');
            var target = _this.getElementFromPosition(cloneElement, e.event);
            sf.base.classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur', 'e-movecur']);
            _this.isOverflowBorder = true;
            var trElement = parentsUntil(target, 'e-grid') ? sf.base.closest(e.target, 'tr') : null;
            if (!e.target) {
                return;
            }
            _this.stopTimer();
            gObj.element.classList.add('e-rowdrag');
            _this.dragTarget = trElement && parentsUntil(target, 'e-grid').id === cloneElement.parentElement.id ?
                trElement.rowIndex : parseInt(_this.startedRow.getAttribute('aria-rowindex'), 10);
            if (gObj.options.rowDropTarget) {
                if (parentsUntil(target, 'e-gridcontent')) {
                    if (parentsUntil(cloneElement.parentElement, 'e-grid').id === parentsUntil(target, 'e-grid').id) {
                        sf.base.classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);
                    }
                    else {
                        sf.base.classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);
                    }
                }
                else if (parentsUntil(target, 'e-droppable')) {
                    sf.base.classList(cloneElement, ['e-defaultcur'], ['e-notallowedcur']);
                }
                else {
                    sf.base.classList(cloneElement, ['e-notallowedcur'], ['e-defaultcur']);
                }
            }
            else {
                var elem = parentsUntil(target, 'e-grid');
                if (elem && elem.id === cloneElement.parentElement.id) {
                    sf.base.classList(cloneElement, ['e-movecur'], ['e-defaultcur']);
                }
                else {
                    sf.base.classList(cloneElement, ['e-notallowedcur'], ['e-movecur']);
                }
            }
            if (!gObj.options.rowDropTarget &&
                (!gObj.options.groupCount || e.target.classList.contains('e-selectionbackground'))) {
                if (parentsUntil(target, 'e-grid')) {
                    _this.updateScrollPostion(e.event, target);
                }
                if (_this.isOverflowBorder && parseInt(_this.startedRow.getAttribute('aria-rowindex'), 10) !== _this.dragTarget) {
                    _this.moveDragRows(e, _this.startedRow, trElement);
                }
                else {
                    if (trElement && _this.parent.getRowByIndex(_this.parent.getRows().length - 1).getAttribute('data-uid') ===
                        trElement.getAttribute('data-uid')) {
                        var bottomborder = sf.base.createElement('div', { className: 'e-lastrow-dragborder' });
                        var gridcontentEle = _this.parent.getContent();
                        bottomborder.style.width = _this.parent.element.offsetWidth - _this.getScrollWidth() + 'px';
                        if (!gridcontentEle.querySelectorAll('.e-lastrow-dragborder').length) {
                            gridcontentEle.classList.add('e-grid-relative');
                            gridcontentEle.appendChild(bottomborder);
                            bottomborder.style.bottom = _this.getScrollWidth() + 'px';
                        }
                    }
                    _this.removeBorder(trElement);
                }
            }
        };
        this.dragStop = function (e) {
            document.body.classList.remove('e-prevent-select');
            if (isActionPrevent(_this.parent.element)) {
                return;
            }
            else {
                _this.processDragStop(e);
            }
        };
        this.processDragStop = function (e) {
            var gObj = _this.parent;
            var targetEle = _this.getElementFromPosition(e.helper, e.event);
            var target = targetEle && !targetEle.classList.contains('e-dlg-overlay') ?
                targetEle : e.target;
            gObj.element.classList.remove('e-rowdrag');
            var dropElement = document.getElementById(gObj.options.rowDropTarget);
            if (_this.parent.options.allowRowDragAndDrop && _this.parent.options.rowDropTarget && !parentsUntil(target, 'e-grid')) {
                var toIdx = 0;
                var targetClass = _this.getElementXPath(e.target);
                var targetID = target.id;
                var fromIdx = parseInt(_this.startedRow.getAttribute('aria-rowindex'), 10);
                var positions = e.target.getBoundingClientRect();
                gObj.dotNetRef.invokeMethodAsync("ReorderRows", fromIdx, toIdx, 'add', false, targetClass, targetID, positions, null, true);
            }
            if (gObj.options.rowDropTarget && dropElement && dropElement.blazor__instance &&
                (typeof dropElement.blazor__instance.getModuleName === 'function') &&
                dropElement.blazor__instance.getModuleName() === 'grid') {
                dropElement.blazor__instance.getContent().classList.remove('e-allowRowDrop');
            }
            if (!parentsUntil(target, 'e-gridcontent')) {
                _this.dragTarget = null;
                sf.base.remove(e.helper);
                return;
            }
            if (_this.parent.options.allowRowDragAndDrop && !_this.parent.options.rowDropTarget) {
                _this.stopTimer();
                _this.parent.getContent().classList.remove('e-grid-relative');
                _this.removeBorder(targetEle);
                var stRow = gObj.element.querySelector('.e-dragstartrow');
                if (stRow) {
                    stRow.classList.remove('e-dragstartrow');
                }
                var toIdx_1 = _this.dragTarget;
                var targetClass_1 = _this.getElementXPath(e.target);
                var targetID_1 = target.id;
                var fromIdx_1 = parseInt(_this.startedRow.getAttribute('aria-rowindex'), 10);
                setTimeout(function () {
                    gObj.dotNetRef.invokeMethodAsync("ReorderRows", fromIdx_1, toIdx_1, 'delete', true, targetClass_1, targetID_1, null, null, false);
                }, 10);
                _this.dragTarget = null;
            }
        };
        this.removeCell = function (targetRow, className) {
            return [].slice.call(targetRow.querySelectorAll('td')).filter(function (cell) {
                if (cell.classList.contains(className)) {
                    targetRow.deleteCell(cell.cellIndex);
                }
            });
        };
        this.drop = function (e) {
            _this.columnDrop({ target: e.target, droppedElement: e.droppedElement });
            sf.base.remove(e.droppedElement);
        };
        this.parent = parent;
        if (this.parent.options.allowRowDragAndDrop) {
            this.initializeDrag();
        }
    }
    RowDD.prototype.stopTimer = function () {
        window.clearInterval(this.timer);
    };
    RowDD.prototype.initializeDrag = function () {
        var gObj = this.parent;
        this.draggable = new sf.base.Draggable(gObj.getContent(), {
            dragTarget: '.e-rowcelldrag, .e-rowdragdrop, .e-rowcell',
            distance: 5,
            helper: this.helper,
            dragStart: this.dragStart,
            drag: this.drag,
            dragStop: this.dragStop,
            isPreventSelect: false
        });
        this.droppable = new sf.base.Droppable(gObj.getContent(), {
            accept: '.e-dragclone',
            drop: this.drop
        });
    };
    RowDD.prototype.updateScrollPostion = function (e, target) {
        var _this = this;
        var frzCols = this.parent.options.frozenColumns;
        var y = getPosition(e).y;
        var cliRect = this.parent.getContent().getBoundingClientRect();
        var rowHeight = this.parent.getRowHeight() - 15;
        var scrollElem = frzCols ? this.parent.getContent().querySelector('.e-movablecontent')
            : this.parent.getContent().firstElementChild;
        if (cliRect.top + rowHeight >= y) {
            var scrollPixel_1 = -(this.parent.getRowHeight());
            this.isOverflowBorder = false;
            this.timer = window.setInterval(function () { _this.setScrollDown(scrollElem, scrollPixel_1, true); }, 200);
        }
        else if (cliRect.top + this.parent.getContent().clientHeight - rowHeight - 20 <= y) {
            var scrollPixel_2 = (this.parent.getRowHeight());
            this.isOverflowBorder = false;
            this.timer = window.setInterval(function () { _this.setScrollDown(scrollElem, scrollPixel_2, true); }, 200);
        }
    };
    RowDD.prototype.setScrollDown = function (scrollElem, scrollPixel, isLeft) {
        scrollElem.scrollTop = scrollElem.scrollTop + scrollPixel;
    };
    RowDD.prototype.moveDragRows = function (e, startedRow, targetRow) {
        var cloneElement = this.parent.element.querySelector('.e-cloneproperties');
        var element = sf.base.closest(e.target, 'tr');
        if (parentsUntil(element, 'e-gridcontent') && parentsUntil(cloneElement.parentElement, 'e-grid').id ===
            parentsUntil(element, 'e-grid').id) {
            var targetElement = element ?
                element : this.startedRow;
            this.setBorder(targetElement, e.event, startedRow, targetRow);
        }
    };
    RowDD.prototype.setBorder = function (element, event, startedRow, targetRow) {
        var node = this.parent.element;
        var cloneElement = this.parent.element.querySelector('.e-cloneproperties');
        this.removeFirstRowBorder(element);
        this.removeLastRowBorder(element);
        if (parentsUntil(element, 'e-gridcontent') && parentsUntil(cloneElement.parentElement, 'e-grid').id ===
            parentsUntil(element, 'e-grid').id) {
            sf.base.removeClass(node.querySelectorAll('.e-rowcell,.e-rowdragdrop'), ['e-dragborder']);
            var rowElement = [];
            if (targetRow && targetRow.rowIndex === 0) {
                var div = sf.base.createElement('div', { className: 'e-firstrow-dragborder' });
                var gridheaderEle = this.parent.getHeaderContent();
                gridheaderEle.classList.add('e-grid-relative');
                div.style.width = node.offsetWidth - this.getScrollWidth() + 'px';
                if (!gridheaderEle.querySelectorAll('.e-firstrow-dragborder').length) {
                    gridheaderEle.appendChild(div);
                }
            }
            else if (targetRow && parseInt(startedRow.getAttribute('aria-rowindex'), 10) > targetRow.rowIndex) {
                element = this.parent.getRowByIndex(targetRow.rowIndex - 1);
                rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));
            }
            else {
                rowElement = [].slice.call(element.querySelectorAll('.e-rowcell,.e-rowdragdrop,.e-detailrowcollapse'));
            }
            if (rowElement.length > 0) {
                addRemoveActiveClasses(rowElement, true, 'e-dragborder');
            }
        }
    };
    RowDD.prototype.getScrollWidth = function () {
        var scrollElem = this.parent.getContent().firstElementChild;
        return scrollElem.scrollWidth > scrollElem.offsetWidth ? getScrollBarWidth() : 0;
    };
    RowDD.prototype.removeFirstRowBorder = function (element) {
        if (this.parent.element.getElementsByClassName('e-firstrow-dragborder').length > 0 && element &&
            element.rowIndex !== 0) {
            this.parent.element.getElementsByClassName('e-firstrow-dragborder')[0].remove();
        }
    };
    RowDD.prototype.removeLastRowBorder = function (element) {
        var islastRowIndex = element &&
            this.parent.getRowByIndex(this.parent.getRows().length - 1).getAttribute('data-uid') !==
                element.getAttribute('data-uid');
        if (this.parent.element.getElementsByClassName('e-lastrow-dragborder').length > 0 && element && islastRowIndex) {
            this.parent.element.getElementsByClassName('e-lastrow-dragborder')[0].remove();
        }
    };
    RowDD.prototype.removeBorder = function (element) {
        this.removeFirstRowBorder(element);
        this.removeLastRowBorder(element);
        element = this.parent.getRows().filter(function (row) {
            return row.querySelector('td.e-dragborder');
        })[0];
        if (element) {
            var rowElement = [].slice.call(element.querySelectorAll('.e-dragborder'));
            addRemoveActiveClasses(rowElement, false, 'e-dragborder');
        }
    };
    RowDD.prototype.getElementFromPosition = function (element, event) {
        var target;
        var position = getPosition(event);
        element.style.display = 'none';
        target = document.elementFromPoint(position.x, position.y);
        element.style.display = '';
        return target;
    };
    RowDD.prototype.getElementXPath = function (element) {
        if (!element)
            return null;
        if (element.id) {
            return "//[@id=" + element.id + "]" + (element.className != '' ? ('.' + element.className.toLowerCase()) : '');
        }
        else if (element.tagName === 'BODY') {
            return '/html/body';
        }
        else {
            var sameTagSiblings = [].slice.call(element.parentElement.childNodes)
                .filter(function (e) { return e.nodeName === element.nodeName; });
            var idx = sameTagSiblings.indexOf(element);
            return this.getElementXPath(element.parentNode) +
                '/' +
                element.tagName.toLowerCase() + (element.className != '' ? ('.' + element.className.toLowerCase()) : '') +
                (sameTagSiblings.length > 1 ? "[" + (idx + 1) + "]" : '');
        }
    };
    RowDD.prototype.getTargetIdx = function (targetRow) {
        return targetRow ? parseInt(targetRow.getAttribute('aria-rowindex'), 10) : 0;
    };
    RowDD.prototype.columnDrop = function (e) {
        var gObj = this.parent;
        if (e.droppedElement.getAttribute('action') !== 'grouping') {
            var targetRow = sf.base.closest(e.target, 'tr');
            var srcControl = void 0;
            var currentIndex = void 0;
            if ((e.droppedElement.querySelector('tr').getAttribute('single-dragrow') !== 'true' &&
                e.droppedElement.parentElement.id === gObj.element.id)
                || (e.droppedElement.querySelector('tr').getAttribute('single-dragrow') === 'true' &&
                    e.droppedElement.parentElement.id !== gObj.element.id)) {
                return;
            }
            if (e.droppedElement.parentElement.id !== gObj.element.id) {
                srcControl = e.droppedElement.parentElement.blazor__instance;
            }
            if (srcControl.element.id !== gObj.element.id && srcControl.options.rowDropTarget !== gObj.element.id) {
                return;
            }
            var targetIndex = currentIndex = this.getTargetIdx(targetRow);
            if (isNaN(targetIndex)) {
                targetIndex = currentIndex = 0;
            }
            if (gObj.options.allowPaging) {
                targetIndex = targetIndex + (gObj.options.currentPage * gObj.options.pageSize) - gObj.options.pageSize;
            }
            var targetClass = this.getElementXPath(e.target);
            var targetID = e.target.id;
            var positions = e.target.getBoundingClientRect();
            gObj.dotNetRef.invokeMethodAsync("ReorderRows", 0, targetIndex, 'add', false, targetClass, targetID, positions, srcControl.dotNetRef, false);
            srcControl.dotNetRef.invokeMethodAsync("ReorderRows", 0, targetIndex, 'delete', false, targetClass, targetID, positions, null, false);
        }
    };
    /**
     * To destroy the print
     * @return {void}
     * @hidden
     */
    RowDD.prototype.destroy = function () {
        var gridElement = this.parent.element;
        if (!gridElement || (!gridElement.querySelector('.e-gridheader') &&
            !gridElement.querySelector('.e-gridcontent'))) {
            return;
        }
        this.draggable.destroy();
    };
    return RowDD;
}());

var Selection = /** @class */ (function () {
    function Selection(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    Selection.prototype.addEventListener = function () {
        sf.base.EventHandler.add(this.parent.getContent().parentElement, 'mousedown', this.mouseDownHandler, this);
    };
    Selection.prototype.removeEventListener = function () {
        sf.base.EventHandler.remove(this.parent.getContent().parentElement, 'mousedown', this.mouseDownHandler);
    };
    Selection.prototype.mouseDownHandler = function (e) {
        var target = e.target;
        var gObj = this.parent;
        var isDrag;
        var gridElement = parentsUntil(target, 'e-grid');
        if (gridElement && gridElement.id !== gObj.element.id || parentsUntil(target, 'e-headercontent') && !this.parent.options.frozenRows) {
            return;
        }
        if (e.shiftKey || e.ctrlKey) {
            e.preventDefault();
        }
        if (parentsUntil(target, 'e-rowcell') && !e.shiftKey && !e.ctrlKey) {
            if (gObj.options.cellSelectionMode.indexOf('Box') > -1 && !this.isRowType() && !this.isSingleSel()) {
                this.isCellDrag = true;
                isDrag = true;
            }
            if (gObj.options.allowRowDragAndDrop && !gObj.options.isEdit) {
                if (!this.isRowType() || this.isSingleSel() || sf.base.closest(target, 'td').classList.contains('e-selectionbackground')) {
                    this.isDragged = false;
                    return;
                }
                isDrag = true;
                this.element = sf.base.createElement('div', { className: 'e-griddragarea' });
                gObj.getContent().appendChild(this.element);
            }
            if (isDrag) {
                this.isAutoFillSel = false;
                this.enableDrag(e, true);
            }
        }
        this.updateStartEndCells();
        if (target.classList.contains('e-autofill') || target.classList.contains('e-xlsel')) {
            this.isCellDrag = true;
            this.isAutoFillSel = true;
            this.enableDrag(e);
            document.body.style.cursor = 'crosshair';
        }
    };
    Selection.prototype.mouseUpHandler = function (e) {
        document.body.classList.remove('e-disableuserselect');
        if (this.element) {
            sf.base.remove(this.element);
        }
        if (!sf.base.isNullOrUndefined(this.prevStartDIndex) || !sf.base.isNullOrUndefined(this.prevEndIndex)) {
            this.parent.dotNetRef.invokeMethodAsync("DragSelection", this.prevStartDIndex, this.prevEndIndex, false);
        }
        // if (this.isDragged && this.selectedRowCellIndexes.length === 1 && this.selectedRowCellIndexes[0].cellIndexes.length === 1) {
        //     this.mUPTarget = parentsUntil(e.target as Element, 'e-rowcell');
        // } else {
        //     this.mUPTarget = null;
        // }
        // if (this.isDragged && !this.isAutoFillSel) {
        //     let target: Element = e.target as Element;
        //     let rowIndex: number = parseInt(target.parentElement.getAttribute('aria-rowindex'), 10);
        //     let cellIndex: number =  parseInt(target.getAttribute('aria-colindex'), 10);
        //     this.isDragged = false;
        //     this.clearCellSelection();
        //     this.selectCellsByRange(
        //         { rowIndex: this.startDIndex, cellIndex: this.startDCellIndex },
        //         { rowIndex: rowIndex, cellIndex: cellIndex });
        // }
        this.isDragged = false;
        document.body.style.cursor = 'default';
        this.prevStartDIndex = undefined;
        this.prevEndIndex = undefined;
        if (this.parent.options.editMode == "Batch" && this.parent.options.enableAutoFill && this.parent.options.frozenColumns === 0 && this.parent.options.frozenRows === 0) {
            if (!sf.base.isNullOrUndefined(this.endRowIndex) && !sf.base.isNullOrUndefined(this.endColIndex) && !this.isAutoFillSel && this.isInitialSelect) {
                this.parent.dotNetRef.invokeMethodAsync("ClearSelection");
                var updateAFPos = this.updateAutofillPosition(this.endColIndex, this.endRowIndex, true);
                this.parent.dotNetRef.invokeMethodAsync("UpdateAutofillPositions", updateAFPos, "UpdateAutofillBox");
                this.assignCells();
                this.selectCellByRow();
                this.isInitialSelect = false;
            }
            if (this.isAutoFillSel) {
                var _this_1 = this;
                this.assignCells();
                setTimeout(function () {
                    _this_1.selectCellByRow();
                }, 10);
                this.expandAFBorder(e, true);
                var updateAFBor = this.createBorder(this.startRowIndex, this.startColIndex, this.endRowIndex, this.endColIndex, true);
                this.parent.dotNetRef.invokeMethodAsync("UpdateAutofillPositions", updateAFBor, "UpdateAutofillBorder");
                var updateAFPos = this.updateAutofillPosition(this.endColIndex, this.endRowIndex, true);
                this.parent.dotNetRef.invokeMethodAsync("UpdateAutofillPositions", updateAFPos, "UpdateAutofillBox");
            }
        }
        sf.base.EventHandler.remove(this.parent.getContent(), 'mousemove', this.mouseMoveHandler);
        if (this.parent.options.frozenRows) {
            sf.base.EventHandler.remove(this.parent.getHeaderContent(), 'mousemove', this.mouseMoveHandler);
        }
        sf.base.EventHandler.remove(document.body, 'mouseup', this.mouseUpHandler);
    };
    Selection.prototype.enableDrag = function (e, isUpdate) {
        var gObj = this.parent;
        if (isUpdate) {
            var tr = sf.base.closest(e.target, 'tr');
            this.startDIndex = parseInt(tr.getAttribute('aria-rowindex'), 10);
            this.startDCellIndex = parseInt(parentsUntil(e.target, 'e-rowcell').getAttribute('aria-colindex'), 10);
        }
        document.body.classList.add('e-disableuserselect');
        var gBRect = gObj.element.getBoundingClientRect();
        var postion = getPosition(e);
        this.x = postion.x - gBRect.left;
        this.y = postion.y - gBRect.top;
        sf.base.EventHandler.add(gObj.getContent(), 'mousemove', this.mouseMoveHandler, this);
        if (this.parent.options.frozenRows) {
            sf.base.EventHandler.add(gObj.getHeaderContent(), 'mousemove', this.mouseMoveHandler, this);
        }
        sf.base.EventHandler.add(document.body, 'mouseup', this.mouseUpHandler, this);
    };
    Selection.prototype.mouseMoveHandler = function (e) {
        e.preventDefault();
        var gBRect = this.parent.element.getBoundingClientRect();
        var x1 = this.x;
        var y1 = this.y;
        var position = getPosition(e);
        var x2 = position.x - gBRect.left;
        var y2 = position.y - gBRect.top;
        var tmp;
        var target = sf.base.closest(e.target, 'tr');
        this.isDragged = true;
        if (!this.isCellDrag) {
            if (!target) {
                target = sf.base.closest(document.elementFromPoint(this.parent.element.offsetLeft + 2, e.clientY), 'tr');
            }
            if (x1 > x2) {
                tmp = x2;
                x2 = x1;
                x1 = tmp;
            }
            if (y1 > y2) {
                tmp = y2;
                y2 = y1;
                y1 = tmp;
            }
            this.element.style.left = x1 + 'px';
            this.element.style.top = y1 - this.parent.getRowHeight() + 'px';
            this.element.style.width = x2 - x1 + 'px';
            this.element.style.height = y2 - y1 + 'px';
        }
        if (target && !e.ctrlKey && !e.shiftKey) {
            var rowIndex = parseInt(target.getAttribute('aria-rowindex'), 10);
            if (!this.isCellDrag && (sf.base.isNullOrUndefined(this.prevStartDIndex) ||
                this.prevStartDIndex != this.startDIndex || this.prevEndIndex != rowIndex)) {
                //Below calculation is to perform ClearSelection in server side
                var clearIndex = -1;
                var isInvokedFirst = false;
                var selectedIndexes = this.parent.getSelectedRowIndexes();
                if (sf.base.isNullOrUndefined(this.prevStartDIndex)) {
                    clearIndex = -1;
                    isInvokedFirst = true;
                }
                else if (rowIndex >= this.prevStartDIndex && selectedIndexes.indexOf(rowIndex) >= 0) {
                    clearIndex = this.prevEndIndex;
                }
                else if (this.prevStartDIndex > rowIndex && selectedIndexes.indexOf(this.startDIndex) >= 0) {
                    clearIndex = this.prevEndIndex;
                }
                this.prevStartDIndex = this.startDIndex;
                this.prevEndIndex = rowIndex;
                if (isInvokedFirst) {
                    this.parent.dotNetRef.invokeMethodAsync("DragSelection", this.startDIndex, rowIndex, true);
                }
                else {
                    this.performDragSelection(this.startDIndex, rowIndex, clearIndex);
                }
            }
            else if (this.parent.options.editMode == "Batch" && this.parent.options.enableAutoFill) {
                if (this.startCell) {
                    var td = parentsUntil(e.target, 'e-rowcell');
                    if (td && !td.classList.contains("e-editedbatchcell")) {
                        this.startAFCell = this.startCell;
                        this.endAFCell = td;
                        this.endCell = td;
                        if (this.isAutoFillSel) {
                            this.expandAFBorder(e, false);
                        }
                        else {
                            this.assignCells();
                            var updateAFBor = this.createBorder(this.startRowIndex, this.startColIndex, this.endRowIndex, this.endColIndex, true);
                            this.parent.dotNetRef.invokeMethodAsync("UpdateAutofillPositions", updateAFBor, "UpdateAutofillBorder");
                            this.isInitialSelect = true;
                        }
                    }
                }
            }
        }
    };
    /**
     * @hidden
     */
    Selection.prototype.updateAutofillPosition = function (cellindex, index, newSelect) {
        if (newSelect === void 0) { newSelect = false; }
        var row = this.parent.getRowByIndex(index);
        var cell = row.querySelector('[aria-colindex="' + cellindex + '"]');
        var selectedCells = [].slice.call(this.parent.element.querySelectorAll('.e-cellselectionbackground'));
        var autoFillBoxLeft = '';
        var autoFillBoxRight = '';
        var autoFillBoxTop = '';
        if (selectedCells && !newSelect) {
            cell = selectedCells[selectedCells.length - 1];
        }
        if (cell && cell.offsetParent) {
            var clientRect = cell.getBoundingClientRect();
            var parentOff = cell.offsetParent.getBoundingClientRect();
            var colWidth = this.isLastCell(cell) ? 4 : 0;
            var rowHeight = this.isLastRow(cell) ? 3 : 0;
            if (!this.parent.options.enableRtl) {
                autoFillBoxLeft = clientRect.left - parentOff.left + clientRect.width - 4 - colWidth + 'px';
            }
            else {
                autoFillBoxRight = parentOff.right - clientRect.right + clientRect.width - 4 - colWidth + 'px';
            }
            autoFillBoxTop = clientRect.top - parentOff.top + clientRect.height - 5 - rowHeight + 'px';
        }
        return {
            Left: autoFillBoxLeft,
            Right: autoFillBoxRight,
            Top: autoFillBoxTop
        };
    };
    /**
     * @hidden
     */
    Selection.prototype.createBorder = function (startRowIndex, startColIndex, endRowIndex, endColIndex, newSelect) {
        if (endRowIndex === void 0) { endRowIndex = null; }
        if (endColIndex === void 0) { endColIndex = null; }
        if (newSelect === void 0) { newSelect = false; }
        var selectedCells = [].slice.call(this.parent.element.querySelectorAll('.e-cellselectionbackground'));
        var rowstart = this.parent.getRowByIndex(startRowIndex);
        var cellStart = rowstart.querySelector('[aria-colindex="' + startColIndex + '"]');
        var cellsStart = [].slice.call(cellStart.parentElement.querySelectorAll('[aria-colindex="' + startColIndex + '"]'));
        var rowEnd;
        var cellEnd;
        var cellsEnd;
        var autoFillBorderRight = '';
        var autoFillBorderLeft = '';
        var autoFillBordersWidth = '';
        var autoFillBorderWidth = '';
        var autoFillBorderHeight = '';
        var autoFillBorderTop = '';
        if (endRowIndex != null && endColIndex != null) {
            rowEnd = this.parent.getRowByIndex(endRowIndex);
            cellEnd = rowEnd.querySelector('[aria-colindex="' + endColIndex + '"]');
            cellsEnd = [].slice.call(cellEnd.parentElement.querySelectorAll('[aria-colindex="' + endColIndex + '"]'));
        }
        else {
            rowEnd = rowstart;
            cellEnd = cellStart;
            cellsEnd = cellsStart;
        }
        if (selectedCells && !newSelect) {
            cellsStart = [].slice.call(selectedCells[0].parentElement.querySelectorAll('[aria-colindex="' + selectedCells[0].cellIndex + '"]'));
            cellsEnd = [].slice.call(selectedCells[selectedCells.length - 1].parentElement.querySelectorAll('[aria-colindex="' + selectedCells[selectedCells.length - 1].cellIndex + '"]'));
        }
        if (!this.startCell) {
            this.startCell = cellsStart[0];
        }
        this.endCells = cellsEnd[0];
        var start = cellsStart[0];
        var end = cellsEnd[0];
        var stOff = start.getBoundingClientRect();
        var endOff = end.getBoundingClientRect();
        var parentOff = start.offsetParent.getBoundingClientRect();
        var rowHeight = this.isLastRow(end) ? 2 : 0;
        var topOffSet = this.parent.options.frozenRows && this.isFirstRow(start) ? 1.5 : 0;
        var leftOffset = this.parent.options.frozenColumns && this.isFirstCell(start) ? 1 : 0;
        if (this.parent.options.enableRtl) {
            autoFillBorderRight = parentOff.right - stOff.right - leftOffset + 'px';
            autoFillBorderWidth = stOff.right - endOff.left + leftOffset + 1 + 'px';
        }
        else {
            autoFillBorderLeft = stOff.left - parentOff.left - leftOffset + 'px';
            autoFillBorderWidth = endOff.right - stOff.left + leftOffset + 1 + 'px';
        }
        autoFillBorderTop = stOff.top - parentOff.top - topOffSet + 'px';
        autoFillBorderHeight = endOff.top - stOff.top > 0 ?
            (endOff.top - parentOff.top + endOff.height + 1) - (stOff.top - parentOff.top) - rowHeight + topOffSet + 'px' :
            endOff.height + topOffSet - rowHeight + 1 + 'px';
        autoFillBordersWidth = '2px';
        return {
            Right: autoFillBorderRight,
            Width: autoFillBorderWidth,
            BorderWidth: autoFillBordersWidth,
            Left: autoFillBorderLeft,
            Height: autoFillBorderHeight,
            Top: autoFillBorderTop
        };
    };
    Selection.prototype.expandAFBorder = function (e, isApply) {
        var selectedCells = [].slice.call(this.parent.element.querySelectorAll('.e-cellselectionbackground'));
        var startrowIdx = parseInt(parentsUntil(this.startCell, 'e-row').getAttribute('aria-rowindex'), 10);
        var startCellIdx = parseInt(this.startCell.getAttribute('aria-colindex'), 10);
        var endrowIdx = parseInt(parentsUntil(this.endCell, 'e-row').getAttribute('aria-rowindex'), 10);
        var endCellIdx = parseInt(this.endCell.getAttribute('aria-colindex'), 10);
        var rowLen = parseInt(parentsUntil(selectedCells[selectedCells.length - 1], 'e-row').getAttribute('aria-rowindex'), 10) - parseInt(parentsUntil(selectedCells[0], 'e-row').getAttribute('aria-rowindex'), 10);
        var rowIdx = parseInt(parentsUntil(selectedCells[0], 'e-row').getAttribute('aria-rowindex'), 10);
        var row = (this.parent.getRowByIndex(rowIdx));
        var colLen = 0;
        for (var i = 0, cellLen = row.cells.length; i < cellLen; i++) {
            if (row.cells[i].classList.contains('e-cellselectionbackground')) {
                colLen++;
            }
        }
        colLen = colLen - 1;
        colLen = colLen >= 0 ? colLen : 0;
        switch (true) {
            case !isApply && this.endAFCell.classList.contains('e-cellselectionbackground') &&
                !!parentsUntil(e.target, 'e-rowcell'):
                this.startAFCell = this.parent.getCellFromIndex(startrowIdx, startCellIdx);
                this.endAFCell = this.parent.getCellFromIndex(startrowIdx + rowLen, startCellIdx + colLen);
                this.drawAFBorders();
                break;
            case startCellIdx + colLen < endCellIdx &&
                endCellIdx - startCellIdx - colLen + 1 > endrowIdx - startrowIdx - rowLen
                && endCellIdx - startCellIdx - colLen + 1 > startrowIdx - endrowIdx:
                this.endAFCell = this.parent.getCellFromIndex(startrowIdx + rowLen, endCellIdx);
                endrowIdx = parseInt(parentsUntil(this.endAFCell, 'e-row').getAttribute('aria-rowindex'), 10);
                endCellIdx = parseInt(this.endAFCell.getAttribute('aria-colindex'), 10);
                if (!isApply) {
                    this.drawAFBorders();
                }
                else {
                    var cellIdx = parseInt(this.endCells.getAttribute('aria-colindex'), 10);
                    for (var i = startrowIdx; i <= endrowIdx; i++) {
                        var cells = this.getAutoFillCells(i, startCellIdx);
                        var c = 0;
                        for (var j = cellIdx + 1; j <= endCellIdx; j++) {
                            if (c > colLen) {
                                c = 0;
                            }
                            this.updateValue(i, j, cells[c]);
                            c++;
                        }
                    }
                }
                break;
            case startCellIdx > endCellIdx &&
                startCellIdx - endCellIdx + 1 > endrowIdx - startrowIdx - rowLen &&
                startCellIdx - endCellIdx + 1 > startrowIdx - endrowIdx:
                this.startAFCell = this.parent.getCellFromIndex(startrowIdx, endCellIdx);
                this.endAFCell = this.endCells;
                if (!isApply) {
                    this.drawAFBorders();
                }
                else {
                    for (var i = startrowIdx; i <= startrowIdx + rowLen; i++) {
                        var cells = this.getAutoFillCells(i, startCellIdx);
                        cells.reverse();
                        var c = 0;
                        for (var j = this.startCellIndex - 1; j >= endCellIdx; j--) {
                            if (c > colLen) {
                                c = 0;
                            }
                            this.updateValue(i, j, cells[c]);
                            c++;
                        }
                    }
                }
                break;
            case startrowIdx > endrowIdx:
                this.startAFCell = this.parent.getCellFromIndex(endrowIdx, startCellIdx);
                this.endAFCell = this.endCells;
                if (!isApply) {
                    this.drawAFBorders();
                }
                else {
                    var trIdx = parseInt(this.endCells.parentElement.getAttribute('aria-rowindex'), 10);
                    var r = trIdx;
                    for (var i = startrowIdx - 1; i >= endrowIdx; i--) {
                        if (r === this.startIndex - 1) {
                            r = trIdx;
                        }
                        var cells = this.getAutoFillCells(r, startCellIdx);
                        var c = 0;
                        r--;
                        for (var j = this.startCellIndex; j <= this.startCellIndex + colLen; j++) {
                            this.updateValue(i, j, cells[c]);
                            c++;
                        }
                    }
                }
                break;
            default:
                this.endAFCell = this.parent.getCellFromIndex(endrowIdx, startCellIdx + colLen);
                if (!isApply) {
                    this.drawAFBorders();
                }
                else {
                    var trIdx = parseInt(this.endCells.parentElement.getAttribute('aria-rowindex'), 10);
                    var r = this.startIndex;
                    for (var i = trIdx + 1; i <= endrowIdx; i++) {
                        if (r === trIdx + 1) {
                            r = this.startIndex;
                        }
                        var cells = this.getAutoFillCells(r, startCellIdx);
                        r++;
                        var c = 0;
                        for (var m = this.startCellIndex; m <= this.startCellIndex + colLen; m++) {
                            this.updateValue(i, m, cells[c]);
                            c++;
                        }
                    }
                }
                break;
        }
    };
    Selection.prototype.drawAFBorders = function () {
        if (!this.startCell) {
            return;
        }
        var stOff = this.startAFCell.getBoundingClientRect();
        var endOff = this.endAFCell.getBoundingClientRect();
        var top = endOff.top - stOff.top > 0 ? 1 : 0;
        var firstCellTop = endOff.top - stOff.top >= 0 && (parentsUntil(this.startAFCell, 'e-movablecontent') ||
            parentsUntil(this.startAFCell, 'e-frozencontent')) && this.isFirstRow(this.startAFCell) ? 1.5 : 0;
        var firstCellLeft = (parentsUntil(this.startAFCell, 'e-movablecontent') ||
            parentsUntil(this.startAFCell, 'e-movableheader')) && this.isFirstCell(this.startAFCell) ? 1 : 0;
        var rowHeight = this.isLastRow(this.endAFCell) && (parentsUntil(this.endAFCell, 'e-movablecontent') ||
            parentsUntil(this.endAFCell, 'e-frozencontent')) ? 2 : 1;
        var parentOff = this.startAFCell.offsetParent.getBoundingClientRect();
        var parentRect = this.parent.element.getBoundingClientRect();
        var sTop = this.startAFCell.offsetParent.parentElement.scrollTop;
        var sLeft = this.startAFCell.offsetParent.parentElement.scrollLeft;
        var scrollTop = sTop - this.startAFCell.offsetTop;
        var scrollLeft = sLeft - this.startAFCell.offsetLeft;
        scrollTop = scrollTop > 0 ? Math.floor(scrollTop) - 1 : 0;
        scrollLeft = scrollLeft > 0 ? scrollLeft : 0;
        var left = stOff.left - parentRect.left;
        var bdrAFLeftLeft = '';
        var bdrAFLeftHeight = '';
        var bdrAFLeftTop = '';
        var bdrAFLeftRight = '';
        var bdrAFRightLeft = '';
        var bdrAFRightHeight = '';
        var bdrAFRightRight = '';
        var bdrAFRightTop = '';
        var bdrAFTopLeft = '';
        var bdrAFTopTop = '';
        var bdrAFTopWidth = '';
        var bdrAFBottomLeft = '';
        var bdrAFBottomTop = '';
        var bdrAFBottomWidth = '';
        if (!this.parent.options.enableRtl) {
            bdrAFLeftLeft = left - firstCellLeft + scrollLeft - 1 + sLeft + 'px';
            bdrAFRightLeft = endOff.left - parentRect.left - 2 + endOff.width + sLeft + 'px';
            bdrAFTopLeft = left + scrollLeft - 0.5 + sLeft + 'px';
            bdrAFTopWidth = parseInt(bdrAFRightLeft, 10) - parseInt(bdrAFLeftLeft, 10)
                - firstCellLeft + 1 + 'px';
        }
        else {
            var scrolloffSet = (parentsUntil(this.startAFCell, 'e-movablecontent') ||
                parentsUntil(this.startAFCell, 'e-movableheader')) ? stOff.right -
                this.startAFCell.offsetParent.parentElement.getBoundingClientRect().width -
                parentRect.left : 0;
            bdrAFLeftRight = parentRect.right - endOff.right - 2 + endOff.width + 'px';
            bdrAFRightRight = parentRect.right - stOff.right - firstCellLeft + scrolloffSet - 1 + 'px';
            bdrAFTopLeft = endOff.left - parentRect.left - 0.5 + 'px';
            bdrAFTopWidth = parseInt(bdrAFLeftRight, 10) - parseInt(bdrAFRightRight, 10)
                - firstCellLeft + 1 + 'px';
        }
        bdrAFLeftTop = stOff.top - parentOff.top - firstCellTop + 'px';
        bdrAFLeftHeight = endOff.top - stOff.top > 0 ?
            (endOff.top - parentOff.top + endOff.height + 1) - (stOff.top - parentOff.top) + firstCellTop - rowHeight - scrollTop + 'px' :
            endOff.height + firstCellTop - rowHeight - scrollTop + 'px';
        bdrAFRightTop = bdrAFLeftTop;
        bdrAFRightHeight = parseInt(bdrAFLeftHeight, 10) + 'px';
        bdrAFTopTop = bdrAFRightTop;
        bdrAFBottomLeft = bdrAFTopLeft;
        bdrAFBottomTop = parseFloat(bdrAFLeftTop) + parseFloat(bdrAFLeftHeight) - top - 1 + 'px';
        bdrAFBottomWidth = bdrAFTopWidth;
        var positionAF = {
            BorderLeftAutofillLeft: bdrAFLeftLeft,
            BorderLeftAutofillTop: bdrAFLeftTop,
            BorderLeftAutofillHeight: bdrAFLeftHeight,
            BorderLeftAutofillRight: bdrAFLeftRight,
            BorderRightAutofillLeft: bdrAFRightLeft,
            BorderRightAutofillHeight: bdrAFRightHeight,
            BorderRightAutofillRight: bdrAFRightRight,
            BorderRightAutofillTop: bdrAFRightTop,
            BorderTopAutofillLeft: bdrAFTopLeft,
            BorderTopAutofillTop: bdrAFTopTop,
            BorderTopAutofillWidth: bdrAFTopWidth,
            BorderBottomAutofillLeft: bdrAFBottomLeft,
            BorderBottomAutofillTop: bdrAFBottomTop,
            BorderBottomAutofillWidth: bdrAFBottomWidth
        };
        this.parent.dotNetRef.invokeMethodAsync("UpdateAutofillPositions", positionAF, "UpdateAutofillPosition");
    };
    Selection.prototype.updateValue = function (rowIndex, colIndex, cell) {
        var col = this.parent.getColumnByIndex(colIndex);
        var valueIndex = parseInt(parentsUntil(cell, 'e-row').getAttribute('aria-rowindex'), 10);
        var column = this.parent.getColumnByIndex(cell.cellIndex);
        var value = cell.innerText;
        this.parent.dotNetRef.invokeMethodAsync("UpdateAutofillCell", rowIndex, col.field, column.field, valueIndex, value);
    };
    Selection.prototype.getAutoFillCells = function (rowIndex, startCellIdx) {
        var cells = [].slice.call(this.parent.getDataRows()[rowIndex].querySelectorAll('.e-cellselectionbackground'));
        return cells;
    };
    Selection.prototype.updateStartEndCells = function () {
        var cells = [].slice.call(this.parent.element.querySelectorAll('.e-cellselectionbackground'));
        this.startCell = cells[0];
        this.endCell = cells[cells.length - 1];
        if (this.startCell) {
            this.startIndex = parseInt(this.startCell.parentElement.getAttribute('aria-rowindex'), 10);
            this.startCellIndex = parseInt(parentsUntil(this.startCell, 'e-rowcell').getAttribute('aria-colindex'), 10);
        }
    };
    Selection.prototype.assignCells = function () {
        this.startRowIndex = parseInt(this.startAFCell.parentElement.getAttribute('aria-rowindex'), 10);
        this.endRowIndex = parseInt(this.endAFCell.parentElement.getAttribute('aria-rowindex'), 10);
        this.startColIndex = parseInt(this.startAFCell.getAttribute('aria-colindex'), 10);
        this.endColIndex = parseInt(this.endAFCell.getAttribute('aria-colindex'), 10);
        if (this.startRowIndex > this.endRowIndex) {
            this.startRowIndex = this.endRowIndex;
            this.endRowIndex = parseInt(this.startAFCell.parentElement.getAttribute('aria-rowindex'), 10);
        }
        if (this.endColIndex < this.startColIndex) {
            this.startColIndex = this.endColIndex;
            this.endColIndex = parseInt(this.startAFCell.getAttribute('aria-colindex'), 10);
        }
    };
    Selection.prototype.selectCellByRow = function () {
        for (var i = this.startRowIndex; i <= this.endRowIndex; i++) {
            for (var j = this.startColIndex; j <= this.endColIndex; j++) {
                this.parent.dotNetRef.invokeMethodAsync("SelectCellByRow", i, j);
            }
        }
    };
    Selection.prototype.isLastCell = function (cell) {
        var LastCell = [].slice.call(cell.parentElement.querySelectorAll('.e-rowcell:not(.e-hide)'));
        return LastCell[LastCell.length - 1] == cell;
    };
    Selection.prototype.isLastRow = function (cell) {
        var LastRow = [].slice.call(sf.base.closest(cell, 'tbody').querySelectorAll('.e-row:not(.e-hiddenrow)'));
        return LastRow[LastRow.length - 1] == cell.parentElement;
    };
    Selection.prototype.isFirstRow = function (cell) {
        var rows = [].slice.call(sf.base.closest(cell, 'tbody').querySelectorAll('.e-row:not(.e-hiddenrow)'));
        return cell.parentElement === rows[0];
    };
    Selection.prototype.isFirstCell = function (cell) {
        var cells = [].slice.call(cell.parentElement.querySelectorAll('.e-rowcell:not(.e-hide)'));
        return cells[0] === cell;
    };
    Selection.prototype.performDragSelection = function (startIndex, endIndex, clearIndex) {
        var sIndex = startIndex;
        var eIndex = endIndex;
        if (startIndex > endIndex) {
            sIndex = endIndex;
            eIndex = startIndex;
        }
        if (clearIndex != -1) {
            this.clearSelectionExceptDragIndexes(sIndex, eIndex);
        }
        this.selectRangeOfRows(sIndex, eIndex);
    };
    Selection.prototype.selectRangeOfRows = function (startIndex, endIndex) {
        var rows = this.parent.getRows();
        for (var i = startIndex; i <= endIndex; i++) {
            if (!sf.base.isNullOrUndefined(rows[i])) {
                rows[i].setAttribute('aria-selected', 'true');
                var cells = [].slice.call(rows[i].querySelectorAll('.e-rowcell'));
                addRemoveActiveClasses.apply(void 0, [cells, true].concat(['e-aria-selected', 'e-active']));
            }
        }
    };
    Selection.prototype.clearSelectionByRow = function (row) {
        var cells = [].slice.call(row.querySelectorAll('.e-rowcell'));
        row.removeAttribute('aria-selected');
        addRemoveActiveClasses.apply(void 0, [cells, false].concat(['e-aria-selected', 'e-active']));
    };
    Selection.prototype.clearSelectionExceptDragIndexes = function (startIndex, endIndex) {
        var rows = this.parent.getRows();
        for (var i = 0; i < rows.length; i++) {
            if (i < startIndex || i > endIndex) {
                this.clearSelectionByRow(rows[i]);
            }
        }
    };
    Selection.prototype.isRowType = function () {
        return this.parent.options.selectionMode === 'Row' || this.parent.options.selectionMode === 'Both';
    };
    Selection.prototype.isSingleSel = function () {
        return this.parent.options.selectionType === 'Single';
    };
    return Selection;
}());

/**
 * InterSectionObserver - class watch whether it enters the viewport.
 * @hidden
 */
var InterSectionObserver = /** @class */ (function () {
    function InterSectionObserver(element, options) {
        var _this = this;
        this.fromWheel = false;
        this.touchMove = false;
        /** @hidden */
        this.options = {};
        this.sentinelInfo = {
            'up': {
                check: function (rect, info) {
                    var top = rect.top - _this.containerRect.top;
                    info.entered = top >= 0;
                    return top + (_this.options.pageHeight / 2) >= 0;
                },
                axis: 'Y'
            },
            'down': {
                check: function (rect, info) {
                    var cHeight = _this.options.container.clientHeight;
                    var top = rect.bottom;
                    info.entered = rect.bottom <= _this.containerRect.bottom;
                    return top - (_this.options.pageHeight / 2) <= _this.options.pageHeight / 2;
                }, axis: 'Y'
            },
            'right': {
                check: function (rect, info) {
                    var right = rect.right;
                    info.entered = right < _this.containerRect.right;
                    return right - _this.containerRect.width <= _this.containerRect.right;
                }, axis: 'X'
            },
            'left': {
                check: function (rect, info) {
                    var left = rect.left;
                    info.entered = left > 0;
                    return left + _this.containerRect.width >= _this.containerRect.left;
                }, axis: 'X'
            }
        };
        this.element = element;
        this.options = options;
    }
    InterSectionObserver.prototype.observe = function (callback, onEnterCallback) {
        var _this = this;
        this.containerRect = this.options.container.getBoundingClientRect();
        sf.base.EventHandler.add(this.options.container, 'wheel', function () { return _this.fromWheel = true; }, this);
        sf.base.EventHandler.add(this.options.container, 'scroll', this.virtualScrollHandler(callback, onEnterCallback), this);
        if (!sf.base.isNullOrUndefined(parentsUntil(this.element, 'e-gridcontent').querySelector('.e-movablescrollbar'))) {
            sf.base.EventHandler.add(parentsUntil(this.element, 'e-gridcontent').querySelector('.e-movablescrollbar'), 'scroll', this.virtualScrollHandler(callback, onEnterCallback), this);
        }
    };
    InterSectionObserver.prototype.check = function (direction) {
        var info = this.sentinelInfo[direction];
        return info.check(this.element.getBoundingClientRect(), info);
    };
    InterSectionObserver.prototype.virtualScrollHandler = function (callback, onEnterCallback) {
        var _this = this;
        var delay = sf.base.Browser.info.name === 'chrome' ? 200 : 100;
        var prevTop = 0;
        var prevLeft = 0;
        var debounced100 = sf.base.debounce(callback, delay);
        var debounced50 = sf.base.debounce(callback, 50);
        return function (e) {
            var top = e.target.scrollTop;
            var left = e.target.scrollLeft;
            var direction = prevTop < top ? 'down' : 'up';
            var isHorizontalMove = e.target.classList.contains('e-movablescrollbar');
            var isLightScroll = true;
            direction = prevLeft === left ? direction : prevLeft < left ? 'right' : 'left';
            if (isHorizontalMove)
                direction = prevLeft < left ? 'right' : 'left';
            if (direction == 'down') {
                isLightScroll = (top - prevTop) < 30;
            }
            else if (direction == 'up') {
                isLightScroll = (prevTop - top) < 30;
            }
            else if (direction == 'right') {
                isLightScroll = (left - prevLeft) < 20;
            }
            else if (direction == 'left') {
                isLightScroll = (prevLeft - left) < 20;
            }
            prevTop = top;
            prevLeft = left;
            var current = _this.sentinelInfo[direction];
            if (_this.options.axes.indexOf(current.axis) === -1) {
                return;
            }
            var check = _this.check(direction);
            var isMaskRow = _this.options.container.querySelectorAll('.e-masked-row').length && current.axis != 'X';
            if (current.entered || ((sf.base.isNullOrUndefined(_this.blazorActiveKey) || _this.blazorActiveKey == '') && !_this.fromWheel && isMaskRow)) {
                onEnterCallback(_this.element, current, isLightScroll, direction, { top: top, left: left }, _this.fromWheel, check);
            }
            if (check || isMaskRow) {
                var fn = debounced100;
                //this.fromWheel ? this.options.debounceEvent ? debounced100 : callback : debounced100;
                if (current.axis === 'X') {
                    fn = debounced50;
                }
                fn({ direction: direction, sentinel: current, offset: { top: top, left: left },
                    focusElement: document.activeElement });
            }
            if (!isMaskRow)
                _this.fromWheel = false;
        };
    };
    InterSectionObserver.prototype.setPageHeight = function (value) {
        this.options.pageHeight = value;
    };
    return InterSectionObserver;
}());

/**
 * VirtualContentRenderer
 * @hidden
 */
var VirtualContentRenderer = /** @class */ (function () {
    function VirtualContentRenderer(parent) {
        var _this_1 = this;
        this.prevHeight = 0;
        this.preStartIndex = 0;
        this.preventEvent = false;
        this.actions = ['filtering', 'searching', 'grouping', 'ungrouping', 'Filtering', 'Searching', 'Grouping', 'Ungrouping', 'UnGrouping'];
        this.offsets = {};
        this.tmpOffsets = {};
        this.offsetKeys = [];
        this.currentInfo = {};
        this.blazorActiveKey = '';
        this.nextRowToNavigate = 0;
        /** @hidden */
        this.startIndex = 0;
        this.bindScrollEvent = function () {
            _this_1.observer.observe(function (scrollArgs) { return _this_1.scrollListener(scrollArgs); }, _this_1.onEntered());
            var gObj = _this_1.parent;
            if (gObj.options.enablePersistence && gObj.scrollPosition) {
                _this_1.content.scrollTop = gObj.scrollPosition.top;
                var scrollValues = { direction: 'down', sentinel: _this_1.observer.sentinelInfo.down,
                    offset: gObj.scrollPosition, focusElement: gObj.element };
                _this_1.scrollListener(scrollValues);
                if (gObj.options.enableColumnVirtualization) {
                    _this_1.content.scrollLeft = gObj.scrollPosition.left;
                }
            }
        };
        this.parent = parent;
        this.contentPanel = this.parent.element.querySelector(".e-gridcontent");
        this.vHelper = new VirtualHelper(parent);
        this.virtualEle = new VirtualElementHandler(parent);
        this.addEventListener();
    }
    /**
     * Get the header content div element of grid
     * @return {Element}
     */
    VirtualContentRenderer.prototype.getPanel = function () {
        return this.contentPanel;
    };
    /**
     * Get the header table element of grid
     * @return {Element}
     */
    VirtualContentRenderer.prototype.getTable = function () {
        return this.contentPanel.querySelector('.e-table');
    };
    VirtualContentRenderer.prototype.renderTable = function () {
        this.header = this.parent.virtualHeaderModule;
        this.virtualEle.table = this.getTable();
        this.virtualEle.content = this.content = this.getPanel().querySelector('.e-content');
        this.virtualEle.renderWrapper(Number(this.parent.options.height));
        this.virtualEle.renderPlaceHolder();
        var content = this.content;
        var opt = {
            container: content, pageHeight: this.getBlockHeight() * 2, debounceEvent: true,
            axes: this.parent.options.enableColumnVirtualization ? ['X', 'Y'] : ['Y']
        };
        this.observer = new InterSectionObserver(this.virtualEle.wrapper, opt);
        this.parent.dotNetRef.invokeMethodAsync("SetRowHeight", this.parent.getRowHeight());
    };
    VirtualContentRenderer.prototype.addEventListener = function () {
        sf.base.EventHandler.add(this.parent.element, 'keydown', this.keyDownHandler, this);
    };
    VirtualContentRenderer.prototype.removeEventListener = function () {
        sf.base.EventHandler.remove(this.parent.element, 'keydown', this.keyDownHandler);
    };
    VirtualContentRenderer.prototype.ensurePageSize = function () {
        var rowHeight = this.parent.getRowHeight();
        var vHeight = this.parent.options.height.toString().indexOf('%') < 0 ? this.parent.options.height :
            this.parent.element.getBoundingClientRect().height;
        var blockSize = ~~(vHeight / rowHeight);
        var height = blockSize * 2;
        var size = this.parent.options.pageSize;
        var actualPageSize = size < height ? height : size;
        this.parent.dotNetRef.invokeMethodAsync("SetPageSizeAndCIndex", {
            pageSize: actualPageSize,
            startColumnIndex: this.startColIndex,
            endColumnIndex: this.endColIndex,
            VTableWidth: this.getColumnOffset(this.endColIndex) - this.getColumnOffset(this.startColIndex - 1) + ''
        });
        this.parent.options.pageSize = actualPageSize;
        this.observer.options.pageHeight = this.getBlockHeight() * 2;
    };
    VirtualContentRenderer.prototype.scrollListener = function (scrollArgs) {
        var _this = this;
        if (this.parent.options.enablePersistence) {
            this.parent.scrollPosition = scrollArgs.offset;
        }
        if (this.preventEvent) {
            this.preventEvent = false;
            return;
        }
        // if (this.preventEvent || this.parent.isDestroyed) { this.preventEvent = false; return; }
        var info = scrollArgs.sentinel;
        var pStartIndex = this.preStartIndex;
        var previousColIndexes = this.parent.getColumnIndexesInView();
        var viewInfo = this.currentInfo = this.getInfoFromView(scrollArgs.direction, info, scrollArgs.offset);
        if (this.parent.options.enableColumnVirtualization &&
            (JSON.stringify(previousColIndexes) !== JSON.stringify(viewInfo.columnIndexes))) {
            var translateX = this.getColumnOffset(this.startColIndex - 1);
            var width_1 = this.getColumnOffset(this.endColIndex) - translateX + '';
            setTimeout(function () {
                _this.parent.dotNetRef.invokeMethodAsync("VirtualRefresh", {
                    requestType: 'virtualscroll',
                    startColumnIndex: viewInfo.columnIndexes[0],
                    endColumnIndex: viewInfo.columnIndexes[viewInfo.columnIndexes.length - 1],
                    axis: 'X',
                    VTablewidth: width_1,
                    translateX: _this.getColumnOffset(viewInfo.columnIndexes[0] - 1),
                    translateY: _this.parent.options.enableVirtualMaskRow ? _this.parent.options.frozenColumns ? _this.movableTranslateY : _this.translateMaskY + _this.movableTranslateY : 0
                });
            }, 0);
            if (!this.parent.options.frozenColumns) {
                this.setColVTableWidthAndTranslate();
            }
        }
        else {
            this.virtualEle.movableAdjustTable(this.getColumnOffset(viewInfo.columnIndexes[0] - 1), 0);
            this.header.virtualEle.movableAdjustTable(this.getColumnOffset(viewInfo.columnIndexes[0] - 1), 0);
        }
        this.parent.setColumnIndexesInView(this.parent.options.enableColumnVirtualization ? viewInfo.columnIndexes : []);
        this.nextRowToNavigate = this.blazorActiveKey != '' ? this.nextRowToNavigate : 0;
        if (this.preStartIndex !== pStartIndex) {
            this.parent.options.currentPage = viewInfo.currentPage;
            setTimeout(function () {
                _this.parent.dotNetRef.invokeMethodAsync("VirtualRefresh", {
                    requestType: 'virtualscroll',
                    nextRowToNavigate: _this.nextRowToNavigate,
                    virtualStartIndex: viewInfo.startIndex,
                    virtualEndIndex: viewInfo.endIndex,
                    axis: 'Y',
                    RHeight: _this.parent.getRowHeight()
                });
            }, 0);
        }
        this.prevInfo = viewInfo;
        this.blazorActiveKey = '';
    };
    VirtualContentRenderer.prototype.setColVTableWidthAndTranslate = function (args) {
        if (this.parent.options.enableColumnVirtualization && this.prevInfo &&
            (JSON.stringify(this.currentInfo.columnIndexes) !==
                JSON.stringify(this.prevInfo.columnIndexes)) || ((args && args.refresh))) {
            var translateX = this.getColumnOffset(this.startColIndex - 1);
            var width = this.getColumnOffset(this.endColIndex) - translateX + '';
            if (this.parent.options.frozenColumns != 0) {
                this.virtualEle.movableContentWrapper.style.width = width;
                this.header.virtualEle.movableHeaderWrapper.style.width = width;
                this.header.virtualEle.movableAdjustTable(this.movableTranslateX, this.movableTranslateY);
                this.virtualEle.movableAdjustTable(this.movableTranslateX, this.movableTranslateY);
            }
            else {
                this.header.virtualEle.setWrapperWidth(width);
                this.virtualEle.setWrapperWidth(width);
                this.header.virtualEle.adjustTable(translateX, 0);
                this.parent.getContentTable().parentElement.style.width = width + 'px';
            }
        }
    };
    VirtualContentRenderer.prototype.refreshOnDataChange = function () {
        this.getPanel().firstElementChild.scrollTop = 0;
        this.getPanel().firstElementChild.scrollLeft = 0;
        if (this.parent.options.enableColumnVirtualization) {
            this.header.virtualEle.adjustTable(0, 0);
        }
        this.virtualEle.adjustTable(0, 0);
        this.refreshOffsets();
        this.refreshVirtualElement();
    };
    // private block(blk: number): boolean {
    //     return this.vHelper.isBlockAvailable(blk);
    // }
    VirtualContentRenderer.prototype.keyDownHandler = function (e) {
        this.blazorActiveKey = (e.key === 'ArrowDown' || e.key === 'ArrowUp') ? e.key : '';
        if (!sf.base.isNullOrUndefined(this.observer))
            this.observer.blazorActiveKey = this.blazorActiveKey;
    };
    VirtualContentRenderer.prototype.focusCell = function (cell, action) {
        cell.focus({ preventScroll: true });
        var rowHeight = this.parent.getRowHeight();
        var content = this.parent.getContent();
        if (action == "MoveDownCell" && cell.getBoundingClientRect().bottom > content.getBoundingClientRect().top +
            content.getBoundingClientRect().height - getScrollBarWidth()) {
            content.scrollTop = content.scrollTop + rowHeight;
        }
        else if (action == "MoveUpCell" &&
            cell.getBoundingClientRect().bottom < content.getBoundingClientRect().top + rowHeight) {
            this.isScrollFromFocus = true;
            content.scrollTop = content.scrollTop - rowHeight;
        }
    };
    VirtualContentRenderer.prototype.getInfoFromView = function (direction, info, e) {
        var infoType = { direction: direction, sentinelInfo: info, offsets: e,
            startIndex: this.preStartIndex, endIndex: this.preEndIndex };
        var vHeight = this.parent.options.height.toString().indexOf('%') < 0 ? this.content.getBoundingClientRect().height :
            this.parent.element.getBoundingClientRect().height;
        infoType.page = this.getPageFromTop(e.top + vHeight, infoType);
        infoType.blockIndexes = this.vHelper.getBlockIndexes(infoType.page);
        // infoType.blockIndexes = tempBlocks = this.vHelper.getBlockIndexes(infoType.page);
        // infoType.loadSelf = !this.vHelper.isBlockAvailable(tempBlocks[infoType.block]);
        // let blocks: number[] = this.ensureBlocks(infoType);
        // if (this.activeKey === 'upArrow' && infoType.blockIndexes.toString() !== blocks.toString()) {
        //     // To avoid dupilcate row index problem in key focus support
        //     let newBlock: number = blocks[blocks.length - 1];
        //     if (infoType.blockIndexes.indexOf(newBlock) === -1) {
        //         isBlockAdded = true;
        //     }
        // }
        // infoType.blockIndexes = blocks;
        // infoType.loadNext = !blocks.filter((val: number) => tempBlocks.indexOf(val) === -1)
        //     .every(this.block.bind(this));
        // infoType.event = (infoType.loadNext || infoType.loadSelf) ? 'modelChanged' : 'refreshVirtualBlock';
        // if (isBlockAdded) {
        //     infoType.blockIndexes = [infoType.blockIndexes[0] - 1, infoType.blockIndexes[0], infoType.blockIndexes[0] + 1];
        // }
        infoType.columnIndexes = info.axis === 'X' ? this.vHelper.getColumnIndexes() : this.parent.getColumnIndexesInView();
        //Row Start and End Index calculation
        var rowHeight = this.parent.getRowHeight();
        var exactTopIndex = e.top / rowHeight;
        var noOfInViewIndexes = vHeight / rowHeight;
        var exactEndIndex = exactTopIndex + noOfInViewIndexes;
        var pageSizeBy4 = this.parent.options.pageSize / 4;
        var totalCount = this.parent.options.groupCount ? this.getVisibleGroupedRowCount() : this.count;
        if (infoType.direction === 'down' && !this.isScrollFromFocus) {
            var sIndex = Math.round(exactEndIndex) - Math.round((pageSizeBy4));
            if (this.parent.options.enableVirtualMaskRow) {
                noOfInViewIndexes = Math.ceil(noOfInViewIndexes) - 1;
                var differenceOfRowIndex = Math.ceil(exactTopIndex) - this.preStartIndex;
                if (differenceOfRowIndex >= noOfInViewIndexes) {
                    infoType.startIndex = Math.ceil(exactTopIndex) >= 0 ? Math.ceil(exactTopIndex) : 0;
                    var eIndex = infoType.startIndex + this.parent.options.pageSize;
                    infoType.endIndex = eIndex < totalCount ? eIndex : totalCount;
                    infoType.startIndex = eIndex >= totalCount ? infoType.endIndex - this.parent.options.pageSize : infoType.startIndex;
                    infoType.currentPage = Math.ceil(infoType.endIndex / this.parent.options.pageSize);
                    this.nextRowToNavigate = Math.floor(exactEndIndex - 1);
                    this.isScrollFromFocus = false;
                    this.preStartIndex = this.startIndex = infoType.startIndex;
                    this.preEndIndex = infoType.endIndex;
                }
                else {
                    this.isScrollFromFocus = false;
                    this.preStartIndex = this.preStartIndex;
                    this.preEndIndex = this.preEndIndex;
                }
            }
            if (!this.parent.options.enableVirtualMaskRow && sf.base.isNullOrUndefined(infoType.startIndex) || (exactEndIndex >
                (infoType.startIndex + Math.round((this.parent.options.pageSize / 2 + pageSizeBy4)))
                && infoType.endIndex !== totalCount)) {
                infoType.startIndex = sIndex >= 0 ? Math.round(sIndex) : 0;
                infoType.startIndex = infoType.startIndex > exactTopIndex ? Math.floor(exactTopIndex) : infoType.startIndex;
                var eIndex = infoType.startIndex + this.parent.options.pageSize;
                infoType.startIndex = eIndex < exactEndIndex ? (Math.ceil(exactEndIndex) - this.parent.options.pageSize)
                    : infoType.startIndex;
                infoType.endIndex = eIndex < totalCount ? eIndex : totalCount;
                infoType.startIndex = eIndex >= totalCount ? (infoType.endIndex - this.parent.options.pageSize > 0 ? infoType.endIndex - this.parent.options.pageSize : 0) : infoType.startIndex;
                infoType.currentPage = Math.ceil(infoType.endIndex / this.parent.options.pageSize);
                this.nextRowToNavigate = Math.floor(exactEndIndex - 1);
            }
        }
        else if (infoType.direction === 'up') {
            if (infoType.startIndex && infoType.endIndex || this.parent.options.enableVirtualMaskRow) {
                var loadAtIndex = Math.round(((infoType.startIndex * rowHeight) + (pageSizeBy4 * rowHeight)) / rowHeight);
                if (this.parent.options.enableVirtualMaskRow) {
                    noOfInViewIndexes = Math.ceil(noOfInViewIndexes);
                    if (exactTopIndex < loadAtIndex || Math.ceil(exactTopIndex) > this.preStartIndex) {
                        var startIndex = Math.ceil(exactTopIndex) > 0 ? Math.ceil(exactTopIndex) : 0;
                        var customStartIndex = totalCount - this.parent.options.pageSize - (this.parent.options.pageSize / 2);
                        if (exactTopIndex < totalCount && customStartIndex < exactTopIndex) {
                            infoType.startIndex = startIndex > 0 ? startIndex - (this.parent.options.pageSize / 2) : 0;
                        }
                        else {
                            infoType.startIndex = startIndex > 0 ? startIndex + this.parent.options.pageSize > totalCount ? totalCount - this.parent.options.pageSize : startIndex : 0;
                        }
                        infoType.startIndex = infoType.startIndex > 0 ? infoType.startIndex - 1 : infoType.startIndex;
                        var eIndex = infoType.startIndex + this.parent.options.pageSize;
                        infoType.endIndex = infoType.startIndex < 0 ? this.parent.options.pageSize : eIndex < totalCount ? eIndex : totalCount;
                        infoType.currentPage = Math.ceil(infoType.startIndex / this.parent.options.pageSize);
                        this.nextRowToNavigate = Math.ceil(exactTopIndex + 1);
                        this.isScrollFromFocus = false;
                        this.preStartIndex = this.startIndex = infoType.startIndex;
                        this.preEndIndex = infoType.endIndex;
                    }
                    else {
                        this.isScrollFromFocus = false;
                        this.preStartIndex = this.preStartIndex;
                        this.preEndIndex = this.preEndIndex;
                    }
                }
                if (exactTopIndex < loadAtIndex && !this.parent.options.enableVirtualMaskRow) {
                    var idxAddedToExactTop = (pageSizeBy4) > noOfInViewIndexes ? pageSizeBy4 :
                        (noOfInViewIndexes + noOfInViewIndexes / 4);
                    var eIndex = Math.round(exactTopIndex + idxAddedToExactTop);
                    infoType.endIndex = eIndex < totalCount ? eIndex : totalCount;
                    var sIndex = infoType.endIndex - this.parent.options.pageSize;
                    infoType.startIndex = sIndex > 0 ? sIndex : 0;
                    infoType.endIndex = sIndex < 0 ? this.parent.options.pageSize : infoType.endIndex;
                    infoType.currentPage = Math.ceil(infoType.startIndex / this.parent.options.pageSize);
                    this.nextRowToNavigate = Math.ceil(exactTopIndex + 1);
                }
            }
        }
        if (!this.parent.options.enableVirtualMaskRow) {
            this.isScrollFromFocus = false;
            this.preStartIndex = this.startIndex = infoType.startIndex;
            this.preEndIndex = infoType.endIndex;
        }
        return infoType;
    };
    VirtualContentRenderer.prototype.onDataReady = function () {
        var _this_1 = this;
        var _this = this;
        this.bindScrollEvent();
        this.count = this.parent.options.totalItemCount;
        this.maxPage = Math.ceil(this.count / this.parent.options.pageSize);
        // this.vHelper.checkAndResetCache(this.parent.options.requestType);
        if (['Refresh', 'Filtering', 'Searching', 'Grouping', 'Ungrouping', 'Reorder',
            'refresh', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', "GroupExpandCollapse", null]
            .some(function (value) { return _this_1.parent.options.requestType === value; })) {
            this.refreshOffsets();
        }
        this.setVirtualHeight();
        this.resetScrollPosition(this.parent.options.requestType);
        this.setColVTableWidthAndTranslate();
        if (this.parent.options.enableVirtualMaskRow) {
            var yValue_1 = Math.min(Math.ceil(this.virtualEle.content.scrollTop), this.offsets[this.maxBlock]);
            yValue_1 = yValue_1.toString() == "NaN" ? 0 : yValue_1;
            if (yValue_1 == 0)
                yValue_1 = yValue_1 - (this.parent.options.pageSize * (this.parent.options.rowHeight ? this.parent.options.rowHeight : 36));
            else
                yValue_1 = yValue_1 - (this.parent.options.pageSize * (this.parent.options.rowHeight ? this.parent.options.rowHeight : 36)) - 10;
            setTimeout(function () {
                _this.translateMaskY = yValue_1;
                _this.translateMaskX = sf.base.isNullOrUndefined(_this.translateMaskX) ? 0 : _this.translateMaskX;
                if (_this.parent.options.frozenColumns == 0)
                    _this.virtualEle.wrapper.style.transform = "translate(" + _this.translateMaskX + "px," + yValue_1 + "px)";
                else
                    _this.virtualEle.wrapper.style.transform = "translate(0px," + yValue_1 + "px)";
            }, 0);
        }
        this.prevInfo = this.prevInfo ? this.prevInfo : this.vHelper.getData();
    };
    /** @hidden */
    VirtualContentRenderer.prototype.setVirtualHeight = function () {
        var width = this.parent.options.enableColumnVirtualization ?
            this.getColumnOffset(this.parent.options.columns.length + this.parent.options.groupCount - 1) + 'px' : '100%';
        var differenceBlocks = this.parent.options.enableColumnVirtualization ? (this.parent.options.enableVirtualMaskRow ? 4 : 2) : 0;
        var virtualHeight = this.parent.options.groupCount
            ? (this.parent.options.visibleGroupedRowsCount * this.parent.getRowHeight()) : this.offsets[this.getTotalBlocks() - differenceBlocks];
        this.virtualEle.setVirtualHeight(virtualHeight, width);
        if (this.parent.options.enableColumnVirtualization) {
            this.header.virtualEle.setVirtualHeight(1, width);
        }
    };
    VirtualContentRenderer.prototype.getPageFromTop = function (sTop, info) {
        var _this_1 = this;
        var total = (isGroupAdaptive(this.parent)) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();
        var page = 0;
        var extra = this.offsets[total] - this.prevHeight;
        this.offsetKeys.some(function (offset) {
            var iOffset = Number(offset);
            var border = sTop <= _this_1.offsets[offset] || (iOffset === total && sTop > _this_1.offsets[offset]);
            if (border) {
                info.block = iOffset % 2 === 0 ? 1 : 0;
                page = Math.max(1, Math.min(_this_1.vHelper.getPage(iOffset), _this_1.maxPage));
            }
            return border;
        });
        return page;
    };
    VirtualContentRenderer.prototype.getTranslateY = function (sTop, cHeight, info, isOnenter) {
        if (info === undefined) {
            info = { page: this.getPageFromTop(sTop + cHeight, {}) };
            info.blockIndexes = this.vHelper.getBlockIndexes(info.page);
        }
        var block = (info.blockIndexes[0] || 1) - 1;
        var translate = this.getOffset(block);
        var endTranslate = this.getOffset(info.blockIndexes[info.blockIndexes.length - 1]);
        if (isOnenter) {
            info = this.prevInfo;
        }
        var result = translate > sTop ?
            this.getOffset(block - 1) : endTranslate < (sTop + cHeight) ? this.getOffset(block + 1) : translate;
        var blockHeight = this.offsets[info.blockIndexes[info.blockIndexes.length - 1]] -
            this.tmpOffsets[info.blockIndexes[0]];
        if (result + blockHeight > this.offsets[isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks()] && this.parent.options.groupCount == 0) {
            result -= (result + blockHeight) - this.offsets[this.getTotalBlocks()];
        }
        return result;
    };
    VirtualContentRenderer.prototype.getOffset = function (block) {
        return Math.min(this.offsets[block] | 0, this.offsets[this.maxBlock] | 0);
    };
    VirtualContentRenderer.prototype.onEntered = function () {
        var _this_1 = this;
        return function (element, current, isLightScroll, direction, e, isWheel, check) {
            if (sf.base.Browser.isIE && !isWheel && check && !_this_1.preventEvent) {
                //ToDo
                //this.parent.showSpinner();
            }
            var xAxis = current.axis === 'X';
            var top = _this_1.prevInfo.offsets ? _this_1.prevInfo.offsets.top : null;
            var height = _this_1.content.getBoundingClientRect().height;
            var x = _this_1.getColumnOffset(xAxis ? _this_1.vHelper.getColumnIndexes()[0] - 1 : _this_1.prevInfo.columnIndexes[0] - 1);
            var y = _this_1.getTranslateY(e.top, height, xAxis && top === e.top ? _this_1.prevInfo : undefined, true);
            if (_this_1.currentInfo && _this_1.currentInfo.startIndex && xAxis) {
                y = _this_1.currentInfo.startIndex * _this_1.parent.getRowHeight();
            }
            _this_1.movableTranslateX = _this_1.vHelper.cOffsets[_this_1.startColIndex - 1] ? _this_1.vHelper.cOffsets[_this_1.startColIndex - 1] : x;
            _this_1.movableTranslateY = _this_1.parent.options.pageSize * _this_1.parent.options.rowHeight;
            if (!_this_1.parent.options.enableVirtualMaskRow) {
                if (_this_1.parent.options.frozenColumns) {
                    _this_1.virtualEle.movableAdjustTable(_this_1.movableTranslateX, Math.min(y, _this_1.offsets[_this_1.maxBlock]));
                    _this_1.header.virtualEle.movableAdjustTable(_this_1.movableTranslateX, Math.min(y, _this_1.offsets[_this_1.maxBlock]));
                }
                _this_1.virtualEle.adjustTable(_this_1.movableTranslateX, Math.min(y, _this_1.offsets[_this_1.maxBlock]));
            }
            else if (_this_1.offsets[_this_1.maxBlock] > y) {
                if (direction == "right" || direction == "left") {
                    _this_1.header.virtualEle.movableAdjustTable(_this_1.movableTranslateX, 0);
                    _this_1.virtualEle.movableAdjustTable(_this_1.movableTranslateX, _this_1.movableTranslateY);
                    if (!_this_1.parent.options.frozenColumns) {
                        _this_1.virtualEle.adjustTable(_this_1.movableTranslateX, _this_1.translateMaskY + _this_1.movableTranslateY);
                    }
                }
                else {
                    var differenceBlocks = _this_1.parent.options.enableColumnVirtualization ? (_this_1.parent.options.enableVirtualMaskRow ? 4 : 2) : 0;
                    _this_1.virtualEle.adjustTable(x, Math.min(isLightScroll ? _this_1.translateMaskY : (direction !== 'up' ? y - (2 * _this_1.movableTranslateY) : y), _this_1.offsets[_this_1.maxBlock - differenceBlocks]));
                }
            }
            if (xAxis && !_this_1.parent.options.frozenColumns) {
                _this_1.setColVTableWidthAndTranslate({ refresh: true });
            }
        };
    };
    VirtualContentRenderer.prototype.getBlockSize = function () {
        return this.parent.options.pageSize >> 1;
    };
    VirtualContentRenderer.prototype.getBlockHeight = function () {
        return this.getBlockSize() * this.parent.getRowHeight();
    };
    VirtualContentRenderer.prototype.getGroupedTotalBlocks = function () {
        var visibleRowCount = this.getVisibleGroupedRowCount();
        return Math.floor((visibleRowCount / this.getBlockSize()) < 1 ? 1 : visibleRowCount / this.getBlockSize());
    };
    VirtualContentRenderer.prototype.getVisibleGroupedRowCount = function () {
        var visibleRowCount = Number(this.virtualEle.placeholder.style.height.substring(0, this.virtualEle.placeholder.style.height.indexOf('p'))) / this.parent.getRowHeight();
        return visibleRowCount;
    };
    VirtualContentRenderer.prototype.getTotalBlocks = function () {
        return Math.ceil(this.count / this.getBlockSize());
    };
    VirtualContentRenderer.prototype.getColumnOffset = function (block) {
        return this.vHelper.cOffsets[block] | 0;
    };
    VirtualContentRenderer.prototype.resetScrollPosition = function (action) {
        var lAction = !sf.base.isNullOrUndefined(action) ? action.toLowerCase() : action;
        if (this.actions.some(function (value) { return value === action; }) || (!sf.base.isNullOrUndefined(this.parent.options.initGroupingField) && this.parent.options.initGroupingField.length > 0 && !sf.base.isNullOrUndefined(lAction) && (lAction == 'sorting' || lAction == 'save' || lAction == 'delete'))) {
            var content = this.content;
            this.preventEvent = content.scrollTop !== 0;
            content.scrollTop = 0;
        }
    };
    /** @hidden */
    VirtualContentRenderer.prototype.refreshOffsets = function () {
        var gObj = this.parent;
        var row = 0;
        var bSize = this.getBlockSize();
        var total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();
        this.prevHeight = this.offsets[total];
        this.maxBlock = total % 2 === 0 ? total - 2 : total - 1;
        this.offsets = {};
        var vcRows = [];
        var cache = {};
        //Row offset update
        var blocks = Array.apply(null, Array(total)).map(function () { return ++row; });
        for (var i = 0; i < blocks.length; i++) {
            var tmp = (cache[blocks[i]] || []).length;
            var rem = !isGroupAdaptive(this.parent) ? this.count % bSize : (vcRows.length % bSize);
            var size = !isGroupAdaptive(this.parent) && blocks[i] in cache ?
                tmp * this.parent.getRowHeight() : rem && blocks[i] === total ? rem * this.parent.getRowHeight() :
                this.getBlockHeight();
            // let size: number = this.parent.groupSettings.columns.length && block in this.vHelper.cache ?
            // tmp * getRowHeight() : this.getBlockHeight();
            this.offsets[blocks[i]] = (this.offsets[blocks[i] - 1] | 0) + size;
            this.tmpOffsets[blocks[i]] = this.offsets[blocks[i] - 1] | 0;
        }
        this.offsetKeys = Object.keys(this.offsets);
        //Column offset update
        if (this.parent.options.enableColumnVirtualization) {
            this.vHelper.refreshColOffsets();
        }
    };
    VirtualContentRenderer.prototype.updateTransform = function (x, y) {
        var _this = this;
        setTimeout(function () {
            _this.translateMaskX = x;
            _this.virtualEle.adjustTable(x, _this.translateMaskY);
            _this.virtualEle.movableAdjustTable(_this.translateMaskX, 0);
            _this.header.virtualEle.movableAdjustTable(_this.translateMaskX, 0);
        }, 500);
    };
    VirtualContentRenderer.prototype.refreshColumnIndexes = function () {
        this.vHelper.refreshColOffsets();
        var colIndexes = this.vHelper.getColumnIndexes();
        this.parent.setColumnIndexesInView(colIndexes);
        this.parent.dotNetRef.invokeMethodAsync("SetColumnIndexes", colIndexes[0], colIndexes[colIndexes.length - 1]);
    };
    VirtualContentRenderer.prototype.refreshVirtualElement = function () {
        this.vHelper.refreshColOffsets();
        this.setVirtualHeight();
    };
    return VirtualContentRenderer;
}());
/**
 * @hidden
 */
var VirtualHeaderRenderer = /** @class */ (function () {
    function VirtualHeaderRenderer(parent) {
        this.parent = parent;
        this.vHelper = new VirtualHelper(this.parent);
        this.virtualEle = new VirtualElementHandler(this.parent);
        this.headerPanel = this.parent.element.querySelector(".e-gridheader");
    }
    /**
     * Get the header content div element of grid
     * @return {Element}
     */
    VirtualHeaderRenderer.prototype.getPanel = function () {
        return this.headerPanel;
    };
    /**
     * Get the header table element of grid
     * @return {Element}
     */
    VirtualHeaderRenderer.prototype.getTable = function () {
        return this.headerPanel.querySelector('.e-table');
    };
    VirtualHeaderRenderer.prototype.renderTable = function () {
        this.vHelper.refreshColOffsets();
        this.parent.setColumnIndexesInView(this.vHelper.getColumnIndexes(this.getPanel().querySelector('.e-headercontent')));
        this.virtualEle.table = this.getTable();
        this.virtualEle.content = this.getPanel().querySelector('.e-headercontent');
        this.virtualEle.content.style.position = 'relative';
        this.virtualEle.renderWrapper();
        this.virtualEle.renderPlaceHolder();
    };
    return VirtualHeaderRenderer;
}());
/**
 * @hidden
 */
var VirtualElementHandler = /** @class */ (function () {
    function VirtualElementHandler(parent) {
        this.parent = parent;
    }
    VirtualElementHandler.prototype.renderWrapper = function (height) {
        this.wrapper = this.content.querySelector('.e-virtualtable');
        this.wrapper.setAttribute('styles', "min-height:" + sf.base.formatUnit(height));
        if (this.content.querySelector('.e-movableheader')) {
            this.movableHeaderWrapper = this.content.querySelector('.e-movableheader').querySelector('.e-virtualtable');
        }
        if (this.content.querySelector('.e-movablecontent') != null) {
            this.movableContentWrapper = this.content.querySelector('.e-movablecontent').querySelector('.e-virtualtable');
        }
    };
    VirtualElementHandler.prototype.renderPlaceHolder = function () {
        this.placeholder = this.content.lastElementChild;
    };
    VirtualElementHandler.prototype.movableAdjustTable = function (xValue, yValue) {
        if (this.movableHeaderWrapper)
            this.movableHeaderWrapper.style.transform = "translate(" + xValue + "px, 0px)";
        if (this.parent.options.enableVirtualMaskRow && this.movableContentWrapper)
            this.movableContentWrapper.style.transform = "translate(" + xValue + "px, " + yValue + "px)";
        else if (this.movableContentWrapper)
            this.movableContentWrapper.style.transform = "translate(" + xValue + "px, 0px)";
    };
    VirtualElementHandler.prototype.adjustTable = function (xValue, yValue) {
        if (this.parent.options.frozenColumns != 0)
            this.wrapper.style.transform = "translate(0px, " + yValue + "px)";
        else
            this.wrapper.style.transform = "translate(" + xValue + "px, " + yValue + "px)";
    };
    VirtualElementHandler.prototype.setWrapperWidth = function (width, full) {
        this.wrapper.style.width = width ? width + "px" : full ? '100%' : '';
    };
    VirtualElementHandler.prototype.setVirtualHeight = function (height, width) {
        this.placeholder.style.height = height + "px";
        if (this.parent.options.frozenColumns)
            this.placeholder.style.width = '100%';
        else
            this.placeholder.style.width = width;
    };
    return VirtualElementHandler;
}());
/**
 * Content module is used to render grid content
 */
var VirtualHelper = /** @class */ (function () {
    function VirtualHelper(parent) {
        this.cOffsets = {};
        this.data = {};
        this.groups = {};
        this.parent = parent;
    }
    VirtualHelper.prototype.getBlockIndexes = function (page) {
        return [page + (page - 1), page * 2];
    };
    VirtualHelper.prototype.getPage = function (block) {
        return block % 2 === 0 ? block / 2 : (block + 1) / 2;
    };
    // public isBlockAvailable(value: number): boolean {
    //     // return value in this.cache;
    // }
    VirtualHelper.prototype.getData = function () {
        return {
            page: this.parent.options.currentPage,
            blockIndexes: this.getBlockIndexes(this.parent.options.currentPage),
            direction: 'down',
            columnIndexes: this.parent.getColumnIndexesInView()
        };
    };
    // private getStartIndex(blk: number, data: Object[], full: boolean = true): number {
    //     let page: number = this.getPage(blk); let even: boolean = blk % 2 === 0;
    //     let index: number = (page - 1) * this.model.pageSize;
    //     return full || !even ? index : index + ~~(this.model.pageSize / 2);
    // }
    VirtualHelper.prototype.getColumnIndexes = function (content) {
        var _this_1 = this;
        if (content === void 0) { content = this.parent.getHeaderContent(); }
        if (!sf.base.isNullOrUndefined(content.querySelector('.e-movableheader'))) {
            content = content.querySelector('.e-movableheader');
        }
        var indexes = [];
        var sLeft = content.scrollLeft | 0;
        var keys = Object.keys(this.cOffsets);
        var cWidth = this.parent.options.needClientAction ? content.getBoundingClientRect().width :
            Number(this.parent.options.width);
        sLeft = Math.min(this.cOffsets[keys.length - 1] - cWidth, sLeft);
        var calWidth = sf.base.Browser.isDevice ? 2 * cWidth : cWidth / 2;
        var left = sLeft + cWidth + (sLeft === 0 ? calWidth : 0);
        keys.some(function (offset, indx, input) {
            var iOffset = Number(offset);
            var offsetVal = _this_1.cOffsets[offset];
            var border = sLeft - calWidth <= offsetVal && left + calWidth >= offsetVal;
            if (border) {
                indexes.push(iOffset);
            }
            return left + calWidth < offsetVal;
        });
        this.parent.virtualContentModule.startColIndex = indexes[0];
        this.parent.virtualContentModule.endColIndex = indexes[indexes.length - 1];
        return indexes;
    };
    // public checkAndResetCache(action: string): boolean {
    //     let clear: boolean = ['paging', 'refresh', 'sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder',
    //                         'save', 'delete'].some((value: string) => action === value);
    //     if (clear) {
    //         this.cache = {}; this.data = {}; this.groups = {};
    //     }
    //     return clear;
    // }
    VirtualHelper.prototype.refreshColOffsets = function () {
        var col = 0;
        this.cOffsets = {};
        var gLen = this.parent.options.groupCount;
        var cols = this.parent.options.columns;
        var cLen = cols.length;
        // let isVisible: Function = (column: Column) => column.visible &&
        //     (!this.parent.options.showGroupedColumn ? this.parent.options.groupedColumns.indexOf(column.field) < 0 : column.visible);
        // let c: string[] = this.parent.options.groupedColumns || [];
        // for (let i: number = 0; i < c.length; i++) {
        //     this.cOffsets[i] = (this.cOffsets[i - 1] | 0) + 30;
        // }
        var blocks = Array.apply(null, Array(cLen)).map(function () { return col++; });
        for (var j = 0; j < blocks.length; j++) {
            blocks[j] = blocks[j] + gLen;
            this.cOffsets[blocks[j]] = (this.cOffsets[blocks[j] - 1] | 0) + (cols[j].visible ? parseInt(cols[j].width, 10) : 0);
        }
    };
    return VirtualHelper;
}());

/**
 * SfGrid client constructor
 */
var SfGrid = /** @class */ (function () {
    function SfGrid(element, options, dotnetRef) {
        var _this = this;
        this.columnModel = [];
        this.frozenColumnModel = [];
        this.frozenReorderColumnModel = [];
        this.inViewIndexes = [];
        this.isRendered = false;
        this.isGridFirstRender = false;
        this.tapEvent = function (e) {
            if (this.resizeModule.getUserAgent()) {
                if (!Global.timer) {
                    Global.timer = setTimeout(function () {
                        Global.timer = null;
                    }, 300);
                }
                else {
                    clearTimeout(Global.timer);
                    Global.timer = null;
                    var clickEvent = document.createEvent('MouseEvents');
                    clickEvent.initEvent('dblclick', true, true);
                    e.target.dispatchEvent(clickEvent);
                }
            }
        };
        this.element = element;
        if (sf.base.isNullOrUndefined(element)) {
            return;
        }
        if (!sf.base.isNullOrUndefined(element)) {
            this.element.blazor__instance = this;
        }
        this.dotNetRef = dotnetRef;
        this.options = options;
        this.header = this.element.querySelector('.e-headercontent');
        this.content = this.element.querySelector('.e-gridcontent .e-content');
        this.footer = this.element.querySelector('.e-summarycontent');
        if (this.element.offsetWidth <= 0) {
            var gridtimer_1 = setInterval(function () {
                if (_this.element.offsetWidth > 0) {
                    _this.initModules();
                    clearInterval(gridtimer_1);
                }
            }, 500);
        }
        else {
            this.initModules();
        }
        this.addScrollEvents(true);
    }
    SfGrid.prototype.initModules = function () {
        this.scrollModule = new Scroll(this);
        this.freezeModule = new Freeze(this);
        this.headerDragDrop = new HeaderDragDrop(this);
        this.contentDragDrop = new ContentDragDrop(this);
        this.reorderModule = new Reorder(this);
        this.groupModule = new Group(this);
        this.resizeModule = new Resize(this);
        this.editModule = new Edit(this);
        this.columnChooserModule = new ColumnChooser(this);
        this.clipboardModule = new Clipboard(this);
        this.columnMenuModule = new ColumnMenu(this);
        this.filterModule = new Filter(this);
        this.virtualContentModule = new VirtualContentRenderer(this);
        this.virtualHeaderModule = new VirtualHeaderRenderer(this);
        this.toolTipModule = new CustomToolTip(this);
        this.rowDragAndDropModule = new RowDD(this);
        this.selectionModule = new Selection(this);
        this.widthService = new ColumnWidthService(this);
        this.isRendered = this.options.isPrerendered;
        this.keyModule = new sf.base.KeyboardEvents(this.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: gridKeyConfigs,
            eventName: 'keydown'
        });
        if (this.options.enableColumnVirtualization) {
            this.virtualHeaderModule.renderTable();
        }
        if (this.options.enableVirtualization) {
            this.virtualContentModule.renderTable();
        }
        if (this.options.allowResizing) {
            this.resizeModule.render();
        }
        // needClientAction should only be used for virtual scroll and hideAtMedia features
        if (!this.options.needClientAction) {
            this.contentReady();
        }
        else {
            this.clientActions();
        }
        this.lastRowBorderCheck();
        this.wireEvents();
    };
    SfGrid.prototype.getHeaderContent = function () { return this.header; };
    SfGrid.prototype.getHeaderTable = function () { return this.header.querySelector('.e-table'); };
    SfGrid.prototype.getContent = function () { return this.content; };
    SfGrid.prototype.getContentTable = function () { return this.content.querySelector('.e-table'); };
    SfGrid.prototype.getFooterContent = function () { return this.footer; };
    SfGrid.prototype.getColumns = function (isRefresh) {
        // let inview: number[] = this.inViewIndexes.map((v: number) => v - this.groupSettings.columns.length).filter((v: number) => v > -1);
        // let vLen: number = inview.length;
        // if (!this.enableColumnVirtualization || isNullOrUndefined(this.columnModel) || this.columnModel.length === 0 || isRefresh) {
        //     this.columnModel = [];
        //     this.updateColumnModel(this.columns as Column[]);
        // }
        // let columns: Column[] = vLen === 0 ? this.columnModel :
        //     this.columnModel.slice(inview[0], inview[vLen - 1] + 1);
        this.columnModel = [];
        this.updateColumnModel(this.options.columns);
        return this.columnModel;
    };
    SfGrid.prototype.addScrollEvents = function (add) {
        if (this.options.showColumnMenu) {
            var elements = sf.popups.getScrollableParent(this.element);
            for (var i = 0; i < elements.length; i++) {
                if (elements[i] instanceof HTMLElement) {
                    add ? sf.base.EventHandler.add(elements[i], 'scroll', this.scrollHandler, this) :
                        sf.base.EventHandler.remove(elements[i], 'scroll', this.scrollHandler);
                }
            }
            add ? sf.base.EventHandler.add(this.content, 'scroll', this.scrollHandler, this) :
                sf.base.EventHandler.remove(this.content, 'scroll', this.scrollHandler);
        }
    };
    SfGrid.prototype.scrollHandler = function (e) {
        if (!sf.base.isNullOrUndefined(this.element) && !sf.base.isNullOrUndefined(this.element.blazor__instance)) {
            return this.element.blazor__instance.columnMenuModule.setPosition();
        }
    };
    SfGrid.prototype.updateColumnLevelFrozen = function () {
        var cols = this.columnModel;
        var leftCols = [];
        var rightCols = [];
        var movableCols = [];
        if (this.options.frozenRightCount != 0 || this.options.frozenLeftCount != 0) {
            for (var i = 0, len = cols.length; i < len; i++) {
                var col = cols[i];
                if (col.freeze === 'Left' && col.isFrozen) {
                    leftCols.push(col);
                }
                else if (col.freeze === 'Right' && col.isFrozen) {
                    rightCols.push(col);
                }
                else {
                    movableCols.push(col);
                }
            }
            this.frozenColumnModel = leftCols.concat(movableCols).concat(rightCols);
            this.frozenReorderColumnModel = leftCols.concat(rightCols).concat(movableCols);
        }
    };
    
    SfGrid.prototype.updateColumnModel = function (columns) {
        for (var i = 0, len = columns.length; i < len; i++) {
            if (columns[i].columns) {
                this.updateColumnModel(columns[i].columns);
            }
            else {
                this.columnModel.push(columns[i]);
            }
        }
        // this.updateFrozenColumns();
        // this.updateLockableColumns();
    };
    SfGrid.prototype.getColumnByIndex = function (index) {
        var column;
        this.getColumns().some(function (col, i) {
            column = col;
            return i === index;
        });
        return column;
    };
    SfGrid.prototype.getDataRows = function () {
        if (sf.base.isNullOrUndefined(this.getContentTable().querySelector('tbody'))) {
            return [];
        }
        var rows = [].slice.call(this.getContentTable().querySelector('tbody').children);
        if (this.options.frozenRows) {
            var freezeRows = [].slice.call(this.getHeaderTable().querySelector('tbody').children);
            rows = this.addMovableRows(freezeRows, rows);
        }
        var dataRows = this.generateDataRows(rows);
        return dataRows;
    };
    SfGrid.prototype.addMovableRows = function (fRows, mrows) {
        for (var i = 0, len = mrows.length; i < len; i++) {
            fRows.push(mrows[i]);
        }
        return fRows;
    };
    SfGrid.prototype.generateDataRows = function (rows) {
        var dRows = [];
        for (var i = 0, len = rows.length; i < len; i++) {
            if (rows[i].classList.contains('e-row') && !rows[i].classList.contains('e-hiddenrow')) {
                dRows.push(rows[i]);
            }
        }
        return dRows;
    };
    SfGrid.prototype.getMovableDataRows = function () {
        var rows = [].slice.call(this.getContent().querySelector('.e-movablecontent').querySelector('tbody').children);
        if (this.options.frozenRows) {
            var freezeRows = [].slice.call(this.getHeaderContent().querySelector('.e-movableheader').querySelector('tbody').children);
            rows = this.addMovableRows(freezeRows, rows);
        }
        var dataRows = this.generateDataRows(rows);
        return dataRows;
    };
    SfGrid.prototype.getFrozenDataRows = function () {
        var rows = [].slice.call(this.getContent().querySelector('.e-frozencontent').querySelector('tbody').children);
        if (this.options.frozenRows) {
            var freezeRows = [].slice.call(this.getHeaderContent().querySelector('.e-frozenheader').querySelector('tbody').children);
            rows = this.addMovableRows(freezeRows, rows);
        }
        var dataRows = this.generateDataRows(rows);
        return dataRows;
    };
    SfGrid.prototype.getRowByIndex = function (index) {
        return this.getDataRows()[index];
    };
    SfGrid.prototype.getCellFromIndex = function (rowIndex, columnIndex) {
        var frzCols = this.options.frozenColumns;
        return frzCols && columnIndex >= frzCols ?
            this.getMovableDataRows()[rowIndex] && this.getMovableDataRows()[rowIndex].querySelectorAll('.e-rowcell')[columnIndex - frzCols] :
            this.getDataRows()[rowIndex] && this.getDataRows()[rowIndex].querySelectorAll('.e-rowcell')[columnIndex];
    };
    SfGrid.prototype.getColumnHeaderByIndex = function (index) {
        return this.getHeaderTable().querySelectorAll('.e-headercell')[index];
    };
    SfGrid.prototype.getRows = function () {
        return this.options.frozenColumns ? this.getFrozenDataRows() : [].slice.call(this.getContentTable().querySelectorAll('tr.e-row[data-uid]'));
    };
    SfGrid.prototype.getSelectedRows = function () {
        return this.getRows().filter(function (row) { return row.getAttribute('aria-selected') === 'true'; });
    };
    SfGrid.prototype.getSelectedRowIndexes = function () {
        var selectedIndexes = [];
        var rows = this.getRows();
        for (var i = 0; i < rows.length; i++) {
            if (rows[i].hasAttribute('aria-selected') && rows[i].getAttribute('aria-selected') === "true") {
                selectedIndexes.push(i);
            }
        }
        return selectedIndexes;
    };
    SfGrid.prototype.getVisibleColumns = function () {
        var cols = [];
        for (var _i = 0, _a = this.columnModel; _i < _a.length; _i++) {
            var col = _a[_i];
            if (col.visible) {
                cols.push(col);
            }
        }
        return cols;
    };
    /**
     * Gets a Column by column name.
     * @param  {string} field - Specifies the column name.
     * @return {Column}
     * @blazorType GridColumn
     */
    SfGrid.prototype.getColumnByField = function (field) {
        return iterateArrayOrObject(this.getColumns(), function (item, index) {
            if (item.field === field) {
                return item;
            }
            return undefined;
        })[0];
    };
    /**
     * Gets a column index by column name.
     * @param  {string} field - Specifies the column name.
     * @return {number}
     */
    SfGrid.prototype.getColumnIndexByField = function (field) {
        var cols = this.getColumns();
        for (var i = 0; i < cols.length; i++) {
            if (cols[i].field === field) {
                return i;
            }
        }
        return -1;
    };
    /**
     * Gets a column by UID.
     * @param  {string} uid - Specifies the column UID.
     * @return {Column}
     * @blazorType GridColumn
     */
    SfGrid.prototype.getColumnByUid = function (uid) {
        return iterateArrayOrObject(this.getColumns().concat(this.getStackedColumns(this.options.columns)), function (item, index) {
            if (item.uid === uid) {
                return item;
            }
            return undefined;
        })[0];
    };
    /**
     * @hidden
     */
    SfGrid.prototype.getStackedColumns = function (columns, stackedColumn) {
        if (stackedColumn === void 0) { stackedColumn = []; }
        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
            var column = columns_1[_i];
            if (column.columns) {
                stackedColumn.push(column);
                this.getStackedColumns(column.columns, stackedColumn);
            }
        }
        return stackedColumn;
    };
    /**
     * Gets a column index by UID.
     * @param  {string} uid - Specifies the column UID.
     * @return {number}
     */
    SfGrid.prototype.getColumnIndexByUid = function (uid) {
        var index = iterateArrayOrObject(this.getColumns(), function (item, index) {
            if (item.uid === uid) {
                return index;
            }
            return undefined;
        })[0];
        return !sf.base.isNullOrUndefined(index) ? index : -1;
    };
    /**
     * Gets a column header by UID.
     * @param  {string} field - Specifies the column uid.
     * @return {Element}
     */
    SfGrid.prototype.getColumnHeaderByUid = function (uid) {
        return this.getHeaderContent().querySelector('[e-mappinguid=' + uid + ']').parentElement;
    };
    /**
     * Gets UID by column name.
     * @param  {string} field - Specifies the column name.
     * @return {string}
     */
    SfGrid.prototype.getUidByColumnField = function (field) {
        return iterateArrayOrObject(this.getColumns(), function (item, index) {
            if (item.field === field) {
                return item.uid;
            }
            return undefined;
        })[0];
    };
    SfGrid.prototype.getStackedHeaderColumnByHeaderText = function (stackedHeader, col) {
        for (var i = 0; i < col.length; i++) {
            var individualColumn = col[i];
            if (individualColumn.field === stackedHeader || individualColumn.headerText === stackedHeader) {
                this.stackedColumn = individualColumn;
                break;
            }
            else if (individualColumn.columns) {
                this.getStackedHeaderColumnByHeaderText(stackedHeader, individualColumn.columns);
            }
        }
        return this.stackedColumn;
    };
    /**
 * Gets TH index by column uid value.
 * @private
 * @param  {string} uid - Specifies the column uid.
 * @return {number}
 */
    SfGrid.prototype.getNormalizedColumnIndex = function (uid) {
        var index = this.getColumnIndexByUid(uid);
        return index + this.getIndentCount();
    };
    /**
    * Gets indent cell count.
    * @private
    * @return {number}
    */
    SfGrid.prototype.getIndentCount = function () {
        var index = 0;
        if (this.options.allowGrouping) {
            index += this.options.groupCount;
        }
        if (this.options.hasDetailTemplate) {
            index++;
        }
        if (this.options.allowRowDragAndDrop && !this.options.hasDropTarget) {
            index++;
        }
        /**
         * TODO: index normalization based on the stacked header, grouping and detailTemplate
         * and frozen should be handled here
         */
        return index;
    };
    /**
     * Gets indent Cell Width
     * @hidden
     */
    SfGrid.prototype.recalcIndentWidth = function () {
        if (!this.isRendered || !this.getHeaderTable().querySelector('.e-emptycell')) {
            return;
        }
        // Handle Detail and DragDrop
        if ((!this.options.groupCount && !this.options.hasDetailTemplate &&
            (this.options.allowRowDragAndDrop && this.options.hasDropTarget)) || !this.getContentTable()
            || this.getHeaderTable().querySelector('.e-emptycell').getAttribute("indentRefreshed")) {
            return;
        }
        var indentWidth = this.getHeaderTable().querySelector('.e-emptycell').parentElement.offsetWidth;
        var perPixel = indentWidth / 30;
        if (perPixel >= 1) {
            indentWidth = (30 / perPixel);
        }
        // if (this.enableColumnVirtualization || this.isAutoGen) { indentWidth = 30; }
        // if (this.isDetail()) {
        //     applyWidth(i, indentWidth);
        //     i++;
        // }
        // if (this.isRowDragable()) {
        //     applyWidth(i, indentWidth);
        // }
        this.getHeaderTable().querySelector('.e-emptycell').setAttribute('indentRefreshed', 'true');
        this.dotNetRef.invokeMethodAsync('SetIndentWidth', indentWidth + 'px');
    };
    SfGrid.prototype.resetColumnWidth = function () {
        if ((this.options.width === 'auto' || typeof (this.options.width) === 'string')
            && this.getColumns().filter(function (col) { return (!col.width || col.width === 'auto') && col.minWidth; }).length > 0) {
            var tgridWidth = this.widthService.getTableWidth(this.getColumns());
            this.widthService.setMinwidthBycalculation(tgridWidth);
        }
    };
    SfGrid.prototype.contentReady = function (action) {
        if (action === void 0) { action = null; }
        if (this.getColumns().some(function (x) { return x.autoFit; })) {
            this.resizeModule.autoFit();
        }
        if (this.options.allowResizing && this.isGridFirstRender && this.options.isColumnResized) {
            var widthService = new ColumnWidthService(this);
            widthService.setWidthToTable();
            this.isGridFirstRender = false;
        }
        if (this.options.frozenColumns) {
            this.freezeModule.refreshRowHeight();
            this.freezeModule.setFrozenHeight();
            if (this.options.aggregatesCount != 0) {
                var rowSummary = this.element.querySelectorAll('.e-summaryrow');
                var height = 0;
                for (var i = 0; i < rowSummary.length; i++) {
                    if (rowSummary[i].querySelectorAll('.e-templatecell').length > 0) {
                        height = rowSummary[i].offsetHeight;
                        break;
                    }
                }
                for (var i = 0; i < rowSummary.length; i++) {
                    rowSummary[i].style.height = height + "px";
                }
            }
            this.freezeModule.refreshStackedHdrHgt();
        }
        if (this.options.enableVirtualization) {
            this.virtualContentModule.onDataReady();
        }
        this.recalcIndentWidth();
        this.resetColumnWidth();
        this.lastRowBorderCheck();
        if (action === 'Paging') { //restore focus on paging.
            if (!parentsUntil(document.activeElement, 'e-grid')) {
                this.element.focus();
            }
        }
    };
    SfGrid.prototype.lastRowBorderCheck = function () {
        if (!this.options.enableVirtualization) {
            if (this.getContent().querySelector(".e-table").scrollHeight < this.getContent().clientHeight) {
                this.dotNetRef.invokeMethodAsync('LastRowBorder', true);
            }
            else {
                this.dotNetRef.invokeMethodAsync('LastRowBorder', false);
            }
        }
    };
    SfGrid.prototype.wireEvents = function () {
        sf.base.EventHandler.add(this.element, 'mousedown', this.mouseDownHandler, this);
        sf.base.EventHandler.add(this.element, 'focus', this.gridFocus, this);
        sf.base.EventHandler.add(document, 'click', this.documentClickHandler, this);
        sf.base.EventHandler.add(this.element, 'keydown', this.gridKeyDownHandler, this);
        sf.base.EventHandler.add(this.element, 'keydown', this.keyDownHandler, this);
        sf.base.EventHandler.add(document.body, 'keydown', this.documentKeyHandler, this);
        sf.base.EventHandler.add(this.getContent(), 'touchstart', this.tapEvent, this);
        if (this.options.allowEditing) {
            sf.base.EventHandler.add(this.element, 'dblclick', this.doubleClickHandler, this);
        }
    };
    SfGrid.prototype.unWireEvents = function () {
        sf.base.EventHandler.remove(this.element, 'mousedown', this.mouseDownHandler);
        sf.base.EventHandler.remove(this.element, 'focus', this.gridFocus);
        sf.base.EventHandler.remove(document, 'click', this.documentClickHandler);
        sf.base.EventHandler.remove(this.element, 'keydown', this.gridKeyDownHandler);
        sf.base.EventHandler.remove(this.element, 'keydown', this.keyDownHandler);
        sf.base.EventHandler.remove(document.body, 'keydown', this.documentKeyHandler);
        sf.base.EventHandler.remove(this.element, 'dblclick', this.doubleClickHandler);
        sf.base.EventHandler.remove(this.getContent(), 'touchstart', this.tapEvent);
    };
    SfGrid.prototype.doubleClickHandler = function (e) {
        if (e.target.tagName == 'TD') {
            e.target.blur();
        }
    };
    SfGrid.prototype.setOptions = function (newOptions, options) {
        var oldOptions = sf.base.extend(options, {});
        this.options = newOptions;
        if (!oldOptions.allowResizing && newOptions.allowResizing) {
            this.resizeModule.render();
        }
        if ((!oldOptions.allowGrouping && newOptions.allowGrouping)
            || (!oldOptions.allowReordering && newOptions.allowReordering) || newOptions.showDropArea) {
            this.headerDragDrop.initializeHeaderDrag();
            this.headerDragDrop.initializeHeaderDrop();
            this.groupModule.initializeGHeaderDrag();
            this.groupModule.initializeGHeaderDrop();
        }
        if (!oldOptions.allowGrouping && newOptions.allowGrouping) {
            this.contentDragDrop.initializeContentDrop();
        }
        if (!oldOptions.allowRowDragAndDrop && newOptions.allowRowDragAndDrop) {
            this.rowDragAndDropModule.initializeDrag();
        }
        else if (oldOptions.allowRowDragAndDrop && !newOptions.allowRowDragAndDrop) {
            this.rowDragAndDropModule.destroy();
        }
        if (!this.isRendered) {
            this.isRendered = this.options.isPrerendered;
        }
        if (oldOptions.groupCount != newOptions.groupCount) {
            var cell = this.getHeaderTable().querySelector('.e-emptycell');
            if (!cell) {
                return;
            }
            cell.removeAttribute('indentRefreshed');
        }
    };
    SfGrid.prototype.documentClickHandler = function (e) {
        var popupElement = parentsUntil(e.target, 'e-popup-open');
        var CCButton = parentsUntil(e.target, 'e-cc-toolbar');
        var datetimePicker = parentsUntil(e.target, 'e-datepicker');
        var daterangePicker = parentsUntil(e.target, 'e-daterangepicker') || parentsUntil(e.target, 'e-zoomin');
        var isBlankCheckbox = (e.target.classList.contains('e-check')) || (e.target.classList.contains('e-uncheck'));
        if (!this.options.enableAdaptiveUI && !popupElement && !datetimePicker && !daterangePicker && !(e.target.classList.contains('e-cc-cancel')) && !(e.target.classList.contains('e-choosercheck')) && !isBlankCheckbox && !(e.target.classList.contains('e-icon-filter')) && !CCButton && (this.element.querySelectorAll('.e-filter-popup.e-popup-open').length || this.element.querySelectorAll('.e-ccdlg.e-popup-open').length)) {
            if (this.element.querySelector('.e-datetimepicker') != null) {
                this.element.querySelector('.e-datetimepicker').blur();
            }
            this.dotNetRef.invokeMethodAsync('FilterPopupClose');
        }
    };
    SfGrid.prototype.documentKeyHandler = function (e) {
        //TODO: handle alt+w
        // 74 - J
        if (e.altKey && e.keyCode === 74 && !sf.base.isNullOrUndefined(this.element)) {
            this.element.focus();
            this.dotNetRef.invokeMethodAsync("GridFocus", e);
        }
    };
    SfGrid.prototype.keyDownHandler = function (e) {
        var gridElement = parentsUntil(e.target, 'e-grid');
        var elementTag = e.target.tagName;
        if ((gridElement && gridElement.id !== this.element.id) ||
            (e.key == "Shift" || e.key == "Control" || e.key == "Alt")) {
            return;
        }
        if ((elementTag == "INPUT" || elementTag == "TEXTAREA") && e.code == "Delete") {
            return;
        }
        this.dotNetRef.invokeMethodAsync("GridKeyDown", {
            key: e.key,
            code: e.code,
            ctrlKey: e.ctrlKey,
            shiftKey: e.shiftKey,
            altKey: e.altKey
        });
    };
    SfGrid.prototype.gridKeyDownHandler = function (e) {
        var popupElement = parentsUntil(e.target, 'e-filter-popup');
        var elementTag = e.target.tagName;
        if (!sf.base.isNullOrUndefined(popupElement) && popupElement.classList.contains('e-popup-open') && e.key != 'Escape') {
            e.stopPropagation();
            if ((e.key == "Tab" || e.key == "shiftTab" || e.key == "Enter" || e.key == "shiftEnter") &&
                (elementTag == "INPUT" || elementTag == "TEXTAREA")) {
                var evt = document.createEvent('HTMLEvents');
                evt.initEvent('change', false, true);
                e.target.dispatchEvent(evt);
            }
        }
        //TODO: datepicker in dialog editing
        if (((e.key == "Tab" || e.key == 'Escape' || e.key == "shiftTab" || e.key == "Enter" || e.key == "shiftEnter")
            && (elementTag == 'INPUT' || e.target.classList.contains('e-datepicker') || e.target.classList.contains('e-datetimepicker'))) || (e.target.classList.contains('e-rowcell') && e.key == "F2")) {
            if (!(e.key == "Tab" && (e.target.classList.contains('e-datepicker') || e.target.classList.contains('e-datetimepicker')))) {
                e.target.blur();
            }
        }
        if (e.key == "Shift" || e.key == "Control" || e.key == "Alt") {
            e.stopPropagation(); //dont let execute c# keydown handler for meta keys.
        }
        if (e.keyCode === 67 && e.ctrlKey) {
            this.clipboardModule.copy();
        }
        else if (e.keyCode === 72 && e.ctrlKey && e.shiftKey) {
            this.clipboardModule.copy(true);
        }
        if (e.keyCode === 86 && e.ctrlKey && !this.options.isEdit) {
            e.stopPropagation();
            this.clipboardModule.pasteHandler();
        }
        if (this.element.querySelector('.e-batchrow')) {
            if (e.key != "Tab" && e.key != "shiftTab" && e.key != "Enter" && e.key != "shiftEnter"
                && e.key != "Escape") {
                e.stopPropagation();
            }
            //new
            if (e.key == "Tab" || e.key == "shiftTab" || e.key == "Enter" || e.key == "shiftEnter") {
                e.preventDefault();
                if (elementTag == "INPUT" || elementTag == "TEXTAREA") {
                    var evt = document.createEvent('HTMLEvents');
                    evt.initEvent('change', false, true);
                    e.target.dispatchEvent(evt);
                }
            }
        }
    };
    SfGrid.prototype.mouseDownHandler = function (e) {
        var gridElement = parentsUntil(e.target, 'e-grid');
        if (gridElement && gridElement.id !== this.element.id) {
            return;
        }
        if (e.shiftKey || e.ctrlKey) {
            e.preventDefault(); //prevent user select on shift pressing during selection
        }
        // e.button = 2 for right mouse button click
        if ((e.button !== 2 && parentsUntil(e.target, 'e-headercell')) || (e.button !== 2 && parentsUntil(e.target, 'e-detailcell')) || parentsUntil(e.target, 'e-detailrowexpand') || parentsUntil(e.target, 'e-detailrowcollapse')
            || e.target.classList.contains('e-content') || e.target.classList.contains('e-headercontent') || sf.base.closest(e.target, ".e-groupdroparea") || sf.base.closest(e.target, ".e-gridpopup")
            || sf.base.closest(e.target, ".e-summarycell") || sf.base.closest(e.target, ".e-rhandler")
            || sf.base.closest(e.target, ".e-filtermenudiv") || sf.base.closest(e.target, ".e-filterbarcell")
            || sf.base.closest(e.target, ".e-groupcaption")) {
            this.dotNetRef.invokeMethodAsync("MouseDownHandler", null, null);
        }
        else {
            var target = null;
            var cellUid = null;
            var editForm = parentsUntil(parentsUntil(e.target, 'e-gridform'), 'e-grid');
            if (parentsUntil(e.target, 'e-editcell') || editForm && editForm.id == gridElement.id) {
                target = "Edit";
            }
            else if (parentsUntil(e.target, 'e-pager')) {
                target = "Pager";
            }
            else if (parentsUntil(e.target, 'e-headercontent')) {
                target = "Header";
                cellUid = parentsUntil(e.target, 'e-headercell') ? parentsUntil(e.target, 'e-headercell').getAttribute('data-uid') : null;
            }
            else if (parentsUntil(e.target, 'e-content')) {
                target = "Content";
                cellUid = parentsUntil(e.target, 'e-rowcell') ? parentsUntil(e.target, 'e-rowcell').getAttribute('data-uid') : null;
            }
            if (target == "Header" || target == "Content" || target == "Pager" || target == "Edit") {
                this.dotNetRef.invokeMethodAsync("MouseDownHandler", target, cellUid);
            }
        }
    };
    SfGrid.prototype.gridFocus = function (e) {
        if (!sf.base.isNullOrUndefined(this.element.querySelector(".e-gridform")) &&
            this.element.querySelector(".e-gridform").classList.contains("e-editing")) {
            return;
        }
        this.dotNetRef.invokeMethodAsync("GridFocus", e);
    };
    SfGrid.prototype.keyActionHandler = function (e) {
        var _this = this;
        if (e.action === 'pageUp' || e.action === 'pageDown' || e.action === 'ctrlAltPageUp'
            || e.action === 'ctrlAltPageDown' || e.action === 'altPageUp' || e.action === 'altPageDown'
            || e.action === 'altDownArrow' || e.action === 'ctrlPlusP') {
            e.preventDefault();
        }
        if (e.action === 'enter' && !sf.base.isNullOrUndefined(this.element.querySelector(".e-gridform"))
            && this.element.querySelector(".e-gridform").classList.contains("e-editing")
            && this.options.editMode !== "Batch") {
            setTimeout(function () {
                e.target.blur();
                _this.dotNetRef.invokeMethodAsync("EndEdit");
            }, 40);
        }
    };
    SfGrid.prototype.destroy = function () {
        this.unWireEvents();
        this.addScrollEvents(false);
        this.toolTipModule.destroy();
        this.keyModule.destroy();
        this.virtualContentModule.removeEventListener();
        this.columnChooserModule.removeMediaListener();
        this.selectionModule.removeEventListener();
        this.rowDragAndDropModule.destroy();
    };
    /**
         * @private
         */
    SfGrid.prototype.getColumnIndexesInView = function () {
        return this.inViewIndexes;
    };
    /**
     * @private
     */
    SfGrid.prototype.setColumnIndexesInView = function (indexes) {
        this.inViewIndexes = indexes;
    };
    SfGrid.prototype.getRowHeight = function () {
        return this.options.rowHeight ? this.options.rowHeight : getRowHeight(this.element);
    };
    SfGrid.prototype.clientActions = function () {
        if (this.options.enableVirtualization && (this.options.pageSize === 12 || this.options.width === 'auto')) {
            this.virtualContentModule.ensurePageSize();
        }
        if (this.getColumns().some(function (col) { return col.hideAtMedia !== ''; })) {
            this.columnChooserModule.setMediaColumns();
        }
    };
    SfGrid.prototype.print = function () {
        this.removeColGroup();
        var printWind = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');
        printWind.moveTo(0, 0);
        printWind.resizeTo(screen.availWidth, screen.availHeight);
        sf.base.print(this.element, printWind);
    };
    SfGrid.prototype.removeColGroup = function () {
        var depth = this.options.groupCount;
        var element = this.element;
        var id = '#' + this.element.id;
        if (!depth) {
            return;
        }
        var groupCaption = element.querySelectorAll(".e-groupcaption");
        var colSpan = groupCaption[depth - 1].getAttribute('colspan');
        for (var i = 0; i < groupCaption.length; i++) {
            groupCaption[i].setAttribute('colspan', colSpan);
        }
        var colGroups = element.querySelectorAll("colgroup" + id + "colGroup");
        var contentColGroups = element.querySelector('.e-content').querySelectorAll('colgroup');
        this.hideColGroup(colGroups, depth);
        this.hideColGroup(contentColGroups, depth);
    };
    SfGrid.prototype.hideColGroup = function (colGroups, depth) {
        for (var i = 0; i < colGroups.length; i++) {
            for (var j = 0; j < depth; j++) {
                colGroups[i].children[j].style.display = 'none';
            }
        }
    };
    /**
     * For internal use only - Get the module name.
     * @private
     */
    SfGrid.prototype.getModuleName = function () {
        return 'grid';
    };
    return SfGrid;
}());
var gridKeyConfigs = {
    pageUp: 'pageup',
    pageDown: 'pagedown',
    ctrlAltPageUp: 'ctrl+alt+pageup',
    ctrlAltPageDown: 'ctrl+alt+pagedown',
    altPageUp: 'alt+pageup',
    altPageDown: 'alt+pagedown',
    altDownArrow: 'alt+downarrow',
    altUpArrow: 'alt+uparrow',
    ctrlDownArrow: 'ctrl+downarrow',
    ctrlUpArrow: 'ctrl+uparrow',
    ctrlPlusA: 'ctrl+A',
    ctrlPlusP: 'ctrl+P',
    ctrlPlusC: 'ctrl+C',
    ctrlShiftPlusH: 'ctrl+shift+H',
    enter: 'enter',
};

/**
 * Blazor grid interop handler
 */
// tslint:disable
var Grid = {
    initialize: function (element, options, dotnetRef) {
        sf.base.enableBlazorMode();
        new SfGrid(element, options, dotnetRef);
    },
    contentReady: function (element, options, action) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            instance.setOptions(options, instance.options);
            instance.options = options;
            instance.contentReady(action);
        }
    },
    customFilterDialog: function (element, dlgID, isExcel) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var dialogElement = document.querySelector("#" + dlgID);
            dialogElement.style.maxHeight = "100%";
            dialogElement.style.border = "1px";
            if (isExcel) {
                var contextMenuElement = element.querySelector(".e-sfcontextmenu");
                contextMenuElement.querySelector("li").style.paddingLeft = "0px";
                contextMenuElement.querySelector(".e-caret").style.paddingRight = "8px";
            }
        }
    },
    setCustomFilterDialogPadding: function (element, field) {
        var setPadding = document.querySelector("#" + field);
        setPadding.style.padding = "16px";
    },
    searchClear: function (element, inputId) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var inputElement = document.querySelector("#" + inputId);
            inputElement.value = "";
            inputElement.focus();
        }
    },
    updateTableWidth: function (element, columns) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            instance.options.columns = columns;
            if (instance.options.allowResizing && instance.options.isResizedGrid) {
                var widthService = new ColumnWidthService(instance);
                widthService.setWidthToTable(columns);
            }
        }
    },
    frozenHeight: function (element, options, action) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            instance.freezeModule.setFrozenHeight();
        }
    },
    virtualHeight: function (element, options, totalItemCount) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            instance.options = options;
            instance.options.totalItemCount = totalItemCount;
            instance.virtualContentModule.refreshOffsets();
            instance.virtualContentModule.setVirtualHeight();
        }
    },
    lazyGroupExpand: function (element, options) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            instance.setOptions(options, instance.options);
            instance.options = options;
            if (instance.options.enableVirtualization) {
                instance.virtualContentModule.onDataReady();
            }
        }
    },
    viewRefresh: function (element, columns) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            var widthService = void 0;
            widthService = new ColumnWidthService(this);
            columns = columns.filter(function (x) { return x.visible; });
            var tablewidth = columns.some(function (x) { return (x.width == "" || x.width == null); });
            widthService.setWidthToTable(columns, tablewidth);
        }
    },
    reorderColumns: function (element, fromFName, toFName) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.reorderModule.reorderColumns(fromFName, toFName);
        }
    },
    reorderColumnByIndex: function (element, fromIndex, toIndex) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.reorderModule.reorderColumnByIndex(fromIndex, toIndex);
        }
    },
    reorderColumnByTargetIndex: function (element, fieldName, toIndex) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.reorderModule.reorderColumnByTargetIndex(fieldName, toIndex);
        }
    },
    renderColumnChooser: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.columnChooserModule.renderColumnChooser();
        }
    },
    renderColumnMenu: function (element, uid, isFilter, key) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            return element.blazor__instance.columnMenuModule.renderColumnMenu(uid, isFilter, key);
        }
        else {
            return { Left: 1, Top: 1 };
        }
    },
    filterPopupRender: function filterPopupRender(element, dlgID, uid, type, isColumnMenu) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.filterModule.filterPopupRender(dlgID, uid, type, isColumnMenu);
        }
    },
    clientHeight: function clientHeight(element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            return Math.max(element.blazor__instance.content.clientHeight, window.innerHeight || 0);
        }
        return 0;
    },
    clientTransformUpdate: function clientTransformUpdate(element, xPosition, yPosition) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.virtualContentModule.updateTransform(xPosition, yPosition);
        }
    },
    autoFitColumns: function (element, columns, fieldNames) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            instance.options.columns = columns;
            element.blazor__instance.resizeModule.autoFitColumns(fieldNames);
        }
    },
    refreshColumnIndex: function (element, columns) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var instance = element.blazor__instance;
            instance.options.columns = columns;
            instance.virtualContentModule.refreshColumnIndexes();
        }
    },
    focus: function (element, rowuid, celluid, action) {
        var cell = element.querySelector("[data-uid=\"" + celluid + "\"]");
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance) && !sf.base.isNullOrUndefined(cell)) {
            var instance = element.blazor__instance;
            if (!instance.options.enableVirtualization) {
                cell.focus();
            }
            else {
                instance.virtualContentModule.focusCell(cell, action);
            }
        }
    },
    focusExcelInput: function (element, celluid) {
        var excelPopup = document.querySelector("#" + celluid + "_excelDlg");
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance) && !sf.base.isNullOrUndefined(excelPopup)) {
            setTimeout(function () {
                excelPopup.querySelector("#" + element.id + "_SearchBox").focus();
            }, 10);
        }
    },
    refreshOnDataChange: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.virtualContentModule.refreshOnDataChange();
        }
    },
    updateAutofillPosition: function (element, cellindex, index) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var _this = element.blazor__instance;
            return _this.selectionModule.updateAutofillPosition(cellindex, index);
        }
        else {
            return null;
        }
    },
    createBorder: function (element, rowIndex, cellIndex) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var _this = element.blazor__instance;
            return _this.selectionModule.createBorder(rowIndex, cellIndex);
        }
        else {
            return null;
        }
    },
    removePersistItem: function (element, id) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var _this = element.blazor__instance;
            _this.getHeaderTable().style.width = "";
            _this.getContentTable().style.width = "";
            if (_this.options.aggregatesCount != 0) {
                _this.getFooterContent().querySelector(".e-table").style.width = "";
            }
            if (_this.options.frozenColumns > 0) {
                _this.element.querySelector(".e-movableheader").querySelector('.e-table').style.width = "";
                _this.element.querySelector(".e-movablecontent").querySelector('.e-table').style.width = "";
            }
        }
        localStorage.removeItem(id);
    },
    focusChild: function (element, rowuid, celluid) {
        var query = 'button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])';
        var child = [].slice.call(element.querySelector("[data-uid=\"" + celluid + "\"]").querySelectorAll(query));
        /* Select the first focusable child element
         * if no child found then select the cell itself.
         * if Grid is in editable state, check for editable control inside child.
         */
        child.length > 0 ? child[0].focus() : element.querySelector("[data-uid=\"" + celluid + "\"]").focus();
        return child.length ? true : false;
    },
    exportSave: function (filename, bytesBase64) {
        if (navigator.msSaveBlob) {
            //Download document in Edge browser
            var data = window.atob(bytesBase64);
            var bytes = new Uint8Array(data.length);
            for (var i = 0; i < data.length; i++) {
                bytes[i] = data.charCodeAt(i);
            }
            var blob = new Blob([bytes.buffer], { type: "application/octet-stream" });
            navigator.msSaveBlob(blob, filename);
        }
        else {
            var link = document.createElement('a');
            link.download = filename;
            link.href = "data:application/octet-stream;base64," + bytesBase64;
            document.body.appendChild(link); // Needed for Firefox
            link.click();
            document.body.removeChild(link);
        }
    },
    destroy: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.destroy();
        }
    },
    validation: function (element, results, isAdd) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.editModule.createTooltip(results, isAdd);
        }
    },
    focusCell: function (element, field, isAdd, frozenEdit) {
        if (frozenEdit === void 0) { frozenEdit = false; }
        if (isAdd && !sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance) && element.blazor__instance.options.frozenColumns) {
            element.querySelector('.e-frozencontent').style.height =
                element.querySelector('.e-movablecontent').getBoundingClientRect().height + 'px';
        }
        var complexField = "#" + field.replace(/[.]/g, "___");
        if (frozenEdit) {
            var forms = [].slice.call(element.querySelectorAll('form'));
            var td = void 0;
            for (var i = 0; i < forms.length; i++) {
                td = forms[i].querySelector('td:not(.e-hide)');
                td.style.height = sf.base.closest(td, '.e-row').getBoundingClientRect().height + 'px';
            }
        }
        if (field === "" && element.querySelector("input.e-boolcell")) {
            element.querySelector("input.e-boolcell").focus();
        }
        else if (field !== "" && element.querySelector(complexField)) {
            element.querySelector(complexField).focus();
        }
    },
    CurrentPageFocus: function (element, key, currentPage) {
        var numericContainer = element.querySelector(".e-numericcontainer");
        if (key == "PreviousPage" || numericContainer.querySelectorAll(".e-link:last-child")[0].innerText != currentPage) {
            numericContainer.querySelector(".e-link").focus();
        }
        else {
            numericContainer.querySelectorAll(".e-link:last-child")[0].focus();
        }
    },
    pagerFocus: function (element, key) {
        var pagerContainer = element.querySelector(".e-gridpager").querySelector(".e-pagercontainer");
        var numericContainer = pagerContainer.querySelector(".e-numericcontainer");
        var firstPage = pagerContainer.querySelector(".e-firstpage.e-pager-default");
        var previousPage = pagerContainer.querySelector(".e-prevpage.e-pager-default");
        if (key === "ArrowDown") {
            if (firstPage) {
                firstPage.focus();
                return "FirstPage";
            }
            else if (previousPage) {
                firstPage.focus();
                return "PreviousPage";
            }
            else {
                numericContainer.querySelectorAll('.e-link')[1].focus();
                return "1";
            }
        }
        else if (key == "ArrowRight") {
            if (firstPage != null && firstPage.classList.contains("e-focused")) {
                previousPage.focus();
                return "PreviousPage";
            }
            else if (previousPage != null && previousPage.classList.contains("e-focused") || pagerContainer.querySelector(".e-pp.e-focused") != null) {
                if (pagerContainer.querySelector(".e-pp") != null && !pagerContainer.querySelector(".e-pp").classList.contains("e-focused")) {
                    pagerContainer.querySelector('.e-pp').focus();
                    return "PreviousPagerCount";
                }
                else {
                    numericContainer.querySelectorAll('.e-link')[0].focus();
                    return numericContainer.querySelectorAll('.e-link')[0].innerText;
                }
            }
            else if (numericContainer.querySelectorAll(".e-link.e-focused").length > 0 && pagerContainer.querySelector('.e-link.e-focused') != null && pagerContainer.querySelector('.e-link.e-focused').nextSibling != null) {
                numericContainer.querySelector('.e-link.e-focused').nextSibling.focus();
                return numericContainer.querySelector('.e-link.e-focused').nextSibling.innerText;
            }
            else if (numericContainer.querySelectorAll(".e-link.e-focused").length > 0 && pagerContainer.querySelector(".e-np") != null && pagerContainer.querySelector(".e-np.e-focused") == null) {
                pagerContainer.querySelector('.e-np').focus();
                return "NextPagerCount";
            }
            else if (numericContainer.querySelectorAll(".e-link.e-focused").length > 0 || pagerContainer.querySelectorAll(".e-np.e-focused").length > 0) {
                if (pagerContainer.querySelector('.e-nextpage') != null) {
                    pagerContainer.querySelector('.e-nextpage').focus();
                    return "NextPage";
                }
                else {
                    numericContainer.querySelector(".e-link.e-focused").focus();
                    return numericContainer.querySelector(".e-link.e-focused").innerText;
                }
            }
            else if (pagerContainer.querySelector(".e-nextpage.e-focused") != null) {
                pagerContainer.querySelector('.e-lastpage').focus();
                return "LastPage";
            }
            else {
                pagerContainer.querySelector('.e-lastpage').focus();
                return "LastPage";
            }
        }
        else if (key == "ArrowLeft") {
            if (previousPage != null && previousPage.classList.contains("e-focused")) {
                firstPage.focus();
                return "FirstPage";
            }
            else if (previousPage && pagerContainer.querySelector(".e-pp.e-focused")) {
                previousPage.focus();
                return "PreviousPage";
            }
            else if (numericContainer.querySelectorAll('.e-link')[0].classList.contains('e-focused')) {
                if (pagerContainer.querySelector(".e-pp") != null) {
                    pagerContainer.querySelector(".e-pp").focus();
                    return "PreviousPagerCount";
                }
                else if (previousPage) {
                    previousPage.focus();
                    return "PreviousPage";
                }
                else {
                    numericContainer.querySelectorAll('.e-link')[0].focus();
                    return "1";
                }
            }
            else if (numericContainer.querySelectorAll(".e-link.e-focused").length > 0) {
                numericContainer.querySelector('.e-link.e-focused').previousSibling.focus();
                return numericContainer.querySelector('.e-link.e-focused').previousSibling.innerText;
            }
            else if (pagerContainer.querySelectorAll(".e-nextpage.e-focused").length > 0 && pagerContainer.querySelector(".e-np") != null) {
                pagerContainer.querySelector('.e-np').focus();
                return "NextPagerCount";
            }
            else if (pagerContainer.querySelectorAll(".e-nextpage.e-focused").length > 0 || pagerContainer.querySelectorAll(".e-np.e-focused").length > 0) {
                var page = numericContainer.querySelectorAll('.e-link').length;
                numericContainer.querySelectorAll('.e-link')[page - 1].focus();
                return numericContainer.querySelectorAll(".e-link:last-child")[0].innerText;
            }
            else if (pagerContainer.querySelector(".e-lastpage.e-focused") != null) {
                pagerContainer.querySelector('.e-nextpage').focus();
                return "NextPage";
            }
            else {
                if (!firstPage.classList.contains('.e-disabled')) {
                    firstPage.focus();
                    return "FirstPage";
                }
                return "0";
            }
        }
        else {
            return "0";
        }
    },
    setFrozenHeight: function (element) {
        element.querySelector('.e-frozencontent').style.height =
            element.querySelector('.e-movablecontent').offsetHeight - getScrollBarWidth() + 'px';
    },
    printGrid: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.print();
        }
    },
    updateMediaColumns: function (element, mediaColumnsUid) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.columnChooserModule.updateMediaColumns(mediaColumnsUid);
        }
    },
    copyToClipBoard: function (element, withHeader) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.clipboardModule.copy(withHeader);
        }
    },
    gridFocus: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.focus();
        }
    },
    isMacDevice: function () {
        return navigator.userAgent.indexOf("Mac OS") !== -1;
    },
};

return Grid;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-inplaceeditor.js":
/*!*******************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-inplaceeditor.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.InPlaceEditor = (function () {
'use strict';

var ROOT = 'e-inplaceeditor';
var OPEN = 'e-editable-open';
var ROOT_TIP = 'e-inplaceeditor-tip';
var DISABLE = 'e-disable';
var RTL = 'e-rtl';
var EDITABLE_VALUE_ELEMENT = 'e-editable-value-container';
var CLEAR_ICON = 'e-clear-icon';
var EDITABLE_COMPONENT = 'e-editable-component';
var EDITABLE_ELEMENT = 'e-editable-elements';
var CREATED = 'Created';
var CANCEL_ACTION = 'CancelAction';
var SAVE_ACTION = 'SaveAction';
var RENDER_EDITOR = 'RenderEditor';
var INLINE = 'Inline';
var KEYDOWN = 'keydown';
var SCROLL = 'scroll';
var RESIZE = 'resize';
var MOUSEDOWN = 'mousedown';
var POPUP = 'Popup';
var SUBMIT = 'Submit';
var CANCEL = 'Cancel';
var BUTTON = 'BUTTON';
var IGNORE = 'Ignore';
var MOUSE_DOWN = 'mousedown';
var TAB_KEY = 'Tab';
var ENTER_KEY = 'Enter';
var SfInPlaceEditor = /** @class */ (function () {
    function SfInPlaceEditor(element, options, dotnetRef) {
        this.submitOnEnter = true;
        this.clearComponents = ['AutoComplete', 'Mask', 'Text'];
        this.element = element;
        this.dotNetRef = dotnetRef;
        this.updateContext(options);
        this.element.blazor__instance = this;
    }
    SfInPlaceEditor.prototype.updateContext = function (inPlaceObj) {
        sf.base.extend(this, this, inPlaceObj);
    };
    SfInPlaceEditor.prototype.initialize = function () {
        this.onResizeScrollHandler = this.scrollResizeHandler.bind(this);
        this.wireEvents();
        this.id = this.element.id;
        this.dotNetRef.invokeMethodAsync(CREATED, null);
    };
    SfInPlaceEditor.prototype.wireEvents = function () {
        sf.base.EventHandler.add(this.element, KEYDOWN, this.valueKeyDownHandler, this);
        sf.base.EventHandler.add(document, SCROLL, this.scrollResizeHandler, this);
        window.addEventListener(RESIZE, this.onResizeScrollHandler);
        if (Array.prototype.indexOf.call(this.clearComponents, this.type) > -1) {
            sf.base.EventHandler.add(this.element, MOUSEDOWN, this.mouseDownHandler, this);
        }
    };
    SfInPlaceEditor.prototype.scrollResizeHandler = function () {
        if (this.mode === POPUP
            && !(sf.base.Browser.isDevice)) {
            this.dotNetRef.invokeMethodAsync(CANCEL_ACTION, null);
        }
    };
    SfInPlaceEditor.prototype.valueKeyDownHandler = function (e) {
        if (e.code === TAB_KEY && e.shiftKey === true && e.target.tagName !== BUTTON) {
            if (this.actionOnBlur === SUBMIT) {
                this.dotNetRef.invokeMethodAsync(SAVE_ACTION, null);
            }
            else if (this.actionOnBlur === CANCEL) {
                this.dotNetRef.invokeMethodAsync(CANCEL_ACTION, null);
            }
        }
        if (e.code === ENTER_KEY && e.target.classList.contains(ROOT) &&
            !this.element.querySelector('.' + EDITABLE_VALUE_ELEMENT).classList.contains(OPEN) && !this.element.classList.contains(DISABLE)) {
            e.preventDefault();
            this.dotNetRef.invokeMethodAsync(RENDER_EDITOR, null);
        }
    };
    SfInPlaceEditor.prototype.mouseDownHandler = function (e) {
        if (e.target.classList.contains(CLEAR_ICON)) {
            this.isClearTarget = true;
        }
    };
    SfInPlaceEditor.prototype.openEditor = function (options) {
        this.updateContext(options);
        if (this.mode === 'Popup') {
            this.popupContent = document.querySelector('#' + this.popupElement + '_content');
        }
        if (this.actionOnBlur !== IGNORE) {
            sf.base.EventHandler.add(document, MOUSE_DOWN, this.docClickHandler, this);
        }
        if (this.submitOnEnter) {
            var editorEle = this.mode === 'Popup' ? this.popupContent : this.element;
            sf.base.EventHandler.add(editorEle, 'keydown', this.enterKeyDownHandler, this);
        }
        this.dotNetRef.invokeMethodAsync('FocusEditor');
    };
    SfInPlaceEditor.prototype.enterKeyDownHandler = function (e) {
        if (!sf.base.closest(e.target, '.' + EDITABLE_COMPONENT + ' .e-richtexteditor')) {
            if ((e.keyCode === 13 && e.which === 13) && sf.base.closest(e.target, '.' + EDITABLE_COMPONENT)) {
                this.dotNetRef.invokeMethodAsync(SAVE_ACTION, null);
            }
            else if (e.keyCode === 27 && e.which === 27) {
                if (!sf.base.isNullOrUndefined(this.element) && !sf.base.isNullOrUndefined(this.element.querySelector('input'))
                    && this.mode === 'Inline') {
                    this.element.querySelector('input').blur();
                }
                else if (!sf.base.isNullOrUndefined(this.popupContent) && !sf.base.isNullOrUndefined(this.popupContent.querySelector('input'))
                    && this.mode === 'Popup') {
                    this.popupContent.querySelector('input').blur();
                }
                this.dotNetRef.invokeMethodAsync(CANCEL_ACTION, null);
            }
            else if (e.code === ENTER_KEY && e.target.classList.contains(ROOT) &&
                (!sf.base.isNullOrUndefined(this.element.querySelector('.' + EDITABLE_VALUE_ELEMENT)) &&
                    !this.element.querySelector('.' + EDITABLE_VALUE_ELEMENT).classList.contains(OPEN)) &&
                !this.element.classList.contains(DISABLE)) {
                e.preventDefault();
                this.dotNetRef.invokeMethodAsync(RENDER_EDITOR, null);
            }
        }
    };
    SfInPlaceEditor.prototype.removeEditor = function (options) {
        this.updateContext(options);
        if (this.enablePersistence) {
            window.localStorage.setItem(this.id, this.value);
        }
        this.unWireEvents();
        sf.base.EventHandler.remove(document, MOUSE_DOWN, this.docClickHandler);
    };
    SfInPlaceEditor.prototype.Destroy = function (options) {
        var _this = this;
        this.updateContext(options);
        this.unWireEvents();
        sf.base.EventHandler.remove(document, MOUSE_DOWN, this.docClickHandler);
        if (this.enablePersistence) {
            window.localStorage.setItem(this.id, this.value);
        }
        if (this.mode === POPUP) {
            this.destroyPopup();
        }
        var classList = [DISABLE, RTL];
        classList.forEach(function (val) {
            sf.base.removeClass([_this.element], [val]);
        });
        while (this.element.firstElementChild) {
            this.element.removeChild(this.element.firstElementChild);
        }
    };
    SfInPlaceEditor.prototype.destroyPopup = function () {
        var popEle = document.querySelector('#' + this.popupElement);
        if (popEle) {
            while (popEle.attributes.length > 0) {
                popEle.removeAttribute(popEle.attributes[0].name);
            }
            var splitNodes = popEle.children;
            for (var i = splitNodes.length - 1; i >= 0; i--) {
                sf.base.detach(splitNodes[i]);
            }
        }
    };
    SfInPlaceEditor.prototype.unWireEvents = function () {
        sf.base.EventHandler.remove(document, SCROLL, this.scrollResizeHandler);
        window.removeEventListener(RESIZE, this.onResizeScrollHandler);
        sf.base.EventHandler.remove(this.element, KEYDOWN, this.valueKeyDownHandler);
        if (Array.prototype.indexOf.call(this.clearComponents, this.type) > -1) {
            sf.base.EventHandler.remove(this.element, MOUSEDOWN, this.mouseDownHandler);
        }
    };
    SfInPlaceEditor.prototype.validate = function () {
        return this.mode === INLINE ? this.element.querySelector('.validation-message') ? true : false :
            (this.componentParent && this.componentParent.querySelector('.validation-message')) ? true : false;
    };
    SfInPlaceEditor.prototype.docClickHandler = function (e) {
        var relateRoot = sf.base.closest(e.target, '.' + ROOT);
        var relateTipRoot = sf.base.closest(e.target, '.' + ROOT_TIP);
        var relateElements = sf.base.closest(e.target, '.' + EDITABLE_ELEMENT);
        var relateRTEElements = sf.base.closest(e.target, '.' + 'e-rte-elements');
        if (this.isClearTarget || ((!sf.base.isNullOrUndefined(relateRoot) && relateRoot.isEqualNode(this.element)) ||
            (!sf.base.isNullOrUndefined(relateTipRoot) && this.popupContent && relateTipRoot.id.indexOf('tooltip') > -1)) ||
            !sf.base.isNullOrUndefined(relateElements) || !sf.base.isNullOrUndefined(relateRTEElements) ||
            e.target.classList.contains('e-chips-close')) {
            this.isClearTarget = false;
            return;
        }
        var ele = this.mode === INLINE ? this.element.querySelector('.' + EDITABLE_COMPONENT) : this.element;
        var btnEle = this.mode === INLINE ? this.element.querySelector('.e-editable-action-buttons') : this.componentParent;
        if (ele.contains(e.target) || (btnEle && btnEle.contains(e.target) ||
            sf.base.closest(e.target, '.e-dropdown-popup.e-control.e-rte-elements') ||
            sf.base.closest(e.target, '.e-dropdown-popup.e-control.e-colorpicker-popup') ||
            (this.popupContent && this.popupContent.contains(e.target)))) {
            return;
        }
        else {
            if (this.actionOnBlur === SUBMIT && !this.element.querySelector('.validation-message')) {
                this.dotNetRef.invokeMethodAsync(SAVE_ACTION, null);
            }
            else if (this.actionOnBlur === CANCEL) {
                this.dotNetRef.invokeMethodAsync(CANCEL_ACTION, null);
            }
        }
    };
    return SfInPlaceEditor;
}());
// tslint:disable-next-line
var InPlaceEditor = {
    initialize: function (element, options, dotnetRef) {
        if (!sf.base.isNullOrUndefined(element)) {
            new SfInPlaceEditor(element, options, dotnetRef);
            element.blazor__instance.initialize();
        }
    },
    openEditor: function (element, options) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.openEditor(options);
        }
    },
    closeEditor: function (element, options) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.removeEditor(options);
        }
    },
    destroy: function (element, options) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.Destroy(options);
        }
    },
    propertyChanged: function (element, options) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.updateContext(options);
        }
    },
    validate: function (element) {
        return element && element.blazor__instance.validate();
    }
};

return InPlaceEditor;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-multiselect.js":
/*!*****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-multiselect.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.MultiSelect = (function () {
'use strict';

var POPUP_CONTENT = 'e-content';
var LIST_ITEM = 'e-list-item';
var CLOSE_POPUP = 'ClosePopup';
var ITEM_FOCUS = 'e-item-focus';
var SELECTED = 'e-active';
var HIDE = 'Hide';
var ICON_ANIM = 'e-icon-anim';
var DDL_DEVICE = 'e-ddl-device';
var MOBILE_FILTER = 'e-ddl-device-filter';
var POPUP_FULL_SCREEN = 'e-popup-full-page';
var FIXED_HEAD = 'e-fixed-head';
var GROUP = 'e-list-group-item';
var GROUP_CHECKBOX = 'e-multiselect-group';
var INPUT_FOCUS = 'e-input-focus';
var REMAIN_WRAPPER = 'e-remain';
var DROP_DOWN_ICON = 'e-input-group-icon e-ddl-icon';
var CLEAR_ICON = 'e-clear-icon';
var TOTAL_COUNT_WRAPPER = 'e-delim-total';
var DELIM_HIDE = 'e-delim-hide';
var VIRTUAL_HANDLER = 'VirtualScrollHandler';
var DDL_HEADER = 'e-ddl-header';
var DDL_FOOTER = 'e-ddl-footer';
var SELECT_ALL_PARENT = 'e-selectall-parent';
var INPUT = 'e-input';
var BLURHANDLER = 'InvokeBlur';
var BLUR = 'blur';
var REMAIN_COUNT = 'RemainCount';
var SfMultiSelect = /** @class */ (function () {
    // tslint:disable
    function SfMultiSelect(containerElement, childContainerElement, element, dotnetRef, options) {
        this.containerElement = containerElement;
        this.childContainerElement = childContainerElement;
        this.element = element;
        this.options = options;
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
        this.isDisposed = false;
    }
    SfMultiSelect.prototype.initialize = function () {
        sf.base.EventHandler.add(window, 'resize', this.windowResize, this);
        sf.base.EventHandler.add(this.element, BLUR, this.blurHandler, this);
    };
    SfMultiSelect.prototype.blurHandler = function () {
        if (!this.isDisposed) {
            this.dotNetRef.invokeMethodAsync(BLURHANDLER);
        }
    };
    SfMultiSelect.prototype.getPopupHeight = function (listHeight, searchBoxHeight, tempEle) {
        var height = Math.round(tempEle.getBoundingClientRect().height);
        return (parseInt(listHeight, 10) - (height + searchBoxHeight)).toString() + 'px';
    };
    // tslint:disable
    SfMultiSelect.prototype.renderPopup = function (popupElement, popupHolderEle, openEventArgs, isModifiedPopup, options, dataItem) {
        this.options = options;
        this.popupHolder = popupHolderEle;
        this.list = popupHolderEle.querySelector('.' + POPUP_CONTENT) || sf.base.select('.' + POPUP_CONTENT);
        this.liCollections = this.getItems();
        var listHeight = sf.base.formatUnit(this.options.popupHeight);
        document.body.appendChild(popupElement);
        popupElement.style.visibility = 'hidden';
        var searchBoxContainer;
        if (this.options.allowFiltering && this.options.mode === 'CheckBox') {
            this.filterInput = popupElement.querySelector('input.' + INPUT);
            searchBoxContainer = this.filterInput.parentElement;
            sf.base.EventHandler.add(this.filterInput, 'keypress', this.filterKeydown, this);
        }
        else {
            this.filterInput = this.element;
        }
        if (this.options.popupHeight !== 'auto') {
            var searchBoxHeight = 0;
            if (!sf.base.isNullOrUndefined(searchBoxContainer)) {
                searchBoxHeight = searchBoxContainer.parentElement.getBoundingClientRect().height;
                listHeight = (parseInt(listHeight, 10) - searchBoxHeight).toString() + 'px';
            }
            var selectAllHeight = 0;
            var selectAllElement = popupElement.querySelector('.' + SELECT_ALL_PARENT);
            if (selectAllElement) {
                selectAllHeight = selectAllElement.getBoundingClientRect().height;
                listHeight = (parseInt(listHeight, 10) - selectAllHeight).toString() + 'px';
            }
            if (popupElement.querySelector('.' + DDL_HEADER)) {
                var header = popupElement.querySelector('.' + DDL_HEADER);
                listHeight = this.getPopupHeight(listHeight, searchBoxHeight, header);
            }
            if (popupElement.querySelector('.' + DDL_FOOTER)) {
                var footer = popupElement.querySelector('.' + DDL_FOOTER);
                listHeight = this.getPopupHeight(listHeight, searchBoxHeight, footer);
            }
            this.list.style.maxHeight = (parseInt(listHeight, 10) - 2).toString() + 'px'; // due to box-sizing property
            popupElement.style.maxHeight = sf.base.formatUnit(this.options.popupHeight);
        }
        else {
            popupElement.style.height = 'auto';
        }
        this.popupCreation(popupElement);
        if (sf.base.Browser.isDevice && this.options.mode === 'CheckBox' && this.options.allowFiltering) {
            this.popupObj.element.classList.add(DDL_DEVICE);
            this.popupObj.element.classList.add(MOBILE_FILTER);
            this.popupObj.position = { X: 0, Y: 0 };
            this.popupObj.dataBind();
            sf.base.attributes(this.popupObj.element, { style: 'left:0px;right:0px;top:0px;bottom:0px;' });
            sf.base.addClass([document.body, this.popupObj.element], POPUP_FULL_SCREEN);
            this.setSearchBoxPosition();
        }
        popupElement.style.visibility = 'visible';
        sf.base.addClass([popupElement], 'e-popup-close');
        sf.base.attributes(this.element, {
            'aria-expanded': 'true'
        });
        if (openEventArgs !== null && openEventArgs.popup !== null && isModifiedPopup) {
            for (var _i = 0, _a = Object.keys(openEventArgs.popup); _i < _a.length; _i++) {
                var prop = _a[_i];
                switch (prop) {
                    case 'collision':
                        if (openEventArgs.popup.collision && (this.popupObj.collision.X !== openEventArgs.popup.collision.X.toLowerCase() || this.popupObj.collision.Y !== openEventArgs.popup.collision.Y.toLowerCase())) {
                            this.popupObj.collision = { X: openEventArgs.popup.collision.X.toLowerCase(), Y: openEventArgs.popup.collision.Y.toLowerCase() };
                        }
                        break;
                    case 'position':
                        if (this.popupObj.position && (this.popupObj.position.X !== openEventArgs.popup.position.X || this.popupObj.position.Y !== openEventArgs.popup.position.Y)) {
                            this.popupObj.position = { X: openEventArgs.popup.position.X, Y: openEventArgs.popup.position.Y };
                        }
                        break;
                    case 'relateTo':
                        if (this.popupObj.relateTo !== openEventArgs.popup.relateTo) {
                            this.popupObj.relateTo = openEventArgs.popup.relateTo;
                        }
                        break;
                    case 'targetType':
                        if (this.popupObj.targetType !== openEventArgs.popup.targetType.toLowerCase()) {
                            this.popupObj.targetType = openEventArgs.popup.targetType;
                        }
                        break;
                    case 'offsetX':
                        if (this.popupObj.offsetX !== openEventArgs.popup.offsetX) {
                            this.popupObj.offsetX = openEventArgs.popup.offsetX;
                        }
                        break;
                    case 'offsetY':
                        if (this.popupObj.offsetY !== openEventArgs.popup.offsetY) {
                            this.popupObj.offsetY = openEventArgs.popup.offsetY;
                        }
                        break;
                }
            }
            this.popupObj.dataBind();
            this.popupObj.refreshPosition(this.popupObj.relateTo, true);
        }
        if (this.options.enableVirtualization) {
            sf.base.EventHandler.add(this.list, 'scroll', this.virtualScroll, this);
        }
        var animModel = {
            name: 'FadeIn',
            duration: 100
        };
        this.popupObj.show(new sf.base.Animation(animModel), this.options.zIndex === 1000 ? this.element : null);
    };
    SfMultiSelect.prototype.setSearchBoxPosition = function () {
        var searchBoxHeight = this.filterInput.parentElement.getBoundingClientRect().height;
        this.popupObj.element.style.maxHeight = '100%';
        this.popupObj.element.style.width = '100%';
        this.list.style.maxHeight = (window.innerHeight - searchBoxHeight) + 'px';
        this.list.style.height = (window.innerHeight - searchBoxHeight) + 'px';
    };
    SfMultiSelect.prototype.filterKeydown = function (e) {
        if (this.filterInput.value === "" && e.keyCode === 32 && this.list.querySelector('.' + ITEM_FOCUS)) {
            e.preventDefault();
        }
    };
    SfMultiSelect.prototype.setWidth = function () {
        var width = sf.base.formatUnit(this.options.popupWidth);
        if (width.indexOf('%') > -1) {
            var inputWidth = this.containerElement.offsetWidth * parseFloat(width) / 100;
            width = inputWidth.toString() + 'px';
        }
        return width;
    };
    SfMultiSelect.prototype.popupCreation = function (popupElement) {
        var _this = this;
        this.popupContainer = popupElement;
        this.popupObj = new sf.popups.Popup(this.popupContainer, {
            width: this.setWidth(), targetType: 'relative',
            relateTo: this.containerElement, collision: { X: 'flip', Y: 'flip' }, offsetY: 1,
            enableRtl: this.options.enableRtl, position: { X: 'left', Y: 'bottom' },
            zIndex: this.options.zIndex,
            close: function () {
                sf.base.EventHandler.remove(_this.list, 'scroll', _this.setFloatingHeader);
                sf.base.removeClass([_this.containerElement], ICON_ANIM);
                _this.fixedHeaderElement = null;
                _this.popupHolder.appendChild(_this.popupContainer);
                sf.base.EventHandler.remove(document, 'mousedown', _this.onDocumentClick);
                if (sf.base.Browser.isDevice && _this.isFilterLayout()) {
                    sf.base.removeClass([document.body, _this.popupObj.element], POPUP_FULL_SCREEN);
                    sf.base.EventHandler.remove(_this.list, 'scroll', _this.listScroll);
                }
                if (_this.options.enableVirtualization) {
                    sf.base.EventHandler.remove(_this.list, 'scroll', _this.virtualScroll);
                }
                if (_this.popupObj) {
                    _this.popupObj.destroy();
                }
                if (!sf.base.isNullOrUndefined(_this.isDisposed) && !_this.isDisposed) {
                    _this.dotNetRef.invokeMethodAsync(CLOSE_POPUP);
                }
                _this.popupObj = null;
            },
            open: function () {
                sf.base.EventHandler.add(document, 'mousedown', _this.onDocumentClick, _this);
                if (_this.options.allowFiltering && _this.filterInput) {
                    _this.filterInput.focus();
                }
                if (_this.list.querySelector('li') && _this.list.querySelector('li').classList.contains(GROUP) && !popupElement.classList.contains(GROUP_CHECKBOX)) {
                    sf.base.EventHandler.add(_this.list, 'scroll', _this.setFloatingHeader, _this);
                }
                _this.setScrollPosition();
            },
            targetExitViewport: function () {
                if (!sf.base.Browser.isDevice && !_this.isDisposed) {
                    _this.dotNetRef.invokeMethodAsync(HIDE);
                }
            }
        });
    };
    SfMultiSelect.prototype.virtualScroll = function () {
        if (this.popupObj && this.popupObj.element) {
            var borderWidth = parseInt(getComputedStyle(this.popupObj.element).borderWidth, 10);
            borderWidth = borderWidth == 0 ? 1 : borderWidth;
            var isPopupOpen = this.popupObj.element.classList.contains('e-popup-open');
            if (((this.list.scrollTop + this.list.offsetHeight) + borderWidth >= this.list.scrollHeight) && isPopupOpen && !this.isDisposed) {
                this.dotNetRef.invokeMethodAsync(VIRTUAL_HANDLER);
            }
        }
    };
    SfMultiSelect.prototype.onDocumentClick = function (e) {
        var target = e.target;
        if (!(!sf.base.isNullOrUndefined(this.popupObj) && sf.base.closest(target, '#' + this.popupObj.element.id)) &&
            !this.containerElement.contains(e.target)) {
            if (!this.isDisposed && this.containerElement.classList.contains(INPUT_FOCUS) || this.isPopupOpen()) {
                this.dotNetRef.invokeMethodAsync(HIDE);
            }
        }
        else if (target !== this.element && !(this.options.allowFiltering && this.options.mode === 'CheckBox' && target === this.filterInput)
            && !(!this.options.allowFiltering && sf.base.Browser.isDevice && target === this.containerElement.querySelector('.e-ddl-icon'))) {
            e.preventDefault();
        }
    };
    SfMultiSelect.prototype.listScroll = function () {
        this.filterInput.blur();
    };
    SfMultiSelect.prototype.setFloatingHeader = function (e) {
        if (sf.base.isNullOrUndefined(this.fixedHeaderElement)) {
            this.fixedHeaderElement = sf.base.createElement('div', { className: FIXED_HEAD });
            if (!this.list.querySelector('li').classList.contains(GROUP)) {
                this.fixedHeaderElement.style.display = 'none';
            }
            sf.base.prepend([this.fixedHeaderElement], this.list);
            this.setFixedHeader();
        }
        this.scrollStop(e);
    };
    SfMultiSelect.prototype.isFilterLayout = function () {
        return this.options.mode === 'CheckBox' && this.options.allowFiltering;
    };
    SfMultiSelect.prototype.setFixedHeader = function () {
        this.list.parentElement.style.display = 'block';
        var borderWidth = 0;
        if (this.list && this.list.parentElement) {
            borderWidth = parseInt(document.defaultView.getComputedStyle(this.list.parentElement, null).getPropertyValue('border-width'), 10);
        }
        var liWidth = this.liCollections[0].offsetWidth - borderWidth;
        this.fixedHeaderElement.style.width = liWidth.toString() + 'px';
        sf.base.setStyleAttribute(this.fixedHeaderElement, { zIndex: 10 });
        var firstLi = this.list.querySelector('.' + GROUP);
        this.fixedHeaderElement.innerHTML = firstLi.innerHTML;
    };
    SfMultiSelect.prototype.scrollStop = function (e) {
        var target = e.target;
        var liHeight = parseInt(getComputedStyle(this.liCollections[0], null).getPropertyValue('height'), 10);
        var topIndex = Math.round(target.scrollTop / liHeight);
        var liCollections = this.list.querySelectorAll('li');
        for (var i = topIndex; i > -1; i--) {
            if (!sf.base.isNullOrUndefined(liCollections[i]) && liCollections[i].classList.contains(GROUP)) {
                var currentLi = liCollections[i];
                this.fixedHeaderElement.innerHTML = currentLi.innerHTML;
                this.fixedHeaderElement.style.top = e.target.scrollTop + 'px';
                this.fixedHeaderElement.style.display = 'block';
                break;
            }
            else {
                this.fixedHeaderElement.style.display = 'none';
                this.fixedHeaderElement.style.top = 'none';
            }
        }
    };
    SfMultiSelect.prototype.closePopup = function (closeEventArgs, options) {
        this.options = options;
        if (this.isPopupOpen() && !closeEventArgs.cancel && this.popupObj) {
            var animModel = {
                name: 'FadeOut',
                duration: 100,
                delay: 0
            };
            this.popupObj.hide(new sf.base.Animation(animModel));
        }
    };
    SfMultiSelect.prototype.setScrollPosition = function (action) {
        if (!sf.base.isNullOrUndefined(action) && action !== '') {
            switch (action) {
                case 'PageDown':
                case 'ArrowDown':
                case 'End':
                    this.scrollBottom();
                    break;
                default:
                    this.scrollTop();
                    break;
            }
        }
        else {
            this.scrollBottom(true);
        }
    };
    SfMultiSelect.prototype.scrollBottom = function (isInitial) {
        if (this.list && (this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED))) {
            var selectedLI = this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED);
            var currentOffset = this.list.offsetHeight;
            var groupBy = this.list.querySelector('li').classList.contains(GROUP);
            var nextBottom = selectedLI.offsetTop + selectedLI.offsetHeight - this.list.scrollTop;
            var nextOffset = this.list.scrollTop + nextBottom - currentOffset;
            nextOffset = isInitial ? nextOffset + parseInt(getComputedStyle(this.list).paddingTop, 10) * 2 : nextOffset;
            var boxRange = selectedLI.offsetTop + selectedLI.offsetHeight - this.list.scrollTop;
            boxRange = groupBy && !sf.base.isNullOrUndefined(this.fixedHeaderElement) ?
                boxRange - this.fixedHeaderElement.offsetHeight : boxRange;
            if (nextBottom > currentOffset || !(boxRange > 0 && this.list.offsetHeight > boxRange)) {
                this.list.scrollTop = nextOffset;
            }
        }
    };
    SfMultiSelect.prototype.scrollTop = function () {
        if (this.list && (this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED))) {
            var selectedLI = this.list.querySelector('.' + ITEM_FOCUS) || this.list.querySelector('.' + SELECTED);
            var nextOffset = selectedLI.offsetTop - this.list.scrollTop;
            var groupBy = this.list.querySelector('li').classList.contains(GROUP);
            nextOffset = groupBy && !sf.base.isNullOrUndefined(this.fixedHeaderElement) ?
                nextOffset - this.fixedHeaderElement.offsetHeight : nextOffset;
            var boxRange = (selectedLI.offsetTop + selectedLI.offsetHeight - this.list.scrollTop);
            if (nextOffset < 0) {
                this.list.scrollTop = this.list.scrollTop + nextOffset;
            }
            else if (!(boxRange > 0 && this.list.offsetHeight > boxRange)) {
                this.list.scrollTop = selectedLI.offsetTop - (groupBy && !sf.base.isNullOrUndefined(this.fixedHeaderElement) ?
                    this.fixedHeaderElement.offsetHeight : 0);
            }
        }
    };
    SfMultiSelect.prototype.windowResize = function () {
        if (this.options.mode !== 'Box' && this.viewContainer) {
            this.updateDelimViews(this.viewContainer, this.options);
        }
    };
    SfMultiSelect.prototype.updateDelimViews = function (viewElement, options) {
        this.options = options;
        this.viewContainer = viewElement;
        if (this.viewContainer && this.viewContainer.previousElementSibling) {
            this.viewContainer.previousElementSibling.classList.add(DELIM_HIDE);
        }
        var delimValues = this.options.delimValue;
        if (!sf.base.isNullOrUndefined(delimValues) && delimValues.length > 0) {
            this.viewContainer.classList.remove(DELIM_HIDE);
        }
        else {
            this.viewContainer.innerHTML = '';
        }
        this.dropIconEle = this.containerElement.querySelector('.' + DROP_DOWN_ICON);
        this.clearIconEle = this.containerElement.querySelector('.' + CLEAR_ICON);
        this.viewContainer.classList.remove(TOTAL_COUNT_WRAPPER);
        if (delimValues && delimValues.length > 0) {
            var data = '';
            var temp = void 0;
            var tempData = void 0;
            var tempIndex = 1;
            var containerWidth = void 0;
            var remaining = void 0;
            var downIconWidth = 0;
            var clearIconWidth = 0;
            var overAllContainer = void 0;
            this.viewContainer.innerHTML = '';
            var raminElement = sf.base.createElement('span', {
                className: REMAIN_WRAPPER
            });
            raminElement.innerHTML = this.options.overFlowContent;
            this.viewContainer.appendChild(raminElement);
            var remainSize = raminElement.offsetWidth;
            sf.base.remove(raminElement);
            if (this.dropIconEle) {
                downIconWidth = this.dropIconEle.offsetWidth +
                    parseInt(window.getComputedStyle(this.dropIconEle).marginRight, 10);
            }
            if (this.clearIconEle) {
                clearIconWidth = this.clearIconEle.offsetWidth +
                    parseInt(window.getComputedStyle(this.clearIconEle).marginRight, 10);
            }
            if (!sf.base.isNullOrUndefined(delimValues)) {
                for (var index = 0; !sf.base.isNullOrUndefined(delimValues[index]); index++) {
                    data += (index === 0) ? '' : this.options.delimiterChar + ' ';
                    temp = delimValues[index];
                    data += temp;
                    temp = this.viewContainer.innerHTML;
                    this.viewContainer.innerHTML = data;
                    containerWidth = this.viewContainer.offsetWidth +
                        parseInt(window.getComputedStyle(this.viewContainer).paddingRight, 10);
                    overAllContainer = this.childContainerElement.offsetWidth -
                        parseInt(window.getComputedStyle(this.childContainerElement).paddingLeft, 10) -
                        parseInt(window.getComputedStyle(this.childContainerElement).paddingRight, 10);
                    if ((containerWidth + downIconWidth + clearIconWidth) > overAllContainer) {
                        if (!sf.base.isNullOrUndefined(tempData) && tempData !== '') {
                            temp = tempData;
                            index = tempIndex + 1;
                        }
                        this.viewContainer.innerHTML = temp;
                        remaining = delimValues.length - index;
                        containerWidth = this.viewContainer.offsetWidth;
                        while (((containerWidth + remainSize + downIconWidth) > overAllContainer) && containerWidth !== 0
                            && this.viewContainer.innerHTML !== '') {
                            var textArr = this.viewContainer.innerHTML.split(this.options.delimiterChar);
                            var totalLength = textArr.length;
                            textArr.pop();
                            var remainTxtLength = textArr.length;
                            this.viewContainer.innerHTML = textArr.join(this.options.delimiterChar);
                            if (remainTxtLength !== totalLength && remainTxtLength !== 0) {
                                remaining = remaining - remainTxtLength + totalLength;
                            }
                            if (this.viewContainer.innerHTML === '') {
                                remaining++;
                            }
                            containerWidth = this.viewContainer.offsetWidth;
                        }
                        break;
                    }
                    else if ((containerWidth + remainSize + downIconWidth + clearIconWidth) <= overAllContainer) {
                        tempData = data;
                        tempIndex = index;
                    }
                    else if (index === 0) {
                        tempData = '';
                        tempIndex = -1;
                    }
                }
                if (remaining > 0) {
                    var totalWidth = overAllContainer - downIconWidth - clearIconWidth;
                    this.updateRemainElement(raminElement, this.viewContainer, remaining, totalWidth);
                }
            }
            else {
                this.viewContainer.innerHTML = '';
                this.viewContainer.style.display = 'none';
            }
        }
    };
    SfMultiSelect.prototype.updateRemainWidth = function (viewContainer, totalWidth) {
        if (viewContainer.classList.contains(TOTAL_COUNT_WRAPPER) && totalWidth < (viewContainer.offsetWidth +
            parseInt(window.getComputedStyle(viewContainer).paddingLeft, 10)
            + parseInt(window.getComputedStyle(viewContainer).paddingLeft, 10))) {
            viewContainer.style.width = totalWidth + 'px';
        }
    };
    SfMultiSelect.prototype.updateRemainElement = function (raminElement, viewContainer, remaining, totalWidth) {
        var _this = this;
        if (viewContainer.firstChild && viewContainer.firstChild.nodeType === 3 && viewContainer.firstChild.nodeValue === '') {
            viewContainer.removeChild(viewContainer.firstChild);
        }
        raminElement.innerHTML = '';
        if (!this.isDisposed) {
            // tslint:disable
            this.dotNetRef.invokeMethodAsync(REMAIN_COUNT, remaining).then(function (remainCount) {
                var remainTemp = _this.options.overFlowContent.replace('${count}', remainCount);
                var totalTemp = _this.options.totalCountContent.replace('${count}', remainCount);
                raminElement.innerHTML = (viewContainer.firstChild && viewContainer.firstChild.nodeType === 3) ?
                    remainTemp : totalTemp;
                if (viewContainer.firstChild && viewContainer.firstChild.nodeType === 3) {
                    viewContainer.classList.remove(TOTAL_COUNT_WRAPPER);
                }
                else {
                    viewContainer.classList.add(TOTAL_COUNT_WRAPPER);
                    _this.updateRemainWidth(viewContainer, totalWidth);
                }
                var remainderElement = _this.viewContainer.querySelector('.' + REMAIN_WRAPPER);
                if (remainderElement) {
                    sf.base.remove(remainderElement);
                }
                _this.viewContainer.appendChild(raminElement);
                _this.updateRemainWidth(_this.viewContainer, totalWidth);
            });
        }
    };
    SfMultiSelect.prototype.isPopupOpen = function () {
        return this.popupObj && document.body.contains(this.popupObj.element);
    };
    SfMultiSelect.prototype.getItems = function () {
        return this.list ? this.list.querySelectorAll('.' + LIST_ITEM) : [];
    };
    SfMultiSelect.prototype.refreshPopup = function () {
        if (this.isPopupOpen()) {
            this.popupObj.refreshPosition(this.containerElement);
        }
    };
    return SfMultiSelect;
}());
// tslint:disable
var MultiSelect = {
    initialize: function (containerElement, childContainerElement, element, dotnetRef, options) {
        if (element) {
            new SfMultiSelect(containerElement, childContainerElement, element, dotnetRef, options);
            if (element.blazor__instance) {
                element.blazor__instance.initialize();
            }
        }
    },
    renderPopup: function (element, popupElement, popupHolderEle, openEventArgs, isModifiedPopup, options, dataItem) {
        if (element && element.blazor__instance && popupElement && popupHolderEle) {
            element.blazor__instance.renderPopup(popupElement, popupHolderEle, openEventArgs, isModifiedPopup, options, dataItem);
        }
    },
    closePopup: function (element, closeEventArgs, options) {
        if (element && element.blazor__instance) {
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    },
    refreshPopup: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.refreshPopup();
        }
    },
    updateScrollPosition: function (element, action) {
        if (element && element.blazor__instance) {
            element.blazor__instance.setScrollPosition(action);
        }
    },
    getPageCount: function (popupEle) {
        var list = popupEle && popupEle.querySelector('.e-content');
        if (list) {
            var liHeight = list.classList.contains('e-nodata') ? null :
                getComputedStyle(list.querySelectorAll('.e-list-item:not(.e-hide-listitem)')[0], null).getPropertyValue('height');
            return Math.round(list.getBoundingClientRect().height / parseInt(liHeight, 10));
        }
        return 0;
    },
    updateDelimViews: function updateDelimViews(element, viewElement, options) {
        if (element && element.blazor__instance) {
            element.blazor__instance.updateDelimViews(viewElement, options);
        }
    },
    destroy: function (element, popupElement, popupHolderEle, closeEventArgs, options) {
        if (element && element.blazor__instance && popupElement && popupElement instanceof HTMLElement && popupHolderEle) {
            element.blazor__instance.isDisposed = true;
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    },
    focusIn: function (inputEle) {
        inputEle && inputEle.focus();
    },
    focusOut: function (inputEle) {
        inputEle && inputEle.blur();
    }
};

return MultiSelect;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-numerictextbox.js":
/*!********************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-numerictextbox.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.NumericTextBox = (function () {
'use strict';

/**
 * Blazor numeric texbot interop handler
 */
var INTREGEXP = new RegExp('^(-)?(\\d*)$');
var ENTER = 13;
var ARROW_UP = 38;
var ARROW_DOWN = 40;
var BACK_SPACE = 8;
var WHEEL_DELTA = 120;
var DELTA = 3;
var LEFT_BUTTON = 0;
var RIGHT_BUTTON = 3;
var MOBILE_INTERVEL_TIME = 600;
var INTERVEL_TIME = 90;
var TIMEOUT = 150;
var MOUSE_BUTTON = 2;
var IE_VERSION = '11.0';
var INCREMENT = 'increment';
var DECREMENT = 'decrement';
var MOUSE_MOVE = 'mouseleave';
var ROOT = 'e-input-group-icon';
var MOUSE_UP = 'mouseup';
var MOUSE_WHEEL = 'mousewheel DOMMouseScroll';
var SERVER_ACTION = 'ServerAction';
var SPIN_UP = 'e-spin-up';
var SPIN_DOWN = 'e-spin-down';
var FOCUS = 'focus';
var BLUR = 'blur';
var KEY_PRESS = 'keypress';
var KEY_DOWN = 'keydown';
var PASTE = 'paste';
var SfNumericTextBox = /** @class */ (function () {
    function SfNumericTextBox(wrapperElement, element, dotnetRef, options) {
        this.wrapperElement = wrapperElement;
        this.element = element;
        this.options = options;
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
    }
    SfNumericTextBox.prototype.initialize = function () {
        this.spinButtonEvents();
        sf.base.EventHandler.add(this.element, FOCUS, this.focusHandler, this);
        sf.base.EventHandler.add(this.element, BLUR, this.focusOutHandler, this);
        sf.base.EventHandler.add(this.element, KEY_PRESS, this.keyPressHandler, this);
        sf.base.EventHandler.add(this.element, KEY_DOWN, this.keyDownHandler, this);
        sf.base.EventHandler.add(this.element, PASTE, this.pasteHandler, this);
    };
    SfNumericTextBox.prototype.keyPressHandler = function (event) {
        if (!this.options.enabled || this.options.readonly) {
            return true;
        }
        var action = event.keyCode;
        if (event.which === LEFT_BUTTON || event.metaKey || event.ctrlKey || action === BACK_SPACE || action === ENTER) {
            return true;
        }
        var currentChar = String.fromCharCode(event.which);
        var text = this.element.value;
        var inputElement = this.element;
        text = text.substring(0, inputElement.selectionStart) + currentChar + text.substring(inputElement.selectionEnd);
        if (!this.numericRegex().test(text)) {
            event.preventDefault();
            event.stopPropagation();
            return false;
        }
        else {
            return true;
        }
    };
    
    SfNumericTextBox.prototype.pasteHandler = function (event) {
        if (!(!this.options.enabled || this.options.readonly)) {
            var pasteValue = event.clipboardData.getData('text/plain');
            if (!this.numericRegex().test(pasteValue)) {
                event.preventDefault();
            }
            else {
                this.dotNetRef.invokeMethodAsync('InvokePasteHandler', pasteValue);
            }
        }
    };
    SfNumericTextBox.prototype.keyDownHandler = function (event) {
        if (!this.options.readonly) {
            if (event.keyCode === ARROW_UP) {
                event.preventDefault();
                this.dotNetRef.invokeMethodAsync(SERVER_ACTION, INCREMENT, event);
            }
            else if (event.keyCode === ARROW_DOWN) {
                event.preventDefault();
                this.dotNetRef.invokeMethodAsync(SERVER_ACTION, DECREMENT, event);
            }
        }
    };
    
    SfNumericTextBox.prototype.numericRegex = function () {
        var decimalSeparator = this.options.decimalSeparator;
        var fractionRule = '*';
        if (decimalSeparator === '.') {
            decimalSeparator = '\\' + decimalSeparator;
        }
        if (this.options.decimals === 0 && this.options.validateDecimalOnType) {
            return INTREGEXP;
        }
        if (this.options.decimals && this.options.validateDecimalOnType) {
            fractionRule = '{0,' + this.options.decimals + '}';
        }
        return new RegExp('^(-)?(((\\d+(' + decimalSeparator + '\\d' + fractionRule +
            ')?)|(' + decimalSeparator + '\\d' + fractionRule + ')))?$');
    };
    
    SfNumericTextBox.prototype.mouseWheel = function (event) {
        event.preventDefault();
        var delta;
        // tslint:disable-next-line
        var rawEvent = event;
        if (rawEvent.wheelDelta) {
            delta = rawEvent.wheelDelta / WHEEL_DELTA;
        }
        else if (rawEvent.detail) {
            delta = -rawEvent.detail / DELTA;
        }
        if (delta > 0) {
            this.dotNetRef.invokeMethodAsync(SERVER_ACTION, INCREMENT, event);
        }
        else if (delta < 0) {
            this.dotNetRef.invokeMethodAsync(SERVER_ACTION, DECREMENT, event);
        }
    };
    SfNumericTextBox.prototype.focusHandler = function (event) {
        this.isFocused = true;
        if (!(!this.options.enabled || this.options.readonly)) {
            if (!sf.base.Browser.isDevice) {
                sf.base.EventHandler.add(this.element, MOUSE_WHEEL, this.mouseWheel, this);
            }
        }
    };
    SfNumericTextBox.prototype.focusOutHandler = function (event) {
        this.isFocused = false;
        event.preventDefault();
        if (!sf.base.Browser.isDevice) {
            sf.base.EventHandler.remove(this.element, MOUSE_WHEEL, this.mouseWheel);
        }
    };
    SfNumericTextBox.prototype.mouseDownOnSpinner = function (event) {
        var _this = this;
        if (this.options.enabled && !this.options.readonly) {
            if (this.isFocused) {
                this.isPrevFocused = true;
                event.preventDefault();
            }
            var target = event.currentTarget;
            var action_1 = (target.classList.contains(SPIN_UP)) ? INCREMENT : DECREMENT;
            sf.base.EventHandler.add(target, MOUSE_MOVE, this.mouseUpClick, this);
            // tslint:disable
            this.timeOut = setInterval(function () {
                _this.isCalled = true;
                _this.dotNetRef.invokeMethodAsync(SERVER_ACTION, action_1, event);
            }, TIMEOUT);
            sf.base.EventHandler.add(document, MOUSE_UP, this.mouseUpClick, this);
        }
    };
    SfNumericTextBox.prototype.mouseUpOnSpinner = function (event) {
        if (this.options.enabled && !this.options.readonly) {
            if (this.isPrevFocused) {
                this.element.focus();
                if (!sf.base.Browser.isDevice) {
                    this.isPrevFocused = false;
                }
            }
            if (!sf.base.Browser.isDevice) {
                event.preventDefault();
            }
            if (!this.getElementData(event)) {
                return;
            }
            var target = event.currentTarget;
            var action = (target.classList.contains(SPIN_UP)) ? INCREMENT : DECREMENT;
            sf.base.EventHandler.remove(target, MOUSE_MOVE, this.mouseUpClick);
            if (!this.isCalled) {
                this.dotNetRef.invokeMethodAsync(SERVER_ACTION, action, event);
            }
            this.isCalled = false;
            sf.base.EventHandler.remove(document, MOUSE_UP, this.mouseUpClick);
        }
    };
    SfNumericTextBox.prototype.touchMoveOnSpinner = function (event) {
        if (!this.options.enabled || this.options.readonly) {
            var target = document.elementFromPoint(event.clientX, event.clientY);
            if (!(target.classList.contains(ROOT))) {
                clearInterval(this.timeOut);
            }
        }
    };
    SfNumericTextBox.prototype.getElementData = function (event) {
        if ((event.which && event.which === RIGHT_BUTTON) || (event.button && event.button === MOUSE_BUTTON)
            || !this.options.enabled || this.options.readonly) {
            return false;
        }
        clearInterval(this.timeOut);
        return true;
    };
    SfNumericTextBox.prototype.mouseUpClick = function (event) {
        event.stopPropagation();
        clearInterval(this.timeOut);
        this.isCalled = false;
        sf.base.EventHandler.remove(this.spinUp, MOUSE_MOVE, this.mouseUpClick);
        sf.base.EventHandler.remove(this.spinDown, MOUSE_MOVE, this.mouseUpClick);
    };
    SfNumericTextBox.prototype.selectRange = function (formatValue) {
        var _this = this;
        if (!sf.base.Browser.isDevice && sf.base.Browser.info.version === IE_VERSION) {
            this.element.setSelectionRange(0, formatValue.length);
        }
        else {
            var delay = (sf.base.Browser.isDevice && sf.base.Browser.isIos) ? MOBILE_INTERVEL_TIME : INTERVEL_TIME;
            setTimeout(function () {
                _this.element.setSelectionRange(0, formatValue.length);
            }, delay);
        }
    };
    SfNumericTextBox.prototype.isDevice = function () {
        return sf.base.Browser.isDevice;
    };
    SfNumericTextBox.prototype.spinButtonEvents = function () {
        this.spinDown = this.wrapperElement ? this.wrapperElement.querySelector('.' + SPIN_DOWN) : null;
        this.spinUp = this.wrapperElement ? this.wrapperElement.querySelector('.' + SPIN_UP) : null;
        if (this.spinDown && this.spinUp) {
            this.unBindSpinButton();
            this.bindSpinButton();
        }
    };
    SfNumericTextBox.prototype.bindSpinButton = function () {
        sf.base.EventHandler.add(this.spinUp, sf.base.Browser.touchStartEvent, this.mouseDownOnSpinner, this);
        sf.base.EventHandler.add(this.spinDown, sf.base.Browser.touchStartEvent, this.mouseDownOnSpinner, this);
        sf.base.EventHandler.add(this.spinUp, sf.base.Browser.touchEndEvent, this.mouseUpOnSpinner, this);
        sf.base.EventHandler.add(this.spinDown, sf.base.Browser.touchEndEvent, this.mouseUpOnSpinner, this);
        sf.base.EventHandler.add(this.spinUp, sf.base.Browser.touchMoveEvent, this.touchMoveOnSpinner, this);
        sf.base.EventHandler.add(this.spinDown, sf.base.Browser.touchMoveEvent, this.touchMoveOnSpinner, this);
    };
    SfNumericTextBox.prototype.unBindSpinButton = function () {
        sf.base.EventHandler.remove(this.spinUp, sf.base.Browser.touchStartEvent, this.mouseDownOnSpinner);
        sf.base.EventHandler.remove(this.spinDown, sf.base.Browser.touchStartEvent, this.mouseDownOnSpinner);
        sf.base.EventHandler.remove(this.spinUp, sf.base.Browser.touchEndEvent, this.mouseUpOnSpinner);
        sf.base.EventHandler.remove(this.spinDown, sf.base.Browser.touchEndEvent, this.mouseUpOnSpinner);
        sf.base.EventHandler.remove(this.spinUp, sf.base.Browser.touchMoveEvent, this.touchMoveOnSpinner);
        sf.base.EventHandler.remove(this.spinDown, sf.base.Browser.touchMoveEvent, this.touchMoveOnSpinner);
    };
    SfNumericTextBox.prototype.destroy = function () {
        sf.base.EventHandler.remove(this.element, FOCUS, this.focusHandler);
        sf.base.EventHandler.remove(this.element, BLUR, this.focusOutHandler);
        sf.base.EventHandler.remove(this.element, KEY_PRESS, this.keyPressHandler);
        sf.base.EventHandler.remove(this.element, KEY_DOWN, this.keyDownHandler);
        sf.base.EventHandler.remove(this.element, PASTE, this.pasteHandler);
    };
    return SfNumericTextBox;
}());
// tslint:disable
var NumericTextBox = {
    initialize: function (wrapperElement, element, dotnetRef, options) {
        if (element) {
            new SfNumericTextBox(wrapperElement, element, dotnetRef, options);
        }
        if (element && element.blazor__instance) {
            element.blazor__instance.initialize();
        }
    },
    selectRange: function (inputEle, formatValue) {
        if (inputEle && inputEle.blazor__instance) {
            inputEle.blazor__instance.selectRange(formatValue);
        }
    },
    propertyChanges: function (element, options) {
        if (element && element.blazor__instance) {
            element.blazor__instance.options = options;
        }
    },
    focusIn: function (inputEle) {
        if (inputEle) {
            inputEle.focus();
        }
    },
    focusOut: function (inputEle) {
        if (inputEle) {
            inputEle.blur();
        }
    },
    spinButtonEvents: function (inputEle) {
        if (inputEle && inputEle.blazor__instance) {
            inputEle.blazor__instance.spinButtonEvents();
        }
    },
    destroy: function (inputEle) {
        if (inputEle && inputEle.blazor__instance) {
            inputEle.blazor__instance.destroy();
        }
    }
};

return NumericTextBox;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-progressbar.js":
/*!*****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-progressbar.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Progressbar = (function () {
'use strict';

/* eslint-disable max-len */
var LINECAPRADIUS = 0.9;
var SPACE = ' ';
var SfProgressbar = /** @class */ (function () {
    function SfProgressbar(element, dotNetRef) {
        this.resizeTo = 0;
        this.element = element;
        this.dotNetRef = dotNetRef;
        // eslint-disable-next-line camelcase
        this.element.blazor__instance = this;
    }
    SfProgressbar.prototype.wireEvents = function () {
        window.addEventListener((sf.base.Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resize.bind(this));
    };
    SfProgressbar.prototype.unWireEvents = function () {
        window.removeEventListener((sf.base.Browser.isTouch && ('orientation' in window && 'onorientationchange' in window)) ? 'orientationchange' : 'resize', this.resize.bind(this));
        this.element = null;
        this.dotNetRef = null;
    };
    SfProgressbar.prototype.resize = function () {
        var _this = this;
        if (this.dotNetRef && !this.cancelResize || ((this.lineardata && this.lineardata.isActive) || (this.circularData && this.circularData.isActive))) {
            if (this.resizeTo) {
                clearTimeout(this.resizeTo);
            }
            this.resizeTo = window.setTimeout(function () { _this.dotNetRef.invokeMethodAsync('TriggerResize'); }, 500);
        }
    };
    SfProgressbar.prototype.getPathArc = function (x, y, radius, startAngle, endAngle, enableRtl, pieView) {
        var start = this.degreeToLocation(x, y, radius, startAngle);
        var end = this.degreeToLocation(x, y, radius, endAngle);
        var largeArcFlag = '0';
        var sweepFlag = (enableRtl) ? '0' : '1';
        if (!enableRtl) {
            largeArcFlag = ((endAngle >= startAngle) ? endAngle : endAngle + 360) - startAngle <= 180 ? '0' : '1';
        }
        else {
            largeArcFlag = ((startAngle >= endAngle) ? startAngle : startAngle + 360) - endAngle <= 180 ? '0' : '1';
        }
        var d;
        if (pieView) {
            d = 'M ' + x + SPACE + y + ' L ' + start.x + SPACE + start.y + ' A ' + radius + SPACE +
                radius + SPACE + ' 0 ' + SPACE + largeArcFlag + SPACE + sweepFlag + SPACE + end.x + SPACE + end.y + SPACE + 'Z';
        }
        else {
            d = 'M' + start.x + SPACE + start.y +
                'A' + radius + SPACE + radius + SPACE + '0' + SPACE + largeArcFlag + SPACE + sweepFlag + SPACE + end.x + SPACE + end.y;
        }
        return d;
    };
    SfProgressbar.prototype.degreeToLocation = function (centerX, centerY, radius, angleInDegrees) {
        var angleInRadians = (angleInDegrees - 90) * (Math.PI / 180);
        return {
            x: centerX + (radius * Math.cos(angleInRadians)),
            y: centerY + (radius * Math.sin(angleInRadians))
        };
    };
    SfProgressbar.prototype.effect = function (currentTime, startValue, endValue, duration, enableRtl) {
        return (enableRtl ? endValue : -endValue) * Math.cos(currentTime / duration * (Math.PI / 2)) + (startValue + (enableRtl ? -endValue : endValue));
    };
    SfProgressbar.prototype.activeAnimate = function (time, start, end, enableRtl) {
        var activeTime = 1 - Math.pow(1 - time, 3);
        return start + (!enableRtl ? activeTime * end : -activeTime * end);
    };
    SfProgressbar.prototype.getPathLine = function (x, animateData) {
        var moveTo = animateData.enableRtl ? animateData.cornerRadius === 'Round' ? (x + animateData.rectWidth) - ((LINECAPRADIUS / 2) * animateData.thickness) : (x + animateData.rectWidth) :
            animateData.cornerRadius === 'Round' ? (x + (LINECAPRADIUS / 2) * animateData.thickness) : x;
        var lineTo = animateData.enableRtl ? animateData.cornerRadius === 'Round' && animateData.progressWidth ? (moveTo - animateData.progressWidth + (LINECAPRADIUS * animateData.thickness)) : moveTo - animateData.progressWidth :
            animateData.cornerRadius === 'Round' && animateData.progressWidth ? moveTo + animateData.progressWidth - (LINECAPRADIUS * animateData.thickness) : moveTo + animateData.progressWidth;
        return 'M' + moveTo + SPACE + (animateData.rectX + (animateData.rectHeight / 2)) + 'L' + lineTo + ' ' + (animateData.rectY + (animateData.rectHeight / 2));
    };
    SfProgressbar.prototype.circularAnimation = function () {
        var _this = this;
        var animation = new sf.base.Animation({});
        var progressElement = document.getElementById(this.element.id + '_clippathcircle');
        var end = 0;
        if (progressElement && this.circularData) {
            progressElement.style.visibility = 'hidden';
            animation.animate((progressElement), {
                duration: this.circularData.duration,
                delay: this.circularData.delay,
                progress: function (args) {
                    _this.cancelResize = true;
                    if (args.timeStamp >= args.delay) {
                        progressElement.style.visibility = 'visible';
                        if (_this.circularData.isActive) {
                            end = _this.activeAnimate((args.timeStamp / args.duration), _this.circularData.startPos, _this.circularData.endPos, _this.circularData.enableRtl);
                            var activeElement = document.getElementById(_this.element.id + '_CircularActiveProgress');
                            if (activeElement) {
                                activeElement.setAttribute('opacity', _this.effect(args.timeStamp, 0.5, 0.5, args.duration, true).toString());
                            }
                        }
                        else {
                            end = _this.effect(args.timeStamp, _this.circularData.startPos, _this.circularData.endPos, args.duration, _this.circularData.enableRtl);
                        }
                        progressElement.setAttribute('d', _this.getPathArc(_this.circularData.x, _this.circularData.y, _this.circularData.pathRadius, _this.circularData.start, end % 360, _this.circularData.enableRtl, true));
                    }
                },
                end: function () {
                    _this.cancelResize = false;
                    progressElement.setAttribute('d', _this.getPathArc(_this.circularData.x, _this.circularData.y, _this.circularData.pathRadius, _this.circularData.start, _this.circularData.progressEnd, _this.circularData.enableRtl, true));
                    if (_this.circularData.isActive) {
                        _this.circularAnimation();
                    }
                    _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
                }
            });
        }
    };
    SfProgressbar.prototype.circularBufferAnimation = function () {
        var _this = this;
        var animation = new sf.base.Animation({});
        var progressElement = document.getElementById(this.element.id + '_clippathBuffercircle');
        var end = 0;
        if (progressElement && this.circularBufferData) {
            progressElement.style.visibility = 'hidden';
            animation.animate((progressElement), {
                duration: this.circularBufferData.duration,
                delay: this.circularBufferData.delay,
                progress: function (args) {
                    _this.cancelResize = true;
                    if (args.timeStamp >= args.delay) {
                        progressElement.style.visibility = 'visible';
                        end = _this.effect(args.timeStamp, _this.circularBufferData.startPos, _this.circularBufferData.endPos, args.duration, _this.circularBufferData.enableRtl);
                        progressElement.setAttribute('d', _this.getPathArc(_this.circularBufferData.x, _this.circularBufferData.y, _this.circularBufferData.pathRadius, _this.circularBufferData.start, end % 360, _this.circularBufferData.enableRtl, true));
                    }
                },
                end: function () {
                    _this.cancelResize = false;
                    progressElement.setAttribute('d', _this.getPathArc(_this.circularBufferData.x, _this.circularBufferData.y, _this.circularBufferData.pathRadius, _this.circularBufferData.start, _this.circularBufferData.progressEnd, _this.circularBufferData.enableRtl, true));
                    _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
                }
            });
        }
    };
    SfProgressbar.prototype.circularIndeterminateAnimation = function (start, end) {
        var _this = this;
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = 0; }
        var progressElement = document.getElementById(this.element.id + '_clippathcircle');
        var animation = new sf.base.Animation({});
        if (progressElement && this.circularData) {
            animation.destroy();
            animation.animate((progressElement), {
                duration: this.circularData.duration,
                delay: 0,
                progress: function () {
                    if (_this.circularData && _this.circularData.enable && _this.circularData.isIndeterminate) {
                        progressElement.style.visibility = 'visible';
                        start += _this.circularData.enableRtl ? -_this.circularData.segmentValue : _this.circularData.segmentValue;
                        end += _this.circularData.enableRtl ? -_this.circularData.segmentValue : _this.circularData.segmentValue;
                        progressElement.setAttribute('d', _this.getPathArc(_this.circularData.x, _this.circularData.y, _this.circularData.pathRadius, start % 360, end % 360, _this.circularData.enableRtl, !_this.circularData.enableProgressSegments));
                    }
                },
                end: function () {
                    if (_this.circularData && _this.circularData.enable && _this.circularData.isIndeterminate) {
                        _this.circularIndeterminateAnimation(start, end);
                    }
                }
            });
        }
    };
    SfProgressbar.prototype.annotationAnimation = function () {
        var _this = this;
        var animation = new sf.base.Animation({});
        var progressElement;
        var annotatElementChanged;
        var annotatElement = document.getElementById(this.element.id + 'Annotation0').children[0];
        if (annotatElement && annotatElement.children[0]) {
            if (annotatElement.children[0].tagName === 'SPAN') {
                annotatElementChanged = annotatElement.children[0];
            }
        }
        if (annotatElementChanged && this.annotationData) {
            if (this.annotationData.type === 'Linear') {
                progressElement = document.getElementById(this.element.id + '_clippathrect');
            }
            else {
                progressElement = document.getElementById(this.element.id + '_clippathcircle');
            }
            if (this.annotationData.isContent) {
                annotatElementChanged.innerHTML = this.annotationData.annotateValue + '%';
            }
            else if (progressElement) {
                animation.animate((progressElement), {
                    duration: this.annotationData.duration,
                    delay: this.annotationData.delay,
                    progress: function (args) {
                        _this.cancelResize = true;
                        var effectValue = _this.effect(args.timeStamp, _this.annotationData.startPos, _this.annotationData.endPos, args.duration, false);
                        var annotateValueChanged = parseInt((((Math.round(effectValue) - _this.annotationData.start) / _this.annotationData.totalAngle) * 100).toString(), 10);
                        annotatElementChanged.innerHTML = annotateValueChanged ? annotateValueChanged.toString() + '%' : '0%';
                    },
                    end: function () {
                        _this.cancelResize = false;
                        annotatElementChanged.innerHTML = _this.annotationData.annotateValue + '%';
                    }
                });
            }
        }
    };
    SfProgressbar.prototype.labelAnimation = function () {
        var _this = this;
        var labelElement;
        if (this.labelData) {
            labelElement = this.labelData.type === 'Linear' ? document.getElementById(this.element.id + '_linearLabel') : document.getElementById(this.element.id + '_circularLabel');
        }
        var animation = new sf.base.Animation({});
        var labelAnimation = new sf.base.Animation({});
        if (labelElement && this.labelData && !this.labelData.isStriped) {
            labelElement.style.visibility = 'hidden';
            animation.animate((labelElement), {
                duration: this.labelData.duration,
                delay: this.labelData.delay,
                progress: function (args) {
                    _this.cancelResize = true;
                    if (_this.labelData.type === 'Linear' && args.timeStamp >= args.delay && _this.labelData.labelText === '') {
                        labelElement.style.visibility = 'visible';
                        var effectValue = _this.effect(args.timeStamp, _this.labelData.progressPos, Math.round(_this.labelData.end - _this.labelData.progressPos), args.duration, false);
                        var valueChanged = parseInt(((effectValue / _this.labelData.width) * 100).toString(), 10);
                        labelElement.innerHTML = valueChanged.toString() + '%';
                        if (_this.labelData.labelPos === 'Far' || _this.labelData.labelPos === 'Center') {
                            var xPos = _this.effect(args.timeStamp, _this.labelData.startPos, _this.labelData.endPos - (_this.labelData.enableRtl ? 0 : _this.labelData.startPos), args.duration, _this.labelData.enableRtl);
                            labelElement.setAttribute('x', xPos.toString());
                        }
                    }
                    else if (_this.labelData.type === 'Circular' && _this.labelData.labelText === '') {
                        labelElement.style.visibility = 'visible';
                        var effectValue = _this.effect(args.timeStamp, _this.labelData.start, _this.labelData.end - _this.labelData.start, args.duration, false);
                        var valueChanged = parseInt(((effectValue / _this.labelData.totalAngle) * 100).toString(), 10);
                        labelElement.innerHTML = valueChanged.toString() + '%';
                    }
                },
                end: function () {
                    _this.cancelResize = false;
                    if (labelElement && _this.labelData.labelText === '') {
                        labelElement.style.visibility = 'visible';
                        labelElement.innerHTML = _this.labelData.text;
                        labelElement.setAttribute('x', _this.labelData.x.toString());
                    }
                    else {
                        labelAnimation.animate(labelElement, {
                            progress: function (args) {
                                labelElement.style.visibility = 'visible';
                                var effectValue = _this.effect(args.timeStamp, 0, 1, args.duration, false);
                                labelElement.setAttribute('opacity', effectValue.toString());
                            },
                            end: function () {
                                labelElement.setAttribute('opacity', '1');
                            }
                        });
                    }
                }
            });
        }
    };
    SfProgressbar.prototype.stripeAnimation = function (pointValue) {
        var _this = this;
        if (pointValue === void 0) { pointValue = 0; }
        var animation = new sf.base.Animation({});
        var stripElement = document.getElementById(this.element.id + '_LinearStriped');
        if (stripElement && this.stripeData) {
            animation.animate((stripElement), {
                duration: this.stripeData.duration,
                delay: this.stripeData.delay,
                progress: function () {
                    if (_this.stripeData.enable) {
                        pointValue += _this.stripeData.enableRtl ? -_this.stripeData.durationValue : _this.stripeData.durationValue;
                        stripElement.setAttribute('gradientTransform', 'translate(' + pointValue + ') rotate(-45)');
                    }
                },
                end: function () {
                    if (_this.stripeData.enable) {
                        _this.stripeAnimation(pointValue);
                    }
                }
            });
        }
    };
    SfProgressbar.prototype.linearIndeterminateAnimation = function () {
        var _this = this;
        var animation = new sf.base.Animation({});
        var progressElement = document.getElementById(this.element.id + '_clippathrect');
        if (progressElement && this.lineardata) {
            progressElement.style.visibility = 'hidden';
            animation.animate((progressElement), {
                duration: this.lineardata.duration,
                delay: 0,
                progress: function (args) {
                    progressElement.style.visibility = 'visible';
                    if (_this.lineardata.enableRtl && _this.lineardata.enableRtl && _this.lineardata.enable && _this.lineardata.isIndeterminate) {
                        var xValue = _this.effect(args.timeStamp, _this.lineardata.x || _this.lineardata.rectX + _this.lineardata.progressWidth, _this.lineardata.end, args.duration, _this.lineardata.enableRtl);
                        if (!_this.lineardata.enableProgressSegments) {
                            progressElement.setAttribute('x', xValue.toString());
                        }
                        else {
                            progressElement.setAttribute('d', _this.getPathLine(xValue, _this.lineardata));
                        }
                    }
                    else if (_this.lineardata.enable && _this.lineardata.isIndeterminate) {
                        var xValue = _this.effect(args.timeStamp, _this.lineardata.start, _this.lineardata.end, args.duration, _this.lineardata.enableRtl);
                        if (!_this.lineardata.enableProgressSegments) {
                            progressElement.setAttribute('x', xValue.toString());
                        }
                        else {
                            progressElement.setAttribute('d', _this.getPathLine(xValue, _this.lineardata));
                        }
                    }
                },
                end: function () {
                    if (_this.lineardata && _this.lineardata.enable && _this.lineardata.isIndeterminate) {
                        if (_this.lineardata.enableRtl && !_this.lineardata.enableProgressSegments && !(_this.lineardata.cornerRadius === 'Round4px')) {
                            progressElement.setAttribute('x', _this.lineardata.x.toString());
                        }
                        else if (!_this.lineardata.enableProgressSegments) {
                            progressElement.setAttribute('x', _this.lineardata.start.toString());
                        }
                        _this.linearIndeterminateAnimation();
                        _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
                    }
                }
            });
        }
    };
    SfProgressbar.prototype.linearAnimation = function () {
        var _this = this;
        var animation = new sf.base.Animation({});
        var progressElement = document.getElementById(this.element.id + '_clippathrect');
        var widthValue = 0;
        if (progressElement && this.lineardata) {
            progressElement.style.visibility = 'hidden';
            animation.animate((progressElement), {
                duration: this.lineardata.duration,
                delay: this.lineardata.delay,
                progress: function (args) {
                    _this.cancelResize = true;
                    if (_this.lineardata.enableRtl && _this.lineardata.cornerRadius !== 'Round4px' && args.timeStamp >= args.delay) {
                        progressElement.style.visibility = 'visible';
                        if (_this.lineardata.isActive) {
                            var activeElement = document.getElementById(_this.element.id + '_LinearActiveProgress');
                            widthValue = _this.activeAnimate((args.timeStamp / args.duration), _this.lineardata.x, _this.lineardata.width, true);
                            if (activeElement) {
                                activeElement.setAttribute('opacity', _this.effect(args.timeStamp, 0.5, 0.5, args.duration, true).toString());
                                progressElement.setAttribute('x', widthValue.toString());
                            }
                        }
                        else {
                            progressElement.setAttribute('x', _this.effect(args.timeStamp, _this.lineardata.start, _this.lineardata.end, args.duration, true).toString());
                        }
                    }
                    else if (args.timeStamp >= args.delay) {
                        progressElement.style.visibility = 'visible';
                        if (_this.lineardata.isActive) {
                            var activeElement = document.getElementById(_this.element.id + '_LinearActiveProgress');
                            widthValue = _this.activeAnimate((args.timeStamp / args.duration), 0, _this.lineardata.width, _this.lineardata.enableRtl);
                            if (activeElement) {
                                activeElement.setAttribute('opacity', _this.effect(args.timeStamp, 0.5, 0.5, args.duration, true).toString());
                                progressElement.setAttribute('width', widthValue.toString());
                            }
                        }
                        else {
                            progressElement.setAttribute('width', _this.effect(args.timeStamp, _this.lineardata.start, _this.lineardata.end, args.duration, false).toString());
                        }
                    }
                },
                end: function () {
                    _this.cancelResize = false;
                    if (_this.lineardata && _this.lineardata.enable && _this.lineardata.enableRtl && _this.lineardata.cornerRadius !== 'Round4px') {
                        if (_this.lineardata.isActive) {
                            progressElement.setAttribute('x', _this.lineardata.x.toString());
                            _this.linearAnimation();
                        }
                        else {
                            progressElement.setAttribute('x', _this.lineardata.rtlX.toString());
                        }
                    }
                    else if (_this.lineardata && _this.lineardata.enable) {
                        progressElement.setAttribute('width', _this.lineardata.width.toString());
                        if (_this.lineardata.isActive) {
                            _this.linearAnimation();
                        }
                    }
                    _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
                }
            });
        }
    };
    SfProgressbar.prototype.linearBufferAnimation = function () {
        var _this = this;
        var animation = new sf.base.Animation({});
        var progressElement = document.getElementById(this.element.id + '_clippathBufferrect');
        if (progressElement && this.linearBufferdata) {
            progressElement.style.visibility = 'hidden';
            animation.animate((progressElement), {
                duration: this.linearBufferdata.duration,
                delay: this.linearBufferdata.delay,
                progress: function (args) {
                    _this.cancelResize = true;
                    if (_this.linearBufferdata.enableRtl && _this.linearBufferdata.cornerRadius !== 'Round4px' && args.timeStamp >= args.delay) {
                        if (args.timeStamp >= args.delay) {
                            progressElement.style.visibility = 'visible';
                            progressElement.setAttribute('x', _this.effect(args.timeStamp, _this.linearBufferdata.start, _this.linearBufferdata.end, args.duration, true).toString());
                        }
                    }
                    else if (args.timeStamp >= args.delay) {
                        progressElement.style.visibility = 'visible';
                        progressElement.setAttribute('width', _this.effect(args.timeStamp, _this.linearBufferdata.start, _this.linearBufferdata.end, args.duration, false).toString());
                    }
                },
                end: function () {
                    _this.cancelResize = false;
                    progressElement.style.visibility = '';
                    if (_this.lineardata && _this.linearBufferdata.enable && _this.linearBufferdata.enableRtl && _this.linearBufferdata.cornerRadius !== 'Round4px') {
                        progressElement.setAttribute('x', _this.linearBufferdata.rtlX.toString());
                    }
                    else if (_this.linearBufferdata && _this.linearBufferdata.enable) {
                        progressElement.setAttribute('width', _this.linearBufferdata.width.toString());
                    }
                    _this.dotNetRef.invokeMethodAsync('TriggerAnimationComplete');
                }
            });
        }
    };
    return SfProgressbar;
}());
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var Progressbar = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    initialize: function (element, height, width, dotNetRef) {
        var layout = new SfProgressbar(element, dotNetRef);
        layout.wireEvents();
        return this.getElementSize(element, height, width);
    },
    setSecondaryElementStyle: function (element) {
        if (element) {
            var svgRect = document.getElementById(element.id + 'SVG').getBoundingClientRect();
            var secElement = document.getElementById(element.id + 'Secondary_Element');
            var elementRect = element.getBoundingClientRect();
            if (secElement && svgRect) {
                secElement.style.visibility = 'visible';
                secElement.style.left = Math.max(svgRect.left - elementRect.left, 0) + 'px';
                secElement.style.top = Math.max(svgRect.top - elementRect.top, 0) + 'px';
            }
        }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getElementSize: function (element, height, width) {
        var elementWidth;
        var elementHeight;
        if (element) {
            element.style.height = height;
            element.style.width = width;
            var elementRect = element.getBoundingClientRect();
            elementWidth = elementRect.width;
            elementHeight = elementRect.height;
            element.style.width = '';
            element.style.height = '';
        }
        return { width: elementWidth, height: elementHeight };
    },
    doLinearBufferAnimation: function (element, animateData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.linearBufferdata = animateData;
            element.blazor__instance.linearBufferAnimation();
        }
    },
    doLinearAnimation: function (element, animateData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.lineardata = animateData;
            element.blazor__instance.linearAnimation();
        }
    },
    doLinearIndeterminate: function (element, animateData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.lineardata = animateData;
            element.blazor__instance.linearIndeterminateAnimation();
        }
    },
    doStripedAnimation: function (element, animateData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.stripeData = animateData;
            element.blazor__instance.stripeAnimation();
        }
    },
    doCircularAnimation: function (element, circularData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.circularData = circularData;
            element.blazor__instance.circularAnimation();
        }
    },
    doCircularBufferAnimation: function (element, circularData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.circularBufferData = circularData;
            element.blazor__instance.circularBufferAnimation();
        }
    },
    doCircularIndeterminate: function (element, circularData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.circularData = circularData;
            element.blazor__instance.circularIndeterminateAnimation(circularData.start, circularData.end);
        }
    },
    doAnnotationAnimation: function (element, annotationData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.annotationData = annotationData;
            element.blazor__instance.annotationAnimation();
        }
    },
    doLabelAnimation: function (element, labelData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.labelData = labelData;
            element.blazor__instance.labelAnimation();
        }
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    update: function (element, animateData, type, labelAnimateData, annotationData) {
        if (!sf.base.isNullOrUndefined(element.blazor__instance)) {
            if (type === 'Linear') {
                var data = animateData;
                if (data.isStriped) {
                    element.blazor__instance.stripeData = data;
                }
                else {
                    element.blazor__instance.lineardata = data;
                }
            }
            else {
                element.blazor__instance.circularData = animateData;
            }
            if (labelAnimateData) {
                element.blazor__instance.labelData = animateData;
            }
            if (annotationData) {
                element.blazor__instance.annotationData = animateData;
            }
        }
    },
    destroy: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.unWireEvents();
        }
    }
};

return Progressbar;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-richtexteditor.js":
/*!********************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-richtexteditor.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.RichTextEditor = (function () {
'use strict';

/**
 * Css class constants
 */
var CLS_RTE = 'e-richtexteditor';


var CLS_DISABLED = 'e-disabled';
var CLS_SCRIPT_SHEET = 'rte-iframe-script-sheet';
var CLS_STYLE_SHEET = 'rte-iframe-style-sheet';
var CLS_TOOLBAR = 'e-rte-toolbar';

var CLS_TB_FLOAT = 'e-rte-tb-float';
var CLS_TB_ABS_FLOAT = 'e-rte-tb-abs-float';



var CLS_FULL_SCREEN = 'e-rte-full-screen';

var CLS_POP = 'e-rte-pop';
var CLS_QUICK_POP = 'e-rte-quick-popup';


var CLS_INLINE_POP = 'e-rte-inline-popup';





var CLS_RTE_CONTENT = 'e-rte-content';
var CLS_TB_ITEM = 'e-toolbar-item';
var CLS_TB_EXTENDED = 'e-toolbar-extended';

var CLS_POPUP = 'e-popup';




var CLS_SHOW = 'e-show';
var CLS_HIDE = 'e-hide';
var CLS_VISIBLE = 'e-visible';
var CLS_FOCUS = 'e-focused';

var CLS_IMGRIGHT = 'e-imgright';
var CLS_IMGLEFT = 'e-imgleft';
var CLS_IMGCENTER = 'e-imgcenter';
var CLS_IMGBREAK = 'e-imgbreak';
var CLS_CAPTION = 'e-img-caption';
var CLS_RTE_CAPTION = 'e-rte-img-caption';
var CLS_CAPINLINE = 'e-caption-inline';
var CLS_IMGINLINE = 'e-imginline';
var CLS_COUNT = 'e-rte-character-count';
var CLS_WARNING = 'e-warning';
var CLS_ERROR = 'e-error';
var CLS_ICONS = 'e-icons';
var CLS_ACTIVE = 'e-active';
var CLS_EXPAND_OPEN = 'e-expand-open';
var CLS_RTE_ELEMENTS = 'e-rte-elements';


var CLS_TB_IOS_FIX = 'e-tbar-ios-fixed';












var CLS_RTE_READONLY = 'e-rte-readonly';
var CLS_TABLE_SEL = 'e-cell-select';
var CLS_TB_DASH_BOR = 'e-dashed-border';
var CLS_TB_ALT_BOR = 'e-alternate-border';
var CLS_TB_COL_RES = 'e-column-resize';
var CLS_TB_ROW_RES = 'e-row-resize';
var CLS_TB_BOX_RES = 'e-table-box';







var CLS_RTE_RES_HANDLE = 'e-resize-handle';
var CLS_RTE_RES_EAST = 'e-south-east';
var CLS_RTE_RES_WEST = 'e-south-west';
var CLS_RTE_IMAGE = 'e-rte-image';
var CLS_RESIZE = 'e-resize';
var CLS_IMG_FOCUS = 'e-img-focus';
var CLS_RTE_DRAG_IMAGE = 'e-rte-drag-image';
var CLS_RTE_UPLOAD_POPUP = 'e-rte-upload-popup';
var CLS_POPUP_OPEN = 'e-popup-open';
var CLS_IMG_RESIZE = 'e-img-resize';
var CLS_DROPAREA = 'e-droparea';
var CLS_IMG_INNER = 'e-img-inner';

var CLS_RTE_DIALOG_UPLOAD = 'e-rte-dialog-upload';
var CLS_RTE_RES_CNT = 'e-rte-resize';



var CLS_TABLE_BORDER = 'e-rte-table-border';
var CLS_RTE_TABLE_RESIZE = 'e-rte-table-resize';
var CLS_RTE_FIXED_TB_EXPAND = 'e-rte-fixed-tb-expand';
var CLS_RTE_QUICK_POPUP_HIDE = 'e-rte-quick-popup-hide';
var CLS_RTE_OVERFLOW = 'e-rte-overflow';
var CLS_PASTED_CONTENT_IMG = 'pasteContent_Img';
var CLS_FILE_SELECT_WRAP = 'e-file-select-wrap';
var CLS_RTE_PASTE_CONTENT = 'pasteContent_RTE';
var CLS_POPUP_CLOSE = 'e-popup-close';
var CLS_EXTENDED_TOOLBAR = 'e-extended-toolbar';
var CLS_EXPENDED_NAV = 'e-expended-nav';
var CLS_INSERT_TABLE_BTN = 'e-insert-table-btn';
var CLS_DROP_DOWN_BTN = 'e-dropdown-btn';
var CLS_RTE_IMG_BOX_MARK = 'e-rte-imageboxmark';

/**
 * Event constants
 */




var contentChanged = 'content-changed';
var initialEnd = 'initial-end';
var iframeMouseDown = 'iframe-click';
var destroy = 'destroy';
var afterPasteCleanUp = 'afterPasteCleanUp';

var toolbarRefresh = 'toolbar-refresh';
var refreshBegin = 'refresh-begin';
var toolbarUpdated = 'toolbar-updated';
var bindOnEnd = 'bind-on-end';

var htmlToolbarClick = 'html-toolbar-click';
var markdownToolbarClick = 'markdown-toolbar-click';

var modelChanged = 'model-changed';
var keyUp = 'keyUp';
var keyDown = 'keyDown';
var mouseUp = 'mouseUp';


var enableFullScreen = 'enableFullScreen';
var disableFullScreen = 'disableFullScreen';
var dropDownSelect = 'dropDownSelect';

var execCommandCallBack = 'execCommandCallBack';
var imageToolbarAction = 'image-toolbar-action';
var linkToolbarAction = 'link-toolbar-action';
var windowResize = 'resize';





var insertLink = 'insertLink';
var unLink = 'unLink';






var insertImage = 'insertImage';
var insertCompleted = 'insertCompleted';





var imageLink = 'insertImgLink';
var imageAlt = 'imgAltText';
var imageDelete = 'delete';
var imageCaption = 'caption';
var imageSize = 'imageSize';
var sourceCode = 'sourceCode';
var updateSource = 'updateSource';

var beforeDropDownOpen = 'beforeDropDownOpen';
var selectionSave = 'selection-save';
var selectionRestore = 'selection-restore';

var count = 'count';


var mouseDown = 'mouseDown';
var sourceCodeMouseDown = 'sourceCodeMouseDown';
var editAreaClick = 'editAreaClick';
var scroll = 'scroll';
var contentscroll = 'contentscroll';

var tableColorPickerChanged = 'tableColorPickerChanged';
var focusChange = 'focusChange';
var selectAll$1 = 'selectAll';
var selectRange = 'selectRange';
var getSelectedHtml = 'getSelectedHtml';

var paste = 'paste-content';


var createTable = 'createTable';
var docClick = 'docClick';
var tableToolbarAction = 'table-toolbar-action';
var checkUndo = 'checkUndoStack';
var readOnlyMode = 'readOnlyMode';
var pasteClean = 'pasteClean';














var drop = 'drop';
var xhtmlValidation = 'xhtmlValidation';

var resizeInitialized = 'resizeInitialized';

var MS_WORD_CLEANUP = 'ms_word_cleanup';
var beforePasteUpload = 'beforePasteUpload';
var beforePasteUploadCallBack = 'beforePasteUploadCallBack';
var uploading = 'uploading';
var success = 'success';
var failure = 'failure';
var canceling = 'canceling';
var removing = 'removing';
var selected = 'selected';
var updateTbItemsStatus = 'updateTbItemsStatus';
var outsideClicked = 'Outside Click';
var ON_BEGIN = 'onBegin';
//Blazor Event
var beforeQuickToolbarOpenEvent = 'BeforeQuickToolbarOpenEvent';
var quickToolbarCloseEvent = 'QuickToolbarCloseEvent';
var actionBeginEvent = 'ActionBeginEvent';
var actionCompleteEvent = 'ActionCompleteEvent';
var beforeUpload = 'BeforeUpload';
var pasteImageUploadFailed = 'PasteImageUploadFailed';
var pasteImageUploadSuccess = 'PasteImageUploadSuccess';
var resizeStartEvent = 'ResizeStartEvent';
var resizeStopEvent = 'ResizeStopEvent';
var updatedToolbarStatusEvent = 'UpdatedToolbarStatusEvent';
//Blazor Methods
var updateClass = 'UpdateClass';
var showFullScreenClient = 'ShowFullScreenClient';
var hideFullScreenClient = 'HideFullScreenClient';
var showImagePopup = 'ShowImagePopup';
var hideImagePopup = 'HideImagePopup';
var showLinkPopup = 'ShowLinkPopup';
var hideLinkPopup = 'HideLinkPopup';
var showTablePopup = 'ShowTablePopup';
var hideTablePopup = 'HideTablePopup';
var showInlinePopup = 'ShowInlinePopup';
var hideInlinePopup = 'HideInlinePopup';
var refreshToolbarOverflow = 'RefreshToolbarOverflow';
var updateUndoRedoStatus = 'UpdateUndoRedoStatus';
var showImageDialog = 'ShowImageDialog';
var closeImageDialog = 'CloseImageDialog';
//Blazor ID
var imageQuickPopup = '_Image_Quick_Popup';
var linkQuickPopup = '_Link_Quick_Popup';
var tableQuickPopup = '_Table_Quick_Popup';
var inlineQuickPopup = '_Inline_Quick_Popup';
var resizeID = '-resizable';
var toolbarCreateTable = '_toolbar_CreateTable';
var imgResizeId = '_imgResize';
/* eslint-disable */
var IFRAME_HEADER = "\n<!DOCTYPE html> \n    <html>\n         <head>\n            <meta charset='utf-8' /> \n            <style>\n                @charset \"UTF-8\";\n                body {\n                    font-family: \"Roboto\", sans-serif;\n                    font-size: 14px;\n                }\n                html, body{height: 100%;margin: 0;}\n                body.e-cursor{cursor:default}\n                span.e-selected-node\t{background-color: #939393;color: white;}\n                span.e-selected-node.e-highlight {background-color: #1d9dd8;}\n                body{color:#333;word-wrap:break-word;padding: 8px;box-sizing: border-box;}\n                .e-rte-image {border: 0;cursor: pointer;display: block;float: none;height: auto;margin: 5px auto;max-width: 100%;position: relative;}\n                .e-img-caption { display: inline-block; float: none; margin: 5px auto; max-width: 100%;position: relative;}\n                .e-img-caption.e-caption-inline {display: inline-block;float: none;margin: 5px auto;margin-left: 5px;margin-right: 5px;max-width: calc(100% - (2 * 5px));position: relativetext-align: center;vertical-align: bottom;}\n                .e-img-inner {box-sizing: border-box;display: block;font-size: 16px;font-weight: initial;margin: auto;opacity: .9;text-align: center;width: 100%;}\n                .e-img-wrap {display: inline-block;margin: auto;padding: 0;text-align: center;width: 100%;}\n                .e-imgleft {float: left;margin: 0 auto;margin-right: 5px;text-align: left;}\n                .e-imgright {float: right;margin: 0 auto;margin-left: 5px;text-align: right;}\n                .e-imgcenter {cursor: pointer;display: block;float: none;height: auto;margin: 5px auto;max-width: 100%;position: relative;}\n                .e-control img:not(.e-resize) {border: 2px solid transparent; z-index: 1000}\n                .e-imginline {display: inline-block;float: none;margin-left: 5px;margin-right: 5px;max-width: calc(100% - (2 * 5px));vertical-align: bottom;}\n                .e-imgbreak {border: 0;cursor: pointer;display: block;float: none;height: auto;margin: 5px auto;max-width: 100%;position: relative;}\n                .e-rte-image.e-img-focus:not(.e-resize) {border: solid 2px #4a90e2;}\n                img.e-img-focus::selection { background: transparent;color: transparent;}\n                span.e-rte-imageboxmark {  width: 10px; height: 10px; position: absolute; display: block; background: #4a90e2; border: 1px solid #fff; z-index: 1000;}\n                .e-mob-rte.e-mob-span span.e-rte-imageboxmark { background: #4a90e2; border: 1px solid #fff; }\n                .e-mob-rte span.e-rte-imageboxmark { background: #fff; border: 1px solid #4a90e2; border-radius: 15px; height: 20px; width: 20px; }\n                .e-mob-rte.e-mob-span span.e-rte-imageboxmark { background: #4a90e2; border: 1px solid #fff; }\n                .e-rte-content .e-content img.e-resize { z-index: 1000; }\n                .e-img-caption .e-img-inner { outline: 0; }\n                .e-img-caption a:focus-visible { outline: none; }\n                .e-rte-img-caption.e-imgcenter { display: block; margin-left: auto; margin-right: auto; }\n                .e-rte-img-caption.e-imgright { display: block; margin-left: auto; margin-right: 0; }\n                .e-rte-img-caption.e-imgleft { display: block; margin-left: 0; margin-right: auto; }\n                .e-img-caption .e-rte-image.e-imgright {float: none; margin-left: auto; margin-right: 0;}\n                .e-img-caption .e-rte-image.e-imgleft { float: none; margin: 0;}\n                .e-rte-img-caption.e-imgleft .e-img-inner {text-align: left;}\n                .e-rte-img-caption.e-imgright .e-img-inner {text-align: right;}\n                body{box-sizing: border-box;min-height: 100px;outline: 0 solid transparent;overflow-x: auto;padding: 16px;position: relative;text-align: inherit;z-index: 2;}\n                p{margin: 0 0 10px;margin-bottom: 10px;}\n                li{margin-bottom: 10px;}\n                h1{font-size: 2.17em;font-weight: 400;line-height: 1;margin: 10px 0;}\n                h2{font-size: 1.74em;font-weight: 400;margin: 10px 0;}\n                h3{font-size: 1.31em;font-weight: 400;margin: 10px 0;}\n                h4{font-size: 16px;font-weight: 400;line-height: 1.5;margin: 0;}\n                h5{font-size: 00.8em;font-weight: 400;margin: 0;}\n                h6{font-size: 00.65em;font-weight: 400;margin: 0;}\n                blockquote{margin: 10px 0;margin-left: 0;padding-left: 5px;border-left: solid 2px #5c5c5c;}\n                .e-rtl blockquote {padding-left: 0;padding-right: 5px;border-left: 0;border-right: 2px solid #5c5c5c;}\n                pre{background-color: inherit;border: 0;border-radius: 0;color: #333;font-size: inherit;line-height: inherit;margin: 0 0 10px;overflow: visible;padding: 0;white-space: pre-wrap;word-break: inherit;word-wrap: break-word;}\n                strong, b{font-weight: 700;}\n                a{text-decoration: none;user-select: auto;}\n                a:hover{text-decoration: underline;};\n                p:last-child, pre:last-child, blockquote:last-child{margin-bottom: 0;}\n                h3+h4, h4+h5, h5+h6{margin-top: 00.6em;}\n                ul:last-child{margin-bottom: 0;}\n                .e-rte-table { border-collapse: collapse; empty-cells: show;}\n                .e-rte-table td, .e-rte-table th {border: 1px solid #BDBDBD; height: 20px; vertical-align: middle;padding: 2px 5px; min-width: 20px;}\n                .e-rte-table.e-rte-table-border { border: 1px solid #BDBDBD; border-collapse: separate; }\n                table.e-alternate-border tbody tr:nth-child(2n) {background-color: #F5F5F5;}\n                table th {background-color: #E0E0E0;}\n                table.e-dashed-border td,table.e-dashed-border th { border: 1px dashed #BDBDBD} \n                table .e-cell-select {border: 1px double #4a90e2;}\n                span.e-table-box { cursor: nwse-resize; display: block; height: 10px; position: absolute; width: 10px; }\n                span.e-table-box.e-hide { display: none; }\n                span.e-table-box.e-rmob {height: 14px;width: 14px;}\n                .e-row-resize, .e-column-resize { background-color: transparent; background-repeat: repeat; bottom: 0;cursor: col-resize;height: 1px;overflow: visible;position: absolute;width: 1px; }\n                .e-row-resize { cursor: row-resize; height: 1px;}\n                .e-table-rhelper { cursor: col-resize; opacity: .87;position: absolute;}\n                .e-table-rhelper.e-column-helper { width: 1px; }\n                .e-table-rhelper.e-row-helper {height: 1px;}\n                .e-reicon::before { border-bottom: 6px solid transparent; border-right: 6px solid; border-top: 6px solid transparent; content: ''; display: block; height: 0; position: absolute; right: 4px; top: 4px; width: 20px; }\n                .e-reicon::after { border-bottom: 6px solid transparent; border-left: 6px solid; border-top: 6px solid transparent; content: ''; display: block; height: 0; left: 4px; position: absolute; top: 4px; width: 20px; z-index: 3; }\n                .e-row-helper.e-reicon::after { top: 10px; transform: rotate(90deg); }\n                .e-row-helper.e-reicon::before { left: 4px; top: -20px; transform: rotate(90deg); }\n                span.e-table-box { background-color: #ffffff; border: 1px solid #BDBDBD; }\n                span.e-table-box.e-rbox-select { background-color: #BDBDBD; border: 1px solid #BDBDBD; }\n                .e-table-rhelper { background-color: #4a90e2;}\n                .e-rtl { direction: rtl; }\n            </style>\n        </head>";
/* eslint-enable */

/**
 * `Count` module is used to handle Count actions.
 */
var Count = /** @class */ (function () {
    function Count(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    Count.prototype.renderCount = function () {
        if (this.parent.showCharCount) {
            this.addEventListener();
            this.countElement = this.parent.element.querySelector('.' + CLS_COUNT);
            this.appendCount();
            if (this.parent.maxLength !== -1) {
                this.charCountBackground(this.htmlLength);
            }
        }
    };
    Count.prototype.appendCount = function () {
        this.countElement = this.parent.element.querySelector('.' + CLS_COUNT);
        var htmlText = this.parent.editorMode === 'Markdown' ? this.parent.getEditPanel().value.trim() :
            this.parent.getEditPanel().textContent.trim();
        if (this.parent.editorMode !== 'Markdown' && htmlText.indexOf('\u200B') !== -1) {
            this.htmlLength = htmlText.replace(/\u200B/g, '').length;
        }
        else {
            this.htmlLength = htmlText.length;
        }
        var string = this.parent.maxLength === -1 ? this.htmlLength : this.htmlLength + ' / ' + this.parent.maxLength;
        this.countElement.innerHTML = string;
    };
    Count.prototype.charCountBackground = function (htmlLength) {
        this.countElement = this.parent.element.querySelector('.' + CLS_COUNT);
        var percentage = (htmlLength / this.parent.maxLength) * 100;
        if (percentage < 85) {
            this.countElement.classList.remove(CLS_WARNING);
            this.countElement.classList.remove(CLS_ERROR);
        }
        else if (percentage > 85 && percentage <= 90) {
            this.countElement.classList.remove(CLS_ERROR);
            this.countElement.classList.add(CLS_WARNING);
        }
        else if (percentage > 90) {
            this.countElement.classList.remove(CLS_WARNING);
            this.countElement.classList.add(CLS_ERROR);
        }
    };
    Count.prototype.refresh = function () {
        if (!sf.base.isNullOrUndefined(this.parent.element) && this.parent.showCharCount) {
            this.appendCount();
            if (this.parent.maxLength !== -1) {
                this.charCountBackground(this.htmlLength);
            }
        }
    };
    Count.prototype.destroy = function () {
        this.countElement = null;
        this.removeEventListener();
    };
    Count.prototype.toggle = function (e) {
        if (this.parent.showCharCount) {
            this.countElement.style.display = (e.member === 'viewSource') ? 'none' : 'block';
        }
    };
    Count.prototype.addEventListener = function () {
        this.parent.observer.on(initialEnd, this.renderCount, this);
        this.parent.observer.on(keyUp, this.refresh, this);
        this.parent.observer.on(count, this.refresh, this);
        this.parent.observer.on(refreshBegin, this.refresh, this);
        this.parent.observer.on(mouseDown, this.refresh, this);
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(sourceCode, this.toggle, this);
        this.parent.observer.on(updateSource, this.toggle, this);
    };
    Count.prototype.removeEventListener = function () {
        this.parent.observer.off(initialEnd, this.renderCount);
        this.parent.observer.off(keyUp, this.refresh);
        this.parent.observer.off(refreshBegin, this.refresh);
        this.parent.observer.off(count, this.refresh);
        this.parent.observer.off(mouseDown, this.refresh);
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(sourceCode, this.toggle);
        this.parent.observer.off(updateSource, this.toggle);
    };
    return Count;
}());

/**
 * `Resize` module is used to resize the editor
 */
var Resize = /** @class */ (function () {
    function Resize(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    Resize.prototype.addEventListener = function () {
        this.parent.observer.on(initialEnd, this.renderResizable, this);
        this.parent.observer.on(destroy, this.destroy, this);
    };
    Resize.prototype.renderResizable = function () {
        if (this.parent.enableResize) {
            var resizeClass = CLS_ICONS + ' ' + CLS_RTE_RES_HANDLE + ' ';
            resizeClass += this.parent.enableRtl ? CLS_RTE_RES_WEST : CLS_RTE_RES_EAST;
            this.resizer = sf.base.createElement('div', { id: this.parent.id + resizeID, className: resizeClass });
            this.parent.element.classList.add(CLS_RTE_RES_CNT);
            this.parent.element.appendChild(this.resizer);
            this.parent.setContentHeight();
            this.touchStartEvent = (sf.base.Browser.info.name === 'msie') ? 'pointerdown' : 'touchstart';
            sf.base.EventHandler.add(this.resizer, 'mousedown', this.resizeStart, this);
            sf.base.EventHandler.add(this.resizer, this.touchStartEvent, this.resizeStart, this);
        }
    };
    Resize.prototype.resizeStart = function (e) {
        var _this = this;
        if (e.cancelable) {
            e.preventDefault();
        }
        this.wireResizeEvents();
        this.parent.observer.notify(resizeInitialized, {});
        var args = { requestType: 'editor' };
        if (this.parent.onResizeStartEnabled) {
            // @ts-ignore-start
            this.parent.dotNetRef.invokeMethodAsync(resizeStartEvent, args).then(function (resizeStartArgs) {
                // @ts-ignore-end
                if (resizeStartArgs.cancel) {
                    _this.unwireResizeEvents();
                }
            });
        }
    };
    Resize.prototype.performResize = function (e) {
        var boundRect = this.parent.element.getBoundingClientRect();
        if (this.isMouseEvent(e)) {
            this.parent.element.style.height = e.clientY - boundRect.top + 'px';
            this.parent.element.style.width = (this.parent.enableRtl ? boundRect.right - e.clientX :
                e.clientX - boundRect.left) + 'px';
        }
        else {
            var eventType = sf.base.Browser.info.name !== 'msie' ? e.touches[0] : e;
            this.parent.element.style.height = eventType.clientY - boundRect.top + 'px';
            this.parent.element.style.width = (this.parent.enableRtl ? boundRect.right - eventType.clientX :
                eventType.clientX - boundRect.left) + 'px';
        }
        this.parent.refresh();
    };
    Resize.prototype.stopResize = function (e) {
        this.parent.refresh();
        this.unwireResizeEvents();
        var args = { requestType: 'editor' };
        if (this.parent.onResizeStopEnabled) {
            this.parent.dotNetRef.invokeMethodAsync(resizeStopEvent, args);
        }
    };
    Resize.prototype.getEventType = function (e) {
        return (e.indexOf('mouse') > -1) ? 'mouse' : 'touch';
    };
    Resize.prototype.isMouseEvent = function (e) {
        var isMouse = false;
        if (this.getEventType(e.type) === 'mouse' || (!sf.base.isNullOrUndefined(e.pointerType) &&
            this.getEventType(e.pointerType) === 'mouse')) {
            isMouse = true;
        }
        return isMouse;
    };
    Resize.prototype.wireResizeEvents = function () {
        sf.base.EventHandler.add(document, 'mousemove', this.performResize, this);
        sf.base.EventHandler.add(document, 'mouseup', this.stopResize, this);
        this.touchMoveEvent = (sf.base.Browser.info.name === 'msie') ? 'pointermove' : 'touchmove';
        this.touchEndEvent = (sf.base.Browser.info.name === 'msie') ? 'pointerup' : 'touchend';
        sf.base.EventHandler.add(document, this.touchMoveEvent, this.performResize, this);
        sf.base.EventHandler.add(document, this.touchEndEvent, this.stopResize, this);
    };
    Resize.prototype.unwireResizeEvents = function () {
        sf.base.EventHandler.remove(document, 'mousemove', this.performResize);
        sf.base.EventHandler.remove(document, 'mouseup', this.stopResize);
        sf.base.EventHandler.remove(document, this.touchMoveEvent, this.performResize);
        sf.base.EventHandler.remove(document, this.touchEndEvent, this.stopResize);
    };
    Resize.prototype.destroy = function () {
        this.removeEventListener();
    };
    Resize.prototype.removeEventListener = function () {
        this.parent.observer.off(initialEnd, this.renderResizable);
        this.parent.element.classList.remove(CLS_RTE_RES_CNT);
        sf.base.EventHandler.remove(this.resizer, 'mousedown', this.resizeStart);
        sf.base.EventHandler.remove(this.resizer, this.touchStartEvent, this.resizeStart);
        if (this.resizer) {
            sf.base.detach(this.resizer);
        }
        this.parent.observer.off(destroy, this.destroy);
    };
    return Resize;
}());

/**
 * Util functions
 */
var inlineNode = ['a', 'abbr', 'acronym', 'audio', 'b', 'bdi', 'bdo', 'big', 'br', 'button',
    'canvas', 'cite', 'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'font', 'i', 'iframe', 'img', 'input',
    'ins', 'kbd', 'label', 'map', 'mark', 'meter', 'noscript', 'object', 'output', 'picture', 'progress',
    'q', 'ruby', 's', 'samp', 'script', 'select', 'slot', 'small', 'span', 'strong', 'strike', 'sub', 'sup', 'svg',
    'template', 'textarea', 'time', 'u', 'tt', 'var', 'video', 'wbr'];
var executeGroup = {
    'bold': {
        command: 'Style',
        subCommand: 'Bold',
        value: 'strong'
    },
    'italic': {
        command: 'Style',
        subCommand: 'Italic',
        value: 'em'
    },
    'underline': {
        command: 'Style',
        subCommand: 'Underline',
        value: 'span'
    },
    'strikeThrough': {
        command: 'Style',
        subCommand: 'StrikeThrough',
        value: 'span'
    },
    'insertCode': {
        command: 'Formats',
        subCommand: 'Pre',
        value: 'pre'
    },
    'superscript': {
        command: 'Effects',
        subCommand: 'SuperScript',
        value: 'sup'
    },
    'subscript': {
        command: 'Effects',
        subCommand: 'SubScript',
        value: 'sub'
    },
    'uppercase': {
        command: 'Casing',
        subCommand: 'UpperCase'
    },
    'lowercase': {
        command: 'Casing',
        subCommand: 'LowerCase'
    },
    'fontColor': {
        command: 'font',
        subCommand: 'fontcolor',
        value: '#ff0000'
    },
    'fontName': {
        command: 'font',
        subCommand: 'fontname',
        value: 'Segoe UI'
    },
    'fontSize': {
        command: 'font',
        subCommand: 'fontsize',
        value: '10pt'
    },
    'backColor': {
        command: 'font',
        subCommand: 'backgroundcolor',
        value: '#ffff00'
    },
    'justifyCenter': {
        command: 'Alignments',
        subCommand: 'JustifyCenter'
    },
    'justifyFull': {
        command: 'Alignments',
        subCommand: 'JustifyFull'
    },
    'justifyLeft': {
        command: 'Alignments',
        subCommand: 'JustifyLeft'
    },
    'justifyRight': {
        command: 'Alignments',
        subCommand: 'JustifyRight'
    },
    'undo': {
        command: 'Actions',
        subCommand: 'Undo'
    },
    'redo': {
        command: 'Actions',
        subCommand: 'Redo'
    },
    'createLink': {
        command: 'Links',
        subCommand: 'createLink'
    },
    'editLink': {
        command: 'Links',
        subCommand: 'createLink'
    },
    'createImage': {
        command: 'Images',
        subCommand: 'Images'
    },
    'formatBlock': {
        command: 'Formats',
        value: 'P'
    },
    'heading': {
        command: 'Formats',
        value: 'H1'
    },
    'indent': {
        command: 'Indents',
        subCommand: 'Indent'
    },
    'outdent': {
        command: 'Indents',
        subCommand: 'Outdent'
    },
    'insertHTML': {
        command: 'InsertHTML',
        subCommand: 'InsertHTML',
        value: ''
    },
    'insertText': {
        command: 'InsertText',
        subCommand: 'InsertText',
        value: ''
    },
    'insertHorizontalRule': {
        command: 'InsertHTML',
        subCommand: 'InsertHTML',
        value: '<hr/>'
    },
    'insertImage': {
        command: 'Images',
        subCommand: 'Image',
    },
    'editImage': {
        command: 'Images',
        subCommand: 'Image',
    },
    'insertTable': {
        command: 'Table',
        subCommand: 'CreateTable'
    },
    'insertBrOnReturn': {
        command: 'InsertHTML',
        subCommand: 'InsertHTML',
        value: '<br/>'
    },
    'insertOrderedList': {
        command: 'Lists',
        value: 'OL'
    },
    'insertUnorderedList': {
        command: 'Lists',
        value: 'UL'
    },
    'insertParagraph': {
        command: 'Formats',
        value: 'P'
    },
    'removeFormat': {
        command: 'Clear',
        subCommand: 'ClearFormat'
    }
};
function sanitizeHelper(value, parent) {
    if (parent.enableHtmlSanitizer) {
        var item_1 = sf.base.SanitizeHtmlHelper.beforeSanitize();
        var beforeEvent = {
            cancel: false,
            helper: null
        };
        sf.base.extend(item_1, item_1, beforeEvent);
        // @ts-ignore-start
        //  parent.dotNetRef.invokeMethodAsync('BeforeSanitizeHtmlEvent', item).then((sanitizeArgs: BeforeSanitizeHtmlArgs) => {
        // @ts-ignore-end
        if (!sf.base.isNullOrUndefined(parent.deniedSanitizeSelectors) && parent.deniedSanitizeSelectors.length > 0) {
            var _loop_1 = function (i) {
                for (var j = 0; j < item_1.selectors.tags.length; j++) {
                    if (item_1.selectors.tags[j] === parent.deniedSanitizeSelectors[i]) {
                        item_1.selectors.tags = item_1.selectors.tags.filter(function (values) { return values != parent.deniedSanitizeSelectors[i]; });
                    }
                }
                var _loop_2 = function (k) {
                    if ((item_1.selectors.attributes[k].attribute || item_1.selectors.attributes[k].selector) === parent.deniedSanitizeSelectors[i]) {
                        item_1.selectors.attributes = item_1.selectors.attributes.filter(function (values) { return values != item_1.selectors.attributes[k]; });
                    }
                };
                for (var k = 0; k < item_1.selectors.attributes.length; k++) {
                    _loop_2(k);
                }
            };
            for (var i = 0; i < parent.deniedSanitizeSelectors.length; i++) {
                _loop_1(i);
            }
        }
        if (!item_1.cancel) {
            value = sf.base.SanitizeHtmlHelper.serializeValue(item_1, value);
        }
        return value;
        // });
    }
    return value;
}
function getIndex(val, items) {
    var index = -1;
    items.some(function (item, i) {
        if (!sf.base.isNullOrUndefined(item) && typeof item.subCommand === 'string' && val === item.subCommand.toLocaleLowerCase()) {
            index = i;
            return true;
        }
        return false;
    });
    return index;
}
function getDropDownValue(items, value, type, returnType) {
    var data;
    var result;
    for (var k = 0; k < items.length; k++) {
        if (type === 'value' && items[k].value.toLocaleLowerCase() === value.toLocaleLowerCase()) {
            data = items[k];
            break;
        }
        else if (type === 'text' && items[k].text.toLocaleLowerCase() === value.toLocaleLowerCase()) {
            data = items[k];
            break;
        }
        else if (type === 'subCommand' && items[k].subCommand.toLocaleLowerCase() === value.toLocaleLowerCase()) {
            data = items[k];
            break;
        }
    }
    if (!sf.base.isNullOrUndefined(data)) {
        switch (returnType) {
            case 'text':
                result = data.text;
                break;
            case 'value':
                result = data.value;
                break;
            case 'cssClass':
                result = data.cssClass;
                break;
        }
    }
    return result;
}
function getEditValue(value, rteObj) {
    var val;
    if (value !== null && value !== '') {
        val = rteObj.enableHtmlEncode ? rteObj.encode(updateTextNode(decode(value))) : updateTextNode(value);
        rteObj.value = val;
    }
    else {
        val = rteObj.enableHtmlEncode ? '&lt;p&gt;&lt;br/&gt;&lt;/p&gt;' : '<p><br/></p>';
    }
    return val;
}
/**
 * @param {string} value - specifies the value
 * @returns {string} - returns the string
 * @hidden
 */
function updateTextNode(value) {
    var tempNode = document.createElement('div');
    var resultElm = document.createElement('div');
    var childNodes = tempNode.childNodes;
    tempNode.innerHTML = value;
    tempNode.setAttribute('class', 'tempDiv');
    if (childNodes.length > 0) {
        var isPreviousInlineElem = void 0;
        var previousParent = void 0;
        var paraElm = void 0;
        while (tempNode.firstChild) {
            if ((tempNode.firstChild.nodeName === '#text' &&
                (tempNode.firstChild.textContent.indexOf('\n') < 0 || tempNode.firstChild.textContent.trim() !== '')) ||
                inlineNode.indexOf(tempNode.firstChild.nodeName.toLocaleLowerCase()) >= 0) {
                if (!isPreviousInlineElem) {
                    paraElm = sf.base.createElement('p');
                    resultElm.appendChild(paraElm);
                    paraElm.appendChild(tempNode.firstChild);
                }
                else {
                    previousParent.appendChild(tempNode.firstChild);
                }
                previousParent = paraElm;
                isPreviousInlineElem = true;
            }
            else if (tempNode.firstChild.nodeName === '#text' && (tempNode.firstChild.textContent === '\n' ||
                (tempNode.firstChild.textContent.indexOf('\n') >= 0 && tempNode.firstChild.textContent.trim() === ''))) {
                sf.base.detach(tempNode.firstChild);
            }
            else {
                resultElm.appendChild(tempNode.firstChild);
                isPreviousInlineElem = false;
            }
        }
        var imageElm = resultElm.querySelectorAll('img');
        for (var i = 0; i < imageElm.length; i++) {
            if (!imageElm[i].classList.contains(CLS_RTE_IMAGE)) {
                imageElm[i].classList.add(CLS_RTE_IMAGE);
            }
            if (!(imageElm[i].classList.contains(CLS_IMGINLINE) ||
                imageElm[i].classList.contains(CLS_IMGBREAK))) {
                imageElm[i].classList.add(CLS_IMGINLINE);
            }
        }
    }
    return resultElm.innerHTML;
}
function isIDevice() {
    return sf.base.Browser.isDevice && sf.base.Browser.isIos;
}
function decode(value) {
    return value.replace(/&amp;/g, '&').replace(/&amp;lt;/g, '<')
        .replace(/&lt;/g, '<').replace(/&amp;gt;/g, '>')
        .replace(/&gt;/g, '>').replace(/&nbsp;/g, ' ')
        .replace(/&amp;nbsp;/g, ' ').replace(/&quot;/g, '');
}
function dispatchEvent(element, type) {
    var evt = document.createEvent('HTMLEvents');
    evt.initEvent(type, false, true);
    element.dispatchEvent(evt);
}
function hasClass(element, className) {
    var hasClass = false;
    if (element.classList.contains(className)) {
        hasClass = true;
    }
    return hasClass;
}
function parseHtml(value) {
    var tempNode = sf.base.createElement('template');
    tempNode.innerHTML = value;
    if (tempNode.content instanceof DocumentFragment) {
        return tempNode.content;
    }
    else {
        return document.createRange().createContextualFragment(value);
    }
}
function setAttributes(htmlAttributes, rte, isFrame, initial) {
    var target;
    if (isFrame) {
        var iFrame = rte.getDocument();
        target = iFrame.querySelector('body');
    }
    else {
        target = rte.element;
    }
    if (Object.keys(htmlAttributes).length) {
        for (var _i = 0, _a = Object.keys(htmlAttributes); _i < _a.length; _i++) {
            var htmlAttr = _a[_i];
            if (htmlAttr === 'class') {
                target.classList.add(htmlAttributes[htmlAttr]);
            }
            else if (htmlAttr === 'disabled' && htmlAttributes[htmlAttr] === 'disabled') {
                rte.enabled = false;
                rte.setEnable();
            }
            else if (htmlAttr === 'readonly' && htmlAttributes[htmlAttr] === 'readonly') {
                rte.readonly = true;
                rte.setReadOnly(initial);
            }
            else if (htmlAttr === 'style') {
                target.setAttribute('style', htmlAttributes[htmlAttr]);
            }
            else if (htmlAttr === 'tabindex') {
                rte.inputElement.setAttribute('tabindex', htmlAttributes[htmlAttr]);
            }
            else if (htmlAttr === 'placeholder') {
                rte.placeholder = htmlAttributes[htmlAttr];
                rte.setPlaceHolder();
            }
            else {
                var validateAttr = ['name', 'required'];
                if (validateAttr.indexOf(htmlAttr) > -1) {
                    rte.valueContainer.setAttribute(htmlAttr, htmlAttributes[htmlAttr]);
                }
                else {
                    target.setAttribute(htmlAttr, htmlAttributes[htmlAttr]);
                }
            }
        }
    }
}
function convertToBlob(dataUrl) {
    var arr = dataUrl.split(',');
    var mime = arr[0].match(/:(.*?);/)[1];
    var bstr = atob(arr[1]);
    var n = bstr.length;
    var u8arr = new Uint8Array(n);
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], { type: mime });
}
function getFormattedFontSize(value) {
    if (sf.base.isNullOrUndefined(value)) {
        return '';
    }
    return value;
}
function setToolbarStatus(e, isPopToolbar) {
    var dropDown = e.dropDownModule;
    var data = e.args;
    var keys = Object.keys(e.args);
    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        for (var j = 0; j < e.tbItems.length; j++) {
            var item = e.tbItems[j] && e.tbItems[j].subCommand;
            var itemStr = item && item.toLocaleLowerCase();
            if (item && (itemStr === key) || (item === 'UL' && key === 'unorderedlist') || (item === 'OL' && key === 'orderedlist') ||
                (itemStr === 'pre' && key === 'insertcode')) {
                if (typeof data[key] === 'boolean') {
                    if (data[key] === true) {
                        sf.base.addClass([e.tbElements[j]], [CLS_ACTIVE]);
                    }
                    else {
                        sf.base.removeClass([e.tbElements[j]], [CLS_ACTIVE]);
                    }
                }
                else if ((typeof data[key] === 'string' || data[key] === null) &&
                    getIndex(key, e.parent.toolbarSettings.items) > -1) {
                    var value = ((data[key]) ? data[key] : '');
                    var result = '';
                    var dropdownBtnText = void 0;
                    switch (key) {
                        case 'formats':
                            if (isPopToolbar) {
                                break;
                            }
                            var formatItems = e.parent.format.items;
                            result = getDropDownValue(formatItems, value, 'subCommand', 'text');
                            var formatContent = (sf.base.isNullOrUndefined(e.parent.format.default) ? formatItems[0].text :
                                e.parent.format.default);
                            dropdownBtnText = e.tbElements[j].querySelector('.e-rte-dropdown-btn-text');
                            dropdownBtnText.innerText = (sf.base.isNullOrUndefined(result) ? formatContent : result);
                            dropdownBtnText.parentElement.style.width = e.parent.format.width;
                            break;
                        case 'alignments':
                            result = getDropDownValue(e.parent.alignments, value, 'subCommand', 'cssClass');
                            dropdownBtnText = e.tbElements[j].querySelector('.e-btn-icon.e-icons');
                            sf.base.removeClass([dropdownBtnText], ['e-justify-left', 'e-justify-center', 'e-justify-right', 'e-justify-full']);
                            sf.base.addClass([dropdownBtnText], (sf.base.isNullOrUndefined(result) ? ['e-icons', 'e-justify-left'] : result.split(' ')));
                            break;
                        case 'fontname':
                            if (isPopToolbar) {
                                break;
                            }
                            var fontNameItems = e.parent.fontFamily.items;
                            result = getDropDownValue(fontNameItems, value, 'value', 'text');
                            var fontNameContent = sf.base.isNullOrUndefined(e.parent.fontFamily.default) ? fontNameItems[0].text :
                                e.parent.fontFamily.default;
                            var name_1 = (sf.base.isNullOrUndefined(result) ? fontNameContent : result);
                            e.tbElements[j].title = name_1;
                            dropdownBtnText = e.tbElements[j].querySelector('.e-rte-dropdown-btn-text');
                            dropdownBtnText.innerText = name_1;
                            dropdownBtnText.parentElement.style.width = e.parent.fontFamily.width;
                            break;
                        case 'fontsize':
                            var fontSizeItems = e.parent.fontSize.items;
                            var fontSizeContent = (sf.base.isNullOrUndefined(e.parent.fontSize.default) ? fontSizeItems[1].text :
                                e.parent.fontSize.default);
                            result = getDropDownValue(fontSizeItems, (value === '' ? fontSizeContent.replace(/\s/g, '') : value), 'value', 'text');
                            dropdownBtnText = e.tbElements[j].querySelector('.e-rte-dropdown-btn-text');
                            dropdownBtnText.innerText = getFormattedFontSize(result);
                            dropdownBtnText.parentElement.style.width = e.parent.fontSize.width;
                            break;
                    }
                }
            }
        }
    }
}
function pageYOffset(e, parentElement, isIFrame) {
    var y = 0;
    if (isIFrame) {
        y = window.pageYOffset + parentElement.getBoundingClientRect().top + e.clientY;
    }
    else {
        y = e.pageY;
    }
    return y;
}

/**
 * Defines types of Render
 *
 * @hidden
 * @deprecated
 */
var RenderType;
(function (RenderType) {
    /* eslint-disable */
    /** Defines RenderType as Toolbar */
    RenderType[RenderType["Toolbar"] = 0] = "Toolbar";
    /** Defines RenderType as Content */
    RenderType[RenderType["Content"] = 1] = "Content";
    /** Defines RenderType as Popup */
    RenderType[RenderType["Popup"] = 2] = "Popup";
    /** Defines RenderType as LinkToolbar */
    RenderType[RenderType["LinkToolbar"] = 3] = "LinkToolbar";
    /** Defines RenderType as TextToolbar */
    RenderType[RenderType["TextToolbar"] = 4] = "TextToolbar";
    /** Defines RenderType as ImageToolbar */
    RenderType[RenderType["ImageToolbar"] = 5] = "ImageToolbar";
    /** Defines RenderType as InlineToolbar */
    RenderType[RenderType["InlineToolbar"] = 6] = "InlineToolbar";
    /** Defines RenderType as TableToolbar */
    RenderType[RenderType["TableToolbar"] = 7] = "TableToolbar";
    /* eslint-enable */
})(RenderType || (RenderType = {}));
/**
 * Defines types to be used as Toolbar.
 */
var ToolbarType;
(function (ToolbarType) {
    /* eslint-disable */
    /** Defines ToolbarType as Standard */
    ToolbarType["Expand"] = "Expand";
    /** Defines ToolbarType as MultiRow */
    ToolbarType["MultiRow"] = "MultiRow";
    /** Defines ToolbarType as Scrollable */
    ToolbarType["Scrollable"] = "Scrollable";
    /* eslint-enable */
})(ToolbarType || (ToolbarType = {}));
/**
 * Defines the type of dialog, which open or close in the Rich Text Editor.
 */
var DialogType;
(function (DialogType) {
    /* eslint-disable */
    /** Defines ToolbarType as Standard */
    DialogType["InsertLink"] = "InsertLink";
    /** Defines ToolbarType as MultiRow */
    DialogType["InsertImage"] = "InsertImage";
    /** Defines ToolbarType as Scrollable */
    DialogType["InsertTable"] = "InsertTable";
    /* eslint-enable */
})(DialogType || (DialogType = {}));

/**
 * `Toolbar` module is used to handle Toolbar actions.
 */
var Toolbar = /** @class */ (function () {
    function Toolbar(parent) {
        this.isToolbar = false;
        this.isTransformChild = false;
        this.parent = parent;
        this.tbElement = this.parent.getToolbarElement();
        this.checkIsTransformChild();
        this.addEventListener();
        this.wireEvents();
    }
    Toolbar.prototype.getToolbarHeight = function () {
        return this.parent.getToolbar().offsetHeight;
    };
    Toolbar.prototype.getExpandTBarPopHeight = function () {
        var popHeight = 0;
        if (this.parent.toolbarSettings.type === ToolbarType.Expand &&
            this.parent.getToolbar().classList.contains(CLS_EXTENDED_TOOLBAR)) {
            var expandPopup = sf.base.select('.' + CLS_TB_EXTENDED, this.parent.getToolbar());
            if (expandPopup && this.parent.getToolbar().classList.contains(CLS_EXPAND_OPEN)
                || expandPopup && expandPopup.classList.contains(CLS_POPUP_OPEN)) {
                sf.base.addClass([expandPopup], [CLS_VISIBLE]);
                popHeight = popHeight + expandPopup.offsetHeight;
                sf.base.removeClass([expandPopup], [CLS_VISIBLE]);
            }
            else {
                sf.base.removeClass([this.parent.getToolbar()], [CLS_EXPAND_OPEN]);
            }
        }
        return popHeight;
    };
    Toolbar.prototype.updateToolbarStatus = function (args) {
        if (!this.parent.getToolbarElement() || (this.parent.inlineMode.enable && (isIDevice() || !sf.base.Browser.isDevice))) {
            return;
        }
        var options = {
            args: args,
            dropDownModule: null,
            parent: this.parent,
            tbElements: sf.base.selectAll('.' + CLS_TB_ITEM, this.parent.getToolbarElement()),
            /* eslint-disable */
            tbItems: this.parent.toolbarSettings.items
            /* eslint-enable */
        };
        setToolbarStatus(options, (this.parent.inlineMode.enable ? true : false));
    };
    Toolbar.prototype.checkIsTransformChild = function () {
        this.isTransformChild = false;
        var transformElements = sf.base.selectAll('[style*="transform"]', document);
        for (var i = 0; i < transformElements.length; i++) {
            if (!sf.base.isNullOrUndefined(transformElements[i].contains) && transformElements[i].contains(this.parent.element)) {
                this.isTransformChild = true;
                break;
            }
        }
    };
    Toolbar.prototype.toggleFloatClass = function (e) {
        var topValue;
        var isBody = false;
        var isFloat = false;
        var scrollParent;
        var floatOffset = this.parent.floatingToolbarOffset;
        if (e && this.parent.iframeSettings.enable && this.parent.inputElement.ownerDocument === e.target) {
            scrollParent = e.target.body;
        }
        else if (e && e.target !== document) {
            scrollParent = e.target;
        }
        else {
            isBody = true;
            scrollParent = document.body;
        }
        var tbHeight = this.getToolbarHeight() + this.getExpandTBarPopHeight();
        if (this.isTransformChild) {
            topValue = 0;
            var scrollParentRelativeTop = 0;
            var trgHeight = this.parent.element.offsetHeight;
            if (isBody) {
                var bodyStyle = window.getComputedStyle(scrollParent);
                scrollParentRelativeTop = parseFloat(bodyStyle.marginTop.split('px')[0]) + parseFloat(bodyStyle.paddingTop.split('px')[0]);
            }
            var targetTop = this.parent.element.getBoundingClientRect().top;
            var scrollParentYOffset = (sf.base.Browser.isMSPointer && isBody) ? window.pageYOffset : scrollParent.parentElement.scrollTop;
            var scrollParentRect = scrollParent.getBoundingClientRect();
            var scrollParentTop = (!isBody) ? scrollParentRect.top : (scrollParentRect.top + scrollParentYOffset);
            var outOfRange = ((targetTop - ((!isBody) ? scrollParentTop : 0)) + trgHeight > tbHeight + floatOffset) ? false : true;
            if (targetTop > (scrollParentTop + floatOffset) || targetTop < -trgHeight || ((targetTop < 0) ? outOfRange : false)) {
                isFloat = false;
                sf.base.removeClass([this.tbElement], [CLS_TB_ABS_FLOAT]);
            }
            else if (targetTop < (scrollParentTop + floatOffset)) {
                if (targetTop < 0) {
                    topValue = (-targetTop) + scrollParentTop;
                }
                else {
                    topValue = scrollParentTop - targetTop;
                }
                topValue = (isBody) ? topValue - scrollParentRelativeTop : topValue;
                sf.base.addClass([this.tbElement], [CLS_TB_ABS_FLOAT]);
                isFloat = true;
            }
        }
        else {
            var parent_1 = this.parent.element.getBoundingClientRect();
            if (window.innerHeight < parent_1.top) {
                return;
            }
            topValue = (e && e.target !== document) ? scrollParent.getBoundingClientRect().top : 0;
            if ((parent_1.bottom < (floatOffset + tbHeight + topValue)) || parent_1.bottom < 0 || parent_1.top > floatOffset + topValue) {
                isFloat = false;
            }
            else if (parent_1.top < floatOffset) {
                isFloat = true;
            }
        }
        if (!isFloat) {
            sf.base.removeClass([this.tbElement], [CLS_TB_FLOAT]);
            sf.base.setStyleAttribute(this.tbElement, { top: 0 + 'px', width: '100%' });
        }
        else {
            sf.base.addClass([this.tbElement], [CLS_TB_FLOAT]);
            sf.base.setStyleAttribute(this.tbElement, { width: this.parent.element.offsetWidth + 'px', top: (floatOffset + topValue) + 'px' });
        }
    };
    Toolbar.prototype.getDOMVisibility = function (el) {
        if (!el.offsetParent && el.offsetWidth === 0 && el.offsetHeight === 0) {
            return false;
        }
        return true;
    };
    Toolbar.prototype.showFixedTBar = function () {
        this.tbElement = this.parent.getToolbarElement();
        sf.base.addClass([this.tbElement], [CLS_SHOW]);
        if (sf.base.Browser.isIos) {
            sf.base.addClass([this.tbElement], [CLS_TB_IOS_FIX]);
        }
    };
    Toolbar.prototype.hideFixedTBar = function () {
        this.tbElement = this.parent.getToolbarElement();
        (!this.isToolbar) ? sf.base.removeClass([this.tbElement], [CLS_SHOW, CLS_TB_IOS_FIX]) : this.isToolbar = false;
    };
    Toolbar.prototype.dropDownBeforeOpenHandler = function (args) {
        this.isToolbar = true;
        if (!sf.base.isNullOrUndefined(sf.base.closest(args.element, ".e-rte-toolbar")) && sf.base.isNullOrUndefined(sf.base.closest(args.element, ".e-rte-quick-toolbar"))) {
            this.parent.hideTableQuickToolbar();
        }
    };
    //#region Bind & Unbind Events
    Toolbar.prototype.addEventListener = function () {
        this.parent.observer.on(scroll, this.scrollHandler, this);
        this.parent.observer.on(refreshBegin, this.onRefresh, this);
        this.parent.observer.on(bindOnEnd, this.toolbarBindEvent, this);
        this.parent.observer.on(mouseDown, this.mouseDownHandler, this);
        this.parent.observer.on(focusChange, this.focusChangeHandler, this);
        this.parent.observer.on(toolbarUpdated, this.updateToolbarStatus, this);
        this.parent.observer.on(beforeDropDownOpen, this.dropDownBeforeOpenHandler, this);
    };
    Toolbar.prototype.removeEventListener = function () {
        this.parent.observer.off(scroll, this.scrollHandler);
        this.parent.observer.off(refreshBegin, this.onRefresh);
        this.parent.observer.off(bindOnEnd, this.toolbarBindEvent);
        this.parent.observer.off(mouseDown, this.mouseDownHandler);
        this.parent.observer.off(focusChange, this.focusChangeHandler);
        this.parent.observer.off(toolbarUpdated, this.updateToolbarStatus);
        this.parent.observer.off(beforeDropDownOpen, this.dropDownBeforeOpenHandler);
    };
    Toolbar.prototype.wireEvents = function () {
        if (this.parent.inlineMode.enable && isIDevice()) {
            return;
        }
        this.tbElement = this.parent.getToolbarElement();
        if (this.tbElement) {
            sf.base.EventHandler.add(this.tbElement, 'focusin', this.tbFocusHandler, this);
            sf.base.EventHandler.add(this.tbElement, 'keydown', this.tbKeydownHandler, this);
        }
    };
    Toolbar.prototype.unWireEvents = function () {
        if (this.tbElement) {
            sf.base.EventHandler.remove(this.tbElement, 'focusin', this.tbFocusHandler);
            sf.base.EventHandler.remove(this.tbElement, 'keydown', this.tbKeydownHandler);
        }
    };
    Toolbar.prototype.toolbarBindEvent = function () {
        if (!this.parent.inlineMode.enable) {
            this.keyBoardModule = new sf.base.KeyboardEvents(this.parent.getToolbarElement(), {
                keyAction: this.toolBarKeyDown.bind(this), keyConfigs: this.parent.formatter.keyConfig, eventName: 'keydown'
            });
        }
    };
    //#endregion
    //#region Event handler methods
    Toolbar.prototype.onRefresh = function () {
        this.parent.dotNetRef.invokeMethodAsync(refreshToolbarOverflow);
        this.parent.setContentHeight('', true);
    };
    Toolbar.prototype.tbFocusHandler = function (e) {
        var activeElm = document.activeElement;
        var isToolbaractive = sf.base.closest(activeElm, '.' + CLS_TOOLBAR);
        if (activeElm === this.parent.getToolbarElement() || isToolbaractive === this.parent.getToolbarElement()) {
            var toolbarItem = this.parent.getToolbarElement().querySelectorAll('.' + CLS_EXPENDED_NAV);
            for (var i = 0; i < toolbarItem.length; i++) {
                if (sf.base.isNullOrUndefined(this.parent.getToolbarElement().querySelector('.' + CLS_INSERT_TABLE_BTN))) {
                    toolbarItem[i].setAttribute('tabindex', '0');
                }
                else {
                    toolbarItem[i].setAttribute('tabindex', '1');
                }
            }
        }
    };
    Toolbar.prototype.tbKeydownHandler = function (e) {
        if (e.target.classList.contains(CLS_DROP_DOWN_BTN) ||
            e.target.getAttribute('id') === this.parent.id + toolbarCreateTable) {
            e.target.setAttribute('tabindex', '0');
        }
    };
    Toolbar.prototype.toolBarKeyDown = function (e) {
        switch (e.action) {
            case 'escape':
                this.parent.getEditPanel().focus();
                break;
        }
    };
    Toolbar.prototype.scrollHandler = function (e) {
        if (!this.parent.inlineMode.enable) {
            this.tbElement = this.parent.getToolbarElement();
            if (this.parent.toolbarSettings.enableFloating && this.getDOMVisibility(this.tbElement)) {
                this.toggleFloatClass(e.args);
            }
        }
    };
    Toolbar.prototype.mouseDownHandler = function () {
        if (sf.base.Browser.isDevice && this.parent.inlineMode.enable && !isIDevice()) {
            this.showFixedTBar();
        }
    };
    Toolbar.prototype.focusChangeHandler = function () {
        if (sf.base.Browser.isDevice && this.parent.inlineMode.enable && !isIDevice()) {
            this.isToolbar = false;
            this.hideFixedTBar();
        }
    };
    return Toolbar;
}());

/**
 * Rich Text Editor classes defined here.
 */
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var CLS_TB_ITEM$1 = 'e-toolbar-item';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var CLS_IMGBREAK$1 = 'e-imgbreak';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var CLS_IMGINLINE$1 = 'e-imginline';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var CLS_ACTIVE$1 = 'e-active';
/**
 * @hidden
 * @deprecated
 */
var CLS_EXPAND_OPEN$1 = 'e-expand-open';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var CLS_RTE_IMAGE$1 = 'e-rte-image';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var CLS_TABLE$1 = 'e-rte-table';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * Defines common util methods used by Rich Text Editor.
 */
var inlineNode$1 = ['a', 'abbr', 'acronym', 'audio', 'b', 'bdi', 'bdo', 'big', 'br', 'button',
    'canvas', 'cite', 'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'font', 'i', 'iframe', 'img', 'input',
    'ins', 'kbd', 'label', 'map', 'mark', 'meter', 'noscript', 'object', 'output', 'picture', 'progress',
    'q', 'ruby', 's', 'samp', 'script', 'select', 'slot', 'small', 'span', 'strong', 'strike', 'sub', 'sup', 'svg',
    'template', 'textarea', 'time', 'u', 'tt', 'var', 'video', 'wbr'];
/**
 * @returns {void}
 * @hidden
 */
function isIDevice$1() {
    var result = false;
    if (sf.base.Browser.isDevice && sf.base.Browser.isIos) {
        result = true;
    }
    return result;
}
/**
 * @param {Element} editableElement - specifies the editable element.
 * @param {string} selector - specifies the string values.
 * @returns {void}
 * @hidden
 */
function setEditFrameFocus(editableElement, selector) {
    if (editableElement.nodeName === 'BODY' && !sf.base.isNullOrUndefined(selector)) {
        var iframe = top.window.document.querySelector(selector);
        if (!sf.base.isNullOrUndefined(iframe)) {
            iframe.contentWindow.focus();
        }
    }
}
/**
 * @param {string} value - specifies the string value
 * @returns {void}
 * @hidden
 */
function updateTextNode$1(value) {
    var tempNode = document.createElement('div');
    tempNode.innerHTML = value;
    tempNode.setAttribute('class', 'tempDiv');
    var resultElm = document.createElement('div');
    var childNodes = tempNode.childNodes;
    if (childNodes.length > 0) {
        var isPreviousInlineElem = void 0;
        var previousParent = void 0;
        var paraElm = void 0;
        while (tempNode.firstChild) {
            if ((tempNode.firstChild.nodeName === '#text' &&
                (tempNode.firstChild.textContent.indexOf('\n') < 0 || tempNode.firstChild.textContent.trim() !== '')) ||
                inlineNode$1.indexOf(tempNode.firstChild.nodeName.toLocaleLowerCase()) >= 0) {
                if (!isPreviousInlineElem) {
                    paraElm = sf.base.createElement('p');
                    resultElm.appendChild(paraElm);
                    paraElm.appendChild(tempNode.firstChild);
                }
                else {
                    previousParent.appendChild(tempNode.firstChild);
                }
                previousParent = paraElm;
                isPreviousInlineElem = true;
            }
            else if (tempNode.firstChild.nodeName === '#text' && (tempNode.firstChild.textContent === '\n' ||
                (tempNode.firstChild.textContent.indexOf('\n') >= 0 && tempNode.firstChild.textContent.trim() === ''))) {
                sf.base.detach(tempNode.firstChild);
            }
            else {
                resultElm.appendChild(tempNode.firstChild);
                isPreviousInlineElem = false;
            }
        }
        var tableElm = resultElm.querySelectorAll('table');
        for (var i = 0; i < tableElm.length; i++) {
            if (tableElm[i].getAttribute('border') === '0') {
                tableElm[i].removeAttribute('border');
            }
            var tdElm = tableElm[i].querySelectorAll('td');
            for (var j = 0; j < tdElm.length; j++) {
                if (tdElm[j].style.borderLeft === 'none') {
                    tdElm[j].style.removeProperty('border-left');
                }
                if (tdElm[j].style.borderRight === 'none') {
                    tdElm[j].style.removeProperty('border-right');
                }
                if (tdElm[j].style.borderBottom === 'none') {
                    tdElm[j].style.removeProperty('border-bottom');
                }
                if (tdElm[j].style.borderTop === 'none') {
                    tdElm[j].style.removeProperty('border-top');
                }
                if (tdElm[j].style.border === 'none') {
                    tdElm[j].style.removeProperty('border');
                }
            }
            if (!tableElm[i].classList.contains(CLS_TABLE$1)) {
                tableElm[i].classList.add(CLS_TABLE$1);
            }
        }
        var imageElm = resultElm.querySelectorAll('img');
        for (var i = 0; i < imageElm.length; i++) {
            if (!imageElm[i].classList.contains(CLS_RTE_IMAGE$1)) {
                imageElm[i].classList.add(CLS_RTE_IMAGE$1);
            }
            if (!(imageElm[i].classList.contains(CLS_IMGINLINE$1) ||
                imageElm[i].classList.contains(CLS_IMGBREAK$1))) {
                imageElm[i].classList.add(CLS_IMGINLINE$1);
            }
        }
    }
    return resultElm.innerHTML;
}
/**
 * @param {Node} startChildNodes - specifies the node
 * @returns {void}
 * @hidden
 */
function getLastTextNode(startChildNodes) {
    var finalNode = startChildNodes;
    do {
        if (finalNode.childNodes.length > 0) {
            finalNode = finalNode.childNodes[0];
        }
    } while (finalNode.childNodes.length > 0);
    return finalNode;
}
/**
 * @returns {void}
 * @hidden
 */
function getDefaultHtmlTbStatus() {
    return {
        bold: false,
        italic: false,
        subscript: false,
        superscript: false,
        strikethrough: false,
        orderedlist: false,
        unorderedlist: false,
        underline: false,
        alignments: null,
        backgroundcolor: null,
        fontcolor: null,
        fontname: null,
        fontsize: null,
        formats: null,
        createlink: false,
        insertcode: false
    };
}
/**
 * @returns {void}
 * @hidden
 */
function getDefaultMDTbStatus() {
    return {
        bold: false,
        italic: false,
        subscript: false,
        superscript: false,
        strikethrough: false,
        orderedlist: false,
        uppercase: false,
        lowercase: false,
        inlinecode: false,
        unorderedlist: false,
        formats: null
    };
}

var __assign$1 = (undefined && undefined.__assign) || function () {
    __assign$1 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};
/**
 * `Link` module is used to handle undo actions.
 */
var Link = /** @class */ (function () {
    function Link(parent) {
        this.parent = parent;
        this.rteId = this.parent.element.id;
        this.addEventListener();
    }
    Link.prototype.addEventListener = function () {
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(keyDown, this.onKeyDown, this);
        this.parent.observer.on(unLink, this.removeLink, this);
        this.parent.observer.on(insertLink, this.linkDialog, this);
        this.parent.observer.on(linkToolbarAction, this.onToolbarAction, this);
        this.parent.observer.on(iframeMouseDown, this.onIframeMouseDown, this);
        this.parent.observer.on(editAreaClick, this.editAreaClickHandler, this);
        this.parent.observer.on(insertCompleted, this.showLinkQuickToolbar, this);
    };
    Link.prototype.removeEventListener = function () {
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(keyDown, this.onKeyDown);
        this.parent.observer.off(unLink, this.removeLink);
        this.parent.observer.off(insertLink, this.linkDialog);
        this.parent.observer.off(linkToolbarAction, this.onToolbarAction);
        this.parent.observer.off(iframeMouseDown, this.onIframeMouseDown);
        this.parent.observer.off(editAreaClick, this.editAreaClickHandler);
        this.parent.observer.off(insertCompleted, this.showLinkQuickToolbar);
        sf.base.EventHandler.remove(this.parent.element.ownerDocument, 'mousedown', this.onDocumentClick);
    };
    Link.prototype.linkDialog = function (e, inputDetails) {
        if (this.parent.editorMode === 'HTML' && (e.selectParent.length > 0 && !sf.base.isNullOrUndefined(e.selectParent[0].classList) &&
            e.selectParent[0].classList.contains('e-rte-anchor')) && sf.base.isNullOrUndefined(inputDetails)) {
            this.editLink(e);
            return;
        }
        this.selectionObj = { selection: e.selection, selectParent: e.selectParent, args: e.args };
        var model = { url: '', text: '', title: '', target: true };
        if (!sf.base.isNullOrUndefined(inputDetails)) {
            model = {
                url: inputDetails.url, text: inputDetails.text,
                title: inputDetails.title, target: (inputDetails.target !== '' ? true : false)
            };
        }
        var selectText = (this.parent.editorMode === 'HTML') ? e.selection.getRange(this.parent.getDocument()).toString() : e.text;
        if ((this.parent.editorMode === 'HTML' && sf.base.isNullOrUndefined(inputDetails) && ((!sf.base.isNullOrUndefined(selectText) && selectText !== '') &&
            (e.selection.range.startOffset === 0) || e.selection.range.startOffset !== e.selection.range.endOffset)) ||
            e.module === 'Markdown') {
            model.text = selectText;
        }
        sf.base.EventHandler.add(this.parent.element.ownerDocument, 'mousedown', this.onDocumentClick, this);
        if (sf.base.isNullOrUndefined(sf.base.select('.e-rte-link-dialog', this.parent.element))) {
            this.parent.dotNetRef.invokeMethodAsync('ShowLinkDialog', model, (!sf.base.isNullOrUndefined(inputDetails) ? 'Edit' : null));
        }
        else {
            this.parent.dotNetRef.invokeMethodAsync('CloseLinkDialog');
        }
        if (this.quickToolObj) {
            this.hideLinkQuickToolbar();
            this.quickToolObj.hideInlineQTBar();
        }
    };
    Link.prototype.insertLink = function (args) {
        var linkTitle;
        var linkUrl = args.url;
        var linkText = args.text;
        if (this.parent.editorMode === 'HTML') {
            linkTitle = args.title;
        }
        var target = args.target ? '_blank' : null;
        if (linkUrl === '') {
            this.checkUrl(true);
            return;
        }
        if (!this.isUrl(linkUrl)) {
            linkText = (linkText === '') ? linkUrl : linkText;
            linkUrl = (!this.parent.enableAutoUrl) ? (linkUrl.indexOf('http') > -1 ? linkUrl : 'http://' + linkUrl) : linkUrl;
        }
        else {
            this.checkUrl(false);
        }
        if (this.parent.editorMode === 'HTML' && sf.base.isNullOrUndefined(sf.base.closest(this.selectionObj.selection.range.startContainer.parentNode, '#' + this.parent.getPanel().id))) {
            this.parent.getEditPanel().focus();
            if (sf.base.Browser.isIE && this.parent.iframeSettings.enable) {
                this.selectionObj.selection.restore();
            }
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            this.selectionObj.selection = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
            this.selectionObj.selectParent = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
        }
        var value = {
            url: linkUrl, text: linkText, title: linkTitle, target: target,
            selection: this.selectionObj.selection, selectParent: this.selectionObj.selectParent
        };
        this.parent.dotNetRef.invokeMethodAsync('CloseLinkDialog');
        if (isIDevice$1() && this.parent.iframeSettings.enable) {
            sf.base.select('iframe', this.parent.element).contentWindow.focus();
        }
        if (this.parent.editorMode === 'HTML') {
            this.selectionObj.selection.restore();
        }
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        var argsValue;
        if (!sf.base.isNullOrUndefined(this.selectionObj.args) && this.selectionObj.args.code === 'KeyK') {
            var event_1 = this.selectionObj.args;
            event_1 = __assign$1({}, event_1, { target: null });
            var argsVal = { item: { command: 'Links', subCommand: 'CreateLink' }, originalEvent: event_1 };
            sf.base.extend(this.selectionObj.args, argsVal, true);
            argsValue = argsVal;
        }
        else {
            argsValue = this.selectionObj.args;
        }
        this.parent.formatter.process(this.parent, argsValue, (!sf.base.isNullOrUndefined(this.selectionObj.args) &&
            this.selectionObj.args.originalEvent), value);
        this.parent.getEditPanel().focus();
    };
    Link.prototype.isUrl = function (url) {
        var regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/gi;
        return regexp.test(url);
    };
    Link.prototype.checkUrl = function (e) {
        var linkUrl = this.parent.element.querySelector('.e-rte-link-dialog .e-rte-linkurl');
        if (e) {
            sf.base.addClass([linkUrl], 'e-error');
            linkUrl.setSelectionRange(0, linkUrl.value.length);
            linkUrl.focus();
        }
        else {
            sf.base.removeClass([linkUrl], 'e-error');
        }
    };
    Link.prototype.cancelDialog = function () {
        if (isIDevice$1()) {
            this.selectionObj.selection.restore();
        }
        else {
            this.parent.getEditPanel().focus();
        }
    };
    Link.prototype.linkDialogClosed = function () {
        if (this.parent.editorMode === 'HTML') {
            this.selectionObj.selection.restore();
        }
        else {
            this.parent.formatter.editorManager.markdownSelection.restore(this.parent.getEditPanel());
        }
    };
    Link.prototype.getAnchorNode = function (element) {
        var selectParent = sf.base.closest(element, 'a');
        return (selectParent ? selectParent : element);
    };
    Link.prototype.openLink = function (e) {
        var selectParentEle = this.getAnchorNode(e.selectParent[0]);
        if (selectParentEle.classList.contains('e-rte-anchor') || selectParentEle.tagName === 'A') {
            this.parent.formatter.process(this.parent, e.args, e.args, {
                url: selectParentEle.href,
                target: selectParentEle.target === '' ? '_self' : '_blank', selectNode: e.selectNode,
                subCommand: e.args.item.subCommand
            });
        }
    };
    Link.prototype.editLink = function (e) {
        var selectedNode = this.getAnchorNode(e.selectNode[0]);
        var selectParentEle = this.getAnchorNode(e.selectParent[0]);
        selectParentEle = selectedNode.nodeName === 'A' ? selectedNode : selectParentEle;
        if (selectParentEle.classList.contains('e-rte-anchor') || selectParentEle.tagName === 'A') {
            var inputDetails = {
                url: selectParentEle.getAttribute('href'), text: selectParentEle.innerText,
                title: selectParentEle.title, target: selectParentEle.target,
            };
            this.linkDialog(e, inputDetails);
        }
    };
    Link.prototype.removeLink = function (e) {
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        this.parent.formatter.process(this.parent, e.args, e.args, {
            selectNode: e.selectNode, selectParent: e.selectParent, selection: e.selection,
            subCommand: e.args.item.subCommand
        });
        if (isIDevice$1() && this.parent.iframeSettings.enable) {
            sf.base.select('iframe', this.parent.element).contentWindow.focus();
        }
        else {
            this.parent.getEditPanel().focus();
        }
        this.hideLinkQuickToolbar();
    };
    Link.prototype.onToolbarAction = function (args) {
        var item = args.args.item;
        switch (item.subCommand) {
            case 'OpenLink':
                this.openLink(args);
                break;
            case 'EditLink':
                this.editLink(args);
                break;
            case 'RemoveLink':
                this.removeLink(args);
                break;
        }
    };
    Link.prototype.editAreaClickHandler = function (e) {
        if (this.parent.readonly) {
            this.hideLinkQuickToolbar();
            return;
        }
        var args = e.args;
        var showOnRightClick = this.parent.quickToolbarSettings.showOnRightClick;
        if (args.which === 2 || (showOnRightClick && args.which === 1) || (!showOnRightClick && args.which === 3)) {
            return;
        }
        if (this.parent.editorMode === 'HTML' && this.parent.quickToolbarModule) {
            var target = args.target;
            target = this.getAnchorNode(target);
            var isPopupOpen = void 0;
            isPopupOpen = document.body.querySelector('#' + this.rteId + '_Link_Quick_Popup').classList.contains('e-rte-pop');
            if (target.nodeName === 'A' && (target.childNodes.length > 0 && target.childNodes[0].nodeName !== 'IMG') &&
                e.args.target.nodeName !== 'IMG') {
                if (isPopupOpen) {
                    return;
                }
                this.showLinkQuickToolbar({
                    args: args,
                    isNotify: false,
                    type: 'Links',
                    elements: [args.target]
                });
            }
            else {
                this.hideLinkQuickToolbar();
            }
        }
    };
    Link.prototype.showLinkQuickToolbar = function (e) {
        if (e.args.action !== 'enter' && e.args.action !== 'space') {
            var pageX = void 0;
            var pageY = void 0;
            if (e.type !== 'Links' || sf.base.isNullOrUndefined(this.parent.quickToolbarModule)) {
                return;
            }
            this.quickToolObj = this.parent.quickToolbarModule;
            var parentTop = this.parent.element.getBoundingClientRect().top;
            var parentLeft = this.parent.element.getBoundingClientRect().left;
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            var tbElement = this.parent.getToolbarElement();
            var tbHeight = (tbElement) ? (tbElement.offsetHeight + this.parent.toolbarModule.getExpandTBarPopHeight()) : 0;
            var target_1;
            [].forEach.call(e.elements, function (element, index) {
                if (index === 0) {
                    target_1 = ((element.nodeName === '#text') ? (element.parentNode) : element);
                }
            });
            if (e.isNotify) {
                var targetRect = target_1.getBoundingClientRect();
                var linkTop = targetRect.top;
                var linkLeft = targetRect.left;
                var linkPos = linkTop - parentTop;
                pageX = this.parent.iframeSettings.enable ? parentLeft + linkLeft : linkLeft;
                pageY = window.pageYOffset + (this.parent.iframeSettings.enable ?
                    (parentTop + tbHeight + linkTop) : (parentTop + linkPos));
            }
            else {
                var args = void 0;
                args = e.args.touches ? e.args.changedTouches[0] : args = e.args;
                pageX = this.parent.iframeSettings.enable ? window.pageXOffset + parentLeft + args.clientX : args.pageX;
                pageY = this.parent.iframeSettings.enable ? window.pageYOffset + parentTop + tbHeight + args.clientY : args.pageY;
            }
            this.quickToolObj.showLinkQTBar(pageX, pageY, range.endContainer, 'Link');
        }
    };
    Link.prototype.hideLinkQuickToolbar = function () {
        if (this.quickToolObj) {
            this.quickToolObj.hideLinkQTBar();
        }
    };
    Link.prototype.showDialog = function (isExternal, event) {
        if (isExternal) {
            this.parent.getEditPanel().focus();
        }
        if (this.parent.editorMode === 'HTML') {
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            var save = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
            var selectNodeEle = this.parent.formatter.editorManager.nodeSelection.getNodeCollection(range);
            var selectParentEle = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
            var eventArgs = {
                args: (isExternal ? { item: { command: 'Links', subCommand: 'CreateLink' },
                    originalEvent: undefined } : event.args),
                selectNode: selectNodeEle, selection: save, selectParent: selectParentEle
            };
            this.linkDialog(eventArgs);
        }
        else {
            var textArea = this.parent.getEditPanel();
            this.parent.formatter.editorManager.markdownSelection.save(textArea.selectionStart, textArea.selectionEnd);
            this.linkDialog({
                args: {
                    item: { command: 'Links', subCommand: 'Link' },
                    originalEvent: isExternal ? undefined : event.args
                },
                member: 'link',
                text: this.parent.formatter.editorManager.markdownSelection.getSelectedText(this.parent.getEditPanel()),
                module: 'Markdown',
                name: 'insertLink'
            });
        }
    };
    Link.prototype.onKeyDown = function (event) {
        var originalEvent = event.args;
        switch (originalEvent.action) {
            case 'escape':
                this.parent.dotNetRef.invokeMethodAsync('CloseLinkDialog');
                break;
            case 'insert-link':
                this.showDialog(false, event);
                originalEvent.preventDefault();
                break;
        }
    };
    Link.prototype.onDocumentClick = function (e) {
        var target = e.target;
        var dlgId = '#' + this.rteId + '_rtelink';
        var tbEle = this.parent.getToolbarElement();
        var tbEleId = '#' + this.rteId + '_toolbar_CreateLink';
        var linkDlgEle = this.parent.element.querySelector(dlgId);
        if (!sf.base.isNullOrUndefined(linkDlgEle) && ((!sf.base.closest(target, dlgId) && this.parent.toolbarSettings.enable &&
            tbEle && !tbEle.contains(e.target)) || (((tbEle && tbEle.contains(e.target)) ||
            this.parent.inlineMode.enable && !sf.base.closest(target, dlgId)) && !sf.base.closest(target, tbEleId) && !target.querySelector(tbEleId)))) {
            this.parent.dotNetRef.invokeMethodAsync('CloseLinkDialog');
            sf.base.EventHandler.remove(this.parent.element.ownerDocument, 'mousedown', this.onDocumentClick);
            this.parent.isBlur = true;
            if (sf.base.Browser.isIE) {
                dispatchEvent(this.parent.element, 'focusout');
            }
        }
    };
    Link.prototype.onIframeMouseDown = function () {
        this.parent.dotNetRef.invokeMethodAsync('CloseLinkDialog');
    };
    Link.prototype.destroy = function () {
        this.removeEventListener();
    };
    return Link;
}());

/**
 * `Table` module is used to handle table actions.
 */
var Table = /** @class */ (function () {
    function Table(parent) {
        this.pageX = null;
        this.pageY = null;
        this.moveEle = null;
        this.rzProgress = false;
        this.ensureInsideTableList = true;
        this.parent = parent;
        this.addEventListener();
    }
    Table.prototype.addEventListener = function () {
        this.parent.observer.on(keyUp, this.keyUp, this);
        this.parent.observer.on(keyDown, this.keyDown, this);
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(docClick, this.docClick, this);
        this.parent.observer.on(initialEnd, this.afterRender, this);
        this.parent.observer.on(mouseUp, this.selectionTable, this);
        this.parent.observer.on(createTable, this.renderDlgContent, this);
        this.parent.observer.on(dropDownSelect, this.dropdownSelect, this);
        this.parent.observer.on(iframeMouseDown, this.onIframeMouseDown, this);
        this.parent.observer.on(editAreaClick, this.editAreaClickHandler, this);
        this.parent.observer.on(tableToolbarAction, this.onToolbarAction, this);
    };
    Table.prototype.removeEventListener = function () {
        this.parent.observer.off(keyUp, this.keyUp);
        this.parent.observer.off(keyDown, this.keyDown);
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(docClick, this.docClick);
        this.parent.observer.off(mouseDown, this.cellSelect);
        this.parent.observer.off(initialEnd, this.afterRender);
        this.parent.observer.off(mouseUp, this.selectionTable);
        this.parent.observer.off(createTable, this.renderDlgContent);
        this.parent.observer.off(dropDownSelect, this.dropdownSelect);
        this.parent.observer.off(iframeMouseDown, this.onIframeMouseDown);
        this.parent.observer.off(tableColorPickerChanged, this.setBGColor);
        this.parent.observer.off(editAreaClick, this.editAreaClickHandler);
        this.parent.observer.off(tableToolbarAction, this.onToolbarAction);
    };
    Table.prototype.afterRender = function () {
        this.parent.observer.on(mouseDown, this.cellSelect, this);
        this.parent.observer.on(tableColorPickerChanged, this.setBGColor, this);
        if (this.parent.tableSettings.resize) {
            sf.base.EventHandler.add(this.parent.getEditPanel(), sf.base.Browser.touchStartEvent, this.resizeStart, this);
        }
        if (!sf.base.Browser.isDevice && this.parent.tableSettings.resize) {
            sf.base.EventHandler.add(this.parent.getEditPanel(), 'mouseover', this.resizeHelper, this);
        }
    };
    Table.prototype.selectionTable = function (e) {
        var target = e.args.target;
        if (sf.base.Browser.info.name === 'mozilla' && !sf.base.isNullOrUndefined(sf.base.closest(target, 'table')) && sf.base.closest(target, 'table').tagName === 'TABLE') {
            this.parent.getEditPanel().setAttribute('contenteditable', 'true');
        }
    };
    Table.prototype.tabSelection = function (event, selection, ele) {
        var insideList = this.insideList(selection.range);
        if ((event.keyCode === 37 || event.keyCode === 39) && selection.range.startContainer.nodeType === 3 ||
            insideList) {
            return;
        }
        event.preventDefault();
        ele.classList.remove(CLS_TABLE_SEL);
        if (!event.shiftKey && event.keyCode !== 37) {
            var nextElement = (!sf.base.isNullOrUndefined(ele.nextSibling)) ? ele.nextSibling :
                (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'tr').nextSibling) ? sf.base.closest(ele, 'tr').nextSibling.childNodes[0] :
                    (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'table').nextSibling)) ?
                        (sf.base.closest(ele, 'table').nextSibling.nodeName.toLowerCase() === 'td') ?
                            sf.base.closest(ele, 'table').nextSibling : ele : ele);
            if (ele === nextElement && ele.nodeName === 'TH') {
                nextElement = sf.base.closest(ele, 'table').rows[1].cells[0];
            }
            if (event.keyCode === 39 && ele === nextElement) {
                nextElement = sf.base.closest(ele, 'table').nextSibling;
            }
            if (nextElement) {
                (nextElement.textContent.trim() !== '' && sf.base.closest(nextElement, 'td')) ?
                    selection.setSelectionNode(this.parent.getDocument(), nextElement) :
                    selection.setSelectionText(this.parent.getDocument(), nextElement, nextElement, 0, 0);
            }
            if (ele === nextElement && event.keyCode !== 39 && nextElement) {
                ele.classList.add(CLS_TABLE_SEL);
                this.addRow(selection, event, true);
                ele.classList.remove(CLS_TABLE_SEL);
                nextElement = nextElement.parentElement.nextSibling.firstChild;
                (nextElement.textContent.trim() !== '' && sf.base.closest(nextElement, 'td')) ?
                    selection.setSelectionNode(this.parent.getDocument(), nextElement) :
                    selection.setSelectionText(this.parent.getDocument(), nextElement, nextElement, 0, 0);
            }
        }
        else {
            var prevElement = (!sf.base.isNullOrUndefined(ele.previousSibling)) ? ele.previousSibling :
                (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'tr').previousSibling) ?
                    sf.base.closest(ele, 'tr').previousSibling.childNodes[sf.base.closest(ele, 'tr').previousSibling.childNodes.length - 1] :
                    (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'table').previousSibling)) ?
                        (sf.base.closest(ele, 'table').previousSibling.nodeName.toLowerCase() === 'td') ? sf.base.closest(ele, 'table').previousSibling :
                            ele : ele);
            if (ele === prevElement && ele.cellIndex === 0 &&
                sf.base.closest(ele, 'table').tHead) {
                var clsTable = sf.base.closest(ele, 'table');
                prevElement = clsTable.rows[0].cells[clsTable.rows[0].cells.length - 1];
            }
            if (event.keyCode === 37 && ele === prevElement) {
                prevElement = sf.base.closest(ele, 'table').previousSibling;
            }
            if (prevElement) {
                (prevElement.textContent.trim() !== '' && sf.base.closest(prevElement, 'td')) ?
                    selection.setSelectionNode(this.parent.getDocument(), prevElement) :
                    selection.setSelectionText(this.parent.getDocument(), prevElement, prevElement, 0, 0);
            }
        }
    };
    Table.prototype.insideList = function (range) {
        var blockNodes = this.parent.formatter.editorManager.domNode.blockNodes();
        var nodes = [];
        for (var i = 0; i < blockNodes.length; i++) {
            if (blockNodes[i].parentNode.tagName === 'LI') {
                nodes.push(blockNodes[i].parentNode);
            }
            else if (blockNodes[i].tagName === 'LI' && blockNodes[i].childNodes[0].tagName !== 'P' &&
                (blockNodes[i].childNodes[0].tagName !== 'OL' &&
                    blockNodes[i].childNodes[0].tagName !== 'UL')) {
                nodes.push(blockNodes[i]);
            }
        }
        if (nodes.length > 1 || nodes.length && ((range.startOffset === 0 && range.endOffset === 0))) {
            this.ensureInsideTableList = true;
            return true;
        }
        else {
            this.ensureInsideTableList = false;
            return false;
        }
    };
    Table.prototype.tableArrowNavigation = function (event, selection, ele) {
        var selText = selection.range.startContainer;
        if ((event.keyCode === 40 && selText.nodeType === 3 && (selText.nextSibling && selText.nextSibling.nodeName === 'BR' ||
            selText.parentNode && selText.parentNode.nodeName !== 'TD')) ||
            (event.keyCode === 38 && selText.nodeType === 3 && (selText.previousSibling && selText.previousSibling.nodeName === 'BR' ||
                selText.parentNode && selText.parentNode.nodeName !== 'TD'))) {
            return;
        }
        event.preventDefault();
        ele.classList.remove(CLS_TABLE_SEL);
        if (event.keyCode === 40) {
            ele = (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'tr').nextElementSibling)) ?
                sf.base.closest(ele, 'tr').nextElementSibling.children[ele.cellIndex] :
                (sf.base.closest(ele, 'table').tHead && ele.nodeName === 'TH') ?
                    sf.base.closest(ele, 'table').rows[1].cells[ele.cellIndex] :
                    (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'table').nextSibling)) ? sf.base.closest(ele, 'table').nextSibling :
                        ele;
        }
        else {
            ele = (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'tr').previousElementSibling)) ?
                sf.base.closest(ele, 'tr').previousElementSibling.children[ele.cellIndex] :
                (sf.base.closest(ele, 'table').tHead && ele.nodeName !== 'TH') ?
                    sf.base.closest(ele, 'table').tHead.rows[0].cells[ele.cellIndex] :
                    (!sf.base.isNullOrUndefined(sf.base.closest(ele, 'table').previousSibling)) ? sf.base.closest(ele, 'table').previousSibling :
                        ele;
        }
        if (ele) {
            selection.setSelectionText(this.parent.getDocument(), ele, ele, 0, 0);
        }
    };
    Table.prototype.cellSelect = function (e) {
        var target = e.args.target;
        var tdNode = sf.base.closest(target, 'td,th');
        target = (target.nodeName !== 'TD' && tdNode && this.parent.getEditPanel().contains(tdNode)) ?
            tdNode : target;
        sf.base.removeClass(this.parent.getEditPanel().querySelectorAll('table td, table th'), CLS_TABLE_SEL);
        if (target && (target.tagName === 'TD' || target.tagName === 'TH')) {
            target.removeAttribute('class');
            sf.base.addClass([target], CLS_TABLE_SEL);
            this.curTable = (this.curTable) ? this.curTable : sf.base.closest(target, 'table');
            this.removeResizeEle();
            if (this.helper && this.parent.getEditPanel().contains(this.helper)) {
                sf.base.detach(this.helper);
            }
        }
        if (sf.base.Browser.info.name === 'mozilla' && !sf.base.isNullOrUndefined(sf.base.closest(target, 'table')) &&
            sf.base.closest(target, 'table').tagName === 'TABLE' && this.parent.getEditPanel().contains(sf.base.closest(target, 'table'))) {
            this.parent.getEditPanel().setAttribute('contenteditable', 'false');
        }
    };
    Table.prototype.renderDlgContent = function (args) {
        this.tableNotifyArgs = args;
        this.parent.observer.notify(selectionSave, {});
        if (sf.base.Browser.isDevice || this.parent.inlineMode.enable) {
            this.insertTableDialog();
            return;
        }
        this.hideTableQuickToolbar();
        var tbEle = this.parent.getToolbarElement();
        var tbTableEle = this.parent.element.querySelector('#' + this.parent.element.id + '_toolbar_CreateTable');
        var top = 0;
        if (this.parent.getToolbar().classList.contains(CLS_EXPAND_OPEN)) {
            top = tbTableEle.offsetTop + tbTableEle.offsetHeight + tbEle.offsetHeight;
        }
        else {
            top = tbTableEle.offsetTop + tbTableEle.offsetHeight;
        }
        if (sf.base.isNullOrUndefined(sf.base.select('.e-rte-table-popup', this.parent.element))) {
            this.parent.dotNetRef.invokeMethodAsync('ShowCreateTableDialog', tbTableEle.offsetLeft, top);
        }
        else {
            this.parent.dotNetRef.invokeMethodAsync('CloseCreateTableDialog');
        }
    };
    Table.prototype.createTablePopupOpened = function () {
        var rowElements = sf.base.selectAll('.e-rte-table-popup .e-rte-table-row', this.parent.element);
        for (var i = 0; i < rowElements.length; i++) {
            sf.base.EventHandler.add(rowElements[i], 'mouseleave', this.tableCellLeave, this);
            var tableCells = sf.base.selectAll('.e-rte-tablecell', rowElements[i]);
            for (var j = 0; j < tableCells.length; j++) {
                sf.base.EventHandler.add(tableCells[j], 'mouseup', this.tableCellClick, this);
                sf.base.EventHandler.add(tableCells[j], 'mousemove', this.tableCellSelect, this);
            }
        }
        var dlgEle = this.parent.element.querySelector('.e-rte-table-popup');
        dlgEle && dlgEle.focus();
        if (!sf.base.isNullOrUndefined(this.parent.getToolbarElement().querySelector('.e-expended-nav'))) {
            this.parent.getToolbarElement().querySelector('.e-expended-nav').setAttribute('tabindex', '1');
        }
    };
    Table.prototype.insertTableDialog = function () {
        this.createDialog();
    };
    Table.prototype.createDialog = function (model, mode) {
        if (model && mode) {
            this.parent.dotNetRef.invokeMethodAsync('ShowEditTableDialog', model, mode);
        }
        else {
            this.parent.dotNetRef.invokeMethodAsync('ShowTableDialog');
        }
        if (this.quickToolObj && this.quickToolObj.inlineQTBar && document.body.contains(this.quickToolObj.inlineQTBar.element)) {
            this.quickToolObj.hideInlineQTBar();
        }
    };
    Table.prototype.tableCellSelect = function (e) {
        var target = e.target;
        var dlgDiv = this.parent.element.querySelector('.e-rte-table-popup');
        var tblHeader = this.parent.element.querySelector('.e-rte-table-popup .e-rte-popup-header');
        var row = Array.prototype.slice.call(target.parentElement.parentElement.children).indexOf(target.parentElement);
        var col = Array.prototype.slice.call(target.parentElement.children).indexOf(target);
        var list = dlgDiv.querySelectorAll('.e-rte-tablecell');
        Array.prototype.forEach.call(list, function (item) {
            var parentIndex = Array.prototype.slice.call(item.parentElement.parentElement.children).indexOf(item.parentElement);
            var cellIndex = Array.prototype.slice.call(item.parentElement.children).indexOf(item);
            sf.base.removeClass([item], 'e-active');
            if (parentIndex <= row && cellIndex <= col) {
                sf.base.addClass([item], 'e-active');
            }
        });
        tblHeader.innerHTML = (col + 1) + 'x' + (row + 1);
    };
    Table.prototype.tableCellLeave = function (e) {
        var dlgDiv = this.parent.element.querySelector('.e-rte-table-popup');
        var tblHeader = this.parent.element.querySelector('.e-rte-table-popup .e-rte-popup-header');
        sf.base.removeClass(dlgDiv.querySelectorAll('.e-rte-tablecell'), 'e-active');
        sf.base.addClass([dlgDiv.querySelector('.e-rte-tablecell')], 'e-active');
        tblHeader.innerHTML = 1 + 'x' + 1;
    };
    Table.prototype.tableCellClick = function (e) {
        var target = e.target;
        var row = Array.prototype.slice.call(target.parentElement.parentElement.children).indexOf(target.parentElement) + 1;
        var col = Array.prototype.slice.call(target.parentElement.children).indexOf(target) + 1;
        this.tableInsert(row, col, 'Create', this);
    };
    Table.prototype.tableInsert = function (row, col, dlgTarget, selectionObj) {
        var proxy = (selectionObj.self) ? selectionObj.self : this;
        var startContainer = this.tableNotifyArgs.selection.range.startContainer;
        if (startContainer.nodeName === 'P' && startContainer.textContent.trim() === '' && !(startContainer.childNodes.length > 0)) {
            startContainer.innerHTML = '<br />';
        }
        var parentNode = startContainer.parentNode;
        if (proxy.parent.editorMode === 'HTML' &&
            ((proxy.parent.iframeSettings.enable && !hasClass(parentNode.ownerDocument.querySelector('body'), 'e-lib')) ||
                (!proxy.parent.iframeSettings.enable && sf.base.isNullOrUndefined(sf.base.closest(parentNode, '#' + proxy.parent.getPanel().id))))) {
            proxy.parent.getEditPanel().focus();
            var range = proxy.parent.formatter.editorManager.nodeSelection.getRange(proxy.parent.getDocument());
            this.tableNotifyArgs.selection = proxy.parent.formatter.editorManager.nodeSelection.save(range, proxy.parent.getDocument());
        }
        var value = {
            rows: row, columns: col, width: {
                minWidth: proxy.parent.tableSettings.minWidth,
                maxWidth: proxy.parent.tableSettings.maxWidth,
                width: proxy.parent.tableSettings.width,
            },
            selection: this.tableNotifyArgs.selection
        };
        if (dlgTarget === 'Create') {
            this.parent.dotNetRef.invokeMethodAsync('CloseCreateTableDialog');
        }
        else {
            this.parent.dotNetRef.invokeMethodAsync('CloseTableDialog');
        }
        this.parent.observer.notify(selectionRestore, {});
        proxy.parent.formatter.process(proxy.parent, this.tableNotifyArgs.args, this.tableNotifyArgs.args.originalEvent, value);
        proxy.parent.getEditPanel().focus();
        proxy.parent.observer.on(mouseDown, proxy.cellSelect, proxy);
    };
    Table.prototype.customTable = function (rowValue, columnValue) {
        if (rowValue && columnValue) {
            var argument = ((sf.base.Browser.isDevice || (!sf.base.isNullOrUndefined(this.tableNotifyArgs.args)
                && !sf.base.isNullOrUndefined(this.tableNotifyArgs.args.originalEvent) &&
                this.tableNotifyArgs.args.originalEvent.action === 'insert-table')
                || this.parent.inlineMode.enable) ? this.tableNotifyArgs : this);
            this.tableInsert(rowValue, columnValue, '', argument);
        }
    };
    Table.prototype.applyTableProperties = function (model) {
        var table = sf.base.closest(this.tableNotifyArgs.selectNode[0], 'table');
        table.style.width = model.width + 'px';
        if (model.padding.toString() !== '') {
            var thElm = table.querySelectorAll('th');
            this.applyCellPadding(thElm, model.padding);
            var tdElm = table.querySelectorAll('td');
            this.applyCellPadding(tdElm, model.padding);
        }
        table.cellSpacing = model.spacing.toString();
        if (table.cellSpacing && table.cellSpacing !== '0') {
            sf.base.addClass([table], CLS_TABLE_BORDER);
        }
        else {
            sf.base.removeClass([table], CLS_TABLE_BORDER);
        }
        this.parent.formatter.saveData();
        this.parent.dotNetRef.invokeMethodAsync('CloseTableDialog');
    };
    Table.prototype.applyCellPadding = function (elements, padding) {
        for (var i = 0; i < elements.length; i++) {
            var padVal = '';
            if (elements[i].style.padding === '') {
                var styles = elements[i].getAttribute('style');
                padVal = (!sf.base.isNullOrUndefined(styles) ? styles : '') + ' padding:' + padding + 'px;';
            }
            else {
                elements[i].style.padding = padding + 'px';
                padVal = elements[i].getAttribute('style');
            }
            elements[i].setAttribute('style', padVal);
        }
    };
    //#region Resize methods
    Table.prototype.resizeHelper = function (e) {
        if (this.parent.readonly) {
            return;
        }
        var target = e.target || e.targetTouches[0].target;
        var closestTable = sf.base.closest(target, 'table');
        if (!sf.base.isNullOrUndefined(this.curTable) && !sf.base.isNullOrUndefined(closestTable) && closestTable !== this.curTable) {
            this.removeResizeEle();
            this.removeHelper(e);
            this.cancelResizeAction();
        }
        if ((target.nodeName === 'TABLE' || target.nodeName === 'TD' || target.nodeName === 'TH') && !this.rzProgress) {
            this.curTable = (closestTable && this.parent.getEditPanel().contains(closestTable))
                && (target.nodeName === 'TD' || target.nodeName === 'TH') ?
                closestTable : target;
            this.removeResizeEle();
            this.tableResizeEleCreation(this.curTable, e);
        }
    };
    Table.prototype.tableResizeEleCreation = function (table, e) {
        this.parent.defaultResize(e, false);
        var columns = Array.prototype.slice.call(table.rows[this.calMaxCol(table)].cells, 1);
        var rows = [];
        for (var i = 0; i < table.rows.length; i++) {
            rows.push(Array.prototype.slice.call(table.rows[i].cells, 0, 1)[0]);
        }
        var height = parseInt(getComputedStyle(table).height, 10);
        var width = parseInt(getComputedStyle(table).width, 10);
        var pos = this.calcPos(table);
        for (var i = 0; columns.length > i; i++) {
            var colReEle = sf.base.createElement('span', {
                attrs: {
                    'data-col': (i + 1).toString(), 'unselectable': 'on', 'contenteditable': 'false'
                }
            });
            colReEle.classList.add(CLS_RTE_TABLE_RESIZE, CLS_TB_COL_RES);
            colReEle.style.cssText = 'height: ' + height + 'px; width: 4px; top: ' + pos.top +
                'px; left:' + (pos.left + this.calcPos(columns[i]).left) + 'px;';
            this.parent.getEditPanel().appendChild(colReEle);
        }
        for (var i = 0; rows.length > i; i++) {
            var rowReEle = sf.base.createElement('span', {
                attrs: {
                    'data-row': (i).toString(), 'unselectable': 'on', 'contenteditable': 'false'
                }
            });
            rowReEle.classList.add(CLS_RTE_TABLE_RESIZE, CLS_TB_ROW_RES);
            var rowPosLeft = !sf.base.isNullOrUndefined(table.getAttribute('cellspacing')) || table.getAttribute('cellspacing') !== '' ?
                0 : this.calcPos(rows[i]).left;
            rowReEle.style.cssText = 'width: ' + width + 'px; height: 4px; top: ' +
                (this.calcPos(rows[i]).top + pos.top + rows[i].offsetHeight - 2) +
                'px; left:' + (rowPosLeft + pos.left) + 'px;';
            this.parent.getEditPanel().appendChild(rowReEle);
        }
        var tableReBox = sf.base.createElement('span', {
            className: CLS_TB_BOX_RES, attrs: {
                'data-col': columns.length.toString(), 'unselectable': 'on', 'contenteditable': 'false'
            }
        });
        tableReBox.style.cssText = 'top: ' + (pos.top + height - 4) +
            'px; left:' + (pos.left + width - 4) + 'px;';
        if (sf.base.Browser.isDevice) {
            tableReBox.classList.add('e-rmob');
        }
        this.parent.getEditPanel().appendChild(tableReBox);
    };
    Table.prototype.resizeStart = function (e) {
        var _this = this;
        if (this.parent.readonly) {
            return;
        }
        if (sf.base.Browser.isDevice) {
            this.resizeHelper(e);
        }
        var target = e.target;
        if (target.classList.contains(CLS_TB_COL_RES) ||
            target.classList.contains(CLS_TB_ROW_RES) ||
            target.classList.contains(CLS_TB_BOX_RES)) {
            e.preventDefault();
            this.parent.defaultResize(e, false);
            if (!target.classList.contains(CLS_TB_BOX_RES)) {
                var rzBox = this.parent.getEditPanel().querySelector('.e-table-box');
                if (!sf.base.isNullOrUndefined(rzBox)) {
                    rzBox.classList.add('e-hide');
                    this.rzProgress = true;
                }
            }
            sf.base.removeClass(this.curTable.querySelectorAll('td,th'), CLS_TABLE_SEL);
            this.parent.formatter.editorManager.nodeSelection.Clear(this.parent.getDocument());
            this.pageX = this.getPointX(e);
            this.pageY = this.getPointY(e);
            this.resizeBtnInit();
            this.hideTableQuickToolbar();
            if (target.classList.contains(CLS_TB_COL_RES)) {
                this.resizeBtnStat.column = true;
                this.columnEle = this.curTable.rows[this.calMaxCol(this.curTable)].cells[parseInt(target.getAttribute('data-col'), 10)];
                this.colIndex = this.columnEle.cellIndex;
                this.moveEle = e.target;
                this.appendHelper();
            }
            if (target.classList.contains(CLS_TB_ROW_RES)) {
                this.rowEle = this.curTable.rows[parseInt(target.getAttribute('data-row'), 10)];
                this.resizeBtnStat.row = true;
                this.appendHelper();
            }
            if (target.classList.contains(CLS_TB_BOX_RES)) {
                this.resizeBtnStat.tableBox = true;
            }
            if (sf.base.Browser.isDevice && this.helper && !this.helper.classList.contains('e-reicon')) {
                this.helper.classList.add('e-reicon');
                sf.base.EventHandler.add(document, sf.base.Browser.touchStartEvent, this.removeHelper, this);
                sf.base.EventHandler.add(this.helper, sf.base.Browser.touchStartEvent, this.resizeStart, this);
            }
            else {
                var args = { requestType: 'Table' };
                if (this.parent.onResizeStartEnabled) {
                    // @ts-ignore-start
                    this.parent.dotNetRef.invokeMethodAsync('ResizeStartEvent', args).then(function (resizeStartArgs) {
                        // @ts-ignore-end
                        if (resizeStartArgs.cancel) {
                            _this.cancelResizeAction();
                        }
                    });
                }
            }
            sf.base.EventHandler.add(this.parent.getDocument(), sf.base.Browser.touchMoveEvent, this.resizing, this);
            sf.base.EventHandler.add(this.parent.getDocument(), sf.base.Browser.touchEndEvent, this.resizeEnd, this);
        }
    };
    Table.prototype.calMaxCol = function (element) {
        var max = 0;
        var maxRowIndex;
        for (var i = 0; i < element.rows.length; i++) {
            if (max < element.rows[i].cells.length) {
                maxRowIndex = i;
                max = element.rows[i].cells.length;
            }
        }
        return maxRowIndex;
    };
    Table.prototype.resizing = function (e) {
        var pageX = this.getPointX(e);
        var pageY = this.getPointY(e);
        var mouseX = (this.parent.enableRtl) ? -(pageX - this.pageX) : (pageX - this.pageX);
        var mouseY = (this.parent.enableRtl) ? -(pageY - this.pageY) : (pageY - this.pageY);
        this.pageX = pageX;
        this.pageY = pageY;
        var tableReBox = this.parent.getEditPanel().querySelector('.e-table-box');
        var tableWidth = parseInt(getComputedStyle(this.curTable).width, 10);
        var tableHeight = parseInt(getComputedStyle(this.curTable).height, 10);
        var paddingSize = +getComputedStyle(this.parent.getEditPanel()).paddingRight.match(/\d/g).join('');
        var rteWidth = this.parent.getEditPanel().offsetWidth - paddingSize * 2;
        if (this.resizeBtnStat.column) {
            var cellColl = this.curTable.rows[this.calMaxCol(this.curTable)].cells;
            var width = parseFloat(this.columnEle.offsetWidth.toString());
            var actualWidth = width - mouseX;
            var totalWidth = parseFloat(this.columnEle.offsetWidth.toString()) +
                parseFloat(cellColl[this.colIndex - 1].offsetWidth.toString());
            for (var i = 0; i < this.curTable.rows.length; i++) {
                if ((totalWidth - actualWidth) > 20 && actualWidth > 20) {
                    var leftColumnWidth = totalWidth - actualWidth;
                    var rightColWidth = actualWidth;
                    if (this.curTable.rows[i].cells[this.colIndex - 1]) {
                        this.curTable.rows[i].cells[this.colIndex - 1].style.width =
                            this.convertPixelToPercentage(leftColumnWidth, tableWidth) + '%';
                    }
                    if (this.curTable.rows[i].cells[this.colIndex]) {
                        this.curTable.rows[i].cells[this.colIndex].style.width =
                            this.convertPixelToPercentage(rightColWidth, tableWidth) + '%';
                    }
                }
            }
            this.updateHelper();
        }
        else if (this.resizeBtnStat.row) {
            this.parent.defaultResize(e, false);
            var height = parseFloat(this.rowEle.clientHeight.toString()) + mouseY;
            if (height > 20) {
                this.rowEle.style.height = height + 'px';
            }
            this.curTable.style.height = '';
            if (!sf.base.isNullOrUndefined(tableReBox)) {
                tableReBox.style.cssText = 'top: ' + (this.calcPos(this.curTable).top + tableHeight - 4) +
                    'px; left:' + (this.calcPos(this.curTable).left + tableWidth - 4) + 'px;';
            }
            this.updateHelper();
        }
        else if (this.resizeBtnStat.tableBox) {
            if (!sf.base.Browser.isDevice) {
                sf.base.EventHandler.remove(this.parent.getEditPanel(), 'mouseover', this.resizeHelper);
            }
            var widthType = this.curTable.style.width.indexOf('%') > -1;
            this.curTable.style.width = widthType ? this.convertPixelToPercentage(tableWidth + mouseX, rteWidth) + '%'
                : tableWidth + mouseX + 'px';
            this.curTable.style.height = tableHeight + mouseY + 'px';
            if (!sf.base.isNullOrUndefined(tableReBox)) {
                tableReBox.classList.add('e-rbox-select');
                tableReBox.style.cssText = 'top: ' + (this.calcPos(this.curTable).top + tableHeight - 4) +
                    'px; left:' + (this.calcPos(this.curTable).left + tableWidth - 4) + 'px;';
            }
        }
    };
    Table.prototype.resizeEnd = function (e) {
        this.resizeBtnInit();
        var rzBox = this.parent.getEditPanel().querySelector('.e-table-box');
        if (!sf.base.isNullOrUndefined(rzBox)) {
            rzBox.classList.remove('e-hide');
            this.rzProgress = false;
        }
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchMoveEvent, this.resizing);
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchEndEvent, this.resizeEnd);
        if (rzBox && this.parent.getEditPanel().contains(rzBox)) {
            if (!sf.base.Browser.isDevice) {
                sf.base.EventHandler.add(this.parent.getEditPanel(), 'mouseover', this.resizeHelper, this);
            }
            this.removeResizeEle();
            if (this.helper && this.parent.getEditPanel().contains(this.helper)) {
                sf.base.detach(this.helper);
                this.helper = null;
            }
            this.pageX = null;
            this.pageY = null;
            this.moveEle = null;
        }
        var args = { requestType: 'Table' };
        if (this.parent.onResizeStopEnabled) {
            this.parent.dotNetRef.invokeMethodAsync('ResizeStopEvent', args);
        }
        this.parent.formatter.saveData();
    };
    Table.prototype.resizeBtnInit = function () {
        return this.resizeBtnStat = { column: false, row: false, tableBox: false };
    };
    Table.prototype.removeResizeEle = function () {
        var item = this.parent.getEditPanel().
            querySelectorAll('.e-column-resize, .e-row-resize, .e-table-box');
        if (item.length > 0) {
            for (var i = 0; i < item.length; i++) {
                sf.base.detach(item[i]);
            }
        }
    };
    Table.prototype.appendHelper = function () {
        this.helper = sf.base.createElement('div', {
            className: 'e-table-rhelper'
        });
        if (sf.base.Browser.isDevice) {
            this.helper.classList.add('e-reicon');
        }
        this.parent.getEditPanel().appendChild(this.helper);
        this.setHelperHeight();
    };
    Table.prototype.setHelperHeight = function () {
        var pos = this.calcPos(this.curTable);
        if (this.resizeBtnStat.column) {
            this.helper.classList.add('e-column-helper');
            this.helper.style.cssText = 'height: ' + getComputedStyle(this.curTable).height + '; top: ' +
                pos.top + 'px; left:' + (pos.left + this.calcPos(this.columnEle).left - 1) + 'px;';
        }
        else {
            this.helper.classList.add('e-row-helper');
            this.helper.style.cssText = 'width: ' + getComputedStyle(this.curTable).width + '; top: ' +
                (this.calcPos(this.rowEle).top + pos.top + this.rowEle.offsetHeight) +
                'px; left:' + (this.calcPos(this.rowEle).left + pos.left) + 'px;';
        }
    };
    Table.prototype.updateHelper = function () {
        var pos = this.calcPos(this.curTable);
        if (this.resizeBtnStat.column) {
            var left = pos.left + this.calcPos(this.columnEle).left - 1;
            this.helper.style.left = left + 'px';
        }
        else {
            var top_1 = this.calcPos(this.rowEle).top + pos.top + this.rowEle.offsetHeight;
            this.helper.style.top = top_1 + 'px';
        }
    };
    Table.prototype.removeHelper = function (e) {
        var cls = e.target.classList;
        if (!(cls.contains('e-reicon')) && this.helper) {
            sf.base.EventHandler.remove(document, sf.base.Browser.touchStartEvent, this.removeHelper);
            sf.base.EventHandler.remove(this.helper, sf.base.Browser.touchStartEvent, this.resizeStart);
            if (this.helper && this.parent.getEditPanel().contains(this.helper)) {
                sf.base.detach(this.helper);
            }
            this.pageX = null;
            this.helper = null;
        }
    };
    Table.prototype.convertPixelToPercentage = function (value, offsetValue) {
        return (value / offsetValue) * 100;
    };
    Table.prototype.cancelResizeAction = function () {
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchMoveEvent, this.resizing);
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchEndEvent, this.resizeEnd);
        this.removeResizeEle();
    };
    Table.prototype.calcPos = function (elem) {
        var parentOffset = {
            top: 0,
            left: 0
        };
        var offset = elem.getBoundingClientRect();
        var doc = elem.ownerDocument;
        var offsetParent = elem.offsetParent || doc.documentElement;
        while (offsetParent &&
            (offsetParent === doc.body || offsetParent === doc.documentElement) &&
            offsetParent.style.position === 'static') {
            offsetParent = offsetParent.parentNode;
        }
        if (offsetParent.nodeName === 'TD' && elem.nodeName === 'TABLE') {
            offsetParent = sf.base.closest(offsetParent, '.e-rte-content');
        }
        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = offsetParent.getBoundingClientRect();
        }
        return {
            top: elem.offsetTop,
            left: elem.offsetLeft
        };
    };
    Table.prototype.getPointX = function (e) {
        if (e.touches && e.touches.length) {
            return e.touches[0].pageX;
        }
        else {
            return e.pageX;
        }
    };
    Table.prototype.getPointY = function (e) {
        if (e.touches && e.touches.length) {
            return e.touches[0].pageY;
        }
        else {
            return e.pageY;
        }
    };
    //#endregion
    //#region Quick toolbar related methods
    Table.prototype.editAreaClickHandler = function (e) {
        if (this.parent.readonly || !sf.base.isNullOrUndefined(sf.base.closest(e.args.target, '.e-img-caption'))) {
            return;
        }
        var args = e.args;
        var showOnRightClick = this.parent.quickToolbarSettings.showOnRightClick;
        if (args.which === 2 || (showOnRightClick && args.which === 1) || (!showOnRightClick && args.which === 3)) {
            return;
        }
        if (this.parent.editorMode === 'HTML' && this.parent.quickToolbarModule) {
            this.quickToolObj = this.parent.quickToolbarModule;
            var parentRect = this.parent.element.getBoundingClientRect();
            var target = args.target;
            var tbElement = this.parent.getToolbarElement();
            var tbHeight = (tbElement) ? (tbElement.offsetHeight + this.parent.toolbarModule.getExpandTBarPopHeight()) : 0;
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            var closestTable = sf.base.closest(target, 'table');
            if (target && target.nodeName !== 'A' && target.nodeName !== 'IMG' && (target.nodeName === 'TD' || target.nodeName === 'TH' ||
                target.nodeName === 'TABLE' || (closestTable && this.parent.getEditPanel().contains(closestTable)))
                && !(range.startContainer.nodeType === 3 && !range.collapsed)) {
                var range_1 = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
                this.parent.formatter.editorManager.nodeSelection.save(range_1, this.parent.getDocument());
                this.parent.formatter.editorManager.nodeSelection.Clear(this.parent.getDocument());
                var pageX = this.parent.iframeSettings.enable ? window.pageXOffset + parentRect.left + args.clientX : args.pageX;
                var pageY = this.parent.iframeSettings.enable ? window.pageYOffset + parentRect.top +
                    tbHeight + args.clientY : args.pageY;
                this.quickToolObj.showTableQTBar(pageX, pageY, target, 'Table');
                this.parent.formatter.editorManager.nodeSelection.restore();
            }
            else {
                this.hideTableQuickToolbar();
            }
        }
    };
    Table.prototype.hideTableQuickToolbar = function () {
        if (this.quickToolObj) {
            this.quickToolObj.hideTableQTBar();
        }
    };
    Table.prototype.onToolbarAction = function (args) {
        var item = args.args.item;
        switch (item.subCommand) {
            case 'TableHeader':
                this.tableHeader(args.selection, args.args);
                break;
            case 'TableRemove':
                this.removeTable(args.selection, args.args);
                break;
            case 'TableEditProperties':
                this.editTable(args);
                break;
        }
    };
    Table.prototype.tableHeader = function (selection, e) {
        this.parent.formatter.process(this.parent, e, e.originalEvent, { selection: selection, subCommand: e.item.subCommand });
    };
    Table.prototype.removeTable = function (selection, args, delKey) {
        var cmd;
        if (delKey) {
            cmd = { item: { command: 'Table', subCommand: 'TableRemove' } };
        }
        var value = {
            selection: selection,
            subCommand: (delKey) ? cmd.item.subCommand : args.item.subCommand
        };
        this.parent.formatter.process(this.parent, (delKey) ? cmd : args, args.originalEvent, value);
        this.parent.getEditPanel().focus();
        this.removeResizeEle();
        this.hideTableQuickToolbar();
    };
    Table.prototype.editTable = function (args) {
        var selectNode = args.selectParent[0];
        this.tableNotifyArgs.selectNode = args.selectParent;
        var width = sf.base.closest(selectNode, 'table').getClientRects()[0].width;
        var padding = sf.base.closest(selectNode, 'td').style.padding;
        var spacing = sf.base.closest(selectNode, 'table').getAttribute('cellspacing');
        this.hideTableQuickToolbar();
        this.createDialog({
            width: width,
            padding: parseFloat((padding !== '' ? parseInt(padding, null) : 0).toString()),
            spacing: parseFloat((spacing !== '' && !sf.base.isNullOrUndefined(spacing) ? parseInt(spacing, null) : 0).toString())
        }, 'Edit');
    };
    Table.prototype.dropdownSelect = function (e) {
        this.parent.observer.notify(selectionSave, {});
        var item = e.item;
        if (!document.body.contains(document.body.querySelector('.e-rte-quick-toolbar')) || item.command !== 'Table') {
            return;
        }
        var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
        var args = {
            args: e,
            selection: this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument()),
            selectParent: this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range)
        };
        switch (item.subCommand) {
            case 'InsertRowBefore':
            case 'InsertRowAfter':
                this.addRow(args.selection, e);
                break;
            case 'InsertColumnLeft':
            case 'InsertColumnRight':
                this.addColumn(args.selection, e);
                break;
            case 'DeleteColumn':
            case 'DeleteRow':
                this.removeRowColumn(args.selection, e);
                break;
            case 'AlignTop':
            case 'AlignMiddle':
            case 'AlignBottom':
                this.verticalAlign(args, e);
                break;
            case 'Dashed':
            case 'Alternate':
            case 'Custom':
                this.tableStyles(args, item.subCommand);
                break;
        }
    };
    Table.prototype.addRow = function (selectCell, e, tabKey) {
        var cmd;
        if (tabKey) {
            cmd = {
                item: { command: 'Table', subCommand: 'InsertRowAfter' }
            };
        }
        var value = {
            selection: selectCell,
            subCommand: (tabKey) ? cmd.item.subCommand : e.item.subCommand
        };
        this.parent.formatter.process(this.parent, (tabKey) ? cmd : e, e, value);
    };
    Table.prototype.addColumn = function (selectCell, e) {
        this.parent.formatter.process(this.parent, e, e, { selection: selectCell, width: this.parent.tableSettings.width, subCommand: e.item.subCommand });
    };
    Table.prototype.removeRowColumn = function (selectCell, e) {
        this.parent.observer.notify(selectionRestore, {});
        this.parent.formatter.process(this.parent, e, e, { selection: selectCell, subCommand: e.item.subCommand });
        this.hideTableQuickToolbar();
        this.parent.observer.notify(selectionSave, {});
    };
    Table.prototype.verticalAlign = function (args, e) {
        var tdEle = sf.base.closest(args.selectParent[0], 'td') || sf.base.closest(args.selectParent[0], 'th');
        if (tdEle) {
            this.parent.formatter.process(this.parent, e, e, { tableCell: tdEle, subCommand: e.item.subCommand });
        }
    };
    Table.prototype.tableStyles = function (args, command) {
        var table = sf.base.closest(args.selectParent[0], 'table');
        if (command === 'Dashed') {
            (this.parent.element.classList.contains(CLS_TB_DASH_BOR)) ?
                this.parent.element.classList.remove(CLS_TB_DASH_BOR) : this.parent.element.classList.add(CLS_TB_DASH_BOR);
            (table.classList.contains(CLS_TB_DASH_BOR)) ? table.classList.remove(CLS_TB_DASH_BOR) :
                table.classList.add(CLS_TB_DASH_BOR);
        }
        if (command === 'Alternate') {
            (this.parent.element.classList.contains(CLS_TB_ALT_BOR)) ?
                this.parent.element.classList.remove(CLS_TB_ALT_BOR) : this.parent.element.classList.add(CLS_TB_ALT_BOR);
            (table.classList.contains(CLS_TB_ALT_BOR)) ? table.classList.remove(CLS_TB_ALT_BOR) :
                table.classList.add(CLS_TB_ALT_BOR);
        }
        if (args.args && args.args.item.cssClass) {
            var classList = args.args.item.cssClass.split(' ');
            for (var i = 0; i < classList.length; i++) {
                (table.classList.contains(classList[i])) ? table.classList.remove(classList[i]) :
                    table.classList.add(classList[i]);
            }
        }
        this.parent.formatter.saveData();
        this.parent.formatter.editorManager.nodeSelection.restore();
        this.hideTableQuickToolbar();
    };
    Table.prototype.setBGColor = function (args) {
        var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
        var selection = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
        var selectedCell = selection.range.startContainer;
        selectedCell = (selectedCell.nodeType === 3) ? sf.base.closest(selectedCell.parentNode, 'td,th') : sf.base.closest(selectedCell, 'td, th');
        if (selectedCell && (selectedCell.nodeName === 'TD' || selectedCell.nodeName === 'TH')) {
            var items = sf.base.closest(selectedCell, 'table').querySelectorAll('.' + CLS_TABLE_SEL);
            for (var i = 0; i < items.length; i++) {
                items[i].style.backgroundColor = args.item.value;
            }
            this.parent.formatter.saveData();
        }
        this.hideTableQuickToolbar();
    };
    Table.prototype.closeOpenedDialog = function () {
        var createDlg = this.parent.element.querySelector('.e-rte-table-popup');
        var insertDlg = this.parent.element.querySelector('.e-rte-edit-table');
        if (createDlg) {
            this.parent.dotNetRef.invokeMethodAsync('CloseCreateTableDialog');
        }
        if (insertDlg) {
            this.parent.dotNetRef.invokeMethodAsync('CloseTableDialog');
        }
    };
    Table.prototype.showDialog = function (isExternal, e) {
        if (isExternal) {
            this.parent.getEditPanel().focus();
        }
        if (this.parent.editorMode === 'HTML') {
            var docElement = this.parent.getDocument();
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(docElement);
            var selection = this.parent.formatter.editorManager.nodeSelection.save(range, docElement);
            this.parent.observer.notify(selectionSave, {});
            var args = {
                originalEvent: isExternal ? undefined : e.args,
                item: { command: 'Table', subCommand: 'CreateTable' }
            };
            this.tableNotifyArgs = { args: args, selection: selection };
            this.insertTableDialog();
        }
    };
    //#endregion
    //#region Event handler methods
    Table.prototype.keyDown = function (e) {
        var event = e.args;
        var proxy = this;
        switch (event.action) {
            case 'escape':
                break;
            case 'insert-table':
                this.showDialog(false, e);
                event.preventDefault();
                break;
        }
        if (!sf.base.isNullOrUndefined(this.parent.formatter.editorManager.nodeSelection) && this.parent.getEditPanel()
            && event.code !== 'KeyK') {
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            var selection = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
            var nodes = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
            var ele = nodes[(range.endOffset !== 0 && event.keyCode === 9 ? nodes.length - 1 : 0)];
            ele = (ele && ele.tagName !== 'TD' && ele.tagName !== 'TH') ? ele.parentElement : ele;
            if ((event.keyCode === 8 || event.keyCode === 46) ||
                (event.ctrlKey && event.keyCode === 88)) {
                if (ele && ele.tagName === 'TBODY') {
                    event.preventDefault();
                    proxy.removeTable(selection, event, true);
                }
                else if (ele && ele.querySelectorAll('table').length > 0) {
                    this.removeResizeEle();
                }
            }
            if (ele && ele.tagName !== 'TD' && ele.tagName !== 'TH') {
                var closestTd = sf.base.closest(ele, 'td');
                ele = !sf.base.isNullOrUndefined(closestTd) && this.parent.inputElement.contains(closestTd) ? closestTd : ele;
            }
            if (ele && (ele.tagName === 'TD' || ele.tagName === 'TH')) {
                switch (event.keyCode) {
                    case 9:
                    case 37:
                    case 39:
                        proxy.tabSelection(event, selection, ele);
                        break;
                    case 40:
                    case 38:
                        proxy.tableArrowNavigation(event, selection, ele);
                        break;
                }
            }
        }
    };
    Table.prototype.docClick = function (e) {
        var target = e.args.target;
        var createDlg = this.parent.element.querySelector('.e-rte-table-popup');
        var insertDlg = this.parent.element.querySelector('.e-rte-edit-table');
        if (target && target.classList && ((createDlg && !sf.base.closest(target, '#' + createDlg.id) ||
            (insertDlg && !sf.base.closest(target, '#' + insertDlg.id)))) && !target.classList.contains('e-create-table') &&
            target.offsetParent && !target.offsetParent.classList.contains('e-rte-backgroundcolor-dropdown')) {
            this.closeOpenedDialog();
            this.parent.isBlur = true;
            if (sf.base.Browser.isIE) {
                dispatchEvent(this.parent.element, 'focusout');
            }
        }
        var closestEle = sf.base.closest(target, 'td');
        var isExist = closestEle && this.parent.getEditPanel().contains(closestEle) ? true : false;
        if (target && target.tagName !== 'TD' && target.tagName !== 'TH' && !isExist &&
            sf.base.closest(target, '.e-rte-quick-popup') === null && target.offsetParent &&
            !target.offsetParent.classList.contains('e-quick-dropdown') &&
            !target.offsetParent.classList.contains('e-rte-backgroundcolor-dropdown') && !sf.base.closest(target, '.e-rte-dropdown-popup')
            && !sf.base.closest(target, '.e-rte-elements')) {
            sf.base.removeClass(this.parent.inputElement.querySelectorAll('table td'), CLS_TABLE_SEL);
            if (!sf.base.Browser.isIE) {
                this.hideTableQuickToolbar();
            }
        }
        if (target && target.classList && !target.classList.contains(CLS_TB_COL_RES) &&
            !target.classList.contains(CLS_TB_ROW_RES) && !target.classList.contains(CLS_TB_BOX_RES)) {
            this.removeResizeEle();
        }
    };
    Table.prototype.onIframeMouseDown = function () {
        this.closeOpenedDialog();
    };
    Table.prototype.keyUp = function (e) {
        var args = e.args;
        if ((args.which === 8 && args.code === 'Backspace') || (args.which === 46 && args.code === 'Delete')) {
            this.hideTableQuickToolbar();
        }
    };
    //#endregion
    Table.prototype.destroy = function () {
        this.removeEventListener();
    };
    return Table;
}());

/**
 * `Image` module is used to handle image actions.
 */
var Image = /** @class */ (function () {
    function Image(parent) {
        this.pageX = null;
        this.pageY = null;
        this.deletedImg = [];
        this.parent = parent;
        this.rteId = parent.element.id;
        this.addEventListener();
    }
    Image.prototype.addEventListener = function () {
        this.parent.observer.on(keyUp, this.onKeyUp, this);
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(paste, this.imagePaste, this);
        this.parent.observer.on(keyDown, this.onKeyDown, this);
        this.parent.observer.on(imageSize, this.imageSize, this);
        this.parent.observer.on(imageCaption, this.caption, this);
        this.parent.observer.on(imageDelete, this.deleteImg, this);
        this.parent.observer.on(imageAlt, this.insertAltText, this);
        this.parent.observer.on(initialEnd, this.afterRender, this);
        this.parent.observer.on(imageLink, this.insertImgLink, this);
        this.parent.observer.on(insertImage, this.imageDialog, this);
        this.parent.observer.on(windowResize, this.onWindowResize, this);
        this.parent.observer.on(dropDownSelect, this.alignmentSelect, this);
        this.parent.observer.on(iframeMouseDown, this.onIframeMouseDown, this);
        this.parent.observer.on(imageToolbarAction, this.onToolbarAction, this);
        this.parent.observer.on(editAreaClick, this.editAreaClickHandler, this);
        this.parent.observer.on(insertCompleted, this.showImageQuickToolbar, this);
    };
    Image.prototype.removeEventListener = function () {
        this.parent.observer.off(keyUp, this.onKeyUp);
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(paste, this.imagePaste);
        this.parent.observer.off(keyDown, this.onKeyDown);
        this.parent.observer.off(imageSize, this.imageSize);
        this.parent.observer.off(imageCaption, this.caption);
        this.parent.observer.off(imageDelete, this.deleteImg);
        this.parent.observer.off(imageAlt, this.insertAltText);
        this.parent.observer.off(initialEnd, this.afterRender);
        this.parent.observer.off(imageLink, this.insertImgLink);
        this.parent.observer.off(insertImage, this.imageDialog);
        this.parent.observer.off(windowResize, this.onWindowResize);
        this.parent.observer.off(dropDownSelect, this.alignmentSelect);
        this.parent.observer.off(iframeMouseDown, this.onIframeMouseDown);
        this.parent.observer.off(imageToolbarAction, this.onToolbarAction);
        this.parent.observer.off(editAreaClick, this.editAreaClickHandler);
        this.parent.observer.off(insertCompleted, this.showImageQuickToolbar);
        var dropElement = this.parent.iframeSettings.enable ?
            this.parent.inputElement.ownerDocument : this.parent.inputElement;
        dropElement.removeEventListener('drop', this.dragDrop.bind(this), true);
        dropElement.removeEventListener('dragstart', this.dragStart.bind(this), true);
        dropElement.removeEventListener('dragenter', this.dragEnter.bind(this), true);
        dropElement.removeEventListener('dragover', this.dragOver.bind(this), true);
        if (!sf.base.isNullOrUndefined(this.parent.getEditPanel())) {
            sf.base.EventHandler.remove(this.parent.getEditPanel(), sf.base.Browser.touchEndEvent, this.imageClick);
            this.parent.formatter.editorManager.observer.off(checkUndo, this.undoStack);
            if (this.parent.insertImageSettings.resize) {
                sf.base.EventHandler.remove(this.parent.getEditPanel(), sf.base.Browser.touchStartEvent, this.resizeStart);
                sf.base.EventHandler.remove(this.parent.element.ownerDocument, 'mousedown', this.onDocumentClick);
                sf.base.EventHandler.remove(this.parent.getEditPanel(), 'cut', this.onCutHandler);
            }
        }
    };
    Image.prototype.afterRender = function () {
        sf.base.EventHandler.add(this.parent.getEditPanel(), sf.base.Browser.touchEndEvent, this.imageClick, this);
        if (this.parent.insertImageSettings.resize) {
            sf.base.EventHandler.add(this.parent.getEditPanel(), sf.base.Browser.touchStartEvent, this.resizeStart, this);
            sf.base.EventHandler.add(this.parent.element.ownerDocument, 'mousedown', this.onDocumentClick, this);
            sf.base.EventHandler.add(this.parent.getEditPanel(), 'cut', this.onCutHandler, this);
        }
        var dropElement = this.parent.iframeSettings.enable ? this.parent.inputElement.ownerDocument :
            this.parent.inputElement;
        dropElement.addEventListener('drop', this.dragDrop.bind(this), true);
        dropElement.addEventListener('dragstart', this.dragStart.bind(this), true);
        dropElement.addEventListener('dragenter', this.dragOver.bind(this), true);
        dropElement.addEventListener('dragover', this.dragOver.bind(this), true);
    };
    Image.prototype.imageDialog = function (e) {
        this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
        this.uploadUrl = { url: '' };
        this.selectionObj = { selfImage: this, selection: e.selection, args: e.args, selectParent: e.selectParent };
        if ((!sf.base.isNullOrUndefined(this.parent.insertImageSettings.path) && this.parent.editorMode === 'Markdown')
            || this.parent.editorMode === 'HTML') {
            var iframe = this.parent.iframeSettings.enable;
            if (this.parent.editorMode === 'HTML' && (!iframe && sf.base.isNullOrUndefined(sf.base.closest(e.selection.range.startContainer.parentNode, '#' +
                this.parent.getPanel().id))
                || (iframe && sf.base.isNullOrUndefined(e.selection.range.startContainer.parentNode.ownerDocument.querySelector('body'))))) {
                this.parent.getEditPanel().focus();
                var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
                this.imgUploadSave = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
                this.imgUploadSelectedParent = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
            }
            else {
                this.imgUploadSave = e.selection;
                this.imgUploadSelectedParent = e.selectParent;
            }
        }
        var obj = { mode: (e.selectNode && e.selectNode[0].nodeName === 'IMG' ? 'Edit' : 'Insert') };
        this.parent.dotNetRef.invokeMethodAsync(showImageDialog, obj);
        if (this.quickToolObj) {
            this.quickToolObj.hideImageQTBar();
            if (!sf.base.isNullOrUndefined(e.selectParent)) {
                sf.base.removeClass([e.selectParent[0]], 'e-img-focus');
            }
            this.quickToolObj.hideInlineQTBar();
        }
    };
    Image.prototype.checkImageBack = function (range) {
        if (range.startContainer.nodeName === '#text' && range.startOffset === 0 &&
            !sf.base.isNullOrUndefined(range.startContainer.previousSibling) && range.startContainer.previousSibling.nodeName === 'IMG') {
            this.deletedImg.push(range.startContainer.previousSibling);
        }
        else if (range.startContainer.nodeName !== '#text' && !sf.base.isNullOrUndefined(range.startContainer.childNodes[range.startOffset - 1]) &&
            range.startContainer.childNodes[range.startOffset - 1].nodeName === 'IMG') {
            this.deletedImg.push(range.startContainer.childNodes[range.startOffset - 1]);
        }
    };
    Image.prototype.checkImageDel = function (range) {
        if (range.startContainer.nodeName === '#text' && range.startOffset === range.startContainer.textContent.length &&
            !sf.base.isNullOrUndefined(range.startContainer.nextSibling) && range.startContainer.nextSibling.nodeName === 'IMG') {
            this.deletedImg.push(range.startContainer.nextSibling);
        }
        else if (range.startContainer.nodeName !== '#text' && !sf.base.isNullOrUndefined(range.startContainer.childNodes[range.startOffset]) &&
            range.startContainer.childNodes[range.startOffset].nodeName === 'IMG') {
            this.deletedImg.push(range.startContainer.childNodes[range.startOffset]);
        }
    };
    Image.prototype.getDropRange = function (x, y) {
        var startRange = this.parent.getDocument().createRange();
        this.parent.formatter.editorManager.nodeSelection.setRange(this.parent.getDocument(), startRange);
        var elem = this.parent.getDocument().elementFromPoint(x, y);
        var startNode = (elem.childNodes.length > 0 ? elem.childNodes[0] : elem);
        var startCharIndexCharacter = 0;
        if (this.parent.inputElement.firstChild.innerHTML === '<br>') {
            startRange.setStart(startNode, startCharIndexCharacter);
            startRange.setEnd(startNode, startCharIndexCharacter);
        }
        else {
            var rangeRect = void 0;
            do {
                startCharIndexCharacter++;
                startRange.setStart(startNode, startCharIndexCharacter);
                startRange.setEnd(startNode, startCharIndexCharacter + 1);
                rangeRect = startRange.getBoundingClientRect();
            } while (rangeRect.left < x && startCharIndexCharacter < startNode.length - 1);
        }
        return startRange;
    };
    Image.prototype.selectRange = function (e) {
        var range;
        if (this.parent.getDocument().caretRangeFromPoint) { //For chrome
            range = this.parent.getDocument().caretRangeFromPoint(e.clientX, e.clientY);
        }
        else if ((e.rangeParent)) { //For mozilla firefox
            range = this.parent.getDocument().createRange();
            range.setStart(e.rangeParent, e.rangeOffset);
        }
        else {
            range = this.getDropRange(e.clientX, e.clientY); //For internet explorer
        }
        this.parent.observer.notify(selectRange, { range: range });
    };
    Image.prototype.imageDropInitialized = function (isStream) {
        var e = this.imageDragArgs;
        if (this.parent.element.querySelector('.' + CLS_IMG_RESIZE)) {
            sf.base.detach(this.imgResizeDiv);
        }
        this.selectRange(this.imageDragArgs);
        if (this.dropFiles.length > 1) {
            return;
        }
        this.parent.observer.notify(drop, { args: e });
        var imgFiles = this.dropFiles;
        var fileName = imgFiles[0].name;
        var imgType = fileName.substring(fileName.lastIndexOf('.'));
        var allowedTypes = this.parent.insertImageSettings.allowedTypes;
        for (var i = 0; i < allowedTypes.length; i++) {
            if (imgType.toLocaleLowerCase() === allowedTypes[i].toLowerCase()) {
                if (this.parent.insertImageSettings.saveUrl || isStream) {
                    this.onSelect(this.dropFiles);
                }
                else {
                    var args = { text: '', file: imgFiles[0] };
                    this.imagePaste(args);
                }
            }
        }
    };
    Image.prototype.insertDragImage = function (e, dropFiles) {
        var _this = this;
        e.preventDefault();
        var activePopupElement = this.parent.element.querySelector('' + CLS_POPUP_OPEN);
        this.parent.observer.notify(drop, { args: e });
        if (activePopupElement) {
            activePopupElement.classList.add(CLS_HIDE);
        }
        if (dropFiles.length <= 0) { //For internal image drag and drop
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            var imgElement = this.parent.inputElement.ownerDocument.querySelector('.' + CLS_RTE_DRAG_IMAGE);
            if (imgElement && imgElement.tagName === 'IMG') {
                if (imgElement.nextElementSibling) {
                    if (imgElement.nextElementSibling.classList.contains(CLS_IMG_INNER)) {
                        range.insertNode(imgElement.parentElement.parentElement);
                    }
                    else {
                        range.insertNode(imgElement);
                    }
                }
                else {
                    range.insertNode(imgElement);
                }
                imgElement.classList.remove(CLS_RTE_DRAG_IMAGE);
                imgElement.addEventListener('load', function () {
                    if (_this.parent.actionCompleteEnabled) {
                        _this.parent.dotNetRef.invokeMethodAsync(actionCompleteEvent, null);
                    }
                });
                this.parent.formatter.editorManager.nodeSelection.Clear(this.parent.getDocument());
                var args = e;
                this.resizeStart(args, imgElement);
                this.hideImageQuickToolbar();
            }
        }
    };
    Image.prototype.onSelect = function (dropFiles) {
        var _this = this;
        var proxy = this;
        var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
        var validFiles = {
            name: '',
            size: 0,
            status: '',
            statusCode: '',
            type: '',
            rawFile: dropFiles[0],
            validationMessages: {}
        };
        this.droppedImage = sf.base.createElement('IMG');
        this.droppedImage.style.opacity = '0.5';
        this.droppedImage.classList.add(CLS_RTE_IMAGE);
        this.droppedImage.classList.add(CLS_IMGINLINE);
        this.droppedImage.classList.add(CLS_RESIZE);
        var file = validFiles.rawFile;
        var reader = new FileReader();
        reader.addEventListener('load', function () {
            var url = URL.createObjectURL(convertToBlob(reader.result));
            _this.droppedImage.src = proxy.parent.insertImageSettings.saveFormat === 'Blob' ? url : reader.result;
        });
        if (file) {
            reader.readAsDataURL(file);
        }
        range.insertNode(this.droppedImage);
        range.selectNodeContents(this.droppedImage);
        this.parent.formatter.editorManager.nodeSelection.setRange(this.parent.getDocument(), range);
        this.droppedImage.addEventListener('load', function () {
            if (_this.parent.actionCompleteEnabled) {
                _this.parent.dotNetRef.invokeMethodAsync(actionCompleteEvent, null);
            }
        });
    };
    Image.prototype.removeDroppedImage = function () {
        sf.base.detach(this.droppedImage);
    };
    Image.prototype.dropUploadSuccess = function (url, altText) {
        this.droppedImage.style.opacity = '1';
        this.droppedImage.classList.add(CLS_IMG_FOCUS);
        this.droppedImage.src = url;
        this.droppedImage.alt = altText;
        this.showImageQuickToolbar({
            args: this.imageDragArgs, type: 'Images', isNotify: undefined, elements: this.droppedImage
        });
        this.resizeStart(this.imageDragArgs, this.droppedImage);
    };
    Image.prototype.dropUploadChange = function (url, isStream) {
        if (isStream) {
            this.droppedImage.src = url;
            this.droppedImage.style.opacity = '1';
        }
    };
    Image.prototype.imagePaste = function (args) {
        var _this = this;
        if (args.text.length === 0 && !sf.base.isNullOrUndefined(args.file)) {
            var proxy_1 = this;
            var reader_1 = new FileReader();
            if (args.args) {
                args.args.preventDefault();
            }
            reader_1.addEventListener('load', function (e) {
                var url = {
                    cssClass: (proxy_1.parent.insertImageSettings.display === 'inline' ? CLS_IMGINLINE : CLS_IMGBREAK),
                    url: _this.parent.insertImageSettings.saveFormat === 'Base64' || !sf.base.isNullOrUndefined(args.callBack) ?
                        reader_1.result : URL.createObjectURL(convertToBlob(reader_1.result)),
                    width: {
                        width: proxy_1.parent.insertImageSettings.width, minWidth: proxy_1.parent.insertImageSettings.minWidth,
                        maxWidth: proxy_1.getMaxWidth()
                    },
                    height: {
                        height: proxy_1.parent.insertImageSettings.height, minHeight: proxy_1.parent.insertImageSettings.minHeight,
                        maxHeight: proxy_1.parent.insertImageSettings.maxHeight
                    }
                };
                if (!sf.base.isNullOrUndefined(args.callBack)) {
                    args.callBack(url);
                    return;
                }
                else {
                    proxy_1.parent.formatter.process(proxy_1.parent, { item: { command: 'Images', subCommand: 'Image' } }, args.args, url);
                    _this.showPopupToolBar(args, url);
                }
            });
            reader_1.readAsDataURL(args.file);
        }
    };
    Image.prototype.showPopupToolBar = function (e, url) {
        var _this = this;
        var imageSrc = 'img[src="' + url.url + '"]';
        var imageElement = this.parent.inputElement.querySelector(imageSrc);
        var args = {
            args: e.args,
            type: 'Images',
            isNotify: undefined,
            elements: imageElement
        };
        if (imageElement) {
            setTimeout(function () { _this.showImageQuickToolbar(args); _this.resizeStart(e.args, imageElement); }, 0);
        }
    };
    Image.prototype.undoStack = function (args) {
        if (args.subCommand.toLowerCase() === 'undo' || args.subCommand.toLowerCase() === 'redo') {
            for (var i = 0; i < this.parent.formatter.getUndoRedoStack().length; i++) {
                var temp = sf.base.createElement('div');
                var contentElem = parseHtml(this.parent.formatter.getUndoRedoStack()[i].text);
                temp.appendChild(contentElem);
                var img = temp.querySelectorAll('img');
                if (temp.querySelector('.' + CLS_IMG_RESIZE) && img.length > 0) {
                    for (var j = 0; j < img.length; j++) {
                        img[j].style.outline = '';
                    }
                    sf.base.detach(temp.querySelector('.' + CLS_IMG_RESIZE));
                    this.parent.formatter.getUndoRedoStack()[i].text = temp.innerHTML;
                }
            }
        }
    };
    //#region Resize methods
    Image.prototype.imageResize = function (e) {
        this.resizeBtnInit();
        this.imgEle = e;
        sf.base.addClass([this.imgEle], 'e-resize');
        this.imgResizeDiv = sf.base.createElement('span', { className: CLS_IMG_RESIZE, id: this.rteId + imgResizeId });
        this.imgResizeDiv.appendChild(sf.base.createElement('span', {
            className: CLS_RTE_IMG_BOX_MARK + ' e-rte-topLeft', styles: 'cursor: nwse-resize'
        }));
        this.imgResizeDiv.appendChild(sf.base.createElement('span', {
            className: CLS_RTE_IMG_BOX_MARK + ' e-rte-topRight', styles: 'cursor: nesw-resize'
        }));
        this.imgResizeDiv.appendChild(sf.base.createElement('span', {
            className: CLS_RTE_IMG_BOX_MARK + ' e-rte-botLeft', styles: 'cursor: nesw-resize'
        }));
        this.imgResizeDiv.appendChild(sf.base.createElement('span', {
            className: CLS_RTE_IMG_BOX_MARK + ' e-rte-botRight', styles: 'cursor: nwse-resize'
        }));
        if (sf.base.Browser.isDevice) {
            sf.base.addClass([this.imgResizeDiv], 'e-mob-rte');
        }
        e.style.outline = '2px solid #4a90e2';
        this.imgResizePos(e, this.imgResizeDiv);
        this.resizeImgDupPos(e);
        this.parent.getEditPanel().appendChild(this.imgResizeDiv);
        sf.base.EventHandler.add(this.parent.getDocument(), sf.base.Browser.touchMoveEvent, this.resizing, this);
    };
    Image.prototype.resizeBtnInit = function () {
        return this.resizeBtnStat = { botLeft: false, botRight: false, topRight: false, topLeft: false };
    };
    Image.prototype.imgResizePos = function (e, imgResizeDiv) {
        var pos = this.calcPos(e);
        var top = pos.top;
        var left = pos.left;
        var imgWid = e.width;
        var imgHgt = e.height;
        var borWid = (sf.base.Browser.isDevice) ? (4 * parseInt((e.style.outline.slice(-3)), 10)) + 2 :
            (2 * parseInt((e.style.outline.slice(-3)), 10)) + 2; //span border width + image outline width
        var devWid = ((sf.base.Browser.isDevice) ? 0 : 2); // span border width
        imgResizeDiv.querySelector('.e-rte-botLeft').style.left = (left - borWid) + 'px';
        imgResizeDiv.querySelector('.e-rte-botLeft').style.top = ((imgHgt - borWid) + top) + 'px';
        imgResizeDiv.querySelector('.e-rte-botRight').style.left = ((imgWid - (borWid - devWid)) + left) + 'px';
        imgResizeDiv.querySelector('.e-rte-botRight').style.top = ((imgHgt - borWid) + top) + 'px';
        imgResizeDiv.querySelector('.e-rte-topRight').style.left = ((imgWid - (borWid - devWid)) + left) + 'px';
        imgResizeDiv.querySelector('.e-rte-topRight').style.top = (top - (borWid)) + 'px';
        imgResizeDiv.querySelector('.e-rte-topLeft').style.left = (left - borWid) + 'px';
        imgResizeDiv.querySelector('.e-rte-topLeft').style.top = (top - borWid) + 'px';
    };
    Image.prototype.resizeImgDupPos = function (e) {
        this.imgDupPos = {
            width: (e.style.height !== '') ? this.imgEle.style.width : e.width + 'px',
            height: (e.style.height !== '') ? this.imgEle.style.height : e.height + 'px'
        };
    };
    Image.prototype.calcPos = function (elem) {
        var ignoreOffset = ['TD', 'TH', 'TABLE', 'A'];
        var parentOffset = { top: 0, left: 0 };
        var doc = elem.ownerDocument;
        var offsetParent = ((elem.offsetParent && (elem.offsetParent.classList.contains('e-img-caption') ||
            ignoreOffset.indexOf(elem.offsetParent.tagName) > -1)) ?
            sf.base.closest(elem, '#' + this.rteId + '_rte-edit-view') : elem.offsetParent) || doc.documentElement;
        while (offsetParent &&
            (offsetParent === doc.body || offsetParent === doc.documentElement) &&
            offsetParent.style.position === 'static') {
            offsetParent = offsetParent.parentNode;
        }
        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = offsetParent.getBoundingClientRect();
        }
        return {
            top: elem.offsetTop,
            left: elem.offsetLeft
        };
    };
    Image.prototype.getPointX = function (e) {
        if (e.touches && e.touches.length) {
            return e.touches[0].pageX;
        }
        else {
            return e.pageX;
        }
    };
    Image.prototype.getPointY = function (e) {
        if (e.touches && e.touches.length) {
            return e.touches[0].pageY;
        }
        else {
            return e.pageY;
        }
    };
    Image.prototype.pixToPercent = function (expected, parentEle) {
        return expected / parseFloat(getComputedStyle(parentEle).width) * 100;
    };
    Image.prototype.imgDupMouseMove = function (width, height, e) {
        if ((parseInt(this.parent.insertImageSettings.minWidth, 10) >= parseInt(width, 10) ||
            parseInt(this.getMaxWidth(), 10) <= parseInt(width, 10))) {
            return;
        }
        if (!this.parent.insertImageSettings.resizeByPercent &&
            (parseInt(this.parent.insertImageSettings.minHeight, 10) >= parseInt(height, 10) ||
                parseInt(this.parent.insertImageSettings.maxHeight, 10) <= parseInt(height, 10))) {
            return;
        }
        this.imgEle.parentElement.style.cursor = 'pointer';
        this.setAspectRatio(this.imgEle, parseInt(width, 10), parseInt(height, 10));
        this.resizeImgDupPos(this.imgEle);
        this.imgResizePos(this.imgEle, this.imgResizeDiv);
        this.parent.setContentHeight('', false);
    };
    Image.prototype.setAspectRatio = function (img, expectedX, expectedY) {
        if (sf.base.isNullOrUndefined(img.width)) {
            return;
        }
        var width = img.style.width !== '' ? parseInt(img.style.width, 10) : img.width;
        var height = img.style.height !== '' ? parseInt(img.style.height, 10) : img.height;
        if (width > height) {
            if (this.parent.insertImageSettings.resizeByPercent) {
                img.style.width = this.pixToPercent((width / height * expectedY), (img.previousElementSibling || img.parentElement)) + '%';
                img.style.height = null;
                img.removeAttribute('height');
            }
            else if (img.style.width === '' && img.style.height !== '') {
                img.style.height = expectedY + 'px';
            }
            else if (img.style.width !== '' && img.style.height === '') {
                img.style.width = ((width / height * expectedY) + width / height).toString() + 'px';
            }
            else if (img.style.width !== '') {
                img.style.width = (width / height * expectedY) + 'px';
                img.style.height = expectedY + 'px';
            }
            else {
                img.setAttribute('width', ((width / height * expectedY) + width / height).toString());
            }
        }
        else if (height > width) {
            if (this.parent.insertImageSettings.resizeByPercent) {
                img.style.width = this.pixToPercent(expectedX, (img.previousElementSibling || img.parentElement)) + '%';
                img.style.height = null;
                img.removeAttribute('height');
            }
            else if (img.style.width !== '') {
                img.style.width = expectedX + 'px';
                img.style.height = (height / width * expectedX) + 'px';
            }
            else {
                img.setAttribute('width', expectedX.toString());
                img.setAttribute('height', (height / width * expectedX).toString());
            }
        }
        else {
            if (this.parent.insertImageSettings.resizeByPercent) {
                img.style.width = this.pixToPercent(expectedX, (img.previousElementSibling || img.parentElement)) + '%';
                img.style.height = null;
                img.removeAttribute('height');
            }
            else if (img.style.width !== '') {
                img.style.width = expectedX + 'px';
                img.style.height = expectedX + 'px';
            }
            else {
                img.setAttribute('width', expectedX.toString());
                img.setAttribute('height', expectedX.toString());
            }
        }
    };
    Image.prototype.getMaxWidth = function () {
        var maxWidth = this.parent.insertImageSettings.maxWidth;
        var imgPadding = 12;
        var imgResizeBorder = 2;
        var editEle = this.parent.getEditPanel();
        var eleStyle = window.getComputedStyle(editEle);
        var editEleMaxWidth = editEle.offsetWidth - (imgPadding + imgResizeBorder +
            parseFloat(eleStyle.paddingLeft.split('px')[0]) + parseFloat(eleStyle.paddingRight.split('px')[0]) +
            parseFloat(eleStyle.marginLeft.split('px')[0]) + parseFloat(eleStyle.marginRight.split('px')[0]));
        return sf.base.isNullOrUndefined(maxWidth) ? editEleMaxWidth : maxWidth;
    };
    Image.prototype.cancelResizeAction = function () {
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchMoveEvent, this.resizing);
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchEndEvent, this.resizeEnd);
        if (this.imgEle && this.imgResizeDiv && this.parent.getEditPanel().contains(this.imgResizeDiv)) {
            sf.base.detach(this.imgResizeDiv);
            this.imgEle.style.outline = '';
            this.imgResizeDiv = null;
            this.pageX = null;
            this.pageY = null;
        }
    };
    Image.prototype.removeResizeEle = function () {
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchMoveEvent, this.resizing);
        sf.base.EventHandler.remove(this.parent.getDocument(), sf.base.Browser.touchEndEvent, this.resizeEnd);
        sf.base.detach(this.parent.getEditPanel().querySelector('.e-img-resize'));
    };
    Image.prototype.onWindowResize = function () {
        if (!sf.base.isNullOrUndefined(this.parent) && !sf.base.isNullOrUndefined(this.parent.getEditPanel().querySelector('.e-img-resize'))) {
            this.cancelResizeAction();
        }
    };
    //#endregion
    //#region Quick toolbar related methods
    Image.prototype.editAreaClickHandler = function (e) {
        if (this.parent.readonly) {
            this.hideImageQuickToolbar();
            return;
        }
        var args = e.args;
        var showOnRightClick = this.parent.quickToolbarSettings.showOnRightClick;
        if (args.which === 2 || (showOnRightClick && args.which === 1) || (!showOnRightClick && args.which === 3)) {
            if ((showOnRightClick && args.which === 1) && !sf.base.isNullOrUndefined(args.target) &&
                args.target.tagName === 'IMG') {
                this.parent.formatter.editorManager.nodeSelection.Clear(this.parent.getDocument());
                this.parent.formatter.editorManager.nodeSelection.setSelectionContents(this.parent.getDocument(), args.target);
            }
            return;
        }
        if (this.parent.editorMode === 'HTML' && this.parent.quickToolbarModule) {
            this.quickToolObj = this.parent.quickToolbarModule;
            var target = args.target;
            var isPopupOpen = void 0;
            isPopupOpen = document.body.querySelector('#' + this.rteId + imageQuickPopup).classList.contains('e-rte-pop');
            if (target.nodeName === 'IMG' && this.parent.quickToolbarModule) {
                if (isPopupOpen) {
                    return;
                }
                this.parent.formatter.editorManager.nodeSelection.Clear(this.parent.getDocument());
                this.parent.formatter.editorManager.nodeSelection.setSelectionContents(this.parent.getDocument(), target);
                if (isIDevice()) {
                    this.parent.observer.notify(selectionSave, e);
                }
                sf.base.addClass([target], 'e-img-focus');
                this.showImageQuickToolbar({ args: args, type: 'Images', elements: [args.target] });
            }
            else {
                this.hideImageQuickToolbar();
            }
        }
    };
    Image.prototype.showImageQuickToolbar = function (e) {
        var _this = this;
        var type = 'ImageLink';
        if (e.type !== 'Images' || sf.base.isNullOrUndefined(this.parent.quickToolbarModule)) {
            return;
        }
        this.quickToolObj = this.parent.quickToolbarModule;
        var args = e.args;
        var target = e.elements;
        var parentRect = this.parent.element.getBoundingClientRect();
        var tbElement = this.parent.getToolbarElement();
        var tbHeight = (tbElement) ? (tbElement.offsetHeight + this.parent.toolbarModule.getExpandTBarPopHeight()) : 0;
        [].forEach.call(e.elements, function (element, index) {
            if (index === 0) {
                target = element;
            }
        });
        if (target && !sf.base.closest(target, 'a')) {
            type = 'Image';
        }
        if (target.nodeName === 'IMG') {
            sf.base.addClass([target], ['e-img-focus']);
        }
        var pageX = this.parent.iframeSettings.enable ? window.pageXOffset + parentRect.left + args.clientX : args.pageX;
        var pageY = this.parent.iframeSettings.enable ? window.pageYOffset + parentRect.top +
            tbHeight + args.clientY : args.pageY;
        if (this.quickToolObj) {
            if (e.isNotify) {
                setTimeout(function () { _this.quickToolObj.showImageQTBar(pageX, pageY, target, type); }, 400);
            }
            else {
                this.quickToolObj.showImageQTBar(pageX, pageY, target, type);
            }
        }
    };
    Image.prototype.hideImageQuickToolbar = function () {
        if (!sf.base.isNullOrUndefined(this.parent.getEditPanel().querySelector('.e-img-focus'))) {
            sf.base.removeClass([this.parent.getEditPanel().querySelector('.e-img-focus')], 'e-img-focus');
            if (this.quickToolObj) {
                this.quickToolObj.hideImageQTBar();
            }
        }
    };
    Image.prototype.onToolbarAction = function (args) {
        if (this.quickToolObj) {
            this.quickToolObj.hideImageQTBar();
            sf.base.removeClass([args.selectNode[0]], 'e-img-focus');
        }
        this.selectionObj = args;
        if (isIDevice()) {
            this.parent.observer.notify(selectionRestore, {});
        }
        var item = args.args.item;
        switch (item.subCommand) {
            case 'Replace':
                this.parent.observer.notify(insertImage, args);
                break;
            case 'Caption':
                this.parent.observer.notify(imageCaption, args);
                break;
            case 'InsertLink':
                this.parent.observer.notify(imageLink, args);
                break;
            case 'AltText':
                this.parent.observer.notify(imageAlt, args);
                break;
            case 'Remove':
                this.parent.observer.notify(imageDelete, args);
                break;
            case 'Dimension':
                this.parent.observer.notify(imageSize, args);
                break;
            case 'OpenImageLink':
                this.openImgLink(args);
                break;
            case 'EditImageLink':
                this.editImgLink(args);
                break;
            case 'RemoveImageLink':
                this.removeImgLink(args);
                break;
        }
    };
    Image.prototype.openImgLink = function (e) {
        var target = e.selectParent[0].parentNode.target === '' ? '_self' : '_blank';
        this.parent.formatter.process(this.parent, e.args, e.args, {
            url: e.selectParent[0].parentNode.href, target: target, selectNode: e.selectNode,
            subCommand: e.args.item.subCommand
        });
    };
    Image.prototype.editImgLink = function (e) {
        var selectParentEle = e.selectParent[0].parentNode;
        var inputDetails = {
            url: selectParentEle.href, target: selectParentEle.target
        };
        this.insertImgLink(e, inputDetails);
    };
    Image.prototype.removeImgLink = function (e) {
        if (sf.base.Browser.isIE) {
            this.parent.getEditPanel().focus();
        }
        e.selection.restore();
        var isCapLink = (this.parent.getEditPanel().contains(this.captionEle) && sf.base.select('a', this.captionEle)) ?
            true : false;
        var selectParent = isCapLink ? [this.captionEle] : [e.selectNode[0].parentElement];
        this.parent.formatter.process(this.parent, e.args, e.args, {
            insertElement: e.selectNode[0], selectParent: selectParent, selection: e.selection,
            subCommand: e.args.item.subCommand
        });
        if (this.quickToolObj) {
            this.quickToolObj.hideImageQTBar();
            if (!sf.base.isNullOrUndefined(e.selectParent)) {
                sf.base.removeClass([e.selectParent[0]], 'e-img-focus');
            }
        }
        if (isCapLink) {
            sf.base.select('.e-img-inner', this.captionEle).focus();
        }
    };
    Image.prototype.caption = function (e) {
        var selectNode = e.selectNode[0];
        if (selectNode.nodeName !== 'IMG') {
            return;
        }
        e.selection.restore();
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        this.cancelResizeAction();
        sf.base.addClass([selectNode], 'e-rte-image');
        var subCommand = (e.args.item) ?
            e.args.item.subCommand : 'Caption';
        if (!sf.base.isNullOrUndefined(sf.base.closest(selectNode, '.' + CLS_CAPTION))) {
            sf.base.detach(sf.base.closest(selectNode, '.' + CLS_CAPTION));
            if (sf.base.Browser.isIE) {
                this.parent.getEditPanel().focus();
                e.selection.restore();
            }
            if (selectNode.parentElement.tagName === 'A') {
                this.parent.formatter.process(this.parent, e.args, e.args, { insertElement: selectNode.parentElement, selectNode: e.selectNode, subCommand: subCommand });
            }
            else {
                this.parent.formatter.process(this.parent, e.args, e.args, { insertElement: selectNode, selectNode: e.selectNode, subCommand: subCommand });
            }
        }
        else {
            this.captionEle = sf.base.createElement('span', {
                className: CLS_CAPTION + ' ' + CLS_RTE_CAPTION,
                attrs: { contenteditable: 'false', draggable: 'false' }
            });
            var imgContain = sf.base.createElement('span', { className: 'e-img-wrap' });
            var imgInner = sf.base.createElement('span', { className: 'e-img-inner', attrs: { contenteditable: 'true' } });
            var parent_1 = e.selectNode[0].parentElement;
            if (parent_1.tagName === 'A') {
                parent_1.setAttribute('contenteditable', 'true');
            }
            imgContain.appendChild(parent_1.tagName === 'A' ? parent_1 : e.selectNode[0]);
            imgContain.appendChild(imgInner);
            /* eslint-disable */
            var imgCaption = this.parent.localeData['imageCaption'];
            /* eslint-enable */
            imgInner.innerHTML = imgCaption;
            this.captionEle.appendChild(imgContain);
            if (selectNode.classList.contains(CLS_IMGINLINE)) {
                sf.base.addClass([this.captionEle], CLS_CAPINLINE);
            }
            if (selectNode.classList.contains(CLS_IMGBREAK)) {
                sf.base.addClass([this.captionEle], CLS_IMGBREAK);
            }
            if (selectNode.classList.contains(CLS_IMGLEFT)) {
                sf.base.addClass([this.captionEle], CLS_IMGLEFT);
            }
            if (selectNode.classList.contains(CLS_IMGRIGHT)) {
                sf.base.addClass([this.captionEle], CLS_IMGRIGHT);
            }
            if (selectNode.classList.contains(CLS_IMGCENTER)) {
                sf.base.addClass([this.captionEle], CLS_IMGCENTER);
            }
            this.parent.formatter.process(this.parent, e.args, e.args, { insertElement: this.captionEle, selectNode: e.selectNode, subCommand: subCommand });
            this.parent.formatter.editorManager.nodeSelection.setSelectionText(this.parent.getDocument(), imgInner.childNodes[0], imgInner.childNodes[0], 0, imgInner.childNodes[0].textContent.length);
        }
        if (this.quickToolObj) {
            this.quickToolObj.hideImageQTBar();
            sf.base.removeClass([selectNode], 'e-img-focus');
        }
    };
    Image.prototype.insertImgLink = function (e, inputDetails) {
        if (e.selectNode[0].nodeName !== 'IMG') {
            return;
        }
        var obj;
        if (!sf.base.isNullOrUndefined(inputDetails)) {
            obj = { mode: 'EditLink', newWindow: inputDetails.target ? true : false, url: inputDetails.url };
        }
        else {
            obj = { mode: 'InsertLink', newWindow: true, url: '' };
        }
        this.parent.dotNetRef.invokeMethodAsync(showImageDialog, obj);
    };
    Image.prototype.isUrl = function (url) {
        var regexp = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/gi;
        return regexp.test(url);
    };
    Image.prototype.insertLink = function (url, target) {
        if (this.selectionObj.selectNode[0].nodeName !== 'IMG') {
            return;
        }
        var linkEle = document.querySelector('.e-rte-img-dialog .e-img-link');
        if (url === '') {
            sf.base.addClass([linkEle], 'e-error');
            linkEle.setSelectionRange(0, url.length);
            linkEle.focus();
            return;
        }
        if (!this.isUrl(url)) {
            url = 'http://' + url;
        }
        else {
            sf.base.removeClass([linkEle], 'e-error');
        }
        if (this.parent.editorMode === 'HTML') {
            this.selectionObj.selection.restore();
        }
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        if (this.selectionObj.selectNode[0].parentElement.nodeName === 'A') {
            this.parent.formatter.process(this.parent, this.selectionObj.args, this.selectionObj.args, {
                url: url, target: target, selectNode: this.selectionObj.selectNode,
                subCommand: this.selectionObj.args.item.subCommand
            });
            this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
            return;
        }
        this.parent.formatter.process(this.parent, this.selectionObj.args, this.selectionObj.args, {
            url: url, target: target, selectNode: this.selectionObj.selectNode,
            subCommand: this.selectionObj.args.item.subCommand,
            selection: this.selectionObj.selection
        });
        var captionEle = sf.base.closest(this.selectionObj.selectNode[0], '.e-img-caption');
        if (captionEle) {
            sf.base.select('.e-img-inner', captionEle).focus();
        }
        this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
    };
    Image.prototype.insertAltText = function (e) {
        if (e.selectNode[0].nodeName !== 'IMG') {
            return;
        }
        var selectNodeAltValue = e.selectNode[0].getAttribute('alt');
        var obj = { mode: 'AltText', altText: ((selectNodeAltValue === null) ? '' : selectNodeAltValue) };
        this.parent.dotNetRef.invokeMethodAsync(showImageDialog, obj);
    };
    Image.prototype.insertAlt = function (altText) {
        this.selectionObj.selection.restore();
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        this.parent.formatter.process(this.parent, this.selectionObj.args, this.selectionObj.args, {
            altText: altText, selectNode: this.selectionObj.selectNode,
            subCommand: this.selectionObj.args.item.subCommand
        });
        this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
    };
    Image.prototype.deleteImg = function (e, keyCode) {
        if (e.selectNode[0].nodeName !== 'IMG') {
            return;
        }
        var args = {
            src: e.selectNode[0].getAttribute('src')
        };
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        e.selection.restore();
        if (this.parent.getEditPanel().querySelector('.e-img-resize')) {
            this.removeResizeEle();
        }
        this.parent.formatter.process(this.parent, e.args, e.args, {
            selectNode: e.selectNode,
            captionClass: CLS_CAPTION,
            subCommand: e.args.item.subCommand
        });
        if (this.quickToolObj) {
            this.quickToolObj.hideImageQTBar();
        }
        this.cancelResizeAction();
        if (sf.base.isNullOrUndefined(keyCode) && this.parent.imageDeleteEnabled) {
            this.parent.dotNetRef.invokeMethodAsync('AfterImageDeleteEvent', args);
        }
    };
    Image.prototype.imageSize = function (e) {
        if (e.selectNode[0].nodeName !== 'IMG') {
            return;
        }
        var selectNode = e.selectNode[0];
        var width = (selectNode.style.width.toString() === 'auto' ||
            selectNode.style.width.toString()) ? selectNode.style.width.toString() : (parseInt(selectNode.getClientRects()[0].width.toString())).toString();
        var height = (selectNode.style.height.toString() === 'auto' ||
            selectNode.style.height.toString()) ? selectNode.style.height.toString() : (parseInt(selectNode.getClientRects()[0].height.toString()).toString());
        var obj = {
            mode: 'Dimension', width: width, height: height, maxWidth: this.getMaxWidth()
        };
        this.parent.dotNetRef.invokeMethodAsync(showImageDialog, obj);
    };
    Image.prototype.insertSize = function (width, height) {
        this.selectionObj.selection.restore();
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        this.parent.formatter.process(this.parent, this.selectionObj.args, this.selectionObj.args, {
            width: width, height: height, selectNode: this.selectionObj.selectNode,
            subCommand: this.selectionObj.args.item.subCommand
        });
        if (this.imgResizeDiv) {
            this.imgResizePos(this.selectionObj.selectNode[0], this.imgResizeDiv);
        }
        this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
    };
    Image.prototype.alignmentSelect = function (e) {
        var item = e.item;
        if (!document.body.contains(document.body.querySelector('.e-rte-quick-toolbar')) || item.command !== 'Images') {
            return;
        }
        var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
        var selectNodeEle = this.parent.formatter.editorManager.nodeSelection.getNodeCollection(range);
        selectNodeEle = (selectNodeEle[0].nodeName === 'IMG') ? selectNodeEle : [this.imgEle];
        var args = { args: e, selectNode: selectNodeEle };
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        switch (item.subCommand) {
            case 'JustifyLeft':
                this.alignImage(args, 'JustifyLeft');
                break;
            case 'JustifyCenter':
                this.alignImage(args, 'JustifyCenter');
                break;
            case 'JustifyRight':
                this.alignImage(args, 'JustifyRight');
                break;
            case 'Inline':
                this.inline(args);
                break;
            case 'Break':
                this.break(args);
                break;
        }
        if (this.quickToolObj) {
            this.quickToolObj.hideImageQTBar();
            sf.base.removeClass([selectNodeEle[0]], 'e-img-focus');
        }
        this.cancelResizeAction();
    };
    Image.prototype.alignImage = function (e, type) {
        var subCommand = (e.args.item) ?
            e.args.item.subCommand : type;
        this.parent.formatter.process(this.parent, e.args, e.args, { selectNode: e.selectNode, subCommand: subCommand });
    };
    Image.prototype.inline = function (e) {
        if (e.selectNode[0].nodeName !== 'IMG') {
            return;
        }
        var subCommand = (e.args.item) ?
            e.args.item.subCommand : 'Inline';
        this.parent.formatter.process(this.parent, e.args, e.args, { selectNode: e.selectNode, subCommand: subCommand });
    };
    Image.prototype.break = function (e) {
        if (e.selectNode[0].nodeName !== 'IMG') {
            return;
        }
        var subCommand = (e.args.item) ?
            e.args.item.subCommand : 'Break';
        this.parent.formatter.process(this.parent, e.args, e.args, { selectNode: e.selectNode, subCommand: subCommand });
    };
    Image.prototype.imageBrowseClick = function () {
        document.getElementById(this.rteId + '_image').querySelector('.e-rte-img-dialog .e-file-select-wrap button').click();
    };
    //#endregion
    //#region Interop methods
    Image.prototype.dialogOpened = function () {
        var dialogContent = this.parent.element.querySelector('.e-rte-img-dialog .e-img-content');
        if (sf.base.isNullOrUndefined(dialogContent)) {
            return;
        }
        var spanElement = document.getElementById(this.rteId + '_dropText');
        var buttonElement = document.getElementById(this.rteId + '_insertImage');
        this.buttonClickElement = sf.base.Browser.isDevice ? spanElement : buttonElement;
        sf.base.EventHandler.add(this.buttonClickElement, 'click', this.imageBrowseClick, this);
        if ((!sf.base.isNullOrUndefined(this.parent.insertImageSettings.path) && this.parent.editorMode === 'Markdown')
            || this.parent.editorMode === 'HTML') {
            dialogContent.querySelector('#' + this.rteId + '_insertImage').focus();
        }
        else {
            dialogContent.querySelector('.e-img-url').focus();
        }
    };
    Image.prototype.imageSelected = function () {
        this.inputUrl.setAttribute('disabled', 'true');
    };
    Image.prototype.imageUploadSuccess = function (url, altText) {
        this.inputUrl = this.parent.element.querySelector('.e-rte-img-dialog .e-img-url');
        if (!sf.base.isNullOrUndefined(this.parent.insertImageSettings.path)) {
            this.uploadUrl = {
                url: url, selection: this.imgUploadSave, altText: altText, selectParent: this.imgUploadSelectedParent,
                width: {
                    width: this.parent.insertImageSettings.width, minWidth: this.parent.insertImageSettings.minWidth,
                    maxWidth: this.getMaxWidth()
                }, height: {
                    height: this.parent.insertImageSettings.height, minHeight: this.parent.insertImageSettings.minHeight,
                    maxHeight: this.parent.insertImageSettings.maxHeight
                }
            };
            this.inputUrl.setAttribute('disabled', 'true');
        }
    };
    Image.prototype.imageUploadComplete = function (base64Str, altText) {
        if (this.parent.editorMode === 'HTML' && sf.base.isNullOrUndefined(this.parent.insertImageSettings.path)) {
            var url = this.parent.insertImageSettings.saveFormat === 'Base64' ? base64Str :
                URL.createObjectURL(convertToBlob(base64Str));
            this.uploadUrl = {
                url: url, selection: this.imgUploadSave, altText: altText, selectParent: this.imgUploadSelectedParent,
                width: {
                    width: this.parent.insertImageSettings.width, minWidth: this.parent.insertImageSettings.minWidth,
                    maxWidth: this.getMaxWidth()
                }, height: {
                    height: this.parent.insertImageSettings.height, minHeight: this.parent.insertImageSettings.minHeight,
                    maxHeight: this.parent.insertImageSettings.maxHeight
                }
            };
            this.inputUrl.setAttribute('disabled', 'true');
        }
    };
    Image.prototype.imageUploadChange = function (url, isStream) {
        this.modifiedUrl = url;
        this.isStreamUrl = isStream;
    };
    Image.prototype.removing = function () {
        this.inputUrl.removeAttribute('disabled');
        if (this.uploadUrl) {
            this.uploadUrl.url = '';
        }
    };
    Image.prototype.dialogClosed = function () {
        if (this.parent.editorMode === 'HTML') {
            this.selectionObj.selection.restore();
        }
        else {
            this.parent.formatter.editorManager.markdownSelection.restore(this.parent.getEditPanel());
        }
        if (this.buttonClickElement) {
            sf.base.EventHandler.remove(this.buttonClickElement, 'click', this.imageBrowseClick);
        }
    };
    Image.prototype.insertImageUrl = function () {
        if (!sf.base.Browser.isDevice) {
            this.inputUrl = this.parent.element.querySelector('.e-rte-img-dialog .e-img-url');
        }
        else {
            this.inputUrl = this.parent.inputElement.ownerDocument.querySelector('#' + this.rteId + '_image').querySelector('.e-rte-img-dialog .e-img-url');
        }
        var url = this.inputUrl.value;
        if (this.isStreamUrl && this.modifiedUrl !== '') {
            this.uploadUrl.url = this.modifiedUrl;
            this.modifiedUrl = '';
        }
        if (this.parent.formatter.getUndoRedoStack().length === 0) {
            this.parent.formatter.saveData();
        }
        if (!sf.base.isNullOrUndefined(this.uploadUrl) && this.uploadUrl.url !== '') {
            this.uploadUrl.cssClass = this.parent.insertImageSettings.display === 'inline' ? CLS_IMGINLINE : CLS_IMGBREAK;
            this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
            this.parent.formatter.process(this.parent, this.selectionObj.args, this.selectionObj.args.originalEvent, this.uploadUrl);
            if (this.parent.getEditPanel().querySelector('.e-img-resize')) {
                this.imgEle.style.outline = '';
                this.removeResizeEle();
            }
        }
        else if (url !== '') {
            if (this.parent.editorMode === 'HTML' && sf.base.isNullOrUndefined(sf.base.closest(this.selectionObj.selection.range.startContainer.parentNode, '#' + this.parent.getPanel().id))) {
                this.parent.getEditPanel().focus();
                var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
                this.selectionObj.selection = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
                this.selectionObj.selectParent = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
            }
            var regex = /[\w-]+.(jpg|png|jpeg|gif)/g;
            var matchUrl = (!sf.base.isNullOrUndefined(url.match(regex)) && this.parent.editorMode === 'HTML') ? url.match(regex)[0] : '';
            var value = {
                cssClass: (this.parent.insertImageSettings.display === 'inline' ? CLS_IMGINLINE : CLS_IMGBREAK),
                url: url, selection: this.selectionObj.selection, altText: matchUrl,
                selectParent: this.selectionObj.selectParent, width: {
                    width: this.parent.insertImageSettings.width, minWidth: this.parent.insertImageSettings.minWidth,
                    maxWidth: this.getMaxWidth()
                },
                height: {
                    height: this.parent.insertImageSettings.height, minHeight: this.parent.insertImageSettings.minHeight,
                    maxHeight: this.parent.insertImageSettings.maxHeight
                }
            };
            this.parent.formatter.process(this.parent, this.selectionObj.args, this.selectionObj.args.originalEvent, value);
            this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
        }
    };
    Image.prototype.showDialog = function (isExternal, event, selection, ele, parentEle) {
        var range;
        var save;
        var selectNodeEle;
        var selectParentEle;
        if (isExternal && !sf.base.isNullOrUndefined(this.parent.formatter.editorManager.nodeSelection)) {
            range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            save = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
            selectNodeEle = this.parent.formatter.editorManager.nodeSelection.getNodeCollection(range);
            selectParentEle = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
        }
        else {
            save = selection;
            selectNodeEle = ele;
            selectParentEle = parentEle;
        }
        if (this.parent.editorMode === 'HTML') {
            this.imageDialog({
                args: {
                    item: { command: 'Images', subCommand: 'Image' },
                    originalEvent: isExternal ? undefined : event
                },
                selectNode: selectNodeEle,
                selection: save,
                selectParent: selectParentEle
            });
        }
        else {
            this.imageDialog({
                args: {
                    item: { command: 'Images', subCommand: 'Image' },
                    originalEvent: isExternal ? undefined : event
                },
                member: 'image',
                text: this.parent.formatter.editorManager.markdownSelection.getSelectedText(this.parent.getEditPanel()),
                module: 'Markdown',
                name: 'insertImage'
            });
        }
    };
    //#endregion
    //#region Event handler methods
    Image.prototype.onCutHandler = function () {
        if (this.imgResizeDiv && this.parent.getEditPanel().contains(this.imgResizeDiv)) {
            this.cancelResizeAction();
        }
    };
    Image.prototype.onIframeMouseDown = function (e) {
        this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
        this.onDocumentClick(e);
    };
    Image.prototype.onDocumentClick = function (e) {
        var target = e.target;
        if (target.nodeName === 'IMG') {
            this.imgEle = target;
        }
        var dlgEle = document.body.querySelector('#' + this.rteId + '_image.e-rte-img-dialog');
        if (!sf.base.isNullOrUndefined(dlgEle) && ((!sf.base.closest(target, '#' + this.rteId + '_image') && this.parent.toolbarSettings.enable && this.parent.getToolbarElement() &&
            !this.parent.getToolbarElement().contains(e.target)) ||
            (this.parent.getToolbarElement() && this.parent.getToolbarElement().contains(e.target) &&
                !sf.base.closest(target, '#' + this.rteId + '_toolbar_Image') &&
                !target.querySelector('#' + this.rteId + '_toolbar_Image')))) {
            if (e.offsetX > e.target.clientWidth || e.offsetY > e.target.clientHeight) {
            }
            else {
                this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, outsideClicked);
                this.parent.isBlur = true;
                if (sf.base.Browser.isIE) {
                    dispatchEvent(this.parent.element, 'focusout');
                }
            }
        }
        if (e.target.tagName !== 'IMG' && this.imgResizeDiv && !this.quickToolObj &&
            this.parent.getEditPanel().contains(this.imgResizeDiv)) {
            this.cancelResizeAction();
        }
        if (this.parent.getEditPanel().querySelector('.e-img-resize')) {
            if (target.tagName !== 'IMG') {
                this.removeResizeEle();
            }
            if (target.tagName !== 'IMG' && !sf.base.isNullOrUndefined(this.imgEle)) {
                this.imgEle.style.outline = '';
            }
            else if (!sf.base.isNullOrUndefined(this.prevSelectedImgEle) && this.prevSelectedImgEle !== target) {
                this.prevSelectedImgEle.style.outline = '';
            }
        }
    };
    Image.prototype.imageClick = function (e) {
        if (sf.base.Browser.isDevice) {
            if ((e.target.tagName === 'IMG' &&
                e.target.parentElement.tagName === 'A') ||
                (e.target.tagName === 'IMG')) {
                this.parent.getEditPanel().setAttribute('contenteditable', 'false');
                e.target.focus();
            }
            else {
                if (!this.parent.readonly) {
                    this.parent.getEditPanel().setAttribute('contenteditable', 'true');
                }
            }
        }
        if (e.target.tagName === 'IMG' &&
            e.target.parentElement.tagName === 'A') {
            e.preventDefault();
        }
    };
    Image.prototype.onKeyDown = function (event) {
        var originalEvent = event.args;
        var range;
        var save;
        var selectNodeEle;
        var selectParentEle;
        this.deletedImg = [];
        var isCursor;
        var keyCodeValues = [27, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,
            44, 45, 9, 16, 17, 18, 19, 20, 33, 34, 35, 36, 37, 38, 39, 40, 91, 92, 93, 144, 145, 182, 183];
        if (this.parent.editorMode === 'HTML') {
            range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            isCursor = range.startContainer === range.endContainer && range.startOffset === range.endOffset;
        }
        if (!isCursor && this.parent.editorMode === 'HTML' && keyCodeValues.indexOf(originalEvent.which) < 0) {
            var nodes = this.parent.formatter.editorManager.nodeSelection.getNodeCollection(range);
            for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].nodeName === 'IMG') {
                    this.deletedImg.push(nodes[i]);
                }
            }
        }
        if (this.parent.editorMode === 'HTML' && ((originalEvent.which === 8 && originalEvent.code === 'Backspace') ||
            (originalEvent.which === 46 && originalEvent.code === 'Delete'))) {
            var isCursor_1 = range.startContainer === range.endContainer && range.startOffset === range.endOffset;
            if ((originalEvent.which === 8 && originalEvent.code === 'Backspace' && isCursor_1)) {
                this.checkImageBack(range);
            }
            else if ((originalEvent.which === 46 && originalEvent.code === 'Delete' && isCursor_1)) {
                this.checkImageDel(range);
            }
        }
        if (!sf.base.isNullOrUndefined(this.parent.formatter.editorManager.nodeSelection) &&
            originalEvent.code !== 'KeyK') {
            range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            save = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
            selectNodeEle = this.parent.formatter.editorManager.nodeSelection.getNodeCollection(range);
            selectParentEle = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
            if (!originalEvent.ctrlKey && originalEvent.key && (originalEvent.key.length === 1 || originalEvent.action === 'enter') &&
                (selectParentEle[0].tagName === 'IMG') && selectParentEle[0].parentElement) {
                var prev = selectParentEle[0].parentElement.childNodes[0];
                if (this.parent.getEditPanel().querySelector('.e-img-resize')) {
                    this.removeResizeEle();
                }
                this.parent.formatter.editorManager.nodeSelection.setSelectionText(this.parent.getDocument(), prev, prev, prev.textContent.length, prev.textContent.length);
                sf.base.removeClass([selectParentEle[0]], 'e-img-focus');
                this.quickToolObj.hideImageQTBar();
            }
        }
        if (originalEvent.ctrlKey && (originalEvent.keyCode === 89 || originalEvent.keyCode === 90)) {
            this.undoStack({ subCommand: (originalEvent.keyCode === 90 ? 'undo' : 'redo') });
        }
        if (originalEvent.keyCode === 8 || originalEvent.keyCode === 46) {
            if (selectNodeEle && selectNodeEle[0].nodeName === 'IMG' && selectNodeEle.length < 1) {
                originalEvent.preventDefault();
                var event_1 = {
                    selectNode: selectNodeEle, selection: save, selectParent: selectParentEle,
                    args: {
                        item: { command: 'Images', subCommand: 'Remove' },
                        originalEvent: originalEvent
                    }
                };
                this.deleteImg(event_1, originalEvent.keyCode);
            }
            if (this.parent.getEditPanel().querySelector('.e-img-resize')) {
                this.removeResizeEle();
            }
        }
        switch (originalEvent.action) {
            case 'escape':
                this.parent.dotNetRef.invokeMethodAsync(closeImageDialog, null);
                break;
            case 'insert-image':
                this.showDialog(false, originalEvent, save, selectNodeEle, selectParentEle);
                originalEvent.preventDefault();
                break;
        }
    };
    Image.prototype.onKeyUp = function (event) {
        if (!sf.base.isNullOrUndefined(this.deletedImg) && this.deletedImg.length > 0) {
            for (var i = 0; i < this.deletedImg.length; i++) {
                var args = {
                    src: this.deletedImg[i].getAttribute('src')
                };
                if (this.parent.imageDeleteEnabled) {
                    this.parent.dotNetRef.invokeMethodAsync('AfterImageDeleteEvent', args);
                }
            }
        }
    };
    Image.prototype.resizeStart = function (e, ele) {
        var _this = this;
        if (this.parent.readonly) {
            return;
        }
        var target = ele ? ele : e.target;
        this.prevSelectedImgEle = this.imgEle;
        if (target.tagName === 'IMG') {
            this.parent.defaultResize(e, false);
            var img = target;
            if (this.imgResizeDiv && this.parent.getEditPanel().contains(this.imgResizeDiv)) {
                sf.base.detach(this.imgResizeDiv);
            }
            this.imageResize(img);
        }
        if (target.classList.contains('e-rte-imageboxmark')) {
            if (this.parent.formatter.getUndoRedoStack().length === 0) {
                this.parent.formatter.saveData();
            }
            this.pageX = this.getPointX(e);
            this.pageY = this.getPointY(e);
            e.preventDefault();
            e.stopImmediatePropagation();
            this.resizeBtnInit();
            if (this.quickToolObj) {
                this.quickToolObj.hideImageQTBar();
            }
            if (target.classList.contains('e-rte-topLeft')) {
                this.resizeBtnStat.topLeft = true;
            }
            if (target.classList.contains('e-rte-topRight')) {
                this.resizeBtnStat.topRight = true;
            }
            if (target.classList.contains('e-rte-botLeft')) {
                this.resizeBtnStat.botLeft = true;
            }
            if (target.classList.contains('e-rte-botRight')) {
                this.resizeBtnStat.botRight = true;
            }
            if (sf.base.Browser.isDevice && this.parent.getEditPanel().contains(this.imgResizeDiv) &&
                !this.imgResizeDiv.classList.contains('e-mob-span')) {
                sf.base.addClass([this.imgResizeDiv], 'e-mob-span');
            }
            else {
                var args = { requestType: 'Images' };
                if (this.parent.onResizeStartEnabled) {
                    // @ts-ignore-start
                    this.parent.dotNetRef.invokeMethodAsync('ResizeStartEvent', args).then(function (resizeStartArgs) {
                        // @ts-ignore-end
                        if (resizeStartArgs.cancel) {
                            _this.cancelResizeAction();
                        }
                    });
                }
            }
            sf.base.EventHandler.add(this.parent.getDocument(), sf.base.Browser.touchEndEvent, this.resizeEnd, this);
        }
    };
    Image.prototype.resizing = function (e) {
        if (this.imgEle.offsetWidth >= this.getMaxWidth()) {
            this.imgEle.style.maxHeight = this.imgEle.offsetHeight + 'px';
        }
        var pageX = this.getPointX(e);
        var pageY = this.getPointY(e);
        var mouseX = (this.resizeBtnStat.botLeft || this.resizeBtnStat.topLeft) ? -(pageX - this.pageX) : (pageX - this.pageX);
        var mouseY = (this.resizeBtnStat.topLeft || this.resizeBtnStat.topRight) ? -(pageY - this.pageY) : (pageY - this.pageY);
        var width = parseInt(this.imgDupPos.width, 10) + mouseX;
        var height = parseInt(this.imgDupPos.height, 10) + mouseY;
        this.pageX = pageX;
        this.pageY = pageY;
        if (this.resizeBtnStat.botRight) {
            this.imgDupMouseMove(width + 'px', height + 'px', e);
        }
        else if (this.resizeBtnStat.botLeft) {
            this.imgDupMouseMove(width + 'px', height + 'px', e);
        }
        else if (this.resizeBtnStat.topRight) {
            this.imgDupMouseMove(width + 'px', height + 'px', e);
        }
        else if (this.resizeBtnStat.topLeft) {
            this.imgDupMouseMove(width + 'px', height + 'px', e);
        }
    };
    Image.prototype.resizeEnd = function (e) {
        this.resizeBtnInit();
        this.imgEle.parentElement.style.cursor = 'auto';
        if (sf.base.Browser.isDevice) {
            sf.base.removeClass([e.target.parentElement], 'e-mob-span');
        }
        var args = { requestType: 'Images' };
        if (this.parent.onResizeStopEnabled) {
            this.parent.dotNetRef.invokeMethodAsync('ResizeStopEvent', args);
        }
        this.parent.formatter.editorManager.observer.on(checkUndo, this.undoStack, this);
        this.parent.formatter.saveData();
    };
    Image.prototype.dragStart = function (e) {
        if (e.target.nodeName === 'IMG') {
            // @ts-ignore-start
            this.parent.dotNetRef.invokeMethodAsync('ActionBeginEvent', e).then(function (actionBeginArgs) {
                // @ts-ignore-end
                if (actionBeginArgs.cancel) {
                    e.preventDefault();
                }
                else {
                    e.dataTransfer.effectAllowed = 'copyMove';
                    e.target.classList.add(CLS_RTE_DRAG_IMAGE);
                }
            });
        }
        else {
            return true;
        }
    };
    
    Image.prototype.dragOver = function (e) {
        if ((sf.base.Browser.info.name === 'edge' && e.dataTransfer.items[0].type.split('/')[0].indexOf('image') > -1) ||
            (sf.base.Browser.isIE && e.dataTransfer.types[0] === 'Files')) {
            e.preventDefault();
        }
        else {
            return true;
        }
    };
    
    Image.prototype.dragEnter = function (e) {
        e.dataTransfer.dropEffect = 'copy';
        e.preventDefault();
    };
    
    Image.prototype.dragDrop = function (e) {
        var _this = this;
        this.imageDragArgs = e;
        this.dropFiles = e.dataTransfer.files;
        var imgElement = this.parent.inputElement.ownerDocument.querySelector('.' + CLS_RTE_DRAG_IMAGE);
        if (imgElement && imgElement.tagName === 'IMG') {
            e.preventDefault();
            if (e.dataTransfer.files.length <= 0) {
                // @ts-ignore-start
                this.parent.dotNetRef.invokeMethodAsync('ActionBeginEvent', e).then(function (actionBeginArgs) {
                    // @ts-ignore-end
                    if (!actionBeginArgs.cancel) {
                        if (sf.base.closest(e.target, '#' + _this.rteId + '_toolbar') ||
                            _this.parent.inputElement.contentEditable === 'false') {
                            return;
                        }
                        if (_this.parent.element.querySelector('.' + CLS_IMG_RESIZE)) {
                            sf.base.detach(_this.imgResizeDiv);
                        }
                        _this.selectRange(e);
                        var uploadArea = _this.parent.element.querySelector('.' + CLS_DROPAREA);
                        if (uploadArea) {
                            return;
                        }
                        _this.insertDragImage(e, _this.dropFiles);
                    }
                });
            }
        }
        else {
            return true;
        }
    };
    //#endregion
    Image.prototype.destroy = function () {
        this.prevSelectedImgEle = undefined;
        this.removeEventListener();
    };
    return Image;
}());

/**
 * XhtmlValidation module called when set enableXhtml as true
 */
var XhtmlValidation = /** @class */ (function () {
    function XhtmlValidation(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    XhtmlValidation.prototype.addEventListener = function () {
        this.parent.observer.on(xhtmlValidation, this.enableXhtmlValidation, this);
        this.parent.observer.on(destroy, this.removeEventListener, this);
    };
    XhtmlValidation.prototype.removeEventListener = function () {
        this.parent.observer.off(xhtmlValidation, this.enableXhtmlValidation);
        this.parent.observer.off(destroy, this.removeEventListener);
    };
    XhtmlValidation.prototype.enableXhtmlValidation = function () {
        if (this.parent.enableXhtml) {
            if (sf.base.isNullOrUndefined(this.parent.inputElement)) {
                this.currentElement = this.parent.element;
            }
            else {
                this.currentElement = this.parent.inputElement;
            }
            this.clean(this.currentElement);
            this.AddRootElement();
            this.ImageTags();
            this.removeTags();
            this.RemoveUnsupported();
            this.currentElement.innerHTML = this.selfEncloseValidation(this.currentElement.innerHTML);
        }
    };
    XhtmlValidation.prototype.selfEncloseValidation = function (currentValue) {
        currentValue = currentValue.replace(/<br>/g, '<br/>').replace(/<hr>/g, '<hr/>').replace(/&nbsp;/gi, ' ').replace(/ /g, ' ');
        var valueTemp;
        var valueDupe = [];
        var valueOriginal = [];
        var imgRegexp = [/<img(.*?)>/gi, /<area(.*?)>/gi, /<base(.*?)>/gi, /<col (.*?)>/gi, /<embed(.*?)>/gi,
            /<input(.*?)>/gi, /<link(.*?)>/gi, /<meta(.*?)>/gi, /<param(.*?)>/gi, /<source(.*?)>/gi,
            /<track(.*?)>/gi, /<wbr(.*?)>/gi];
        for (var j = 0; j < imgRegexp.length; j++) {
            valueTemp = imgRegexp[j].exec(currentValue);
            while ((valueTemp) !== null) {
                valueDupe.push(valueTemp[0].toString());
                valueTemp = imgRegexp[j].exec(currentValue);
            }
            valueOriginal = valueDupe.slice(0);
            for (var i = 0; i < valueDupe.length; i++) {
                if (valueDupe[i].indexOf('/') === -1 || valueDupe[i].lastIndexOf('/') !== valueDupe[i].length - 2) {
                    valueDupe[i] = valueDupe[i].substr(0, valueDupe[i].length - 1) + ' /' +
                        valueDupe[i].substr(valueDupe[i].length - 1, valueDupe[i].length);
                }
            }
            for (var g = 0; g <= valueDupe.length - 1; g++) {
                currentValue = currentValue.replace(valueOriginal[g], valueDupe[g]);
            }
        }
        return currentValue;
    };
    XhtmlValidation.prototype.AddRootElement = function () {
        if ((this.currentElement.childNodes.length === 1 && this.currentElement.firstChild.nodeName !== 'DIV') ||
            this.currentElement.childNodes.length > 1) {
            var parentEle = document.createElement('div');
            while (this.currentElement.childNodes.length > 0) {
                parentEle.appendChild(this.currentElement.childNodes[0]);
            }
            this.currentElement.appendChild(parentEle);
        }
    };
    
    XhtmlValidation.prototype.clean = function (node) {
        for (var n = 0; n < node.childNodes.length; n++) {
            var child = node.childNodes[n];
            if (child.nodeType === 8 || child.nodeName === 'V:IMAGE') {
                node.removeChild(child);
                n--;
            }
            else if (child.nodeType === 1) {
                this.clean(child);
            }
        }
        return this.currentElement.innerHTML;
    };
    XhtmlValidation.prototype.ImageTags = function () {
        var imgNodes = this.currentElement.querySelectorAll('IMG');
        for (var i = imgNodes.length - 1; i >= 0; i--) {
            if (!imgNodes[i].hasAttribute('alt')) {
                var img = imgNodes[i];
                img.setAttribute('alt', '');
            }
        }
    };
    
    XhtmlValidation.prototype.removeTags = function () {
        var removeAttribute = [['br', 'ul'], ['br', 'ol'], ['table', 'span'], ['div', 'span'], ['p', 'span']];
        for (var i = 0; i < removeAttribute.length; i++) {
            this.RemoveElementNode(removeAttribute[i][0], removeAttribute[i][1]);
        }
    };
    
    XhtmlValidation.prototype.RemoveElementNode = function (rmvNode, parentNode) {
        var parentArray = this.currentElement.querySelectorAll(parentNode);
        for (var i = 0; i < parentArray.length; i++) {
            var rmvArray = parentArray[i].querySelectorAll(rmvNode);
            for (var j = rmvArray.length; j > 0; j--) {
                sf.base.detach(rmvArray[j - 1]);
            }
        }
    };
    
    XhtmlValidation.prototype.RemoveUnsupported = function () {
        var underlineEle = this.currentElement.querySelectorAll('u');
        for (var i = underlineEle.length - 1; i >= 0; i--) {
            var spanEle = document.createElement('span');
            spanEle.style.textDecoration = 'underline';
            spanEle.innerHTML = underlineEle[i].innerHTML;
            underlineEle[i].parentNode.insertBefore(spanEle, underlineEle[i]);
            sf.base.detach(underlineEle[i]);
        }
        var strongEle = this.currentElement.querySelectorAll('strong');
        for (var i = strongEle.length - 1; i >= 0; i--) {
            var boldEle = document.createElement('b');
            boldEle.innerHTML = strongEle[i].innerHTML;
            strongEle[i].parentNode.insertBefore(boldEle, strongEle[i]);
            sf.base.detach(strongEle[i]);
        }
        var attrArray = ['language', 'role', 'target', 'contenteditable', 'cellspacing',
            'cellpadding', 'border', 'valign', 'colspan'];
        for (var i = 0; i <= attrArray.length; i++) {
            this.RemoveAttributeByName(attrArray[i]);
        }
    };
    
    XhtmlValidation.prototype.RemoveAttributeByName = function (attrName) {
        if (this.currentElement.firstChild !== null) {
            if (this.currentElement.firstChild.nodeType !== 3) {
                for (var i = 0; i < this.currentElement.childNodes.length; i++) {
                    var ele = this.currentElement.childNodes[i];
                    if (ele.nodeType !== 3 && ele.nodeName !== 'TABLE' && ele.nodeName !== 'TBODY' && ele.nodeName !== 'THEAD' &&
                        ele.nodeName !== 'TH' && ele.nodeName !== 'TR' && ele.nodeName !== 'TD') {
                        if (ele.hasAttribute(attrName)) {
                            ele.removeAttribute(attrName);
                        }
                        if (ele.hasChildNodes()) {
                            for (var j = 0; j < ele.childNodes.length; j++) {
                                var childEle = ele.childNodes[j];
                                if (childEle.nodeType !== 3 && childEle.nodeName !== 'TABLE' && childEle.nodeName !== 'TBODY' &&
                                    childEle.nodeName !== 'THEAD' && childEle.nodeName !== 'TH' && childEle.nodeName !== 'TR' &&
                                    childEle.nodeName !== 'TD' && childEle.hasAttribute(attrName)) {
                                    childEle.removeAttribute(attrName);
                                }
                                if (childEle.hasChildNodes()) {
                                    for (var k = 0; k < childEle.childNodes.length; k++) {
                                        if (childEle.childNodes[k].nodeType !== 3 && childEle.childNodes[k].nodeName !== 'TABLE' &&
                                            childEle.childNodes[k].nodeName !== 'TBODY' && childEle.childNodes[k].nodeName !== 'THEAD' &&
                                            childEle.childNodes[k].nodeName !== 'TH' && childEle.childNodes[k].nodeName !== 'TR'
                                            && childEle.childNodes[k].nodeName !== 'TD'
                                            && childEle.childNodes[k].hasAttribute(attrName)) {
                                            childEle.childNodes[k].removeAttribute(attrName);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    
    return XhtmlValidation;
}());

/**
 * Is formatted or not.
 *
 * @hidden
 * @deprecated
 */
var IsFormatted = /** @class */ (function () {
    function IsFormatted() {
    }
    /**
     * getFormattedNode method
     *
     * @param {Node} node - specifies the node.
     * @param {string} format - specifies the string value.
     * @param {Node} endNode - specifies the end node
     * @returns {Node} - returns the node
     * @hidden
     * @deprecated
     */
    IsFormatted.prototype.getFormattedNode = function (node, format, endNode) {
        var parentNode = this.getFormatParent(node, format, endNode);
        if (parentNode !== null && parentNode !== endNode) {
            return parentNode;
        }
        return null;
    };
    IsFormatted.prototype.getFormatParent = function (node, format, endNode) {
        do {
            node = node.parentNode;
        } while (node && (node !== endNode) && !this.isFormattedNode(node, format));
        return node;
    };
    IsFormatted.prototype.isFormattedNode = function (node, format) {
        switch (format) {
            case 'bold':
                return IsFormatted.isBold(node);
            case 'italic':
                return IsFormatted.isItalic(node);
            case 'underline':
                return IsFormatted.isUnderline(node);
            case 'strikethrough':
                return IsFormatted.isStrikethrough(node);
            case 'superscript':
                return IsFormatted.isSuperscript(node);
            case 'subscript':
                return IsFormatted.isSubscript(node);
            case 'fontcolor':
                return this.isFontColor(node);
            case 'fontname':
                return this.isFontName(node);
            case 'fontsize':
                return this.isFontSize(node);
            case 'backgroundcolor':
                return this.isBackgroundColor(node);
            default:
                return false;
        }
    };
    /**
     * isBold method
     *
     * @param {Node} node - specifies the node value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    IsFormatted.isBold = function (node) {
        var validTags = ['strong', 'b'];
        if (validTags.indexOf(node.nodeName.toLowerCase()) !== -1) {
            return true;
        }
        else if (this.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            node.style && node.style.fontWeight === 'bold') {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * isItalic method
     *
     * @param {Node} node - specifies the node value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    IsFormatted.isItalic = function (node) {
        var validTags = ['em', 'i'];
        if (validTags.indexOf(node.nodeName.toLowerCase()) !== -1) {
            return true;
        }
        else if (this.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            node.style && node.style.fontStyle === 'italic') {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * isUnderline method
     *
     * @param {Node} node - specifies the node value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    IsFormatted.isUnderline = function (node) {
        var validTags = ['u'];
        if (validTags.indexOf(node.nodeName.toLowerCase()) !== -1) {
            return true;
        }
        else if (this.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            node.style && node.style.textDecoration === 'underline') {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * isStrikethrough method
     *
     * @param {Node} node - specifies the node value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    IsFormatted.isStrikethrough = function (node) {
        var validTags = ['del', 'strike'];
        if (validTags.indexOf(node.nodeName.toLowerCase()) !== -1) {
            return true;
        }
        else if (this.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            node.style && node.style.textDecoration === 'line-through') {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * isSuperscript method
     *
     * @param {Node} node - specifies the node value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    IsFormatted.isSuperscript = function (node) {
        var validTags = ['sup'];
        if (validTags.indexOf(node.nodeName.toLowerCase()) !== -1) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * isSubscript method
     *
     * @param {Node} node - specifies the node value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    IsFormatted.isSubscript = function (node) {
        var validTags = ['sub'];
        if (validTags.indexOf(node.nodeName.toLowerCase()) !== -1) {
            return true;
        }
        else {
            return false;
        }
    };
    IsFormatted.prototype.isFontColor = function (node) {
        var color = node.style && node.style.color;
        if (IsFormatted.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            color !== null && color !== '' && color !== undefined) {
            return true;
        }
        else {
            return false;
        }
    };
    IsFormatted.prototype.isBackgroundColor = function (node) {
        var backColor = node.style && node.style.backgroundColor;
        if (IsFormatted.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            backColor !== null && backColor !== '' && backColor !== undefined) {
            return true;
        }
        else {
            return false;
        }
    };
    IsFormatted.prototype.isFontSize = function (node) {
        var size = node.style && node.style.fontSize;
        if (IsFormatted.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            size !== null && size !== '' && size !== undefined) {
            return true;
        }
        else {
            return false;
        }
    };
    IsFormatted.prototype.isFontName = function (node) {
        var name = node.style && node.style.fontFamily;
        if (IsFormatted.inlineTags.indexOf(node.nodeName.toLowerCase()) !== -1 &&
            name !== null && name !== '' && name !== undefined) {
            return true;
        }
        else {
            return false;
        }
    };
    // Get Formatted Node
    IsFormatted.inlineTags = [
        'a',
        'abbr',
        'acronym',
        'b',
        'bdo',
        'big',
        'cite',
        'code',
        'dfn',
        'em',
        'i',
        'kbd',
        'label',
        'q',
        'samp',
        'small',
        'span',
        'strong',
        'sub',
        'sup',
        'tt',
        'u',
        'var',
        'del'
    ];
    return IsFormatted;
}());

/**
 * Constant values for EditorManager
 */
/**
 * Image plugin events
 *
 * @hidden
 */
var IMAGE = 'INSERT-IMAGE';
var TABLE = 'INSERT-TABLE';
var LINK = 'INSERT-LINK';
var INSERT_ROW = 'INSERT-ROW';
var INSERT_COLUMN = 'INSERT-COLUMN';
var DELETEROW = 'DELETE-ROW';
var DELETECOLUMN = 'DELETE-COLUMN';
var REMOVETABLE = 'REMOVE-TABLE';
var TABLEHEADER = 'TABLE-HEADER';
var TABLE_VERTICAL_ALIGN = 'TABLE_VERTICAL_ALIGN';
var TABLE_MERGE = 'TABLE_MERGE';
var TABLE_VERTICAL_SPLIT = 'TABLE_VERTICAL_SPLIT';
var TABLE_HORIZONTAL_SPLIT = 'TABLE_HORIZONTAL_SPLIT';
var TABLE_MOVE = 'TABLE_MOVE';
/**
 * Alignments plugin events
 *
 * @hidden
 */
var ALIGNMENT_TYPE = 'alignment-type';
/**
 * Indents plugin events
 *
 * @hidden
 */
var INDENT_TYPE = 'indent-type';
/**
 * Constant tag names
 *
 * @hidden
 */
var DEFAULT_TAG = 'p';
/**
 * @hidden
 */
var BLOCK_TAGS = ['address', 'article', 'aside', 'audio', 'blockquote',
    'canvas', 'details', 'dd', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer',
    'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'li', 'main', 'nav',
    'noscript', 'ol', 'output', 'p', 'pre', 'section', 'table', 'tbody', 'td', 'tfoot', 'th',
    'thead', 'tr', 'ul', 'video', 'body'];
/**
 * @hidden
 */
var IGNORE_BLOCK_TAGS = ['td', 'th'];
/**
 * @hidden
 */
var TABLE_BLOCK_TAGS = ['table', 'tbody', 'td', 'tfoot', 'th',
    'thead', 'tr'];
/**
 * Selection plugin events
 *
 * @hidden
 */
var SELECTION_TYPE = 'selection-type';
/**
 * Insert HTML plugin events
 *
 * @hidden
 */
var INSERTHTML_TYPE = 'inserthtml-type';
/**
 * Insert Text plugin events
 *
 * @hidden
 */
var INSERT_TEXT_TYPE = 'insert-text-type';
/**
 * Clear Format HTML plugin events
 *
 * @hidden
 */
var CLEAR_TYPE = 'clear-type';

/**
 * `Selection` module is used to handle RTE Selections.
 */
var NodeSelection = /** @class */ (function () {
    function NodeSelection() {
        this.startNodeName = [];
        this.endNodeName = [];
    }
    NodeSelection.prototype.saveInstance = function (range, body) {
        this.range = range.cloneRange();
        this.rootNode = this.documentFromRange(range);
        this.body = body;
        this.startContainer = this.getNodeArray(range.startContainer, true);
        this.endContainer = this.getNodeArray(range.endContainer, false);
        this.startOffset = range.startOffset;
        this.endOffset = range.endOffset;
        this.html = this.body.innerHTML;
        return this;
    };
    NodeSelection.prototype.documentFromRange = function (range) {
        return (9 === range.startContainer.nodeType) ? range.startContainer : range.startContainer.ownerDocument;
    };
    NodeSelection.prototype.getRange = function (docElement) {
        var select$$1 = this.get(docElement);
        var range = select$$1 && select$$1.rangeCount > 0 ? select$$1.getRangeAt(select$$1.rangeCount - 1) : docElement.createRange();
        return (range.startContainer !== docElement || range.endContainer !== docElement
            || range.startOffset || range.endOffset || (range.setStart(docElement.body, 0), range.collapse(!0)), range);
    };
    /**
     * get method
     *
     * @param {Document} docElement - specifies the get function
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.get = function (docElement) {
        return docElement.defaultView.getSelection();
    };
    /**
     * save method
     *
     * @param {Range} range - range value.
     * @param {Document} docElement - specifies the document.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.save = function (range, docElement) {
        range = (range) ? range.cloneRange() : this.getRange(docElement);
        return this.saveInstance(range, docElement.body);
    };
    /**
     * getIndex method
     *
     * @param {Node} node - specifies the node value.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getIndex = function (node) {
        var index;
        var num = 0;
        node = !node.previousSibling && node.tagName === 'BR' ? node : node.previousSibling;
        if (node) {
            for (var type = node.nodeType; node; null) {
                index = node.nodeType;
                num++;
                //eslint-disable-next-line
                type = index;
                node = node.previousSibling;
            }
        }
        return num;
    };
    NodeSelection.prototype.isChildNode = function (nodeCollection, parentNode) {
        for (var index = 0; index < parentNode.childNodes.length; index++) {
            if (nodeCollection.indexOf(parentNode.childNodes[index]) > -1) {
                return true;
            }
        }
        return false;
    };
    NodeSelection.prototype.getNode = function (startNode, endNode, nodeCollection) {
        if (endNode === startNode &&
            (startNode.nodeType === 3 || !startNode.firstChild || nodeCollection.indexOf(startNode.firstChild) !== -1
                || this.isChildNode(nodeCollection, startNode))) {
            return null;
        }
        if (nodeCollection.indexOf(startNode.firstChild) === -1 && startNode.firstChild && !this.isChildNode(nodeCollection, startNode)) {
            return startNode.firstChild;
        }
        if (startNode.nextSibling) {
            return startNode.nextSibling;
        }
        if (!startNode.parentNode) {
            return null;
        }
        else {
            return startNode.parentNode;
        }
    };
    /**
     * getNodeCollection method
     *
     * @param {Range} range -specifies the range.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getNodeCollection = function (range) {
        var startNode = range.startContainer.childNodes[range.startOffset]
            || range.startContainer;
        var endNode = range.endContainer.childNodes[(range.endOffset > 0) ? (range.endOffset - 1) : range.endOffset]
            || range.endContainer;
        if (startNode === endNode && startNode.childNodes.length === 0) {
            return [startNode];
        }
        if (range.startOffset === range.endOffset && range.startOffset !== 0 && range.startContainer.nodeName === 'PRE') {
            return [startNode.nodeName === 'BR' || startNode.nodeName === '#text' ? startNode : startNode.childNodes[0]];
        }
        var nodeCollection = [];
        do {
            if (nodeCollection.indexOf(startNode) === -1) {
                nodeCollection.push(startNode);
            }
            startNode = this.getNode(startNode, endNode, nodeCollection);
        } while (startNode);
        return nodeCollection;
    };
    /**
     * getParentNodeCollection method
     *
     * @param {Range} range - specifies the range value.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getParentNodeCollection = function (range) {
        return this.getParentNodes(this.getNodeCollection(range), range);
    };
    /**
     * getParentNodes method
     *
     * @param {Node[]} nodeCollection - specifies the collection of nodes.
     * @param {Range} range - specifies the range values.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getParentNodes = function (nodeCollection, range) {
        nodeCollection = nodeCollection.reverse();
        for (var index = 0; index < nodeCollection.length; index++) {
            if ((nodeCollection.indexOf(nodeCollection[index].parentNode) !== -1)
                || (nodeCollection[index].nodeType === 3 &&
                    range.startContainer !== range.endContainer &&
                    range.startContainer.parentNode !== range.endContainer.parentNode)) {
                nodeCollection.splice(index, 1);
                index--;
            }
            else if (nodeCollection[index].nodeType === 3) {
                nodeCollection[index] = nodeCollection[index].parentNode;
            }
        }
        return nodeCollection;
    };
    /**
     * getSelectionNodeCollection method
     *
     * @param {Range} range - specifies the range value.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getSelectionNodeCollection = function (range) {
        return this.getSelectionNodes(this.getNodeCollection(range));
    };
    /**
     * getSelectionNodeCollection along with BR node method
     *
     * @param {Range} range - specifies the range value.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getSelectionNodeCollectionBr = function (range) {
        return this.getSelectionNodesBr(this.getNodeCollection(range));
    };
    /**
     * getParentNodes method
     *
     * @param {Node[]} nodeCollection - specifies the collection of nodes.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getSelectionNodes = function (nodeCollection) {
        nodeCollection = nodeCollection.reverse();
        var regEx = new RegExp(String.fromCharCode(8203), 'g');
        for (var index = 0; index < nodeCollection.length; index++) {
            if (nodeCollection[index].nodeType !== 3 || (nodeCollection[index].textContent.trim() === '' ||
                (nodeCollection[index].textContent.length === 1 && nodeCollection[index].textContent.match(regEx)))) {
                nodeCollection.splice(index, 1);
                index--;
            }
        }
        return nodeCollection.reverse();
    };
    /**
     * Get selection text nodes with br method.
     *
     * @param {Node[]} nodeCollection - specifies the collection of nodes.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getSelectionNodesBr = function (nodeCollection) {
        nodeCollection = nodeCollection.reverse();
        var regEx = new RegExp(String.fromCharCode(8203), 'g');
        for (var index = 0; index < nodeCollection.length; index++) {
            if (nodeCollection[index].nodeName !== 'BR' &&
                (nodeCollection[index].nodeType !== 3 || (nodeCollection[index].textContent.trim() === '' ||
                    (nodeCollection[index].textContent.length === 1 && nodeCollection[index].textContent.match(regEx))))) {
                nodeCollection.splice(index, 1);
                index--;
            }
        }
        return nodeCollection.reverse();
    };
    /**
     * getInsertNodeCollection method
     *
     * @param {Range} range - specifies the range value.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getInsertNodeCollection = function (range) {
        return this.getInsertNodes(this.getNodeCollection(range));
    };
    /**
     * getInsertNodes method
     *
     * @param {Node[]} nodeCollection - specifies the collection of nodes.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getInsertNodes = function (nodeCollection) {
        nodeCollection = nodeCollection.reverse();
        for (var index = 0; index < nodeCollection.length; index++) {
            if ((nodeCollection[index].childNodes.length !== 0 &&
                nodeCollection[index].nodeType !== 3) ||
                (nodeCollection[index].nodeType === 3 &&
                    nodeCollection[index].textContent === '')) {
                nodeCollection.splice(index, 1);
                index--;
            }
        }
        return nodeCollection.reverse();
    };
    /**
     * getNodeArray method
     *
     * @param {Node} node - specifies the node content.
     * @param {boolean} isStart - specifies the boolean value.
     * @param {Document} root - specifies the root document.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getNodeArray = function (node, isStart, root) {
        var array = [];
        // eslint-disable-next-line
        ((isStart) ? (this.startNodeName = []) : (this.endNodeName = []));
        for (; node !== (root ? root : this.rootNode); null) {
            if (sf.base.isNullOrUndefined(node)) {
                break;
            }
            // eslint-disable-next-line
            (isStart) ? this.startNodeName.push(node.nodeName.toLowerCase()) : this.endNodeName.push(node.nodeName.toLowerCase());
            array.push(this.getIndex(node));
            node = node.parentNode;
        }
        return array;
    };
    NodeSelection.prototype.setRangePoint = function (range, isvalid, num, size) {
        var node = this.rootNode;
        var index = num.length;
        var constant = size;
        for (; index--; null) {
            node = node && node.childNodes[num[index]];
        }
        if (node && constant >= 0 && node.nodeName !== 'html') {
            range[isvalid ? 'setStart' : 'setEnd'](node, constant);
        }
        return range;
    };
    /**
     * restore method
     *
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.restore = function () {
        var range = this.range.cloneRange();
        range = this.setRangePoint(range, true, this.startContainer, this.startOffset);
        range = this.setRangePoint(range, false, this.endContainer, this.endOffset);
        this.selectRange(this.rootNode, range);
        return range;
    };
    NodeSelection.prototype.selectRange = function (docElement, range) {
        this.setRange(docElement, range);
        this.save(range, docElement);
    };
    /**
     * setRange method
     *
     * @param {Document} docElement - specifies the document.
     * @param {Range} range - specifies the range.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.setRange = function (docElement, range) {
        var selection = this.get(docElement);
        selection.removeAllRanges();
        selection.addRange(range);
    };
    /**
     * setSelectionText method
     *
     * @param {Document} docElement - specifies the documrent
     * @param {Node} startNode - specifies the starting node.
     * @param {Node} endNode - specifies the the end node.
     * @param {number} startIndex - specifies the starting index.
     * @param {number} endIndex - specifies the end index.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.setSelectionText = function (docElement, startNode, endNode, startIndex, endIndex) {
        var range = docElement.createRange();
        range.setStart(startNode, startIndex);
        range.setEnd(endNode, endIndex);
        this.setRange(docElement, range);
    };
    /**
     * setSelectionContents method
     *
     * @param {Document} docElement - specifies the document.
     * @param {Node} element - specifies the node.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.setSelectionContents = function (docElement, element) {
        var range = docElement.createRange();
        range.selectNode(element);
        this.setRange(docElement, range);
    };
    /**
     * setSelectionNode method
     *
     * @param {Document} docElement - specifies the document.
     * @param {Node} element - specifies the node.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.setSelectionNode = function (docElement, element) {
        var range = docElement.createRange();
        range.selectNodeContents(element);
        this.setRange(docElement, range);
    };
    /**
     * getSelectedNodes method
     *
     * @param {Document} docElement - specifies the document.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.getSelectedNodes = function (docElement) {
        return this.getNodeCollection(this.getRange(docElement));
    };
    /**
     * Clear method
     *
     * @param {Document} docElement - specifies the document.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.Clear = function (docElement) {
        this.get(docElement).removeAllRanges();
    };
    /**
     * insertParentNode method
     *
     * @param {Document} docElement - specifies the document.
     * @param {Node} newNode - specicfies the new node.
     * @param {Range} range - specifies the range.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.insertParentNode = function (docElement, newNode, range) {
        range.surroundContents(newNode);
        this.selectRange(docElement, range);
    };
    /**
     * setCursorPoint method
     *
     * @param {Document} docElement - specifies the document.
     * @param {Element} element - specifies the element.
     * @param {number} point - specifies the point.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    NodeSelection.prototype.setCursorPoint = function (docElement, element, point) {
        var range = docElement.createRange();
        var selection = docElement.defaultView.getSelection();
        range.setStart(element, point);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
    };
    return NodeSelection;
}());

/**
 * `Selection` module is used to handle RTE Selections.
 */

/**
 * Update Toolbar Status
 *
 * @hidden
 * @deprecated
 */
var statusCollection = getDefaultHtmlTbStatus();
var ToolbarStatus = /** @class */ (function () {
    function ToolbarStatus() {
    }
    /**
     * get method
     *
     * @param {Document} docElement - specifies the document element
     * @param {Node} targetNode - specifies the target node
     * @param {string[]} formatNode - specifies the format node
     * @param {string[]} fontSize - specifies the font size
     * @param {string[]} fontName - specifies the font name.
     * @param {Node} documentNode - specifies the document node.
     * @returns {IToolbarStatus} - returns the toolbar status
     * @hidden
     * @deprecated
     */
    ToolbarStatus.get = function (docElement, targetNode, formatNode, fontSize, fontName, documentNode) {
        var formatCollection = JSON.parse(JSON.stringify(statusCollection));
        var nodeCollection = JSON.parse(JSON.stringify(statusCollection));
        var nodeSelection = new NodeSelection();
        var nodes = documentNode ? [documentNode] : nodeSelection.getNodeCollection(nodeSelection.getRange(docElement));
        var nodesLength = nodes.length;
        var isNodeChanged = false;
        var range = nodeSelection.getRange(docElement);
        for (var index = 0; index < nodes.length; index++) {
            while (nodes[index].nodeType === 3 && range.startContainer.nodeType === 3 && nodes[index].parentNode &&
                nodes[index].parentNode.lastElementChild && nodes[index].parentNode.lastElementChild.nodeName !== "BR" &&
                this.getImmediateBlockNode(nodes[index].parentNode, targetNode).textContent.replace(/\u200B/g, '').length === 0 &&
                range.startContainer.textContent.replace(/\u200B/g, '').length === 0 &&
                nodeSelection.get(docElement).toString().replace(/\u200B/g, '').length === 0) {
                nodes[index] = nodes[index].parentNode.lastElementChild.firstChild;
                isNodeChanged = true;
            }
            if (isNodeChanged && nodes[index]) {
                nodeSelection.setCursorPoint(docElement, nodes[index], nodes[index].textContent.length);
                isNodeChanged = false;
            }
            if ((nodes[index].nodeName !== 'BR' && nodes[index].nodeType !== 3) ||
                (nodesLength > 1 && nodes[index].nodeType === 3 && nodes[index].textContent.trim() === '')) {
                nodes.splice(index, 1);
                index--;
            }
        }
        for (var index = 0; index < nodes.length; index++) {
            formatCollection = this.getFormatParent(docElement, formatCollection, nodes[index], targetNode, formatNode, fontSize, fontName);
            if ((index === 0 && formatCollection.bold) || !formatCollection.bold) {
                nodeCollection.bold = formatCollection.bold;
            }
            if ((index === 0 && formatCollection.insertcode) || !formatCollection.insertcode) {
                nodeCollection.insertcode = formatCollection.insertcode;
            }
            if ((index === 0 && formatCollection.italic) || !formatCollection.italic) {
                nodeCollection.italic = formatCollection.italic;
            }
            if ((index === 0 && formatCollection.underline) || !formatCollection.underline) {
                nodeCollection.underline = formatCollection.underline;
            }
            if ((index === 0 && formatCollection.strikethrough) || !formatCollection.strikethrough) {
                nodeCollection.strikethrough = formatCollection.strikethrough;
            }
            if ((index === 0 && formatCollection.superscript) || !formatCollection.superscript) {
                nodeCollection.superscript = formatCollection.superscript;
            }
            if ((index === 0 && formatCollection.subscript) || !formatCollection.subscript) {
                nodeCollection.subscript = formatCollection.subscript;
            }
            if ((index === 0 && formatCollection.fontcolor) || !formatCollection.fontcolor) {
                nodeCollection.fontcolor = formatCollection.fontcolor;
            }
            if ((index === 0 && formatCollection.fontname) || !formatCollection.fontname) {
                nodeCollection.fontname = formatCollection.fontname;
            }
            if ((index === 0 && formatCollection.fontsize) || !formatCollection.fontsize) {
                nodeCollection.fontsize = formatCollection.fontsize;
            }
            if ((index === 0 && formatCollection.backgroundcolor) || !formatCollection.backgroundcolor) {
                nodeCollection.backgroundcolor = formatCollection.backgroundcolor;
            }
            if ((index === 0 && formatCollection.orderedlist) || !formatCollection.orderedlist) {
                nodeCollection.orderedlist = formatCollection.orderedlist;
            }
            if ((index === 0 && formatCollection.unorderedlist) || !formatCollection.unorderedlist) {
                nodeCollection.unorderedlist = formatCollection.unorderedlist;
            }
            if ((index === 0 && formatCollection.alignments) || !formatCollection.alignments) {
                nodeCollection.alignments = formatCollection.alignments;
            }
            if ((index === 0 && formatCollection.formats) || !formatCollection.formats) {
                nodeCollection.formats = formatCollection.formats;
            }
            if ((index === 0 && formatCollection.createlink) || !formatCollection.createlink) {
                nodeCollection.createlink = formatCollection.createlink;
            }
            if ((index === 0 && formatCollection.numberFormatList) || !formatCollection.numberFormatList) {
                nodeCollection.numberFormatList = formatCollection.numberFormatList;
            }
            if ((index === 0 && formatCollection.bulletFormatList) || !formatCollection.bulletFormatList) {
                nodeCollection.bulletFormatList = formatCollection.bulletFormatList;
            }
            formatCollection = JSON.parse(JSON.stringify(statusCollection));
        }
        return nodeCollection;
    };
    ToolbarStatus.getImmediateBlockNode = function (node, editNode) {
        do {
            node = node.parentNode;
        } while (node && BLOCK_TAGS.indexOf(node.nodeName.toLocaleLowerCase()) < 0);
        return node;
    };
    ToolbarStatus.getFormatParent = function (docElement, formatCollection, node, targetNode, formatNode, fontSize, fontName) {
        if (targetNode.contains(node) ||
            (node.nodeType === 3 && targetNode.nodeType !== 3 && targetNode.contains(node.parentNode))) {
            do {
                formatCollection = this.isFormattedNode(docElement, formatCollection, node, formatNode, fontSize, fontName);
                node = node.parentNode;
            } while (node && (node !== targetNode));
        }
        return formatCollection;
    };
    ToolbarStatus.isFormattedNode = function (docElement, formatCollection, node, formatNode, fontSize, fontName) {
        if (!formatCollection.bold) {
            formatCollection.bold = IsFormatted.isBold(node);
        }
        if (!formatCollection.italic) {
            formatCollection.italic = IsFormatted.isItalic(node);
        }
        if (!formatCollection.underline) {
            formatCollection.underline = IsFormatted.isUnderline(node);
        }
        if (!formatCollection.strikethrough) {
            formatCollection.strikethrough = IsFormatted.isStrikethrough(node);
        }
        if (!formatCollection.superscript) {
            formatCollection.superscript = IsFormatted.isSuperscript(node);
        }
        if (!formatCollection.subscript) {
            formatCollection.subscript = IsFormatted.isSubscript(node);
        }
        if (!formatCollection.fontcolor) {
            formatCollection.fontcolor = this.isFontColor(docElement, node);
        }
        if (!formatCollection.fontname) {
            formatCollection.fontname = this.isFontName(docElement, node, fontName);
        }
        if (!formatCollection.fontsize) {
            formatCollection.fontsize = this.isFontSize(node, fontSize);
        }
        if (!formatCollection.backgroundcolor) {
            formatCollection.backgroundcolor = this.isBackgroundColor(node);
        }
        if (!formatCollection.orderedlist) {
            formatCollection.orderedlist = this.isOrderedList(node);
        }
        if (!formatCollection.unorderedlist) {
            formatCollection.unorderedlist = this.isUnorderedList(node);
        }
        if (!formatCollection.alignments) {
            formatCollection.alignments = this.isAlignment(node);
        }
        if (!formatCollection.formats) {
            formatCollection.formats = this.isFormats(node, formatNode);
            if (formatCollection.formats === 'pre') {
                formatCollection.insertcode = true;
            }
        }
        if (!formatCollection.createlink) {
            formatCollection.createlink = this.isLink(node);
        }
        if (!formatCollection.numberFormatList) {
            formatCollection.numberFormatList = this.isNumberFormatList(node);
        }
        if (!formatCollection.bulletFormatList) {
            formatCollection.bulletFormatList = this.isBulletFormatList(node);
        }
        return formatCollection;
    };
    ToolbarStatus.isFontColor = function (docElement, node) {
        var color = node.style && node.style.color;
        if ((color === null || color === undefined || color === '') && node.nodeType !== 3) {
            color = this.getComputedStyle(docElement, node, 'color');
        }
        if (color !== null && color !== '' && color !== undefined) {
            return color;
        }
        else {
            return null;
        }
    };
    ToolbarStatus.isLink = function (node) {
        if (node.nodeName.toLocaleLowerCase() === 'a') {
            return true;
        }
        else {
            return false;
        }
    };
    ToolbarStatus.isBackgroundColor = function (node) {
        var backColor = node.style && node.style.backgroundColor;
        if (backColor !== null && backColor !== '' && backColor !== undefined) {
            return backColor;
        }
        else {
            return null;
        }
    };
    ToolbarStatus.isFontSize = function (node, fontSize) {
        var size = node.style && node.style.fontSize;
        if ((size !== null && size !== '' && size !== undefined)
            && (fontSize === null || fontSize === undefined || (fontSize.indexOf(size) > -1))) {
            return size;
        }
        else {
            return null;
        }
    };
    ToolbarStatus.isFontName = function (docElement, node, fontName) {
        var name = node.style && node.style.fontFamily;
        if ((name === null || name === undefined || name === '') && node.nodeType !== 3) {
            name = this.getComputedStyle(docElement, node, 'font-family');
        }
        var index = null;
        if ((name !== null && name !== '' && name !== undefined)
            && (fontName === null || fontName === undefined || (fontName.filter(function (value, pos) {
                var pattern = new RegExp(name, 'i');
                if ((value.replace(/"/g, '').replace(/ /g, '') === name.replace(/"/g, '').replace(/ /g, '')) ||
                    (value.search(pattern) > -1)) {
                    index = pos;
                }
            }) && (index !== null)))) {
            return (index !== null) ? fontName[index] : name.replace(/"/g, '');
        }
        else {
            return null;
        }
    };
    ToolbarStatus.isOrderedList = function (node) {
        if (node.nodeName.toLocaleLowerCase() === 'ol') {
            return true;
        }
        else {
            return false;
        }
    };
    ToolbarStatus.isUnorderedList = function (node) {
        if (node.nodeName.toLocaleLowerCase() === 'ul') {
            return true;
        }
        else {
            return false;
        }
    };
    ToolbarStatus.isAlignment = function (node) {
        var align = node.style && node.style.textAlign;
        if (align === 'left') {
            return 'justifyleft';
        }
        else if (align === 'center') {
            return 'justifycenter';
        }
        else if (align === 'right') {
            return 'justifyright';
        }
        else if (align === 'justify') {
            return 'justifyfull';
        }
        else {
            return null;
        }
    };
    ToolbarStatus.isFormats = function (node, formatNode) {
        if (((formatNode === undefined || formatNode === null)
            && BLOCK_TAGS.indexOf(node.nodeName.toLocaleLowerCase()) > -1)
            || (formatNode !== null && formatNode !== undefined
                && formatNode.indexOf(node.nodeName.toLocaleLowerCase()) > -1)) {
            return node.nodeName.toLocaleLowerCase();
        }
        else {
            return null;
        }
    };
    ToolbarStatus.getComputedStyle = function (docElement, node, prop) {
        return docElement.defaultView.getComputedStyle(node, null).getPropertyValue(prop);
    };
    ToolbarStatus.isNumberFormatList = function (node) {
        var list = node.style && node.style.listStyleType;
        if (list === 'lower-alpha') {
            return 'Lower Alpha';
        }
        else if (list === 'number') {
            return 'Number';
        }
        else if (list === 'upper-alpha') {
            return 'Upper Alpha';
        }
        else if (list === 'lower-roman') {
            return 'Lower Roman';
        }
        else if (list === 'upper-roman') {
            return 'Upper Roman';
        }
        else if (list === 'lower-greek') {
            return 'Lower Greek';
        }
        else if (list === 'none') {
            return 'None';
        }
        else {
            return null;
        }
    };
    ToolbarStatus.isBulletFormatList = function (node) {
        var list = node.style && node.style.listStyleType;
        if (list === 'circle') {
            return 'Circle';
        }
        else if (list === 'square') {
            return 'Square';
        }
        else if (list === 'none') {
            return 'None';
        }
        else if (list === 'disc') {
            return 'Disc';
        }
        else {
            return null;
        }
    };
    return ToolbarStatus;
}());

/**
 * HtmlToolbarStatus module for refresh the toolbar status
 */
var HtmlToolbarStatus = /** @class */ (function () {
    function HtmlToolbarStatus(parent) {
        this.parent = parent;
        this.toolbarStatus = this.prevToolbarStatus = getDefaultHtmlTbStatus();
        this.addEventListener();
    }
    HtmlToolbarStatus.prototype.addEventListener = function () {
        this.parent.observer.on(toolbarRefresh, this.onRefreshHandler, this);
        this.parent.observer.on(destroy, this.removeEventListener, this);
    };
    HtmlToolbarStatus.prototype.removeEventListener = function () {
        this.parent.observer.off(toolbarRefresh, this.onRefreshHandler);
        this.parent.observer.off(destroy, this.removeEventListener);
    };
    HtmlToolbarStatus.prototype.onRefreshHandler = function (args) {
        if (this.parent.readonly) {
            return;
        }
        var fontsize = [];
        var fontName = [];
        var formats = [];
        this.parent.fontSize.items.forEach(function (item) { fontsize.push(item.value); });
        this.parent.fontFamily.items.forEach(function (item) { fontName.push(item.value); });
        this.parent.format.items.forEach(function (item) {
            formats.push(item.value.toLocaleLowerCase());
        });
        this.toolbarStatus = ToolbarStatus.get(this.parent.getDocument(), this.parent.getEditPanel(), formats, fontsize, fontName, args.documentNode);
        var tbStatusString = JSON.stringify(this.toolbarStatus);
        this.parent.observer.notify(toolbarUpdated, this.toolbarStatus);
        if (JSON.stringify(this.prevToolbarStatus) !== tbStatusString) {
            this.parent.observer.notify(updateTbItemsStatus, { html: JSON.parse(tbStatusString), markdown: null });
            this.prevToolbarStatus = JSON.parse(tbStatusString);
        }
    };
    return HtmlToolbarStatus;
}());

/**
 * Constant values for Common
 */
/**
 * Keydown event trigger
 *
 * @hidden
 */
var KEY_DOWN = 'keydown';
/**
 * Undo and Redo action HTML plugin events
 *
 * @hidden
 */
var ACTION = 'action';
/**
 * Formats plugin events
 *
 * @hidden
 */
var FORMAT_TYPE = 'format-type';
/**
 * Keydown handler event trigger
 *
 * @hidden
 */
var KEY_DOWN_HANDLER = 'keydown-handler';
/**
 * List plugin events
 *
 * @hidden
 */
var LIST_TYPE = 'list-type';
/**
 * Keyup handler event trigger
 *
 * @hidden
 */
var KEY_UP_HANDLER = 'keyup-handler';
/**
 * Keyup event trigger
 *
 * @hidden
 */
var KEY_UP = 'keyup';
/**
 * Model changed plugin event trigger
 *
 * @hidden
 */
var MODEL_CHANGED_PLUGIN = 'model_changed_plugin';
/**
 * Model changed event trigger
 *
 * @hidden
 */
var MODEL_CHANGED = 'model_changed';
/**
 * PasteCleanup plugin for MSWord content
 *
 * @hidden
 */
var MS_WORD_CLEANUP_PLUGIN$1 = 'ms_word_cleanup_plugin';
/**
 * PasteCleanup for MSWord content
 *
 * @hidden
 */
var MS_WORD_CLEANUP$1 = 'ms_word_cleanup';
/**
* ActionBegin event callback
*
* @hidden
*/
var ON_BEGIN$1 = 'onBegin';
/**
* Callback for spacelist action
*
* @hidden
*/
var SPACE_ACTION = 'actionBegin';

/* eslint-disable */
/**
 * Export items model
 */

/* eslint-disable */
/**
 * Export default locale
 */

/**
 * Defines util methods used by Rich Text Editor.
 */
/**
 * @param {string} val - specifies the string value
 * @param {string} items - specifies the value
 * @returns {number} - returns the number value
 * @hidden
 */

/**
 * @param {Element} element - specifies the element
 * @param {string} className - specifies the string value
 * @returns {boolean} - returns the boolean value
 * @hidden
 */

/**
 * @param {IDropDownItemModel} items - specifies the item model
 * @param {string} value - specifies the string value
 * @param {string} type - specifies the string value
 * @param {string} returnType - specifies the return type
 * @returns {string} - returns the string value
 * @hidden
 */

/**
 * @returns {boolean} - returns the boolean value
 * @hidden
 */
function isIDevice$2() {
    var result = false;
    if (sf.base.Browser.isDevice && sf.base.Browser.isIos) {
        result = true;
    }
    return result;
}
/**
 * @param {string} value - specifies the value
 * @returns {string} - returns the string value
 * @hidden
 */

/**
 * @param {MouseEvent} e - specifies the mouse event
 * @param {HTMLElement} parentElement - specifies the parent element
 * @param {boolean} isIFrame - specifies the boolean value
 * @returns {number} - returns the number
 * @hidden
 */

/**
 * @param {string} item - specifies the string
 * @param {ServiceLocator} serviceLocator - specifies the service locator
 * @returns {string} - returns the string
 * @hidden
 */

/**
 * @param {ISetToolbarStatusArgs} e - specifies the e element
 * @param {boolean} isPopToolbar - specifies the boolean value
 * @param {IRichTextEditor} self - specifies the parent element
 * @returns {void}
 * @hidden
 */

/**
 * @param {string} items - specifies the string value
 * @returns {string[]} - returns the array value
 * @hidden
 */

/**
 * @param {string[]} items - specifies the array of string value
 * @param {IToolbarItemModel} toolbarItems - specifies the tool bar model
 * @returns {number} - returns the number
 * @hidden
 */

/**
 * @param {BaseToolbar} baseToolbar - specifies the base
 * @param {boolean} undoRedoStatus - specifies the boolean value
 * @returns {void}
 * @hidden
 */

/**
 * To dispatch the event manually
 *
 * @param {Element} element - specifies the element.
 * @param {string} type - specifies the string type.
 * @returns {void}
 * @hidden
 * @deprecated
 */

/**
 * To parse the HTML
 *
 * @param {string} value - specifies the string value
 * @returns {DocumentFragment} - returns the document
 * @hidden
 */

/**
 * @param {Document} docElement - specifies the document element
 * @param {Element} node - specifies the node
 * @returns {Node[]} - returns the node array
 * @hidden
 */
function getTextNodesUnder(docElement, node) {
    var nodes = [];
    for (node = node.firstChild; node; node = node.nextSibling) {
        if (node.nodeType === 3) {
            nodes.push(node);
        }
        else {
            nodes = nodes.concat(getTextNodesUnder(docElement, node));
        }
    }
    return nodes;
}
/**
 * @param {IToolsItemConfigs} obj - specifies the configuration
 * @returns {void}
 * @hidden
 */

/**
 * @param {string} value - specifies the string value
 * @param {IRichTextEditor} rteObj - specifies the rte object
 * @returns {string} - returns the string
 * @hidden
 */

/**
 * @param {string} value - specifies the value
 * @returns {string} - returns the string
 * @hidden
 */

/**
 * @param {IRichTextEditor} rteObj - specifies the rte object
 * @returns {string} - returns the value based on enter configuration.
 * @hidden
 */

/**
 * @param {string} value - specifies the value
 * @returns {boolean} - returns the boolean value
 * @hidden
 */

/**
 * @param {string} value - specifies the string value
 * @returns {string} - returns the string
 * @hidden
 */

/**
 * @param {string} value - specifies the string value
 * @param {IRichTextEditor} parent - specifies the rte
 * @returns {string} - returns the string value
 * @hidden
 */

/**
 * @param {string} dataUrl - specifies the string value
 * @returns {BaseToolbar} - returns the value
 * @hidden
 */
//Converting the base64 url to blob
function convertToBlob$1(dataUrl) {
    var arr = dataUrl.split(',');
    var mime = arr[0].match(/:(.*?);/)[1];
    var bstr = atob(arr[1]);
    var n = bstr.length;
    var u8arr = new Uint8Array(n);
    while (n--) {
        u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], { type: mime });
}
/**
 * @param {IRichTextEditor} self - specifies the rte
 * @param {string} localeItems - specifies the locale items
 * @param {IDropDownItemModel} item - specifies the dropdown item
 * @returns {string} - returns the value
 * @hidden
 */

/**
 * @param {IRichTextEditor} self - specifies the rte
 * @returns {void}
 * @hidden
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * Specifies Rich Text Editor internal events
 */
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var contentChanged$1 = 'content-changed';
/**
 * @hidden
 * @deprecated
 */
var initialEnd$1 = 'initial-end';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var destroy$1 = 'destroy';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var execCommandCallBack$1 = 'execCommandCallBack';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var insertCompleted$1 = 'insertCompleted';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var sourceCode$1 = 'sourceCode';
/**
 * @hidden
 * @deprecated
 */
var updateSource$1 = 'updateSource';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var sourceCodeMouseDown$1 = 'sourceCodeMouseDown';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */
var checkUndo$1 = 'checkUndoStack';
/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

/**
 * @hidden
 * @deprecated
 */

var __assign$2 = (undefined && undefined.__assign) || function () {
    __assign$2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};
/**
 * Formatter
 */
var Formatter = /** @class */ (function () {
    function Formatter() {
    }
    Formatter.prototype.process = function (self, args, event, value) {
        var _this = this;
        var selection = self.getDocument().getSelection();
        var range = (selection.rangeCount > 0) ? selection.getRangeAt(selection.rangeCount - 1) : null;
        var saveSelection;
        if (self.editorMode === 'HTML') {
            saveSelection = this.editorManager.nodeSelection.save(range, self.getDocument());
        }
        if (!sf.base.isNullOrUndefined(args)
            && args.item.command
            && args.item.command !== 'Table'
            && args.item.command !== 'Actions'
            && args.item.command !== 'Links'
            && args.item.command !== 'Images'
            && range
            && !(self.getEditPanel().contains(this.getAncestorNode(range.commonAncestorContainer))
                || self.getEditPanel() === range.commonAncestorContainer
                || self.getPanel() === range.commonAncestorContainer)) {
            return;
        }
        if (sf.base.isNullOrUndefined(args)) {
            var action_1 = event.action;
            if (action_1 !== 'tab' && action_1 !== 'enter' && action_1 !== 'space' && action_1 !== 'escape') {
                args = {};
                if (self.editorMode === 'Markdown' && action_1 === 'insert-table') {
                    value = {
                        'headingText': self.localeData.headingText,
                        'colText': self.localeData.colText
                    };
                }
                var items = {
                    originalEvent: event, cancel: false,
                    requestType: action_1 || (event.key + 'Key'),
                };
                sf.base.extend(args, args, items, true);
                delete args.item;
                args.originalEvent = __assign$2({}, args.originalEvent, { target: null });
                if (self.actionBeginEnabled) {
                    // @ts-ignore-start
                    self.dotNetRef.invokeMethodAsync(actionBeginEvent, args).then(function (actionBeginArgs) {
                        // @ts-ignore-end
                        if (args.cancel) {
                            if (action_1 === 'paste' || action_1 === 'cut' || action_1 === 'copy') {
                                event.preventDefault();
                            }
                        }
                    });
                }
            }
            var isTableModule = sf.base.isNullOrUndefined(self.tableModule) ? true : self.tableModule ?
                self.tableModule.ensureInsideTableList : false;
            if ((event.which === 9 && isTableModule) || event.which !== 9) {
                this.editorManager.observer.notify((event.type === 'keydown' ? KEY_DOWN : KEY_UP), {
                    event: event,
                    callBack: this.onSuccess.bind(this, self),
                    value: value
                });
            }
        }
        else if (!sf.base.isNullOrUndefined(args) && args.item.command && args.item.subCommand && ((args.item.command !== args.item.subCommand
            && args.item.command !== 'Font')
            || ((args.item.subCommand === 'FontName' || args.item.subCommand === 'FontSize') && args.name === 'dropDownSelect')
            || ((args.item.subCommand === 'BackgroundColor' || args.item.subCommand === 'FontColor')
                && args.name === 'colorPickerChanged'))) {
            args.originalEvent = __assign$2({}, args.originalEvent, { target: null });
            sf.base.extend(args, args, { requestType: args.item.subCommand, cancel: false }, true);
            if (self.actionBeginEnabled) {
                // @ts-ignore-start
                self.dotNetRef.invokeMethodAsync(actionBeginEvent, args).then(function (actionBeginArgs) {
                    // @ts-ignore-end
                    if (!actionBeginArgs.cancel) {
                        _this.actionBeginCallBack(self, args, saveSelection, event, value);
                    }
                });
            }
            else {
                this.actionBeginCallBack(self, args, saveSelection, event, value);
            }
        }
        if (sf.base.isNullOrUndefined(event) || event && event.action !== 'copy') {
            this.enableUndo(self);
        }
    };
    Formatter.prototype.getAncestorNode = function (node) {
        node = node.nodeType === 3 ? node.parentNode : node;
        return node;
    };
    Formatter.prototype.onKeyHandler = function (self, e) {
        var _this = this;
        this.editorManager.observer.notify(KEY_UP, {
            event: e, callBack: function () {
                self.observer.notify(contentChanged$1, {});
                _this.enableUndo(self);
            }
        });
    };
    Formatter.prototype.onSuccess = function (self, events) {
        var _this = this;
        self.observer.notify(contentChanged$1, {});
        if (events && (sf.base.isNullOrUndefined(events.event) || events.event.action !== 'copy')) {
            if (events.requestType === 'Paste') {
                self.observer.notify(execCommandCallBack$1, events);
                this.enableUndo(self);
            }
            else {
                this.enableUndo(self);
                self.observer.notify(execCommandCallBack$1, events);
            }
        }
        events.event = __assign$2({}, events.event, { target: null });
        this.successArgs = __assign$2({}, events);
        delete events.elements;
        delete events.range;
        if (self.actionCompleteEnabled) {
            // @ts-ignore-start
            self.dotNetRef.invokeMethodAsync(actionCompleteEvent, events).then(function (callbackArgs) {
                // @ts-ignore-end
                _this.actionCompleteCallBack(self, callbackArgs);
            });
        }
        else {
            this.actionCompleteCallBack(self, events);
        }
    };
    Formatter.prototype.saveData = function (e) {
        this.editorManager.undoRedoManager.saveData(e);
    };
    Formatter.prototype.getUndoStatus = function () {
        return this.editorManager.undoRedoManager.getUndoStatus();
    };
    Formatter.prototype.getUndoRedoStack = function () {
        return this.editorManager.undoRedoManager.undoRedoStack;
    };
    Formatter.prototype.enableUndo = function (self) {
        if (self.undoRedoStatus) {
            var status_1 = this.getUndoStatus();
            if (self.inlineMode.enable && (!sf.base.Browser.isDevice || isIDevice$2())) {
                self.dotNetRef.invokeMethodAsync(updateUndoRedoStatus, status_1);
            }
            else {
                if (self.toolbarModule) {
                    self.dotNetRef.invokeMethodAsync(updateUndoRedoStatus, status_1);
                }
            }
        }
    };
    Formatter.prototype.actionBeginCallBack = function (self, args, selection, event, value) {
        if (this.getUndoRedoStack().length === 0 && args.item.command !== 'Links'
            && args.item.command !== 'Images') {
            this.saveData();
        }
        self.isBlur = false;
        self.getEditPanel().focus();
        if (self.editorMode === 'HTML') {
            selection.restore();
        }
        var command = args.item.subCommand.toLocaleLowerCase();
        if (command === 'paste' || command === 'cut' || command === 'copy') {
            self.clipboardAction(command, event);
        }
        else {
            this.editorManager.observer.notify(checkUndo$1, { subCommand: args.item.subCommand });
            this.editorManager.execCommand(args.item.command, args.item.subCommand, event, this.onSuccess.bind(this, self), args.item.value, args.item.subCommand === 'Pre' && args.name === 'dropDownSelect' ?
                { name: args.name } : value, ('#' + '' + ' iframe'));
        }
    };
    Formatter.prototype.actionCompleteCallBack = function (self, args) {
        self.setPlaceHolder();
        if (args.requestType === 'Images' || args.requestType === 'Links' && args.editorMode === 'HTML') {
            var successArgs = this.successArgs;
            if (args.requestType === 'Links' && args.event && args.event.type === 'keydown' &&
                args.event.keyCode === 32) {
                return;
            }
            self.observer.notify(insertCompleted$1, {
                args: successArgs.event, type: args.requestType, isNotify: true, elements: successArgs.elements
            });
        }
        self.autoResize();
    };
    return Formatter;
}());

/**
 * Default Markdown formats config for adapter
 */
var markdownFormatTags = {
    'h6': '###### ',
    'h5': '##### ',
    'h4': '#### ',
    'h3': '### ',
    'h2': '## ',
    'h1': '# ',
    'blockquote': '> ',
    'pre': '```\n',
    'p': ''
};
/**
 * Default selection formats config for adapter
 */
var markdownSelectionTags = {
    'Bold': '**',
    'Italic': '*',
    'StrikeThrough': '~~',
    'InlineCode': '`',
    'SubScript': '<sub>',
    'SuperScript': '<sup>',
    'UpperCase': 'A-Z',
    'LowerCase': 'a-z'
};
/**
 * Default Markdown lists config for adapter
 */
var markdownListsTags = {
    'OL': '1. ',
    'UL': '- '
};
/**
 * Default html key config for adapter
 */
var htmlKeyConfig = {
    'toolbar-focus': 'alt+f10',
    'escape': '27',
    'insert-link': 'ctrl+k',
    'insert-image': 'ctrl+shift+i',
    'insert-table': 'ctrl+shift+e',
    'undo': 'ctrl+z',
    'redo': 'ctrl+y',
    'copy': 'ctrl+c',
    'cut': 'ctrl+x',
    'paste': 'ctrl+v',
    'bold': 'ctrl+b',
    'italic': 'ctrl+i',
    'underline': 'ctrl+u',
    'strikethrough': 'ctrl+shift+s',
    'uppercase': 'ctrl+shift+u',
    'lowercase': 'ctrl+shift+l',
    'superscript': 'ctrl+shift+=',
    'subscript': 'ctrl+=',
    'indents': 'ctrl+]',
    'outdents': 'ctrl+[',
    'html-source': 'ctrl+shift+h',
    'full-screen': 'ctrl+shift+f',
    'decrease-fontsize': 'ctrl+shift+<',
    'increase-fontsize': 'ctrl+shift+>',
    'justify-center': 'ctrl+e',
    'justify-full': 'ctrl+j',
    'justify-left': 'ctrl+l',
    'justify-right': 'ctrl+r',
    'clear-format': 'ctrl+shift+r',
    'ordered-list': 'ctrl+shift+o',
    'unordered-list': 'ctrl+alt+o',
    'space': '32',
    'enter': '13',
    'tab': 'tab',
    'delete': '46'
};
/**
 * Default  markdown key config for adapter
 */
var markdownKeyConfig = {
    'toolbar-focus': 'alt+f10',
    'escape': '27',
    'insert-link': 'ctrl+k',
    'insert-image': 'ctrl+shift+i',
    'insert-table': 'ctrl+shift+e',
    'undo': 'ctrl+z',
    'redo': 'ctrl+y',
    'copy': 'ctrl+c',
    'cut': 'ctrl+x',
    'paste': 'ctrl+v',
    'bold': 'ctrl+b',
    'italic': 'ctrl+i',
    'strikethrough': 'ctrl+shift+s',
    'uppercase': 'ctrl+shift+u',
    'lowercase': 'ctrl+shift+l',
    'superscript': 'ctrl+shift+=',
    'subscript': 'ctrl+=',
    'full-screen': 'ctrl+shift+f',
    'ordered-list': 'ctrl+shift+o',
    'unordered-list': 'ctrl+alt+o'
};
/**
 * PasteCleanup Grouping of similar functionality tags
 */
var pasteCleanupGroupingTags = {
    'b': ['strong'],
    'strong': ['b'],
    'i': ['emp', 'cite'],
    'emp': ['i', 'cite'],
    'cite': ['i', 'emp']
};
/**
 * PasteCleanup Grouping of similar functionality tags
 */

/**
 * Dom-Node Grouping of self closing tags
 *
 * @hidden
 */
var selfClosingTags = [
    'BR',
    'IMG'
];

var markerClassName = {
    startSelection: 'e-editor-select-start',
    endSelection: 'e-editor-select-end'
};
/**
 * DOMNode internal plugin
 *
 * @hidden
 * @deprecated
 */
var DOMNode = /** @class */ (function () {
    /**
     * Constructor for creating the DOMNode plugin
     *
     * @param {Element} parent - specifies the parent element
     * @param {Document} currentDocument - specifies the current document.
     * @hidden
     * @deprecated
     */
    function DOMNode(parent, currentDocument) {
        this.parent = parent;
        this.nodeSelection = new NodeSelection();
        this.currentDocument = currentDocument;
    }
    /**
     * contents method
     *
     * @param {Element} element - specifies the element.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.contents = function (element) {
        return (element && 'IFRAME' !== element.tagName ? Array.prototype.slice.call(element.childNodes || []) : []);
    };
    /**
     * isBlockNode method
     *
     * @param {Element} element - specifies the node element.
     * @returns {boolean} - sepcifies the boolean value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.isBlockNode = function (element) {
        return (!!element && (element.nodeType === Node.ELEMENT_NODE && BLOCK_TAGS.indexOf(element.tagName.toLowerCase()) >= 0));
    };
    /**
     * isLink method
     *
     * @param {Element} element - specifies the element
     * @returns {boolean} -  specifies the boolean value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.isLink = function (element) {
        return (!!element && (element.nodeType === Node.ELEMENT_NODE && 'a' === element.tagName.toLowerCase()));
    };
    /**
     * blockParentNode method
     *
     * @param {Element} element - specifies the element
     * @returns {Element} - returns the element value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.blockParentNode = function (element) {
        for (; element && element.parentNode !== this.parent && ((!element.parentNode ||
            !this.hasClass(element.parentNode, 'e-node-inner'))); null) {
            element = element.parentNode;
            if (this.isBlockNode(element)) {
                return element;
            }
        }
        return element;
    };
    /**
     * rawAttributes method
     *
     * @param {Element} element - specifies the element
     * @returns {string} - returns the string value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.rawAttributes = function (element) {
        var rawAttr = {};
        var attributes$$1 = element.attributes;
        if (attributes$$1.length > 0) {
            for (var d = 0; d < attributes$$1.length; d++) {
                var e = attributes$$1[d];
                rawAttr[e.nodeName] = e.value;
            }
        }
        return rawAttr;
    };
    /**
     * attributes method
     *
     * @param {Element} element - sepcifies the element.
     * @returns {string} - returns the string value.
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.attributes = function (element) {
        if (!element) {
            return '';
        }
        var attr = '';
        var rawAttr = this.rawAttributes(element);
        var orderRawAttr = Object.keys(rawAttr).sort();
        for (var e = 0; e < orderRawAttr.length; e++) {
            var attrKey = orderRawAttr[e];
            var attrValue = rawAttr[attrKey];
            /* eslint-disable */
            if (attrValue.indexOf("'") < 0 && attrValue.indexOf('"') >= 0) {
                attr += ' ' + attrKey + "='" + attrValue + "'";
            }
            else if (attrValue.indexOf('"') >= 0 && attrValue.indexOf("'") >= 0) {
                /* eslint-enable */
                attrValue = attrValue.replace(/"/g, '&quot;');
                attr += ' ' + attrKey + '="' + attrValue + '"';
            }
            else {
                attr += ' ' + attrKey + '="' + attrValue + '"';
            }
        }
        return attr;
    };
    /**
     * clearAttributes method
     *
     * @param {Element} element - specifies the element
     * @returns {void}
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.clearAttributes = function (element) {
        for (var attr = element.attributes, c = attr.length - 1; c >= 0; c--) {
            var key = attr[c];
            element.removeAttribute(key.nodeName);
        }
    };
    /**
     * openTagString method
     *
     * @param {Element} element - specifies the element.
     * @returns {string} - returns the string
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.openTagString = function (element) {
        return '<' + element.tagName.toLowerCase() + this.attributes(element) + '>';
    };
    /**
     * closeTagString method
     *
     * @param {Element} element - specifies the element
     * @returns {string} - returns the string value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.closeTagString = function (element) {
        return '</' + element.tagName.toLowerCase() + '>';
    };
    /**
     * createTagString method
     *
     * @param {string} tagName - specifies the tag name
     * @param {Element} relativeElement - specifies the relative element
     * @param {string} innerHTML - specifies the string value
     * @returns {string} - returns the string value.
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.createTagString = function (tagName, relativeElement, innerHTML) {
        return '<' + tagName.toLowerCase() + this.attributes(relativeElement) + '>' + innerHTML + '</' + tagName.toLowerCase() + '>';
    };
    /**
     * isList method
     *
     * @param {Element} element - specifes the element.
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.isList = function (element) {
        return !!element && ['UL', 'OL'].indexOf(element.tagName) >= 0;
    };
    /**
     * isElement method
     *
     * @param {Element} element - specifes the element.
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.isElement = function (element) {
        return element === this.parent;
    };
    /**
     * isEditable method
     *
     * @param {Element} element - specifes the element.
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.isEditable = function (element) {
        return ((!element.getAttribute || element.getAttribute('contenteditable') === 'true')
            && ['STYLE', 'SCRIPT'].indexOf(element.tagName) < 0);
    };
    /**
     * hasClass method
     *
     * @param {Element} element - specifes the element.
     * @param {string} className - specifies the class name value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.hasClass = function (element, className) {
        return element && element.classList && element.classList.contains(className);
    };
    /**
     * replaceWith method
     *
     * @param {Element} element - specifes the element.
     * @param {string} value - specifies the string value
     * @returns {void}
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.replaceWith = function (element, value) {
        var parentNode = element.parentNode;
        parentNode.insertBefore(this.parseHTMLFragment(value), element);
        sf.base.detach(element);
    };
    /**
     * parseHTMLFragment method
     *
     * @param {string} value - specifies the string value
     * @returns {Element} - returns the element
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.parseHTMLFragment = function (value) {
        /* eslint-disable */
        var temp = sf.base.createElement('template');
        temp.innerHTML = value;
        if (temp.content instanceof DocumentFragment) {
            return temp.content;
        }
        else {
            return document.createRange().createContextualFragment(value);
        }
        /* eslint-enable */
    };
    /**
     * wrap method
     *
     * @param {Element} element - specifies the element
     * @param {Element} wrapper - specifies the element.
     * @returns {Element} - returns the element
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.wrap = function (element, wrapper) {
        element.parentNode.insertBefore(wrapper, element);
        wrapper = element.previousSibling;
        wrapper.appendChild(element);
        return wrapper;
    };
    /**
     * insertAfter method
     *
     * @param {Element} newNode - specifies the new node element
     * @param {Element} referenceNode - specifies the referenece node
     * @returns {void}
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.insertAfter = function (newNode, referenceNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    };
    /**
     * wrapInner method
     *
     * @param {Element} parent - specifies the parent element.
     * @param {Element} wrapper - specifies the wrapper element.
     * @returns {Element} - returns the element
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.wrapInner = function (parent, wrapper) {
        parent.appendChild(wrapper);
        wrapper = parent.querySelector('.e-rte-wrap-inner');
        wrapper.classList.remove('e-rte-wrap-inner');
        if (wrapper.classList.length === 0) {
            wrapper.removeAttribute('class');
        }
        while (parent.firstChild !== wrapper) {
            wrapper.appendChild(parent.firstChild);
        }
        return wrapper;
    };
    /**
     * unWrap method
     *
     * @param {Element} element - specifies the element.
     * @returns {Element} - returns the element.
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.unWrap = function (element) {
        var parent = element.parentNode;
        var unWrapNode = [];
        while (element.firstChild) {
            unWrapNode.push(element.firstChild);
            parent.insertBefore(element.firstChild, element);
        }
        unWrapNode = unWrapNode.length > 0 ? unWrapNode : [element.parentNode];
        parent.removeChild(element);
        return unWrapNode;
    };
    /**
     * getSelectedNode method
     *
     * @param {Element} element - specifies the element
     * @param {number} index - specifies the index value.
     * @returns {Element} - returns the element
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.getSelectedNode = function (element, index) {
        if (element.nodeType === Node.ELEMENT_NODE && element.childNodes.length > 0 &&
            element.childNodes[index - 1] && element.childNodes[index - 1].nodeType === Node.ELEMENT_NODE &&
            (element.childNodes[index - 1].classList.contains(markerClassName.startSelection) ||
                element.childNodes[index - 1].classList.contains(markerClassName.endSelection))) {
            element = element.childNodes[index - 1];
        }
        else if (element.nodeType === Node.ELEMENT_NODE && element.childNodes.length > 0 && element.childNodes[index]) {
            element = element.childNodes[index];
        }
        if (element.nodeType === Node.TEXT_NODE) {
            element = element.parentNode;
        }
        return element;
    };
    /**
     * nodeFinds method
     *
     * @param {Element} element - specifies the element.
     * @param {Element[]} elements - specifies the array of elements
     * @returns {Element[]} - returnts the array elements
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.nodeFinds = function (element, elements) {
        var existNodes = [];
        for (var i = 0; i < elements.length; i++) {
            if (element.contains(elements[i]) && element !== elements[i]) {
                existNodes.push(elements[i]);
            }
        }
        return existNodes;
    };
    /**
     * isEditorArea method
     *
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.isEditorArea = function () {
        var range = this.getRangePoint(0);
        var element;
        for (element = range.commonAncestorContainer; element && !this.isElement(element); null) {
            element = element.parentNode;
        }
        return !!this.isElement(element);
    };
    /**
     * getRangePoint method
     *
     * @param {number} point - specifies the number value.
     * @returns {Range} - returns the range.
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.getRangePoint = function (point) {
        var selection = this.getSelection();
        var ranges = [];
        if (selection && selection.getRangeAt && selection.rangeCount) {
            ranges = [];
            for (var f = 0; f < selection.rangeCount; f++) {
                ranges.push(selection.getRangeAt(f));
            }
        }
        else {
            ranges = [this.currentDocument.createRange()];
        }
        return 'undefined' !== typeof point ? ranges[point] : ranges;
    };
    DOMNode.prototype.getSelection = function () {
        return this.nodeSelection.get(this.currentDocument);
    };
    /**
     * getPreviousNode method
     *
     * @param {Element} element - specifies the element
     * @returns {Element} - returns the element
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.getPreviousNode = function (element) {
        element = element.previousElementSibling;
        for (; element && element.textContent === '\n'; null) {
            element = element.previousElementSibling;
        }
        return element;
    };
    /**
     * encode method
     *
     * @param {string} value - specifies the string value
     * @returns {string} - specifies the string value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.encode = function (value) {
        var divNode = document.createElement('div');
        divNode.innerText = value;
        // eslint-disable-next-line
        return divNode.innerHTML.replace(/<br\s*[\/]?>/gi, '\n');
    };
    /**
     * saveMarker method
     *
     * @param {NodeSelection} save - specifies the node selection,
     * @param {string} action - specifies the action  value.
     * @returns {NodeSelection} - returns the value
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.saveMarker = function (save, action) {
        var start = this.parent.querySelector('.' + markerClassName.startSelection);
        var end = this.parent.querySelector('.' + markerClassName.endSelection);
        var startTextNode;
        var endTextNode;
        if (start.textContent === '' && sf.base.isNullOrUndefined(end) && action !== 'tab') {
            if (start.childNodes.length === 1 && start.childNodes[0].nodeName === 'BR') {
                start.innerHTML = '&#65279;&#65279;<br>';
            }
            else {
                start.innerHTML = '&#65279;&#65279;';
            }
        }
        if (this.hasClass(start, markerClassName.startSelection) && start.classList.length > 1) {
            var replace = this.createTagString(DEFAULT_TAG, start, this.encode(start.textContent));
            this.replaceWith(start, replace);
            start = this.parent.querySelector('.' + markerClassName.startSelection);
            start.classList.remove(markerClassName.startSelection);
            startTextNode = start.childNodes[0];
        }
        else {
            startTextNode = this.unWrap(start)[0];
        }
        if (this.hasClass(end, markerClassName.endSelection) && end.classList.length > 1) {
            var replace = this.createTagString(DEFAULT_TAG, end, this.encode(end.textContent));
            this.replaceWith(end, replace);
            end = this.parent.querySelector('.' + markerClassName.endSelection);
            end.classList.remove(markerClassName.endSelection);
            endTextNode = end.childNodes[0];
        }
        else {
            endTextNode = end ? this.unWrap(end)[0] : startTextNode;
        }
        save.startContainer = save.getNodeArray(startTextNode, true);
        save.endContainer = save.getNodeArray(endTextNode, false);
        return save;
    };
    DOMNode.prototype.marker = function (className, textContent) {
        return '<span class="' + className + '">' + textContent + '</span>';
    };
    /**
     * setMarker method
     *
     * @param {NodeSelection} save - specifies the node selection.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.setMarker = function (save) {
        var range = save.range;
        var startChildNodes = range.startContainer.childNodes;
        var isTableStart = startChildNodes.length > 1 && startChildNodes[0].nodeName === 'TABLE';
        var start = ((isTableStart ? getLastTextNode(startChildNodes[range.startOffset + 1]) :
            startChildNodes[(range.startOffset > 0) ? (range.startOffset - 1) : range.startOffset]) || range.startContainer);
        var end = (range.endContainer.childNodes[(range.endOffset > 0) ? (range.endOffset - 1) : range.endOffset]
            || range.endContainer);
        if ((start.nodeType === Node.ELEMENT_NODE && end.nodeType === Node.ELEMENT_NODE) && (start.contains(end) || end.contains(start))) {
            var existNode = start.contains(end) ? start : end;
            var isElement = existNode.nodeType !== Node.TEXT_NODE;
            if (isElement) {
                var nodes = [];
                var textNodes = [];
                for (var node = existNode; existNode.contains(node); null) {
                    if (nodes.indexOf(node) < 0 && node.childNodes && node.childNodes.length) {
                        nodes.push(node);
                        node = node.childNodes[0];
                    }
                    else if (node.nextSibling) {
                        node = node.nextSibling;
                    }
                    else if (node.parentNode) {
                        node = node.parentNode;
                        nodes.push(node);
                    }
                    if (textNodes.indexOf(node) < 0 && (node.nodeType === Node.TEXT_NODE ||
                        (IGNORE_BLOCK_TAGS.indexOf(node.parentNode.tagName.toLocaleLowerCase()) >= 0
                            && (node.tagName === 'BR' || node.tagName === 'IMG')))) {
                        textNodes.push(node);
                    }
                }
                if (textNodes.length) {
                    start = start.contains(end) ? textNodes[0] : start;
                    end = textNodes[textNodes.length - 1];
                }
            }
        }
        if (start !== end) {
            if (start.nodeType !== Node.TEXT_NODE && ((start.tagName === 'BR' &&
                IGNORE_BLOCK_TAGS.indexOf(start.parentNode.tagName.toLocaleLowerCase()) >= 0) ||
                start.tagName === 'IMG')) {
                this.replaceWith(start, this.marker(markerClassName.startSelection, this.encode(start.textContent)));
                var markerStart = range.startContainer.querySelector('.' + markerClassName.startSelection);
                markerStart.appendChild(start);
            }
            else {
                this.replaceWith(start, this.marker(markerClassName.startSelection, this.encode(start.textContent)));
            }
            if (end.nodeType !== Node.TEXT_NODE && end.tagName === 'BR' &&
                IGNORE_BLOCK_TAGS.indexOf(end.parentNode.tagName.toLocaleLowerCase()) >= 0) {
                this.replaceWith(end, this.marker(markerClassName.endSelection, this.encode(end.textContent)));
                var markerEnd = range.endContainer.querySelector('.' + markerClassName.endSelection);
                markerEnd.appendChild(end);
            }
            else {
                this.ensureSelfClosingTag(end, markerClassName.endSelection, range);
            }
        }
        else {
            this.ensureSelfClosingTag(start, markerClassName.startSelection, range);
        }
    };
    /**
     * ensureSelfClosingTag method
     *
     * @param {Element} start - specifies the element.
     * @param {string} className - specifes the class name string value
     * @param {Range} range - specifies the range value
     * @returns {void}
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.ensureSelfClosingTag = function (start, className, range) {
        var isTable = false;
        if (start.nodeType === 3) {
            this.replaceWith(start, this.marker(className, this.encode(start.textContent)));
        }
        else if (start.tagName === 'BR') {
            this.replaceWith(start, this.marker(className, this.encode(start.textContent)));
            var markerStart = range.startContainer.querySelector('.' + className);
            markerStart.appendChild(start);
        }
        else {
            if (start.tagName === 'IMG') {
                var parNode = document.createElement('p');
                start.parentElement.insertBefore(parNode, start);
                parNode.appendChild(start);
                start = parNode.children[0];
            }
            if (start.tagName === 'TABLE') {
                isTable = true;
                if (start.textContent === '') {
                    var tdNode = start.querySelectorAll('td');
                    start = tdNode[tdNode.length - 1];
                    start = !sf.base.isNullOrUndefined(start.childNodes[0]) ? start.childNodes[0] : start;
                }
                else {
                    var lastNode = start.lastChild;
                    while (lastNode.nodeType !== 3 && lastNode.nodeName !== '#text' &&
                        lastNode.nodeName !== 'BR') {
                        lastNode = lastNode.lastChild;
                    }
                    start = lastNode;
                }
            }
            for (var i = 0; i < selfClosingTags.length; i++) {
                start = (start.tagName === selfClosingTags[i] && !isTable) ? start.parentNode : start;
            }
            if (start.nodeType === 3 && start.nodeName === '#text') {
                this.replaceWith(start, this.marker(className, this.encode(start.textContent)));
            }
            else if (start.nodeName === 'BR') {
                this.replaceWith(start, this.marker(markerClassName.endSelection, this.encode(start.textContent)));
                var markerEnd = range.endContainer.querySelector('.' + markerClassName.endSelection);
                markerEnd.appendChild(start);
            }
            else {
                var marker = this.marker(className, '');
                sf.base.append([this.parseHTMLFragment(marker)], start);
            }
        }
    };
    /**
     * createTempNode method
     *
     * @param {Element} element - specifies the element.
     * @returns {Element} - returns the element
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.createTempNode = function (element) {
        var textContent = element.textContent;
        if (element.tagName === 'BR') {
            var wrapper = '<' + DEFAULT_TAG + '></' + DEFAULT_TAG + '>';
            var node = element.parentNode;
            if (IGNORE_BLOCK_TAGS.indexOf(node.tagName.toLocaleLowerCase()) >= 0) {
                element = this.wrap(element, this.parseHTMLFragment(wrapper));
            }
        }
        else if (((element.nodeType !== Node.TEXT_NODE &&
            (element.classList.contains(markerClassName.startSelection) ||
                element.classList.contains(markerClassName.endSelection))) ||
            textContent.replace(/\n/g, '').replace(/(^ *)|( *$)/g, '').length > 0 ||
            textContent.length && textContent.indexOf('\n') < 0)) {
            var wrapper = '<' + DEFAULT_TAG + '></' + DEFAULT_TAG + '>';
            var target = element;
            element = this.wrap(element, this.parseHTMLFragment(wrapper));
            var ignoreBr = target.nodeType === Node.ELEMENT_NODE && target.firstChild && target.firstChild.nodeName === 'BR'
                && (target.classList.contains(markerClassName.startSelection) ||
                    target.classList.contains(markerClassName.endSelection));
            if (!ignoreBr && element.nextElementSibling && element.nextElementSibling.tagName === 'BR') {
                element.appendChild(element.nextElementSibling);
            }
        }
        return element;
    };
    /**
     * getImageTagInSelection method
     *
     * @returns {void}
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.getImageTagInSelection = function () {
        var selection = this.getSelection();
        if (this.isEditorArea() && selection.rangeCount) {
            return selection.focusNode.querySelectorAll('img');
        }
        return null;
    };
    /**
     * blockNodes method
     *
     * @returns {Node[]} - returns the node array values
     * @hidden
     * @deprecated
     */
    DOMNode.prototype.blockNodes = function () {
        var collectionNodes = [];
        var selection = this.getSelection();
        if (this.isEditorArea() && selection.rangeCount) {
            var ranges = this.getRangePoint();
            for (var j = 0; j < ranges.length; j++) {
                var parentNode = void 0;
                var range = ranges[j];
                var startNode = this.getSelectedNode(range.startContainer, range.startOffset);
                var endNode = this.getSelectedNode(range.endContainer, range.endOffset);
                if (this.isBlockNode(startNode) && collectionNodes.indexOf(startNode) < 0) {
                    collectionNodes.push(startNode);
                }
                parentNode = this.blockParentNode(startNode);
                if (parentNode && collectionNodes.indexOf(parentNode) < 0) {
                    if (IGNORE_BLOCK_TAGS.indexOf(parentNode.tagName.toLocaleLowerCase()) >= 0 && (startNode.tagName === 'BR' ||
                        startNode.nodeType === Node.TEXT_NODE ||
                        startNode.classList.contains(markerClassName.startSelection) ||
                        startNode.classList.contains(markerClassName.endSelection))) {
                        var tempNode = startNode.previousSibling &&
                            startNode.previousSibling.nodeType === Node.TEXT_NODE ?
                            startNode.previousSibling : startNode;
                        if (!startNode.nextSibling && !startNode.previousSibling && startNode.tagName === 'BR') {
                            collectionNodes.push(tempNode);
                        }
                        else {
                            collectionNodes.push(this.createTempNode(tempNode));
                        }
                    }
                    else {
                        collectionNodes.push(parentNode);
                    }
                }
                var nodes = [];
                for (var node = startNode; node !== endNode && node !== this.parent; null) {
                    if (nodes.indexOf(node) < 0 && node.childNodes && node.childNodes.length) {
                        nodes.push(node);
                        node = node.childNodes[0];
                    }
                    else if (node && node.nodeType !== 8 && (node.tagName === 'BR' || (node.nodeType === Node.TEXT_NODE &&
                        node.textContent.trim() !== '') || (node.nodeType !== Node.TEXT_NODE &&
                        (node.classList.contains(markerClassName.startSelection) ||
                            node.classList.contains(markerClassName.endSelection)))) &&
                        IGNORE_BLOCK_TAGS.indexOf(node.parentNode.tagName.toLocaleLowerCase()) >= 0) {
                        node = this.createTempNode(node);
                    }
                    else if (node.nextSibling && node.nextSibling.nodeType !== 8 &&
                        (node.nextSibling.tagName === 'BR' ||
                            node.nextSibling.nodeType === Node.TEXT_NODE ||
                            node.nextSibling.classList.contains(markerClassName.startSelection) ||
                            node.nextSibling.classList.contains(markerClassName.endSelection)) &&
                        IGNORE_BLOCK_TAGS.indexOf(node.nextSibling.parentNode.tagName.toLocaleLowerCase()) >= 0) {
                        node = this.createTempNode(node.nextSibling);
                    }
                    else if (node.nextSibling) {
                        node = node.nextSibling;
                    }
                    else if (node.parentNode) {
                        node = node.parentNode;
                        nodes.push(node);
                    }
                    if (collectionNodes.indexOf(node) < 0 && node.nodeType === Node.ELEMENT_NODE &&
                        IGNORE_BLOCK_TAGS.indexOf(node.parentNode.tagName.toLocaleLowerCase()) >= 0 &&
                        (node.classList.contains(markerClassName.startSelection) ||
                            node.classList.contains(markerClassName.endSelection))) {
                        collectionNodes.push(this.createTempNode(node));
                    }
                    if (this.isBlockNode(node) && this.ignoreTableTag(node) && nodes.indexOf(node) < 0 &&
                        collectionNodes.indexOf(node) < 0 && (node !== endNode || range.endOffset > 0)) {
                        collectionNodes.push(node);
                    }
                    if (node.nodeName === 'IMG' && node.parentElement.contentEditable === 'true') {
                        collectionNodes.push(node);
                    }
                }
                parentNode = this.blockParentNode(endNode);
                if (parentNode && this.ignoreTableTag(parentNode) && collectionNodes.indexOf(parentNode) < 0 &&
                    (!sf.base.isNullOrUndefined(parentNode.previousElementSibling) && parentNode.previousElementSibling.tagName !== 'IMG')) {
                    collectionNodes.push(parentNode);
                }
            }
        }
        for (var i = collectionNodes.length - 1; i > 0; i--) {
            var nodes = this.nodeFinds(collectionNodes[i], collectionNodes);
            if (nodes.length) {
                var listNodes = collectionNodes[i].querySelectorAll('ul, ol');
                if (collectionNodes[i].tagName === 'LI' && listNodes.length > 0) {
                    continue;
                }
                else {
                    collectionNodes.splice(i, 1);
                }
            }
        }
        return collectionNodes;
    };
    DOMNode.prototype.ignoreTableTag = function (element) {
        return !(TABLE_BLOCK_TAGS.indexOf(element.tagName.toLocaleLowerCase()) >= 0);
    };
    return DOMNode;
}());

/**
 * Lists internal component
 *
 * @hidden
 * @deprecated
 */
var Lists = /** @class */ (function () {
    /**
     * Constructor for creating the Lists plugin
     *
     * @param {EditorManager} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function Lists(parent) {
        this.parent = parent;
        this.domNode = this.parent.domNode;
        this.addEventListener();
    }
    Lists.prototype.addEventListener = function () {
        this.parent.observer.on(LIST_TYPE, this.applyListsHandler, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.keyDownHandler, this);
        this.parent.observer.on(SPACE_ACTION, this.spaceKeyAction, this);
    };
    Lists.prototype.testList = function (elem) {
        var olListRegex = [/^[\d]+[.]+$/,
            /^(?=[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})[.]$/gi,
            /^[a-zA-Z][.]+$/];
        var elementStart = !sf.base.isNullOrUndefined(elem) ? elem.innerText.trim().split('.')[0] + '.' : null;
        if (!sf.base.isNullOrUndefined(elementStart)) {
            for (var i = 0; i < olListRegex.length; i++) {
                if (olListRegex[i].test(elementStart)) {
                    return true;
                }
            }
        }
        return false;
    };
    Lists.prototype.testCurrentList = function (range) {
        var olListStartRegex = [/^[1]+[.]+$/, /^[i]+[.]+$/, /^[a]+[.]+$/];
        if (!sf.base.isNullOrUndefined(range.startContainer.textContent.slice(0, range.startOffset))) {
            for (var i = 0; i < olListStartRegex.length; i++) {
                if (olListStartRegex[i].test(range.startContainer.textContent.replace(/\u200B/g, '').slice(0, range.startOffset).trim())) {
                    return true;
                }
            }
        }
        return false;
    };
    Lists.prototype.spaceList = function (e) {
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        this.saveSelection = this.parent.nodeSelection.save(range, this.parent.currentDocument);
        var startNode = this.parent.domNode.getSelectedNode(range.startContainer, range.startOffset);
        // eslint-disable-next-line
        var endNode = this.parent.domNode.getSelectedNode(range.endContainer, range.endOffset);
        var preElement = startNode.previousElementSibling;
        var nextElement = startNode.nextElementSibling;
        var preElemULStart = !sf.base.isNullOrUndefined(preElement) ?
            preElement.innerText.trim().substring(0, 1) : null;
        var nextElemULStart = !sf.base.isNullOrUndefined(nextElement) ?
            nextElement.innerText.trim().substring(0, 1) : null;
        var startElementOLTest = this.testCurrentList(range);
        var preElementOLTest = this.testList(preElement);
        var nextElementOLTest = this.testList(nextElement);
        if (!preElementOLTest && !nextElementOLTest && preElemULStart !== '*' && nextElemULStart !== '*') {
            if (startElementOLTest) {
                range.startContainer.textContent = range.startContainer.textContent.slice(range.startOffset, range.startContainer.textContent.length);
                this.applyListsHandler({ subCommand: 'OL', callBack: e.callBack });
                e.event.preventDefault();
            }
            else if (range.startContainer.textContent.replace(/\u200B/g, '').slice(0, range.startOffset).trim() === '*' ||
                range.startContainer.textContent.replace(/\u200B/g, '').slice(0, range.startOffset).trim() === '-') {
                range.startContainer.textContent = range.startContainer.textContent.slice(range.startOffset, range.startContainer.textContent.length);
                this.applyListsHandler({ subCommand: 'UL', callBack: e.callBack });
                e.event.preventDefault();
            }
        }
    };
    // eslint-disable-next-line
    Lists.prototype.enterList = function (e) {
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        var startNode = range.startContainer.nodeName === 'LI' ? range.startContainer :
            range.startContainer.parentElement.closest('LI');
        var endNode = range.endContainer.nodeName === 'LI' ? range.endContainer :
            range.endContainer.parentElement.closest('LI');
        if (!sf.base.isNullOrUndefined(startNode) && !sf.base.isNullOrUndefined(endNode) && startNode === endNode && startNode.tagName === 'LI' && startNode.textContent.trim() === '') {
            if (startNode.textContent.charCodeAt(0) === 65279) {
                startNode.textContent = '';
            }
            var startNodeParent = startNode.parentElement;
            if (sf.base.isNullOrUndefined(startNodeParent.parentElement.closest('UL')) && sf.base.isNullOrUndefined(startNodeParent.parentElement.closest('OL'))) {
                if (!sf.base.isNullOrUndefined(startNode.nextElementSibling)) {
                    var nearBlockNode = this.parent.domNode.blockParentNode(startNode);
                    this.parent.nodeCutter.GetSpliceNode(range, nearBlockNode);
                }
                var insertTag = void 0;
                if (e.enterAction === 'DIV') {
                    insertTag = sf.base.createElement('div');
                    insertTag.innerHTML = '<br>';
                }
                else if (e.enterAction === 'P') {
                    insertTag = sf.base.createElement('p');
                    insertTag.innerHTML = '<br>';
                }
                else {
                    insertTag = sf.base.createElement('br');
                }
                this.parent.domNode.insertAfter(insertTag, startNodeParent);
                e.event.preventDefault();
                this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, insertTag, 0);
                if (startNodeParent.textContent === '') {
                    sf.base.detach(startNodeParent);
                }
                else {
                    sf.base.detach(startNode);
                }
            }
        }
    };
    // eslint-disable-next-line
    Lists.prototype.backspaceList = function (e) {
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        var startNode = this.parent.domNode.getSelectedNode(range.startContainer, range.startOffset);
        var endNode = this.parent.domNode.getSelectedNode(range.endContainer, range.endOffset);
        startNode = startNode.nodeName === 'BR' ? startNode.parentElement : startNode;
        endNode = endNode.nodeName === 'BR' ? endNode.parentElement : endNode;
        if (startNode === endNode && !sf.base.isNullOrUndefined(sf.base.closest(startNode, 'li')) &&
            ((startNode.textContent.trim() === '' && startNode.textContent.charCodeAt(0) === 65279) ||
                (startNode.textContent.length === 1 && startNode.textContent.charCodeAt(0) === 8203))) {
            startNode.textContent = '';
        }
        if (startNode === endNode && startNode.textContent === '') {
            if (startNode.parentElement.tagName === 'LI' && endNode.parentElement.tagName === 'LI') {
                sf.base.detach(startNode);
            }
            else if (startNode.closest('ul') || startNode.closest('ol')) {
                var parentList = !sf.base.isNullOrUndefined(startNode.closest('ul')) ? startNode.closest('ul') : startNode.closest('ol');
                if (parentList.firstElementChild === startNode && !sf.base.isNullOrUndefined(parentList.children[1]) &&
                    (parentList.children[1].tagName === 'OL' || parentList.children[1].tagName === 'UL')) {
                    if (parentList.tagName === parentList.children[1].tagName) {
                        while (parentList.children[1].lastChild) {
                            this.parent.domNode.insertAfter(parentList.children[1].lastChild, parentList.children[1]);
                        }
                        sf.base.detach(parentList.children[1]);
                    }
                    else {
                        parentList.parentElement.insertBefore(parentList.children[1], parentList);
                    }
                }
            }
        }
        else if (!sf.base.isNullOrUndefined(startNode.firstChild) && startNode.firstChild.nodeName === 'BR' &&
            (!sf.base.isNullOrUndefined(startNode.childNodes[1]) && (startNode.childNodes[1].nodeName === 'UL' ||
                startNode.childNodes[1].nodeName === 'OL'))) {
            var parentList = !sf.base.isNullOrUndefined(startNode.closest('ul')) ? startNode.closest('ul') : startNode.closest('ol');
            if (parentList.tagName === startNode.childNodes[1].nodeName) {
                while (startNode.childNodes[1].lastChild) {
                    this.parent.domNode.insertAfter(startNode.children[1].lastChild, startNode);
                }
                sf.base.detach(startNode.childNodes[1]);
            }
            else {
                parentList.parentElement.insertBefore(startNode.children[1], parentList);
            }
        }
    };
    Lists.prototype.keyDownHandler = function (e) {
        if (e.event.which === 13) {
            this.enterList(e);
        }
        if (e.event.which === 32) {
            this.spaceList(e);
        }
        if (e.event.which === 8) {
            this.backspaceList(e);
        }
        if (e.event.which === 46 && e.event.action === 'delete') {
            var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
            var commonAncestor = range.commonAncestorContainer;
            var startEle = range.startContainer;
            var endEle = range.endContainer;
            var startNode = startEle.nodeType === 3 ? startEle.parentElement : startEle;
            var endNode = endEle.nodeType === 3 ? endEle.parentElement : endEle;
            if ((commonAncestor.nodeName === 'UL' || commonAncestor.nodeName === 'OL') && startNode !== endNode
                && (!sf.base.isNullOrUndefined(sf.base.closest(startNode, 'ul')) || !sf.base.isNullOrUndefined(sf.base.closest(startNode, 'ol')))
                && (!sf.base.isNullOrUndefined(sf.base.closest(endNode, 'ul')) || !sf.base.isNullOrUndefined(sf.base.closest(endNode, 'ol')))
                && (commonAncestor.lastElementChild === sf.base.closest(endNode, 'li')) && !range.collapsed) {
                sf.base.detach(commonAncestor);
            }
        }
        if (e.event.which === 9) {
            var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
            if (!(e.event.action && e.event.action === 'indent')) {
                this.saveSelection = this.parent.nodeSelection.save(range, this.parent.currentDocument);
            }
            var blockNodes = void 0;
            var startOffset = range.startOffset;
            var endOffset = range.endOffset;
            var startNode = this.parent.domNode.getSelectedNode(range.startContainer, range.startOffset);
            var endNode = this.parent.domNode.getSelectedNode(range.endContainer, range.endOffset);
            if ((startNode === endNode && (startNode.nodeName === 'BR' || startNode.nodeName === '#text') &&
                IGNORE_BLOCK_TAGS.indexOf(startNode.parentNode.tagName.toLocaleLowerCase()) >= 0)) {
                return;
            }
            else {
                if (!(e.event.action && e.event.action === 'indent')) {
                    this.domNode.setMarker(this.saveSelection);
                }
                blockNodes = this.domNode.blockNodes();
            }
            var nodes = [];
            var isNested = true;
            for (var i = 0; i < blockNodes.length; i++) {
                if (blockNodes[i].parentNode.tagName === 'LI') {
                    nodes.push(blockNodes[i].parentNode);
                }
                else if (blockNodes[i].tagName === 'LI' && blockNodes[i].childNodes[0].tagName !== 'P' &&
                    (blockNodes[i].childNodes[0].tagName !== 'OL' &&
                        blockNodes[i].childNodes[0].tagName !== 'UL')) {
                    nodes.push(blockNodes[i]);
                }
            }
            if (nodes.length > 1 || nodes.length && ((startOffset === 0 && endOffset === 0) || e.ignoreDefault)) {
                e.event.preventDefault();
                e.event.stopPropagation();
                this.currentAction = this.getAction(nodes[0]);
                if (e.event.shiftKey) {
                    this.revertList(nodes);
                    this.revertClean();
                }
                else {
                    isNested = this.nestedList(nodes);
                }
                if (isNested) {
                    this.cleanNode();
                    this.parent.editableElement.focus();
                }
                if (!(e.event.action && e.event.action === 'indent')) {
                    this.saveSelection = this.domNode.saveMarker(this.saveSelection);
                    this.saveSelection.restore();
                    if (e.callBack) {
                        e.callBack({
                            requestType: this.currentAction,
                            editorMode: 'HTML',
                            range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                            elements: this.parent.domNode.blockNodes(),
                            event: e.event
                        });
                    }
                }
            }
            else {
                if (!(e.event.action && e.event.action === 'indent')) {
                    if (e.event && e.event.shiftKey && e.event.key === 'Tab') {
                        e.event.action = 'tab';
                    }
                    this.saveSelection = this.domNode.saveMarker(this.saveSelection, e.event.action);
                    this.saveSelection.restore();
                }
            }
        }
        else {
            switch (e.event.action) {
                case 'ordered-list':
                    this.applyListsHandler({ subCommand: 'OL', callBack: e.callBack });
                    e.event.preventDefault();
                    break;
                case 'unordered-list':
                    this.applyListsHandler({ subCommand: 'UL', callBack: e.callBack });
                    e.event.preventDefault();
                    break;
            }
        }
    };
    Lists.prototype.spaceKeyAction = function (e) {
        if (e.event.which === 32) {
            this.spaceList(e);
        }
    };
    Lists.prototype.getAction = function (element) {
        var parentNode = element.parentNode;
        return (parentNode.nodeName === 'OL' ? 'OL' : 'UL');
    };
    Lists.prototype.revertClean = function () {
        var collectionNodes = this.parent.editableElement.querySelectorAll('ul, ol');
        for (var i = 0; i < collectionNodes.length; i++) {
            var listNodes = collectionNodes[i].querySelectorAll('ul, ol');
            if (listNodes.length > 0) {
                for (var j = 0; j < listNodes.length; j++) {
                    var prevSibling = listNodes[j].previousSibling;
                    if (prevSibling && prevSibling.tagName === 'LI') {
                        prevSibling.appendChild(listNodes[j]);
                    }
                }
            }
        }
    };
    Lists.prototype.noPreviousElement = function (elements) {
        var firstNode;
        var firstNodeOL;
        var siblingListOL = elements.querySelectorAll('ol, ul');
        var siblingListLI = elements
            .querySelectorAll('li');
        var siblingListLIFirst = this.domNode.contents(siblingListLI[0])[0];
        if (siblingListLI.length > 0 && (siblingListLIFirst.nodeName === 'OL' || siblingListLIFirst.nodeName === 'UL')) {
            firstNode = siblingListLI[0];
        }
        else {
            firstNodeOL = siblingListOL[0];
        }
        if (firstNode) {
            for (var h = this.domNode.contents(elements)[0]; h && !this.domNode.isList(h); null) {
                var nextSibling = h.nextSibling;
                sf.base.prepend([h], firstNode);
                sf.base.setStyleAttribute(elements, { 'list-style-type': 'none' });
                sf.base.setStyleAttribute(firstNode, { 'list-style-type': '' });
                h = nextSibling;
            }
        }
        else if (firstNodeOL) {
            var nestedElement = sf.base.createElement('li');
            sf.base.prepend([nestedElement], firstNodeOL);
            for (var h = this.domNode.contents(elements)[0]; h && !this.domNode.isList(h); null) {
                var nextSibling = h.nextSibling;
                nestedElement.appendChild(h);
                h = nextSibling;
            }
            sf.base.prepend([firstNodeOL], elements.parentNode);
            sf.base.detach(elements);
            var nestedElementLI = sf.base.createElement('li', { styles: 'list-style-type: none;' });
            sf.base.prepend([nestedElementLI], firstNodeOL.parentNode);
            sf.base.append([firstNodeOL], nestedElementLI);
        }
        else {
            var nestedElementLI = sf.base.createElement('li', { styles: 'list-style-type: none;' });
            sf.base.prepend([nestedElementLI], elements.parentNode);
            var nestedElement = sf.base.createElement(elements.parentNode.tagName);
            sf.base.prepend([nestedElement], nestedElementLI);
            sf.base.append([elements], nestedElement);
        }
    };
    Lists.prototype.nestedList = function (elements) {
        var isNested = false;
        for (var i = 0; i < elements.length; i++) {
            var prevSibling = this.domNode.getPreviousNode(elements[i]);
            if (prevSibling) {
                isNested = true;
                var firstNode = void 0;
                var firstNodeLI = void 0;
                var siblingListOL = elements[i].querySelectorAll('ol, ul');
                var siblingListLI = elements[i]
                    .querySelectorAll('li');
                var siblingListLIFirst = this.domNode.contents(siblingListLI[0])[0];
                if (siblingListLI.length > 0 && (siblingListLIFirst.nodeName === 'OL' || siblingListLIFirst.nodeName === 'UL')) {
                    firstNodeLI = siblingListLI[0];
                }
                else {
                    firstNode = siblingListOL[0];
                }
                if (firstNode) {
                    var nestedElement = sf.base.createElement('li');
                    sf.base.prepend([nestedElement], firstNode);
                    for (var h = this.domNode.contents(elements[i])[0]; h && !this.domNode.isList(h); null) {
                        var nextSibling = h.nextSibling;
                        nestedElement.appendChild(h);
                        h = nextSibling;
                    }
                    sf.base.append([firstNode], prevSibling);
                    sf.base.detach(elements[i]);
                }
                else if (firstNodeLI) {
                    if (prevSibling.tagName === 'LI') {
                        for (var h = this.domNode.contents(elements[i])[0]; h && !this.domNode.isList(h); null) {
                            var nextSibling = h.nextSibling;
                            sf.base.prepend([h], firstNodeLI);
                            sf.base.setStyleAttribute(elements[i], { 'list-style-type': 'none' });
                            sf.base.setStyleAttribute(firstNodeLI, { 'list-style-type': '' });
                            h = nextSibling;
                        }
                        sf.base.append([firstNodeLI.parentNode], prevSibling);
                        sf.base.detach(elements[i]);
                    }
                }
                else {
                    if (prevSibling.tagName === 'LI') {
                        var nestedElement = sf.base.createElement(elements[i].parentNode.tagName);
                        sf.base.append([nestedElement], prevSibling);
                        sf.base.append([elements[i]], nestedElement);
                    }
                }
            }
            else {
                var element = elements[i];
                isNested = true;
                this.noPreviousElement(element);
            }
        }
        return isNested;
    };
    Lists.prototype.applyListsHandler = function (e) {
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        this.saveSelection = this.parent.nodeSelection.save(range, this.parent.currentDocument);
        this.currentAction = e.subCommand;
        this.currentAction = e.subCommand = this.currentAction === 'NumberFormatList' ? 'OL' : this.currentAction === 'BulletFormatList' ? 'UL' : this.currentAction;
        this.domNode.setMarker(this.saveSelection);
        var listsNodes = this.domNode.blockNodes();
        if (e.enterAction === 'BR') {
            this.setSelectionBRConfig();
            var allSelectedNode = this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument);
            var selectedNodes = this.parent.nodeSelection.getSelectionNodes(allSelectedNode);
            var currentFormatNodes = [];
            if (selectedNodes.length === 0) {
                selectedNodes.push(listsNodes[0]);
            }
            for (var i = 0; i < selectedNodes.length; i++) {
                var currentNode = selectedNodes[i];
                var previousCurrentNode = void 0;
                while (!this.parent.domNode.isBlockNode(currentNode) && currentNode !== this.parent.editableElement) {
                    previousCurrentNode = currentNode;
                    currentNode = currentNode.parentElement;
                }
                if (this.parent.domNode.isBlockNode(currentNode) && currentNode === this.parent.editableElement) {
                    currentFormatNodes.push(previousCurrentNode);
                }
            }
            for (var i = 0; i < currentFormatNodes.length; i++) {
                if (!this.parent.domNode.isBlockNode(currentFormatNodes[i])) {
                    var currentNode = currentFormatNodes[i];
                    var previousNode = currentNode;
                    while (currentNode === this.parent.editableElement) {
                        previousNode = currentNode;
                        currentNode = currentNode.parentElement;
                    }
                    var tempElem = void 0;
                    if (this.parent.domNode.isBlockNode(previousNode.parentElement) &&
                        previousNode.parentElement === this.parent.editableElement) {
                        tempElem = sf.base.createElement('p');
                        previousNode.parentElement.insertBefore(tempElem, previousNode);
                        tempElem.appendChild(previousNode);
                    }
                    else {
                        tempElem = previousNode;
                    }
                    var preNode = tempElem.previousSibling;
                    while (!sf.base.isNullOrUndefined(preNode) && preNode.nodeName !== 'BR' &&
                        !this.parent.domNode.isBlockNode(preNode)) {
                        tempElem.firstChild.parentElement.insertBefore(preNode, tempElem.firstChild);
                        preNode = tempElem.previousSibling;
                    }
                    if (!sf.base.isNullOrUndefined(preNode) && preNode.nodeName === 'BR') {
                        sf.base.detach(preNode);
                    }
                    var postNode = tempElem.nextSibling;
                    while (!sf.base.isNullOrUndefined(postNode) && postNode.nodeName !== 'BR' &&
                        !this.parent.domNode.isBlockNode(postNode)) {
                        tempElem.appendChild(postNode);
                        postNode = tempElem.nextSibling;
                    }
                    if (!sf.base.isNullOrUndefined(postNode) && postNode.nodeName === 'BR') {
                        sf.base.detach(postNode);
                    }
                }
            }
            this.setSelectionBRConfig();
            listsNodes = this.parent.domNode.blockNodes();
        }
        for (var i = 0; i < listsNodes.length; i++) {
            if (listsNodes[i].tagName === 'TABLE' && !range.collapsed) {
                listsNodes.splice(i, 1);
            }
            if (listsNodes.length > 0 && listsNodes[i].tagName !== 'LI'
                && 'LI' === listsNodes[i].parentNode.tagName) {
                listsNodes[i] = listsNodes[i].parentNode;
            }
        }
        this.applyLists(listsNodes, this.currentAction, e.selector, e.item);
        if (e.callBack) {
            e.callBack({
                requestType: this.currentAction,
                event: e.event,
                editorMode: 'HTML',
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.domNode.blockNodes()
            });
        }
    };
    Lists.prototype.setSelectionBRConfig = function () {
        var startElem = this.parent.editableElement.querySelector('.' + markerClassName.startSelection);
        var endElem = this.parent.editableElement.querySelector('.' + markerClassName.endSelection);
        if (sf.base.isNullOrUndefined(endElem)) {
            this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, startElem, 0);
        }
        else {
            this.parent.nodeSelection.setSelectionText(this.parent.currentDocument, startElem, endElem, 0, 0);
        }
    };
    Lists.prototype.applyLists = function (elements, type, selector, item) {
        if (this.isRevert(elements, type) && sf.base.isNullOrUndefined(item)) {
            this.revertList(elements);
            this.removeEmptyListElements();
        }
        else {
            this.checkLists(elements, type, item);
            for (var i = 0; i < elements.length; i++) {
                if (!sf.base.isNullOrUndefined(item) && !sf.base.isNullOrUndefined(item.listStyle)) {
                    if (item.listStyle === 'listImage') {
                        sf.base.setStyleAttribute(elements[i], { 'list-style-image': item.listImage });
                    }
                    else {
                        sf.base.setStyleAttribute(elements[i], { 'list-style-image': 'none' });
                        sf.base.setStyleAttribute(elements[i], { 'list-style-type': item.listStyle.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() });
                    }
                }
                if (elements[i].getAttribute('contenteditable') === 'true'
                    && elements[i].childNodes.length === 1 && elements[i].childNodes[0].nodeName === 'TABLE') {
                    var listEle = document.createElement(type);
                    listEle.innerHTML = '<li><br/></li>';
                    elements[i].appendChild(listEle);
                }
                else if ('LI' !== elements[i].tagName && sf.base.isNullOrUndefined(item)) {
                    var elemAtt = elements[i].tagName === 'IMG' ? '' : this.domNode.attributes(elements[i]);
                    var openTag = '<' + type + '>';
                    var closeTag = '</' + type + '>';
                    var newTag = 'li' + elemAtt;
                    var replaceHTML = (elements[i].tagName.toLowerCase() === DEFAULT_TAG ? elements[i].innerHTML :
                        elements[i].outerHTML);
                    var innerHTML = this.domNode.createTagString(newTag, null, replaceHTML);
                    var collectionString = openTag + innerHTML + closeTag;
                    this.domNode.replaceWith(elements[i], collectionString);
                }
                else if (!sf.base.isNullOrUndefined(item) && 'LI' !== elements[i].tagName) {
                    // eslint-disable-next-line
                    var elemAtt = elements[i].tagName === 'IMG' ? '' : this.domNode.attributes(elements[i]);
                    var openTag = '<' + type + elemAtt + '>';
                    var closeTag = '</' + type + '>';
                    var newTag = 'li';
                    var replaceHTML = (elements[i].tagName.toLowerCase() === DEFAULT_TAG ? elements[i].innerHTML :
                        elements[i].outerHTML);
                    var innerHTML = this.domNode.createTagString(newTag, null, replaceHTML);
                    var collectionString = openTag + innerHTML + closeTag;
                    this.domNode.replaceWith(elements[i], collectionString);
                }
            }
        }
        this.cleanNode();
        this.parent.editableElement.focus();
        if (isIDevice$1()) {
            setEditFrameFocus(this.parent.editableElement, selector);
        }
        this.saveSelection = this.domNode.saveMarker(this.saveSelection);
        this.saveSelection.restore();
    };
    Lists.prototype.removeEmptyListElements = function () {
        var listElem = this.parent.editableElement.querySelectorAll('ol, ul');
        for (var i = 0; i < listElem.length; i++) {
            if (listElem[i].textContent.trim() === '') {
                sf.base.detach(listElem[i]);
            }
        }
    };
    Lists.prototype.isRevert = function (nodes, tagName) {
        var isRevert = true;
        for (var i = 0; i < nodes.length; i++) {
            if (nodes[i].tagName !== 'LI') {
                return false;
            }
            if (nodes[i].parentNode.tagName !== tagName) {
                isRevert = false;
            }
        }
        return isRevert;
    };
    Lists.prototype.checkLists = function (nodes, tagName, item) {
        var nodesTemp = [];
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i].parentNode;
            if (!sf.base.isNullOrUndefined(item) && 'LI' === nodes[i].tagName && !sf.base.isNullOrUndefined(item.listStyle)) {
                if (item.listStyle === 'listImage') {
                    sf.base.setStyleAttribute(node, { 'list-style-image': item.listImage });
                }
                else {
                    sf.base.setStyleAttribute(node, { 'list-style-image': 'none' });
                    sf.base.setStyleAttribute(node, { 'list-style-type': item.listStyle.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() });
                }
            }
            if ((nodes[i].tagName === 'LI' && node.tagName !== tagName && nodesTemp.indexOf(node) < 0) ||
                (nodes[i].tagName === 'LI' && node.tagName === tagName && nodesTemp.indexOf(node) < 0 && item !== null)) {
                nodesTemp.push(node);
            }
        }
        for (var j = nodesTemp.length - 1; j >= 0; j--) {
            var h = nodesTemp[j];
            var replace = '<' + tagName.toLowerCase() + ' '
                + this.domNode.attributes(h) + '>' + h.innerHTML + '</' + tagName.toLowerCase() + '>';
            this.domNode.replaceWith(nodesTemp[j], replace);
        }
    };
    Lists.prototype.cleanNode = function () {
        var liParents = this.parent.editableElement.querySelectorAll('ol + ol, ul + ul');
        for (var c = 0; c < liParents.length; c++) {
            var node = liParents[c];
            if (this.domNode.isList(node.previousElementSibling) &&
                this.domNode.openTagString(node) === this.domNode.openTagString(node.previousElementSibling)) {
                var contentNodes = this.domNode.contents(node);
                for (var f = 0; f < contentNodes.length; f++) {
                    node.previousElementSibling.appendChild(contentNodes[f]);
                }
                node.parentNode.removeChild(node);
            }
        }
    };
    Lists.prototype.findUnSelected = function (temp, elements) {
        temp = temp.slice().reverse();
        if (temp.length > 0) {
            var rightIndent = [];
            var indentElements = [];
            var lastElement = elements[elements.length - 1];
            var lastElementChild = [];
            var childElements = [];
            lastElementChild = (lastElement.childNodes);
            for (var z = 0; z < lastElementChild.length; z++) {
                if (lastElementChild[z].tagName === 'OL' || lastElementChild[z].tagName === 'UL') {
                    var childLI = lastElementChild[z]
                        .querySelectorAll('li');
                    if (childLI.length > 0) {
                        for (var y = 0; y < childLI.length; y++) {
                            childElements.push(childLI[y]);
                        }
                    }
                }
            }
            for (var i = 0; i < childElements.length; i++) {
                var count = 0;
                for (var j = 0; j < temp.length; j++) {
                    if (!childElements[i].contains((temp[j]))) {
                        count = count + 1;
                    }
                }
                if (count === temp.length) {
                    indentElements.push(childElements[i]);
                }
            }
            if (indentElements.length > 0) {
                for (var x = 0; x < indentElements.length; x++) {
                    if (this.domNode.contents(indentElements[x])[0].nodeName !== 'OL' &&
                        this.domNode.contents(indentElements[x])[0].nodeName !== 'UL') {
                        rightIndent.push(indentElements[x]);
                    }
                }
            }
            if (rightIndent.length > 0) {
                this.nestedList(rightIndent);
            }
        }
    };
    Lists.prototype.revertList = function (elements) {
        var temp = [];
        for (var i = elements.length - 1; i >= 0; i--) {
            for (var j = i - 1; j >= 0; j--) {
                if (elements[j].contains((elements[i])) || elements[j] === elements[i]) {
                    temp.push(elements[i]);
                    elements.splice(i, 1);
                    break;
                }
            }
        }
        this.findUnSelected(temp, elements);
        var viewNode = [];
        for (var i = 0; i < elements.length; i++) {
            var element = elements[i];
            if (this.domNode.contents(element)[0].nodeType === 3 && this.domNode.contents(element)[0].textContent.trim().length === 0) {
                sf.base.detach(this.domNode.contents(element)[0]);
            }
            var parentNode = elements[i].parentNode;
            var className = element.getAttribute('class');
            if (temp.length === 0) {
                var siblingList = elements[i].querySelectorAll('ul, ol');
                var firstNode = siblingList[0];
                if (firstNode) {
                    var child = firstNode
                        .querySelectorAll('li');
                    if (child) {
                        var nestedElement = sf.base.createElement(firstNode.tagName);
                        sf.base.append([nestedElement], firstNode.parentNode);
                        var nestedElementLI = sf.base.createElement('li', { styles: 'list-style-type: none;' });
                        sf.base.append([nestedElementLI], nestedElement);
                        sf.base.append([firstNode], nestedElementLI);
                    }
                }
            }
            if (element.parentNode.insertBefore(this.closeTag(parentNode.tagName), element), 'LI' === parentNode.parentNode.tagName) {
                element.parentNode.insertBefore(this.closeTag('LI'), element);
            }
            else {
                if (DEFAULT_TAG && 0 === element.querySelectorAll(BLOCK_TAGS.join(', ')).length) {
                    var wrapperclass = sf.base.isNullOrUndefined(className) ? ' class="e-rte-wrap-inner"' :
                        ' class="' + className + ' e-rte-wrap-inner"';
                    var wrapper = '<' + DEFAULT_TAG + wrapperclass +
                        this.domNode.attributes(parentNode) + '></' + DEFAULT_TAG + '>';
                    this.domNode.wrapInner(element, this.domNode.parseHTMLFragment(wrapper));
                }
                else if (this.domNode.contents(element)[0].nodeType === 3) {
                    var replace = this.domNode.createTagString(DEFAULT_TAG, parentNode, this.parent.domNode.encode(this.domNode.contents(element)[0].textContent));
                    this.domNode.replaceWith(this.domNode.contents(element)[0], replace);
                }
                else if (this.domNode.contents(element)[0].classList.contains(markerClassName.startSelection) ||
                    this.domNode.contents(element)[0].classList.contains(markerClassName.endSelection)) {
                    var replace = this.domNode.createTagString(DEFAULT_TAG, parentNode, this.domNode.contents(element)[0].outerHTML);
                    this.domNode.replaceWith(this.domNode.contents(element)[0], replace);
                }
                else {
                    var childNode = element.firstChild;
                    className = childNode.getAttribute('class');
                    sf.base.attributes(childNode, this.domNode.rawAttributes(parentNode));
                    if (className && childNode.getAttribute('class')) {
                        sf.base.attributes(childNode, { 'class': className + ' ' + childNode.getAttribute('class') });
                    }
                }
                sf.base.append([this.openTag('LI')], element);
                sf.base.prepend([this.closeTag('LI')], element);
            }
            this.domNode.insertAfter(this.openTag(parentNode.tagName), element);
            if (parentNode.parentNode.tagName === 'LI') {
                parentNode = parentNode.parentNode.parentNode;
            }
            if (viewNode.indexOf(parentNode) < 0) {
                viewNode.push(parentNode);
            }
        }
        for (var i = 0; i < viewNode.length; i++) {
            var node = viewNode[i];
            var nodeInnerHtml = node.innerHTML;
            var closeTag = /<span class="e-rte-list-close-([a-z]*)"><\/span>/g;
            var openTag = /<span class="e-rte-list-open-([a-z]*)"><\/span>/g;
            nodeInnerHtml = nodeInnerHtml.replace(closeTag, '</$1>');
            nodeInnerHtml = nodeInnerHtml.replace(openTag, '<$1 ' + this.domNode.attributes(node) + '>');
            this.domNode.replaceWith(node, this.domNode.openTagString(node) + nodeInnerHtml.trim() + this.domNode.closeTagString(node));
        }
        var emptyUl = this.parent.editableElement.querySelectorAll('ul:empty, ol:empty');
        for (var i = 0; i < emptyUl.length; i++) {
            sf.base.detach(emptyUl[i]);
        }
        var emptyLi = this.parent.editableElement.querySelectorAll('li:empty');
        for (var i = 0; i < emptyLi.length; i++) {
            sf.base.detach(emptyLi[i]);
        }
    };
    Lists.prototype.openTag = function (type) {
        return this.domNode.parseHTMLFragment('<span class="e-rte-list-open-' + type.toLowerCase() + '"></span>');
    };
    Lists.prototype.closeTag = function (type) {
        return this.domNode.parseHTMLFragment('<span class="e-rte-list-close-' + type.toLowerCase() + '"></span>');
    };
    return Lists;
}());

/**
 * Node appending methods.
 *
 * @hidden
 */
var InsertMethods = /** @class */ (function () {
    function InsertMethods() {
    }
    /**
     * WrapBefore method
     *
     * @param {Text} textNode - specifies the text node
     * @param {HTMLElement} parentNode - specifies the parent node
     * @param {boolean} isAfter - specifies the boolean value
     * @returns {Text} - returns the text value
     * @hidden
     * @deprecated
     */
    InsertMethods.WrapBefore = function (textNode, parentNode, isAfter) {
        parentNode.innerText = textNode.textContent;
        //eslint-disable-next-line
        (!isAfter) ? this.AppendBefore(parentNode, textNode) : this.AppendBefore(parentNode, textNode, true);
        if (textNode.parentNode) {
            textNode.parentNode.removeChild(textNode);
        }
        return parentNode.childNodes[0];
    };
    /**
     * Wrap method
     *
     * @param {HTMLElement} childNode - specifies the child node
     * @param {HTMLElement} parentNode - specifies the parent node.
     * @returns {HTMLElement} - returns the element
     * @hidden
     * @deprecated
     */
    InsertMethods.Wrap = function (childNode, parentNode) {
        this.AppendBefore(parentNode, childNode);
        parentNode.appendChild(childNode);
        return childNode;
    };
    /**
     * unwrap method
     *
     * @param {Node} node - specifies the node element.
     * @returns {Node[]} - returns the array of value
     * @hidden
     * @deprecated
     */
    InsertMethods.unwrap = function (node) {
        var parent = node.parentNode;
        var child = [];
        for (; node.firstChild; null) {
            child.push(parent.insertBefore(node.firstChild, node));
        }
        parent.removeChild(node);
        return child;
    };
    /**
     * AppendBefore method
     *
     * @param {HTMLElement} textNode - specifies the element
     * @param {HTMLElement} parentNode - specifies the parent node
     * @param {boolean} isAfter - specifies the boolean value
     * @returns {void}
     * @hidden
     * @deprecated
     */
    InsertMethods.AppendBefore = function (textNode, parentNode, isAfter) {
        return (parentNode.parentNode) ? ((!isAfter) ? parentNode.parentNode.insertBefore(textNode, parentNode)
            : parentNode.parentNode.insertBefore(textNode, parentNode.nextSibling)) :
            parentNode;
    };
    return InsertMethods;
}());

/**
 * Split the Node based on selection
 *
 * @hidden
 * @deprecated
 */
var NodeCutter = /** @class */ (function () {
    function NodeCutter() {
        this.enterAction = 'P';
        this.position = -1;
        this.nodeSelection = new NodeSelection();
    }
    // Split Selection Node
    /**
     * GetSpliceNode method
     *
     * @param {Range} range - specifies the range
     * @param {HTMLElement} node - specifies the node element.
     * @returns {Node} - returns the node value
     * @hidden
     * @deprecated
     */
    NodeCutter.prototype.GetSpliceNode = function (range, node) {
        node = this.SplitNode(range, node, true);
        node = this.SplitNode(range, node, false);
        return node;
    };
    /**
     * @param {Range} range - specifies the range
     * @param {HTMLElement} node - specifies the node element.
     * @param {boolean} isCollapsed - specifies the boolean value
     * @returns {HTMLElement} - returns the element
     * @hidden
     * @deprecated
     */
    NodeCutter.prototype.SplitNode = function (range, node, isCollapsed) {
        if (node) {
            var clone = range.cloneRange();
            var parent_1 = node.parentNode;
            var index = this.nodeSelection.getIndex(node);
            clone.collapse(isCollapsed);
            // eslint-disable-next-line
            (isCollapsed) ? clone.setStartBefore(node) : clone.setEndAfter(node);
            var fragment = clone.extractContents();
            if (isCollapsed) {
                node = parent_1.childNodes[index];
                fragment = this.spliceEmptyNode(fragment, false);
                if (fragment && fragment.childNodes.length > 0) {
                    var isEmpty = (fragment.childNodes.length === 1 && fragment.childNodes[0].nodeName !== 'IMG'
                        && this.isImgElm(fragment) && fragment.textContent === '') ? true : false;
                    if (!isEmpty) {
                        if (node) {
                            InsertMethods.AppendBefore(fragment, node);
                        }
                        else {
                            parent_1.appendChild(fragment);
                            var divNode = document.createElement('div');
                            divNode.innerHTML = '&#65279;&#65279;';
                            node = divNode.firstChild;
                            parent_1.appendChild(node);
                        }
                    }
                }
            }
            else {
                node = parent_1.childNodes.length > 1 ? parent_1.childNodes[index] :
                    parent_1.childNodes[0];
                fragment = this.spliceEmptyNode(fragment, true);
                if (fragment && fragment.childNodes.length > 0) {
                    var isEmpty = (fragment.childNodes.length === 1 && fragment.childNodes[0].nodeName !== 'IMG'
                        && this.isImgElm(fragment) && fragment.textContent.trim() === '') ? true : false;
                    if (!isEmpty) {
                        if (node) {
                            InsertMethods.AppendBefore(fragment, node, true);
                        }
                        else {
                            parent_1.appendChild(fragment);
                            var divNode = document.createElement('div');
                            divNode.innerHTML = '&#65279;&#65279;';
                            parent_1.insertBefore(divNode.firstChild, parent_1.firstChild);
                            node = parent_1.firstChild;
                        }
                    }
                }
            }
            return node;
        }
        else {
            return null;
        }
    };
    NodeCutter.prototype.isImgElm = function (fragment) {
        var result = true;
        if (fragment.childNodes.length === 1 && fragment.childNodes[0].nodeName !== 'IMG') {
            var firstChild = fragment.childNodes[0];
            for (var i = 0; !sf.base.isNullOrUndefined(firstChild.childNodes) && i < firstChild.childNodes.length; i++) {
                if (firstChild.childNodes[i].nodeName === 'IMG') {
                    result = false;
                }
            }
        }
        else {
            result = true;
        }
        return result;
    };
    NodeCutter.prototype.spliceEmptyNode = function (fragment, isStart) {
        var len;
        if (fragment.childNodes.length === 1 && fragment.childNodes[0].nodeName === '#text' &&
            fragment.childNodes[0].textContent === '' || fragment.textContent === '') {
            len = -1;
        }
        else {
            len = fragment.childNodes.length - 1;
        }
        if (len > -1 && !isStart) {
            this.spliceEmptyNode(fragment.childNodes[len], isStart);
        }
        else if (len > -1) {
            this.spliceEmptyNode(fragment.childNodes[0], isStart);
        }
        else if (fragment.nodeType !== 3 && fragment.nodeType !== 11) {
            fragment.parentNode.removeChild(fragment);
        }
        return fragment;
    };
    // Cursor Position split
    NodeCutter.prototype.GetCursorStart = function (indexes, index, isStart) {
        indexes = (isStart) ? indexes : indexes.reverse();
        var position = indexes[0];
        for (var num = 0; num < indexes.length && ((isStart) ? (indexes[num] < index) : (indexes[num] >= index)); num++) {
            position = indexes[num];
        }
        return position;
    };
    /**
     * GetCursorRange method
     *
     * @param {Document} docElement - specifies the document
     * @param {Range} range - specifies the range
     * @param {Node} node - specifies the node.
     * @returns {Range} - returns the range value
     * @hidden
     * @deprecated
     */
    NodeCutter.prototype.GetCursorRange = function (docElement, range, node) {
        var cursorRange = docElement.createRange();
        var indexes = [];
        indexes.push(0);
        var str = this.TrimLineBreak(node.data);
        var index = str.indexOf(' ', 0);
        while (index !== -1) {
            if (indexes.indexOf(index) < 0) {
                indexes.push(index);
            }
            if (new RegExp('\\s').test(str[index - 1]) && (indexes.indexOf(index - 1) < 0)) {
                indexes.push(index - 1);
            }
            if (new RegExp('\\s').test(str[index + 1])) {
                indexes.push(index + 1);
            }
            index = str.indexOf(' ', (index + 1));
        }
        indexes.push(str.length);
        if ((indexes.indexOf(range.startOffset) >= 0)
            || ((indexes.indexOf(range.startOffset - 1) >= 0) && (range.startOffset !== 1
                || (range.startOffset === 1 && new RegExp('\\s').test(str[0])))
                || ((indexes[indexes.length - 1] - 1) === range.startOffset))) {
            cursorRange = range;
            this.position = 1;
        }
        else {
            var startOffset = this.GetCursorStart(indexes, range.startOffset, true);
            this.position = range.startOffset - startOffset;
            cursorRange.setStart(range.startContainer, startOffset);
            cursorRange.setEnd(range.startContainer, this.GetCursorStart(indexes, range.startOffset, false));
        }
        return cursorRange;
    };
    /**
     * GetCursorNode method
     *
     * @param {Document} docElement - specifies the document
     * @param {Range} range - specifies the range
     * @param {Node} node - specifies the node.
     * @returns {Node} - returns the node value
     * @hidden
     * @deprecated
     */
    NodeCutter.prototype.GetCursorNode = function (docElement, range, node) {
        return this.GetSpliceNode(this.GetCursorRange(docElement, range, node), node);
    };
    /**
     * TrimLineBreak method
     *
     * @param {string} line - specifies the string value.
     * @returns {string} - returns the string
     * @hidden
     * @deprecated
     */
    NodeCutter.prototype.TrimLineBreak = function (line) {
        return line.replace(/(\r\n\t|\n|\r\t)/gm, ' ');
    };
    return NodeCutter;
}());

/**
 * Formats internal component
 *
 * @hidden
 * @deprecated
 */
var Formats = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the parent element.
     * @hidden
     * @deprecated
     */
    function Formats(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    Formats.prototype.addEventListener = function () {
        this.parent.observer.on(FORMAT_TYPE, this.applyFormats, this);
        this.parent.observer.on(KEY_UP_HANDLER, this.onKeyUp, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.onKeyDown, this);
    };
    Formats.prototype.getParentNode = function (node) {
        for (; node.parentNode && node.parentNode !== this.parent.editableElement; null) {
            node = node.parentNode;
        }
        return node;
    };
    Formats.prototype.onKeyUp = function (e) {
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        var endCon = range.endContainer;
        var lastChild = endCon.lastChild;
        if (e.event.which === 13 && range.startContainer === endCon && endCon.nodeType !== 3) {
            var pTag = sf.base.createElement('p');
            pTag.innerHTML = '<br>';
            if (!sf.base.isNullOrUndefined(lastChild) && lastChild && lastChild.nodeName === 'BR' && (lastChild.previousSibling && lastChild.previousSibling.nodeName === 'TABLE')) {
                endCon.replaceChild(pTag, lastChild);
                this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, pTag, 0);
            }
            else {
                var brNode = this.parent.nodeSelection.getSelectionNodeCollectionBr(range)[0];
                if (!sf.base.isNullOrUndefined(brNode) && brNode.nodeName === 'BR' && (brNode.previousSibling && brNode.previousSibling.nodeName === 'TABLE')) {
                    endCon.replaceChild(pTag, brNode);
                    this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, pTag, 0);
                }
            }
        }
    };
    Formats.prototype.onKeyDown = function (e) {
        if (e.event.which === 13) {
            var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
            var startCon = (range.startContainer.textContent.length === 0 || range.startContainer.nodeName === 'PRE')
                ? range.startContainer : range.startContainer.parentElement;
            var endCon = (range.endContainer.textContent.length === 0 || range.endContainer.nodeName === 'PRE')
                ? range.endContainer : range.endContainer.parentElement;
            var preElem = sf.base.closest(startCon, 'pre');
            var endPreElem = sf.base.closest(endCon, 'pre');
            var liParent = !sf.base.isNullOrUndefined(preElem) && !sf.base.isNullOrUndefined(preElem.parentElement) && preElem.parentElement.tagName === 'LI';
            if (liParent) {
                return;
            }
            if (((sf.base.isNullOrUndefined(preElem) && !sf.base.isNullOrUndefined(endPreElem)) || (!sf.base.isNullOrUndefined(preElem) && sf.base.isNullOrUndefined(endPreElem)))) {
                e.event.preventDefault();
                this.deleteContent(range);
                this.removeCodeContent(range);
                range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
                this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, endCon, 0);
            }
            if (e.event.which === 13 && !sf.base.isNullOrUndefined(preElem) && !sf.base.isNullOrUndefined(endPreElem)) {
                e.event.preventDefault();
                this.deleteContent(range);
                this.removeCodeContent(range);
                range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
                var lastEmpty = range.startContainer.childNodes[range.endOffset];
                var lastBeforeBr = range.startContainer.childNodes[range.endOffset - 1];
                var startParent = range.startContainer;
                if (!sf.base.isNullOrUndefined(lastEmpty) && !sf.base.isNullOrUndefined(lastBeforeBr) && sf.base.isNullOrUndefined(lastEmpty.nextSibling) &&
                    lastEmpty.nodeName === 'BR' && lastBeforeBr.nodeName === 'BR') {
                    this.paraFocus(range.startContainer, e.enterAction);
                }
                else if ((startParent.textContent.charCodeAt(0) === 8203 &&
                    startParent.textContent.length === 1) || startParent.textContent.length === 0) {
                    //Double enter with any parent tag for the node
                    while (startParent.parentElement.nodeName !== 'PRE' &&
                        (startParent.textContent.length === 1 || startParent.textContent.length === 0)) {
                        startParent = startParent.parentElement;
                    }
                    if (!sf.base.isNullOrUndefined(startParent.previousSibling) && startParent.previousSibling.nodeName === 'BR' &&
                        sf.base.isNullOrUndefined(startParent.nextSibling)) {
                        this.paraFocus(startParent.parentElement);
                    }
                    else {
                        this.isNotEndCursor(preElem, range);
                    }
                }
                else {
                    //Cursor at start and middle
                    this.isNotEndCursor(preElem, range);
                }
            }
        }
    };
    Formats.prototype.removeCodeContent = function (range) {
        var regEx = new RegExp(String.fromCharCode(65279), 'g');
        if (!sf.base.isNullOrUndefined(range.endContainer.textContent.match(regEx))) {
            var pointer = range.endContainer.textContent.charCodeAt(range.endOffset - 1) === 65279 ?
                range.endOffset - 2 : range.endOffset;
            range.endContainer.textContent = range.endContainer.textContent.replace(regEx, '');
            if (range.endContainer.textContent === '') {
                this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, range.endContainer.parentElement, 0);
            }
            else {
                this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, range.endContainer, pointer);
            }
        }
    };
    Formats.prototype.deleteContent = function (range) {
        if (range.startContainer !== range.endContainer || range.startOffset !== range.endOffset) {
            range.deleteContents();
        }
    };
    Formats.prototype.paraFocus = function (referNode, enterAction) {
        var insertTag;
        if (enterAction === 'DIV') {
            insertTag = sf.base.createElement('div');
            insertTag.innerHTML = '<br>';
        }
        else if (enterAction === 'BR') {
            insertTag = sf.base.createElement('br');
        }
        else {
            insertTag = sf.base.createElement('p');
            insertTag.innerHTML = '<br>';
        }
        this.parent.domNode.insertAfter(insertTag, referNode);
        this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, insertTag, 0);
        sf.base.detach(referNode.lastChild);
    };
    Formats.prototype.isNotEndCursor = function (preElem, range) {
        var nodeCutter = new NodeCutter();
        var isEnd = range.startOffset === preElem.lastChild.textContent.length &&
            preElem.lastChild.textContent === range.startContainer.textContent;
        //Cursor at start point
        if (preElem.textContent.indexOf(range.startContainer.textContent) === 0 &&
            ((range.startOffset === 0 && range.endOffset === 0) || range.startContainer.nodeName === 'PRE')) {
            this.insertMarker(preElem, range);
            var brTag = sf.base.createElement('br');
            preElem.childNodes[range.endOffset].parentElement.insertBefore(brTag, preElem.childNodes[range.endOffset]);
        }
        else {
            //Cursor at middle
            var cloneNode = nodeCutter.SplitNode(range, preElem, true);
            this.insertMarker(preElem, range);
            var previousSib = preElem.previousElementSibling;
            if (previousSib.tagName === 'PRE') {
                previousSib.insertAdjacentHTML('beforeend', '<br>' + cloneNode.innerHTML);
                sf.base.detach(preElem);
            }
        }
        //To place the cursor position
        this.setCursorPosition(isEnd, preElem);
    };
    Formats.prototype.setCursorPosition = function (isEnd, preElem) {
        var isEmpty = false;
        var markerElem = this.parent.editableElement.querySelector('.tempSpan');
        var mrkParentElem = markerElem.parentElement;
        // eslint-disable-next-line
        markerElem.parentNode.textContent === '' ? isEmpty = true :
            this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, markerElem, 0);
        if (isEnd) {
            if (isEmpty) {
                //Enter press when pre element is empty
                if (mrkParentElem === preElem) {
                    this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, markerElem, 0);
                    sf.base.detach(markerElem);
                }
                else {
                    this.focusSelectionParent(markerElem, mrkParentElem);
                }
            }
            else {
                var brElm = sf.base.createElement('br');
                this.parent.domNode.insertAfter(brElm, markerElem);
                this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, markerElem, 0);
                sf.base.detach(markerElem);
            }
        }
        else {
            // eslint-disable-next-line
            isEmpty ? this.focusSelectionParent(markerElem, mrkParentElem) : sf.base.detach(markerElem);
        }
    };
    Formats.prototype.focusSelectionParent = function (markerElem, tempSpanPElem) {
        sf.base.detach(markerElem);
        tempSpanPElem.innerHTML = '\u200B';
        this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, tempSpanPElem, 0);
    };
    Formats.prototype.insertMarker = function (preElem, range) {
        var tempSpan = sf.base.createElement('span', { className: 'tempSpan' });
        if (range.startContainer.nodeName === 'PRE') {
            preElem.childNodes[range.endOffset].parentElement.insertBefore(tempSpan, preElem.childNodes[range.endOffset]);
        }
        else {
            range.startContainer.parentElement.insertBefore(tempSpan, range.startContainer);
        }
    };
    Formats.prototype.applyFormats = function (e) {
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        var isSelectAll = false;
        if (this.parent.editableElement === range.endContainer &&
            !sf.base.isNullOrUndefined(this.parent.editableElement.children[range.endOffset - 1]) &&
            this.parent.editableElement.children[range.endOffset - 1].tagName === 'TABLE' && !range.collapsed) {
            isSelectAll = true;
        }
        var save = this.parent.nodeSelection.save(range, this.parent.currentDocument);
        this.parent.domNode.setMarker(save);
        var formatsNodes = this.parent.domNode.blockNodes();
        if (e.enterAction === 'BR') {
            this.setSelectionBRConfig();
            var allSelectedNode = this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument);
            var selectedNodes = this.parent.nodeSelection.getSelectionNodes(allSelectedNode);
            var currentFormatNodes = [];
            if (selectedNodes.length === 0) {
                selectedNodes.push(formatsNodes[0]);
            }
            for (var i = 0; i < selectedNodes.length; i++) {
                var currentNode = selectedNodes[i];
                var previousCurrentNode = void 0;
                while (!this.parent.domNode.isBlockNode(currentNode) && currentNode !== this.parent.editableElement) {
                    previousCurrentNode = currentNode;
                    currentNode = currentNode.parentElement;
                }
                if (this.parent.domNode.isBlockNode(currentNode) && currentNode === this.parent.editableElement) {
                    currentFormatNodes.push(previousCurrentNode);
                }
            }
            for (var i = 0; i < currentFormatNodes.length; i++) {
                if (!this.parent.domNode.isBlockNode(currentFormatNodes[i])) {
                    var currentNode = currentFormatNodes[i];
                    var previousNode = currentNode;
                    while (currentNode === this.parent.editableElement) {
                        previousNode = currentNode;
                        currentNode = currentNode.parentElement;
                    }
                    var tempElem = void 0;
                    if (this.parent.domNode.isBlockNode(previousNode.parentElement) &&
                        previousNode.parentElement === this.parent.editableElement) {
                        tempElem = sf.base.createElement('div');
                        previousNode.parentElement.insertBefore(tempElem, previousNode);
                        tempElem.appendChild(previousNode);
                    }
                    else {
                        tempElem = previousNode;
                    }
                    var preNode = tempElem.previousSibling;
                    while (!sf.base.isNullOrUndefined(preNode) && preNode.nodeName !== 'BR' &&
                        !this.parent.domNode.isBlockNode(preNode)) {
                        tempElem.firstChild.parentElement.insertBefore(preNode, tempElem.firstChild);
                        preNode = tempElem.previousSibling;
                    }
                    if (!sf.base.isNullOrUndefined(preNode) && preNode.nodeName === 'BR') {
                        sf.base.detach(preNode);
                    }
                    var postNode = tempElem.nextSibling;
                    while (!sf.base.isNullOrUndefined(postNode) && postNode.nodeName !== 'BR' &&
                        !this.parent.domNode.isBlockNode(postNode)) {
                        tempElem.appendChild(postNode);
                        postNode = tempElem.nextSibling;
                    }
                    if (!sf.base.isNullOrUndefined(postNode) && postNode.nodeName === 'BR') {
                        sf.base.detach(postNode);
                    }
                }
            }
            this.setSelectionBRConfig();
            formatsNodes = this.parent.domNode.blockNodes();
        }
        for (var i = 0; i < formatsNodes.length; i++) {
            var parentNode = void 0;
            var replaceHTML = void 0;
            if (e.subCommand.toLowerCase() === 'blockquote') {
                parentNode = this.getParentNode(formatsNodes[i]);
                replaceHTML = this.parent.domNode.isList(parentNode) ||
                    parentNode.tagName === 'TABLE' ? parentNode.outerHTML : parentNode.innerHTML;
            }
            else {
                parentNode = formatsNodes[i];
                replaceHTML = parentNode.innerHTML;
            }
            if ((e.subCommand.toLowerCase() === parentNode.tagName.toLowerCase() &&
                (e.subCommand.toLowerCase() !== 'pre' ||
                    (!sf.base.isNullOrUndefined(e.exeValue) && e.exeValue.name === 'dropDownSelect'))) ||
                sf.base.isNullOrUndefined(parentNode.parentNode) ||
                (parentNode.tagName === 'TABLE' && e.subCommand.toLowerCase() === 'pre')) {
                continue;
            }
            this.cleanFormats(parentNode, e.subCommand);
            var replaceNode = (e.subCommand.toLowerCase() === 'pre' && parentNode.tagName.toLowerCase() === 'pre') ?
                'p' : e.subCommand;
            var replaceTag = this.parent.domNode.createTagString(replaceNode, parentNode, replaceHTML.replace(/>\s+</g, '><'));
            if (parentNode.tagName === 'LI') {
                parentNode.innerHTML = '';
                parentNode.insertAdjacentHTML('beforeend', replaceTag);
            }
            else {
                this.parent.domNode.replaceWith(parentNode, replaceTag);
            }
        }
        this.preFormatMerge();
        var startNode = this.parent.editableElement.querySelector('.' + markerClassName.startSelection);
        var endNode = this.parent.editableElement.querySelector('.' + markerClassName.endSelection);
        if (!sf.base.isNullOrUndefined(startNode) && !sf.base.isNullOrUndefined(endNode)) {
            startNode = startNode.lastChild;
            endNode = endNode.lastChild;
        }
        save = this.parent.domNode.saveMarker(save, null);
        if (isIDevice$1()) {
            setEditFrameFocus(this.parent.editableElement, e.selector);
        }
        if (isSelectAll) {
            this.parent.nodeSelection.setSelectionText(this.parent.currentDocument, startNode, endNode, 0, endNode.textContent.length);
        }
        else {
            save.restore();
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.domNode.blockNodes()
            });
        }
    };
    Formats.prototype.setSelectionBRConfig = function () {
        var startElem = this.parent.editableElement.querySelector('.' + markerClassName.startSelection);
        var endElem = this.parent.editableElement.querySelector('.' + markerClassName.endSelection);
        if (sf.base.isNullOrUndefined(endElem)) {
            this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, startElem, 0);
        }
        else {
            this.parent.nodeSelection.setSelectionText(this.parent.currentDocument, startElem, endElem, 0, 0);
        }
    };
    Formats.prototype.preFormatMerge = function () {
        var preNodes = this.parent.editableElement.querySelectorAll('PRE');
        if (!sf.base.isNullOrUndefined(preNodes)) {
            for (var i = 0; i < preNodes.length; i++) {
                var previousSib = preNodes[i].previousElementSibling;
                if (!sf.base.isNullOrUndefined(previousSib) && previousSib.tagName === 'PRE') {
                    previousSib.insertAdjacentHTML('beforeend', '<br>' + preNodes[i].innerHTML);
                    sf.base.detach(preNodes[i]);
                }
            }
        }
    };
    Formats.prototype.cleanFormats = function (element, tagName) {
        var ignoreAttr = ['display', 'font-size', 'margin-top', 'margin-bottom', 'margin-left', 'margin-right', 'font-weight'];
        tagName = tagName.toLowerCase();
        for (var i = 0; i < ignoreAttr.length && (tagName !== 'p' && tagName !== 'blockquote' && tagName !== 'pre'); i++) {
            element.style.removeProperty(ignoreAttr[i]);
        }
    };
    return Formats;
}());

/**
 * Insert a HTML Node or Text
 *
 * @hidden
 * @deprecated
 */
var InsertHtml = /** @class */ (function () {
    function InsertHtml() {
    }
    InsertHtml.Insert = function (docElement, insertNode, editNode, isExternal) {
        var node;
        if (typeof insertNode === 'string') {
            var divNode = document.createElement('div');
            divNode.innerHTML = insertNode;
            node = isExternal ? divNode : divNode.firstChild;
        }
        else {
            if (isExternal && !(!sf.base.isNullOrUndefined(insertNode) && !sf.base.isNullOrUndefined(insertNode.classList) &&
                insertNode.classList.contains('pasteContent'))) {
                var divNode = document.createElement('div');
                divNode.appendChild(insertNode);
                node = divNode;
            }
            else {
                node = insertNode;
            }
        }
        var nodeSelection = new NodeSelection();
        var nodeCutter = new NodeCutter();
        var range = nodeSelection.getRange(docElement);
        var isCursor = range.startOffset === range.endOffset && range.startOffset === 0 &&
            range.startContainer === range.endContainer;
        var isCollapsed = range.collapsed;
        var nodes = this.getNodeCollection(range, nodeSelection, node);
        var closestParentNode = (node.nodeName.toLowerCase() === 'table') ? this.closestEle(nodes[0].parentNode, editNode) : nodes[0];
        if (isExternal || (!sf.base.isNullOrUndefined(node) && !sf.base.isNullOrUndefined(node.classList) &&
            node.classList.contains('pasteContent'))) {
            this.pasteInsertHTML(nodes, node, range, nodeSelection, nodeCutter, docElement, isCollapsed, closestParentNode, editNode);
            return;
        }
        if (editNode !== range.startContainer && ((!isCollapsed && !(closestParentNode.nodeType === Node.ELEMENT_NODE &&
            TABLE_BLOCK_TAGS.indexOf(closestParentNode.tagName.toLocaleLowerCase()) !== -1))
            || (node.nodeName.toLowerCase() === 'table' && closestParentNode &&
                TABLE_BLOCK_TAGS.indexOf(closestParentNode.tagName.toLocaleLowerCase()) === -1))) {
            var preNode = nodeCutter.GetSpliceNode(range, closestParentNode);
            var sibNode = preNode.previousSibling;
            var parentNode = preNode.parentNode;
            if (nodes.length === 1 || (node.nodeName.toLowerCase() === 'table' && preNode.childElementCount === 0)) {
                nodeSelection.setSelectionContents(docElement, preNode);
                range = nodeSelection.getRange(docElement);
            }
            else {
                var lasNode = nodeCutter.GetSpliceNode(range, nodes[nodes.length - 1].parentElement);
                lasNode = sf.base.isNullOrUndefined(lasNode) ? preNode : lasNode;
                nodeSelection.setSelectionText(docElement, preNode, lasNode, 0, (lasNode.nodeType === 3) ?
                    lasNode.textContent.length : lasNode.childNodes.length);
                range = nodeSelection.getRange(docElement);
            }
            range.extractContents();
            if (insertNode.tagName === 'TABLE') {
                this.removeEmptyElements(editNode);
            }
            for (var index = 0; index < nodes.length; index++) {
                if (nodes[index].nodeType !== 3 && nodes[index].parentNode != null) {
                    if (nodes[index].nodeName === 'IMG') {
                        continue;
                    }
                    nodes[index].parentNode.removeChild(nodes[index]);
                }
            }
            if (sibNode) {
                InsertMethods.AppendBefore(node, sibNode, true);
            }
            else {
                var previousNode = null;
                while (parentNode !== editNode && parentNode.firstChild &&
                    (parentNode.textContent.trim() === '')) {
                    var parentNode1 = parentNode.parentNode;
                    previousNode = parentNode;
                    parentNode = parentNode1;
                }
                if (previousNode !== null) {
                    parentNode = previousNode;
                }
                if (parentNode.firstChild && (parentNode !== editNode ||
                    (node.nodeName === 'TABLE' && isCursor && parentNode === range.startContainer &&
                        parentNode === range.endContainer))) {
                    if (parentNode.textContent.trim() === '' && parentNode !== editNode) {
                        InsertMethods.AppendBefore(node, parentNode, false);
                        sf.base.detach(parentNode);
                    }
                    else {
                        InsertMethods.AppendBefore(node, parentNode.firstChild, false);
                    }
                }
                else {
                    parentNode.appendChild(node);
                }
            }
            if (node.nodeName === 'IMG') {
                this.imageFocus(node, nodeSelection, docElement);
            }
            else if (node.nodeType !== 3) {
                nodeSelection.setSelectionText(docElement, node, node, 0, node.childNodes.length);
            }
            else {
                nodeSelection.setSelectionText(docElement, node, node, 0, node.textContent.length);
            }
        }
        else {
            range.deleteContents();
            if (isCursor && range.startContainer.textContent === '' && range.startContainer.nodeName !== 'BR') {
                range.startContainer.innerHTML = '';
            }
            if (sf.base.Browser.isIE) {
                var frag = docElement.createDocumentFragment();
                frag.appendChild(node);
                range.insertNode(frag);
            }
            else if (range.startContainer.nodeType === 1 && range.startContainer.nodeName.toLowerCase() === 'hr'
                && range.endContainer.nodeName.toLowerCase() === 'hr') {
                var paraElem = range.startContainer.nextElementSibling;
                if (paraElem) {
                    if (paraElem.querySelector('br')) {
                        sf.base.detach(paraElem.querySelector('br'));
                    }
                    paraElem.appendChild(node);
                }
            }
            else {
                if (range.startContainer.nodeName === 'BR') {
                    range.startContainer.parentElement.insertBefore(node, range.startContainer);
                }
                else {
                    range.insertNode(node);
                }
            }
            if (node.nodeType !== 3 && node.childNodes.length > 0) {
                nodeSelection.setSelectionText(docElement, node, node, 1, 1);
            }
            else if (node.nodeName === 'IMG') {
                this.imageFocus(node, nodeSelection, docElement);
            }
            else if (node.nodeType !== 3) {
                nodeSelection.setSelectionContents(docElement, node);
            }
            else {
                nodeSelection.setSelectionText(docElement, node, node, node.textContent.length, node.textContent.length);
            }
        }
    };
    InsertHtml.pasteInsertHTML = function (nodes, node, range, nodeSelection, nodeCutter, docElement, isCollapsed, closestParentNode, editNode) {
        var isCursor = range.startOffset === range.endOffset &&
            range.startContainer === range.endContainer;
        if (isCursor && range.startContainer === editNode && editNode.textContent === '') {
            var currentBlockNode = this.getImmediateBlockNode(nodes[nodes.length - 1], editNode);
            nodeSelection.setSelectionText(docElement, currentBlockNode, currentBlockNode, 0, 0);
            range = nodeSelection.getRange(docElement);
        }
        var lasNode;
        var sibNode;
        var isSingleNode;
        var preNode;
        if (editNode !== range.startContainer && ((!isCollapsed && !(closestParentNode.nodeType === Node.ELEMENT_NODE &&
            TABLE_BLOCK_TAGS.indexOf(closestParentNode.tagName.toLocaleLowerCase()) !== -1))
            || (node.nodeName.toLowerCase() === 'table' && closestParentNode &&
                TABLE_BLOCK_TAGS.indexOf(closestParentNode.tagName.toLocaleLowerCase()) === -1))) {
            preNode = nodeCutter.GetSpliceNode(range, closestParentNode);
            sibNode = sf.base.isNullOrUndefined(preNode.previousSibling) ? preNode.parentNode.previousSibling : preNode.previousSibling;
            if (nodes.length === 1) {
                nodeSelection.setSelectionContents(docElement, preNode);
                range = nodeSelection.getRange(docElement);
                isSingleNode = true;
            }
            else {
                lasNode = nodeCutter.GetSpliceNode(range, nodes[nodes.length - 1].parentElement);
                lasNode = sf.base.isNullOrUndefined(lasNode) ? preNode : lasNode;
                nodeSelection.setSelectionText(docElement, preNode, lasNode, 0, (lasNode.nodeType === 3) ?
                    lasNode.textContent.length : lasNode.childNodes.length);
                range = nodeSelection.getRange(docElement);
                isSingleNode = false;
            }
        }
        var containsBlockNode = false;
        this.removingComments(node);
        var allChildNodes = node.childNodes;
        for (var i = 0; i < allChildNodes.length; i++) {
            if (BLOCK_TAGS.indexOf(allChildNodes[i].nodeName.toLocaleLowerCase()) >= 0) {
                containsBlockNode = true;
                break;
            }
        }
        var lastSelectionNode;
        var fragment = document.createDocumentFragment();
        if (!containsBlockNode) {
            if (!isCursor) {
                while (node.firstChild) {
                    lastSelectionNode = node.firstChild;
                    fragment.appendChild(node.firstChild);
                }
                if (isSingleNode) {
                    preNode.parentNode.replaceChild(fragment, preNode);
                }
                else {
                    range.deleteContents();
                    sf.base.detach(lasNode);
                    // eslint-disable-next-line
                    !sf.base.isNullOrUndefined(sibNode) ? sibNode.parentNode.appendChild(fragment) : editNode.appendChild(fragment);
                }
            }
            else {
                var tempSpan = sf.base.createElement('span', { className: 'tempSpan' });
                var nearestAnchor = sf.base.closest(range.startContainer.parentElement, 'a');
                if (range.startContainer.nodeType === 3 && nearestAnchor) {
                    var immediateBlockNode = this.getImmediateBlockNode(range.startContainer, editNode);
                    if (immediateBlockNode.querySelectorAll('br').length > 0) {
                        sf.base.detach(immediateBlockNode.querySelector('br'));
                    }
                    var rangeElement = sf.base.closest(nearestAnchor, 'span');
                    rangeElement.appendChild(tempSpan);
                }
                else {
                    range.insertNode(tempSpan);
                }
                while (node.firstChild) {
                    lastSelectionNode = node.firstChild;
                    fragment.appendChild(node.firstChild);
                }
                tempSpan.parentNode.replaceChild(fragment, tempSpan);
            }
        }
        else {
            this.insertTempNode(range, node, nodes, nodeCutter, editNode);
            var isFirstTextNode = true;
            var isPreviousInlineElem = void 0;
            var paraElm = void 0;
            var previousParent = void 0;
            range.deleteContents();
            while (node.firstChild) {
                if (node.firstChild.nodeName === '#text' && node.firstChild.textContent.trim() === '') {
                    sf.base.detach(node.firstChild);
                    continue;
                }
                if (node.firstChild.nodeName === '#text' && isFirstTextNode ||
                    (this.inlineNode.indexOf(node.firstChild.nodeName.toLocaleLowerCase()) >= 0 && isFirstTextNode)) {
                    lastSelectionNode = node.firstChild;
                    if (sf.base.isNullOrUndefined(node.previousElementSibling)) {
                        var firstParaElm = sf.base.createElement('p');
                        node.parentElement.insertBefore(firstParaElm, node);
                    }
                    node.previousElementSibling.appendChild(node.firstChild);
                }
                else {
                    lastSelectionNode = node.firstChild;
                    if (node.firstChild.nodeName === '#text' ||
                        (this.inlineNode.indexOf(node.firstChild.nodeName.toLocaleLowerCase()) >= 0)) {
                        if (!isPreviousInlineElem) {
                            paraElm = sf.base.createElement('p');
                            paraElm.appendChild(node.firstChild);
                            fragment.appendChild(paraElm);
                        }
                        else {
                            previousParent.appendChild(node.firstChild);
                            fragment.appendChild(previousParent);
                        }
                        previousParent = paraElm;
                        isPreviousInlineElem = true;
                    }
                    else {
                        fragment.appendChild(node.firstChild);
                        isPreviousInlineElem = false;
                    }
                    isFirstTextNode = false;
                }
            }
            node.parentNode.replaceChild(fragment, node);
        }
        if (lastSelectionNode.nodeName === '#text') {
            this.placeCursorEnd(lastSelectionNode, node, nodeSelection, docElement, editNode);
        }
        else {
            this.cursorPos(lastSelectionNode, node, nodeSelection, docElement, editNode);
        }
    };
    InsertHtml.placeCursorEnd = function (lastSelectionNode, node, nodeSelection, docElement, editNode) {
        lastSelectionNode = lastSelectionNode.nodeName === 'BR' ? (sf.base.isNullOrUndefined(lastSelectionNode.previousSibling) ? lastSelectionNode.parentNode
            : lastSelectionNode.previousSibling) : lastSelectionNode;
        while (!sf.base.isNullOrUndefined(lastSelectionNode) && lastSelectionNode.nodeName !== '#text' && lastSelectionNode.nodeName !== 'IMG' &&
            lastSelectionNode.nodeName !== 'BR' && lastSelectionNode.nodeName !== 'HR') {
            lastSelectionNode = lastSelectionNode.lastChild;
        }
        lastSelectionNode = sf.base.isNullOrUndefined(lastSelectionNode) ? node : lastSelectionNode;
        if (lastSelectionNode.nodeName === 'IMG') {
            this.imageFocus(lastSelectionNode, nodeSelection, docElement);
        }
        else {
            nodeSelection.setSelectionText(docElement, lastSelectionNode, lastSelectionNode, lastSelectionNode.textContent.length, lastSelectionNode.textContent.length);
        }
        this.removeEmptyElements(editNode);
    };
    InsertHtml.getNodeCollection = function (range, nodeSelection, node) {
        var nodes = [];
        if (range.startOffset === range.endOffset && range.startContainer === range.endContainer
            && (range.startContainer.nodeName === 'TD' || (range.startContainer.nodeType !== 3 &&
                node.classList && node.classList.contains('pasteContent')))) {
            nodes.push(range.startContainer.childNodes[range.endOffset]);
        }
        else {
            nodes = nodeSelection.getInsertNodeCollection(range);
        }
        return nodes;
    };
    InsertHtml.insertTempNode = function (range, node, nodes, nodeCutter, editNode) {
        if (range.startContainer === editNode && !sf.base.isNullOrUndefined(range.startContainer.childNodes[range.endOffset - 1]) &&
            range.startContainer.childNodes[range.endOffset - 1].nodeName === 'TABLE') {
            if (sf.base.isNullOrUndefined(range.startContainer.childNodes[range.endOffset - 1].nextSibling)) {
                range.startContainer.appendChild(node);
            }
            else {
                range.startContainer.insertBefore(node, range.startContainer.childNodes[range.endOffset - 1].nextSibling);
            }
        }
        else if (range.startContainer === editNode && !sf.base.isNullOrUndefined(range.startContainer.childNodes[range.endOffset]) &&
            range.startContainer.childNodes[range.endOffset].nodeName === 'TABLE') {
            range.startContainer.insertBefore(node, range.startContainer.childNodes[range.endOffset]);
        }
        else if (range.startContainer === range.endContainer && range.startContainer.nodeType !== 3
            && node.firstChild.nodeName === 'HR') {
            if (range.startContainer.classList.contains('e-content') || range.startContainer.nodeName === 'BODY') {
                range.startContainer.appendChild(node);
            }
            else {
                range.startContainer.parentNode.insertBefore(node, range.startContainer);
            }
        }
        else {
            var blockNode = this.getImmediateBlockNode(nodes[nodes.length - 1], editNode);
            if ((sf.base.isNullOrUndefined(blockNode) || sf.base.isNullOrUndefined(blockNode.parentElement)) && range.endContainer.nodeType !== 3) {
                blockNode = range.endContainer;
                range.setEnd(blockNode, range.endContainer.textContent.length);
            }
            if (!sf.base.isNullOrUndefined(blockNode) && editNode === blockNode &&
                range.startContainer === editNode && range.endContainer === editNode) {
                blockNode = editNode.firstElementChild;
                range.setStart(editNode.firstElementChild, editNode.firstElementChild.textContent.length);
                range.setEnd(editNode.firstElementChild, editNode.firstElementChild.textContent.length);
            }
            if (blockNode.nodeName === 'BODY' && range.startContainer === range.endContainer && range.startContainer.nodeType === 1) {
                blockNode = range.startContainer;
            }
            if (blockNode.nodeName === 'TD' || blockNode.nodeName === 'TH') {
                var tempSpan = sf.base.createElement('span', { className: 'tempSpan' });
                range.insertNode(tempSpan);
                tempSpan.parentNode.replaceChild(node, tempSpan);
            }
            else {
                var splitedElm = nodeCutter.GetSpliceNode(range, blockNode);
                splitedElm.parentNode.replaceChild(node, splitedElm);
            }
        }
    };
    InsertHtml.cursorPos = function (lastSelectionNode, node, nodeSelection, docElement, editNode) {
        lastSelectionNode.classList.add('lastNode');
        editNode.innerHTML = updateTextNode$1(editNode.innerHTML);
        lastSelectionNode = editNode.querySelector('.lastNode');
        if (!sf.base.isNullOrUndefined(lastSelectionNode)) {
            this.placeCursorEnd(lastSelectionNode, node, nodeSelection, docElement, editNode);
            lastSelectionNode.classList.remove('lastNode');
            if (lastSelectionNode.classList.length === 0) {
                lastSelectionNode.removeAttribute('class');
            }
        }
    };
    InsertHtml.imageFocus = function (node, nodeSelection, docElement) {
        var focusNode = document.createTextNode(' ');
        node.parentNode.insertBefore(focusNode, node.nextSibling);
        nodeSelection.setSelectionText(docElement, node.nextSibling, node.nextSibling, 0, 0);
    };
    // eslint-disable-next-line
    InsertHtml.getImmediateBlockNode = function (node, editNode) {
        do {
            node = node.parentNode;
        } while (node && BLOCK_TAGS.indexOf(node.nodeName.toLocaleLowerCase()) < 0);
        return node;
    };
    InsertHtml.removingComments = function (elm) {
        var innerElement = elm.innerHTML;
        innerElement = innerElement.replace(/<!--[\s\S]*?-->/g, '');
        elm.innerHTML = innerElement;
    };
    InsertHtml.findDetachEmptyElem = function (element) {
        var removableElement;
        if (!sf.base.isNullOrUndefined(element.parentElement)) {
            if (element.parentElement.textContent.trim() === '' && element.parentElement.contentEditable !== 'true') {
                removableElement = this.findDetachEmptyElem(element.parentElement);
            }
            else {
                removableElement = element;
            }
        }
        else {
            removableElement = null;
        }
        return removableElement;
    };
    InsertHtml.removeEmptyElements = function (element) {
        var emptyElements = element.querySelectorAll(':empty');
        for (var i = 0; i < emptyElements.length; i++) {
            if (emptyElements[i].tagName !== 'IMG' && emptyElements[i].tagName !== 'BR' &&
                emptyElements[i].tagName !== 'IFRAME' && emptyElements[i].tagName !== 'TD' &&
                emptyElements[i].tagName !== 'SOURCE' && emptyElements[i].tagName !== 'HR') {
                var detachableElement = this.findDetachEmptyElem(emptyElements[i]);
                if (!sf.base.isNullOrUndefined(detachableElement)) {
                    sf.base.detach(detachableElement);
                }
            }
        }
    };
    InsertHtml.closestEle = function (element, editNode) {
        var el = element;
        while (el && el.nodeType === 1) {
            if (el.parentNode === editNode ||
                (!sf.base.isNullOrUndefined(el.parentNode.tagName) &&
                    IGNORE_BLOCK_TAGS.indexOf(el.parentNode.tagName.toLocaleLowerCase()) !== -1)) {
                return el;
            }
            el = el.parentNode;
        }
        return null;
    };
    /**
     * Insert method
     *
     * @hidden
     * @deprecated
     */
    InsertHtml.inlineNode = ['a', 'abbr', 'acronym', 'audio', 'b', 'bdi', 'bdo', 'big', 'br', 'button',
        'canvas', 'cite', 'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'font', 'i', 'iframe', 'img', 'input',
        'ins', 'kbd', 'label', 'map', 'mark', 'meter', 'noscript', 'object', 'output', 'picture', 'progress',
        'q', 'ruby', 's', 'samp', 'script', 'select', 'slot', 'small', 'span', 'strong', 'sub', 'sup', 'svg',
        'template', 'textarea', 'time', 'u', 'tt', 'var', 'video', 'wbr'];
    return InsertHtml;
}());

/**
 * Link internal component
 *
 * @hidden
 * @deprecated
 */
var LinkCommand = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the editor manager
     * @hidden
     * @deprecated
     */
    function LinkCommand(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    LinkCommand.prototype.addEventListener = function () {
        this.parent.observer.on(LINK, this.linkCommand, this);
    };
    LinkCommand.prototype.linkCommand = function (e) {
        switch (e.value.toString().toLocaleLowerCase()) {
            case 'createlink':
            case 'editlink':
                this.createLink(e);
                break;
            case 'openlink':
                this.openLink(e);
                break;
            case 'removelink':
                this.removeLink(e);
                break;
        }
    };
    LinkCommand.prototype.createLink = function (e) {
        var closestAnchor = (!sf.base.isNullOrUndefined(e.item.selectParent) && e.item.selectParent.length > 0) &&
            sf.base.closest(e.item.selectParent[0], 'a');
        closestAnchor = !sf.base.isNullOrUndefined(closestAnchor) ? closestAnchor :
            (!sf.base.isNullOrUndefined(e.item.selectParent) && e.item.selectParent.length > 0) ? (e.item.selectParent[0]) : null;
        if (!sf.base.isNullOrUndefined(closestAnchor) && closestAnchor.tagName === 'A') {
            var anchorEle = closestAnchor;
            var linkText = '';
            if (!sf.base.isNullOrUndefined(e.item.url)) {
                anchorEle.setAttribute('href', e.item.url);
            }
            if (!sf.base.isNullOrUndefined(e.item.title)) {
                anchorEle.setAttribute('title', e.item.title);
            }
            if (!sf.base.isNullOrUndefined(e.item.text) && e.item.text !== '') {
                linkText = anchorEle.innerText;
                anchorEle.innerText = e.item.text;
            }
            if (!sf.base.isNullOrUndefined(e.item.target)) {
                anchorEle.setAttribute('target', e.item.target);
            }
            else {
                anchorEle.removeAttribute('target');
            }
            if (linkText === e.item.text) {
                e.item.selection.setSelectionText(this.parent.currentDocument, anchorEle, anchorEle, 1, 1);
                e.item.selection.restore();
            }
            else {
                var startIndex = e.item.action === 'Paste' ? anchorEle.childNodes[0].textContent.length : 0;
                e.item.selection.setSelectionText(this.parent.currentDocument, anchorEle.childNodes[0], anchorEle.childNodes[0], startIndex, anchorEle.childNodes[0].textContent.length);
            }
        }
        else {
            var domSelection = new NodeSelection();
            var range = domSelection.getRange(this.parent.currentDocument);
            var text = sf.base.isNullOrUndefined(e.item.text) ? true : e.item.text.replace(/ /g, '').localeCompare(range.toString()
                .replace(/\n/g, ' ').replace(/ /g, '')) < 0;
            if (e.event && e.event.type === 'keydown' && (e.event.keyCode === 32
                || e.event.keyCode === 13) || e.item.action === 'Paste' || range.collapsed || text) {
                var anchor = this.createAchorNode(e);
                anchor.innerText = e.item.text === '' ? e.item.url : e.item.text;
                e.item.selection.restore();
                InsertHtml.Insert(this.parent.currentDocument, anchor, this.parent.editableElement);
                if (e.event && e.event.type === 'keydown' && (e.event.keyCode === 32
                    || e.event.keyCode === 13)) {
                    var startContainer = e.item.selection.range.startContainer;
                    startContainer.textContent = this.removeText(startContainer.textContent, e.item.text);
                }
                else {
                    var startIndex = e.item.action === 'Paste' ? anchor.childNodes[0].textContent.length : 0;
                    e.item.selection.setSelectionText(this.parent.currentDocument, anchor.childNodes[0], anchor.childNodes[0], startIndex, anchor.childNodes[0].textContent.length);
                }
            }
            else {
                this.createLinkNode(e);
            }
        }
        if (e.callBack) {
            e.callBack({
                requestType: 'Links',
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    LinkCommand.prototype.createLinkNode = function (e) {
        var domSelection = new NodeSelection();
        var nodeCutter = new NodeCutter();
        var range = domSelection.getRange(this.parent.currentDocument);
        var nodes = this.getSelectionNodes(domSelection.getNodeCollection(range));
        var save = domSelection.save(range, this.parent.currentDocument);
        var txtArray = [];
        var inlineNodes = [];
        var currentNode;
        var removeNodes = [];
        var anchorNodes = [];
        var finalinlineNodes = [];
        var cloneNode;
        for (var index = 0; index < nodes.length; index++) {
            nodes[index] = nodeCutter.GetSpliceNode(range, nodes[index]);
            txtArray[index] = nodes[index];
        }
        for (var i = 0; i < txtArray.length; i++) {
            var check = true;
            currentNode = txtArray[i];
            while (check === true) {
                if (currentNode.parentNode.nodeName === 'A') {
                    var anchorEle = currentNode.parentNode;
                    currentNode.parentNode.parentNode.insertBefore(anchorEle.firstChild, anchorEle);
                    currentNode.parentNode.removeChild(anchorEle);
                }
                if (this.isBlockNode(currentNode.parentNode) || txtArray.length === 0 || i === 0 || i === txtArray.length - 1
                    || range.startContainer.nodeType === 3) {
                    inlineNodes[i] = currentNode;
                    check = false;
                }
                else {
                    currentNode = currentNode.parentNode;
                }
            }
        }
        for (var i = 0, j_1 = 0; i < inlineNodes.length; i++) {
            if (i === 0) {
                finalinlineNodes[j_1] = inlineNodes[i];
            }
            if (inlineNodes.length > 1 && i < inlineNodes.length - 1) {
                if ((inlineNodes[i].parentElement === inlineNodes[i + 1].parentElement) && (inlineNodes[i] === inlineNodes[i + 1])) {
                    continue;
                }
                else {
                    finalinlineNodes[j_1 + 1] = inlineNodes[i + 1];
                    j_1++;
                }
            }
        }
        var j = 0;
        anchorNodes[j] = this.createAchorNode(e);
        for (var i = 0; i < finalinlineNodes.length; i++) {
            if (i === 0) {
                cloneNode = finalinlineNodes[i].cloneNode(true);
                anchorNodes[i].appendChild(cloneNode);
            }
            if (i < finalinlineNodes.length - 1) {
                if (finalinlineNodes[i].parentNode === finalinlineNodes[i + 1].parentNode) {
                    var cln = finalinlineNodes[i + 1].cloneNode(true);
                    anchorNodes[j].appendChild(cln);
                }
                else {
                    j = j + 1;
                    anchorNodes[j] = this.createAchorNode(e);
                    cloneNode = finalinlineNodes[i + 1].cloneNode(true);
                    anchorNodes[j].appendChild(cloneNode);
                }
            }
        }
        this.parent.nodeSelection.setRange(document, save.range);
        for (var i = 0, j_2 = 0, k = 0; i <= finalinlineNodes.length; i++) {
            if (i === 0) {
                finalinlineNodes[i].parentNode.insertBefore(anchorNodes[j_2], finalinlineNodes[i].nextSibling);
                if (this.parent.domNode.blockNodes().length === 1) {
                    this.parent.nodeSelection.setSelectionNode(this.parent.currentDocument, anchorNodes[j_2]);
                }
                removeNodes[k] = finalinlineNodes[i];
                k++;
            }
            if (i < finalinlineNodes.length - 1) {
                if (finalinlineNodes[i].parentNode === finalinlineNodes[i + 1].parentNode) {
                    removeNodes[k] = finalinlineNodes[i + 1];
                    k++;
                }
                else {
                    j_2 = j_2 + 1;
                    finalinlineNodes[i + 1].parentNode.insertBefore(anchorNodes[j_2], finalinlineNodes[i + 1]);
                    removeNodes[k] = finalinlineNodes[i + 1];
                    k++;
                }
            }
        }
        for (var i = 0; i < removeNodes.length; i++) {
            if (removeNodes[i].parentNode) {
                removeNodes[i].parentNode.removeChild(removeNodes[i]);
            }
        }
    };
    LinkCommand.prototype.createAchorNode = function (e) {
        var anchorEle = sf.base.createElement('a', {
            className: 'e-rte-anchor',
            attrs: {
                href: e.item.url,
                title: sf.base.isNullOrUndefined(e.item.title) || e.item.title === '' ? e.item.url : e.item.title
            }
        });
        if (!sf.base.isNullOrUndefined(e.item.target)) {
            anchorEle.setAttribute('target', e.item.target);
        }
        return anchorEle;
    };
    LinkCommand.prototype.getSelectionNodes = function (nodeCollection) {
        nodeCollection = nodeCollection.reverse();
        for (var index = 0; index < nodeCollection.length; index++) {
            if (nodeCollection[index].nodeType !== 3 || nodeCollection[index].textContent.trim() === '') {
                if (nodeCollection[index].nodeName !== 'IMG') {
                    nodeCollection.splice(index, 1);
                    index--;
                }
            }
        }
        return nodeCollection.reverse();
    };
    LinkCommand.prototype.isBlockNode = function (element) {
        return (!!element && (element.nodeType === Node.ELEMENT_NODE && BLOCK_TAGS.indexOf(element.tagName.toLowerCase()) >= 0));
    };
    LinkCommand.prototype.removeText = function (text, val) {
        var arr = text.split(' ');
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === val) {
                arr.splice(i, 1);
                i--;
            }
        }
        return arr.join(' ') + ' ';
    };
    LinkCommand.prototype.openLink = function (e) {
        document.defaultView.open(e.item.url, e.item.target);
        this.callBack(e);
    };
    LinkCommand.prototype.removeLink = function (e) {
        var blockNodes = this.parent.domNode.blockNodes();
        if (blockNodes.length < 2) {
            this.parent.domNode.setMarker(e.item.selection);
            var closestAnchor = sf.base.closest(e.item.selectParent[0], 'a');
            var selectParent = closestAnchor ? closestAnchor : e.item.selectParent[0];
            var parent_1 = selectParent.parentNode;
            var child = [];
            for (; selectParent.firstChild; null) {
                child.push(parent_1.insertBefore(selectParent.firstChild, selectParent));
            }
            parent_1.removeChild(selectParent);
            if (child && child.length === 1) {
                e.item.selection.startContainer = e.item.selection.getNodeArray(child[child.length - 1], true);
                e.item.selection.endContainer = e.item.selection.startContainer;
            }
            e.item.selection = this.parent.domNode.saveMarker(e.item.selection);
        }
        else {
            for (var i = 0; i < blockNodes.length; i++) {
                var linkNode = blockNodes[i].querySelectorAll('a');
                for (var j = 0; j < linkNode.length; j++) {
                    if (document.getSelection().containsNode(linkNode[j], true)) {
                        linkNode[j].outerHTML = linkNode[j].innerHTML;
                    }
                }
            }
        }
        e.item.selection.restore();
        this.callBack(e);
    };
    LinkCommand.prototype.callBack = function (e) {
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    return LinkCommand;
}());

/**
 * Formats internal component
 *
 * @hidden
 * @deprecated
 */
var Alignments = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the parent element.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    function Alignments(parent) {
        this.alignments = {
            'JustifyLeft': 'left',
            'JustifyCenter': 'center',
            'JustifyRight': 'right',
            'JustifyFull': 'justify'
        };
        this.parent = parent;
        this.addEventListener();
    }
    Alignments.prototype.addEventListener = function () {
        this.parent.observer.on(ALIGNMENT_TYPE, this.applyAlignment, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.onKeyDown, this);
    };
    Alignments.prototype.onKeyDown = function (e) {
        switch (e.event.action) {
            case 'justify-center':
                this.applyAlignment({ subCommand: 'JustifyCenter', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'justify-full':
                this.applyAlignment({ subCommand: 'JustifyFull', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'justify-left':
                this.applyAlignment({ subCommand: 'JustifyLeft', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'justify-right':
                this.applyAlignment({ subCommand: 'JustifyRight', callBack: e.callBack });
                e.event.preventDefault();
                break;
        }
    };
    Alignments.prototype.getTableNode = function (range) {
        var startNode = range.startContainer.nodeType === Node.ELEMENT_NODE
            ? range.startContainer : range.startContainer.parentNode;
        var cellNode = sf.base.closest(startNode, 'td,th');
        return [cellNode];
    };
    Alignments.prototype.applyAlignment = function (e) {
        var isTableAlign = e.value === 'Table' ? true : false;
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        var save = this.parent.nodeSelection.save(range, this.parent.currentDocument);
        if (!isTableAlign) {
            this.parent.domNode.setMarker(save);
            var alignmentNodes = this.parent.domNode.blockNodes();
            for (var i = 0; i < alignmentNodes.length; i++) {
                var parentNode = alignmentNodes[i];
                sf.base.setStyleAttribute(parentNode, { 'text-align': this.alignments[e.subCommand] });
            }
            var imageTags = this.parent.domNode.getImageTagInSelection();
            for (var i = 0; i < imageTags.length; i++) {
                var elementNode = [];
                elementNode.push(imageTags[i]);
                this.parent.imgObj.imageCommand({
                    item: {
                        selectNode: elementNode
                    },
                    subCommand: e.subCommand,
                    value: e.subCommand,
                    callBack: e.callBack,
                    selector: e.selector
                });
            }
            this.parent.editableElement.focus();
            save = this.parent.domNode.saveMarker(save);
            if (isIDevice$1()) {
                setEditFrameFocus(this.parent.editableElement, e.selector);
            }
            save.restore();
        }
        else {
            sf.base.setStyleAttribute(this.getTableNode(range)[0], { 'text-align': this.alignments[e.subCommand] });
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: (isTableAlign ? this.getTableNode(range) : this.parent.domNode.blockNodes())
            });
        }
    };
    return Alignments;
}());

/**
 * Indents internal component
 *
 * @hidden
 * @deprecated
 */
var Indents = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function Indents(parent) {
        this.indentValue = 20;
        this.parent = parent;
        this.addEventListener();
    }
    Indents.prototype.addEventListener = function () {
        this.parent.observer.on(INDENT_TYPE, this.applyIndents, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.onKeyDown, this);
    };
    Indents.prototype.onKeyDown = function (e) {
        switch (e.event.action) {
            case 'indents':
                this.applyIndents({ subCommand: 'Indent', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'outdents':
                this.applyIndents({ subCommand: 'Outdent', callBack: e.callBack });
                e.event.preventDefault();
                break;
        }
    };
    Indents.prototype.applyIndents = function (e) {
        var editEle = this.parent.editableElement;
        var isRtl = editEle.classList.contains('e-rtl');
        var range = this.parent.nodeSelection.getRange(this.parent.currentDocument);
        var save = this.parent.nodeSelection.save(range, this.parent.currentDocument);
        this.parent.domNode.setMarker(save);
        var indentsNodes = this.parent.domNode.blockNodes();
        var parentNodes = indentsNodes.slice();
        var listsNodes = [];
        for (var i = 0; i < parentNodes.length; i++) {
            if (parentNodes[i].tagName !== 'LI' && 'LI' === parentNodes[i].parentNode.tagName) {
                indentsNodes.splice(indentsNodes.indexOf(parentNodes[i]), 1);
                listsNodes.push(parentNodes[i].parentNode);
            }
            else if (parentNodes[i].tagName === 'LI') {
                indentsNodes.splice(indentsNodes.indexOf(parentNodes[i]), 1);
                listsNodes.push(parentNodes[i]);
            }
        }
        if (listsNodes.length > 0) {
            this.parent.observer.notify(KEY_DOWN_HANDLER, {
                event: {
                    preventDefault: function () {
                        return;
                    },
                    stopPropagation: function () {
                        return;
                    },
                    shiftKey: (e.subCommand === 'Indent' ? false : true),
                    which: 9,
                    action: 'indent'
                },
                ignoreDefault: true
            });
        }
        for (var i = 0; i < indentsNodes.length; i++) {
            var parentNode = indentsNodes[i];
            var marginLeftOrRight = isRtl ? parentNode.style.marginRight : parentNode.style.marginLeft;
            var indentsValue = void 0;
            if (e.subCommand === 'Indent') {
                /* eslint-disable */
                indentsValue = marginLeftOrRight === '' ? this.indentValue + 'px' : parseInt(marginLeftOrRight, null) + this.indentValue + 'px';
                isRtl ? (parentNode.style.marginRight = indentsValue) : (parentNode.style.marginLeft = indentsValue);
            }
            else {
                indentsValue = (marginLeftOrRight === '' || marginLeftOrRight === '0px') ? '' : parseInt(marginLeftOrRight, null) - this.indentValue + 'px';
                isRtl ? (parentNode.style.marginRight = indentsValue) : (parentNode.style.marginLeft = indentsValue);
                /* eslint-enable */
            }
        }
        editEle.focus();
        if (isIDevice$1()) {
            setEditFrameFocus(editEle, e.selector);
        }
        save = this.parent.domNode.saveMarker(save);
        save.restore();
        if (e.callBack) {
            e.callBack({
                requestType: e.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.domNode.blockNodes()
            });
        }
    };
    return Indents;
}());

/**
 * Rich Text Editor classes defined here.
 */
/**
 * @hidden
 * @deprecated
 */
var CLASS_IMAGE_RIGHT = 'e-imgright';
var CLASS_IMAGE_LEFT = 'e-imgleft';
var CLASS_IMAGE_CENTER = 'e-imgcenter';
var CLASS_IMAGE_BREAK = 'e-imgbreak';
var CLASS_CAPTION = 'e-img-caption';

var CLASS_CAPTION_INLINE = 'e-caption-inline';
var CLASS_IMAGE_INLINE = 'e-imginline';

/**
 * Link internal component
 *
 * @hidden
 * @deprecated
 */
var ImageCommand = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function ImageCommand(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    ImageCommand.prototype.addEventListener = function () {
        this.parent.observer.on(IMAGE, this.imageCommand, this);
    };
    /**
     * imageCommand method
     *
     * @param {IHtmlItem} e - specifies the element
     * @returns {void}
     * @hidden
     * @deprecated
     */
    ImageCommand.prototype.imageCommand = function (e) {
        switch (e.value.toString().toLowerCase()) {
            case 'image':
            case 'replace':
                this.createImage(e);
                break;
            case 'insertlink':
                this.insertImageLink(e);
                break;
            case 'openimagelink':
                this.openImageLink(e);
                break;
            case 'editimagelink':
                this.editImageLink(e);
                break;
            case 'removeimagelink':
                this.removeImageLink(e);
                break;
            case 'remove':
                this.removeImage(e);
                break;
            case 'alttext':
                this.insertAltTextImage(e);
                break;
            case 'dimension':
                this.imageDimension(e);
                break;
            case 'caption':
                this.imageCaption(e);
                break;
            case 'justifyleft':
                this.imageJustifyLeft(e);
                break;
            case 'justifycenter':
                this.imageJustifyCenter(e);
                break;
            case 'justifyright':
                this.imageJustifyRight(e);
                break;
            case 'inline':
                this.imageInline(e);
                break;
            case 'break':
                this.imageBreak(e);
                break;
        }
    };
    ImageCommand.prototype.createImage = function (e) {
        var _this = this;
        var isReplaced = false;
        e.item.url = sf.base.isNullOrUndefined(e.item.url) || e.item.url === 'undefined' ? e.item.src : e.item.url;
        if (!sf.base.isNullOrUndefined(e.item.selectParent) && e.item.selectParent[0].tagName === 'IMG') {
            var imgEle = e.item.selectParent[0];
            this.setStyle(imgEle, e);
            isReplaced = true;
        }
        else {
            var imgElement = sf.base.createElement('img');
            this.setStyle(imgElement, e);
            if (!sf.base.isNullOrUndefined(e.item.selection)) {
                e.item.selection.restore();
            }
            if (!sf.base.isNullOrUndefined(e.selector) && e.selector === 'pasteCleanupModule') {
                e.callBack({ requestType: 'Images',
                    editorMode: 'HTML',
                    event: e.event,
                    range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                    elements: [imgElement]
                });
            }
            else {
                InsertHtml.Insert(this.parent.currentDocument, imgElement, this.parent.editableElement);
            }
        }
        if (e.callBack && (sf.base.isNullOrUndefined(e.selector) || !sf.base.isNullOrUndefined(e.selector) && e.selector !== 'pasteCleanupModule')) {
            var selectedNode = this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)[0];
            var imgElm_1 = (e.value === 'Replace' || isReplaced) ? e.item.selectParent[0] :
                (sf.base.Browser.isIE ? selectedNode.previousSibling : selectedNode.previousElementSibling);
            imgElm_1.addEventListener('load', function () {
                if (e.value !== 'Replace' || !isReplaced) {
                    e.callBack({
                        requestType: 'Images',
                        editorMode: 'HTML',
                        event: e.event,
                        range: _this.parent.nodeSelection.getRange(_this.parent.currentDocument),
                        elements: [imgElm_1]
                    });
                }
            });
        }
    };
    ImageCommand.prototype.setStyle = function (imgElement, e) {
        if (!sf.base.isNullOrUndefined(e.item.url)) {
            imgElement.setAttribute('src', e.item.url);
        }
        imgElement.setAttribute('class', 'e-rte-image' + (sf.base.isNullOrUndefined(e.item.cssClass) ? '' : ' ' + e.item.cssClass));
        if (!sf.base.isNullOrUndefined(e.item.altText)) {
            imgElement.setAttribute('alt', e.item.altText);
        }
        if (!sf.base.isNullOrUndefined(e.item.width) && !sf.base.isNullOrUndefined(e.item.width.width)) {
            imgElement.setAttribute('width', this.calculateStyleValue(e.item.width.width));
        }
        if (!sf.base.isNullOrUndefined(e.item.height) && !sf.base.isNullOrUndefined(e.item.height.height)) {
            imgElement.setAttribute('height', this.calculateStyleValue(e.item.height.height));
        }
        if (!sf.base.isNullOrUndefined(e.item.width) && !sf.base.isNullOrUndefined(e.item.width.minWidth)) {
            imgElement.style.minWidth = this.calculateStyleValue(e.item.width.minWidth);
        }
        if (!sf.base.isNullOrUndefined(e.item.width) && !sf.base.isNullOrUndefined(e.item.width.maxWidth)) {
            imgElement.style.maxWidth = this.calculateStyleValue(e.item.width.maxWidth);
        }
        if (!sf.base.isNullOrUndefined(e.item.height) && !sf.base.isNullOrUndefined(e.item.height.minHeight)) {
            imgElement.style.minHeight = this.calculateStyleValue(e.item.height.minHeight);
        }
        if (!sf.base.isNullOrUndefined(e.item.height) && !sf.base.isNullOrUndefined(e.item.height.maxHeight)) {
            imgElement.style.maxHeight = this.calculateStyleValue(e.item.height.maxHeight);
        }
    };
    ImageCommand.prototype.calculateStyleValue = function (value) {
        var styleValue;
        if (typeof (value) === 'string') {
            if (value.indexOf('px') || value.indexOf('%') || value.indexOf('auto')) {
                styleValue = value;
            }
            else {
                styleValue = value + 'px';
            }
        }
        else {
            styleValue = value + 'px';
        }
        return styleValue;
    };
    ImageCommand.prototype.insertImageLink = function (e) {
        var anchor = sf.base.createElement('a', {
            attrs: {
                href: e.item.url
            }
        });
        if (e.item.selectNode[0].parentElement.classList.contains('e-img-wrap')) {
            e.item.selection.restore();
            anchor.setAttribute('contenteditable', 'true');
        }
        anchor.appendChild(e.item.selectNode[0]);
        if (!sf.base.isNullOrUndefined(e.item.target)) {
            anchor.setAttribute('target', e.item.target);
        }
        InsertHtml.Insert(this.parent.currentDocument, anchor, this.parent.editableElement);
        this.callBack(e);
    };
    ImageCommand.prototype.openImageLink = function (e) {
        document.defaultView.open(e.item.url, e.item.target);
        this.callBack(e);
    };
    ImageCommand.prototype.removeImageLink = function (e) {
        var selectParent = e.item.selectParent[0];
        if (selectParent.classList.contains('e-img-caption')) {
            var capImgWrap = sf.base.select('.e-img-wrap', selectParent);
            var textEle = sf.base.select('.e-img-inner', selectParent);
            var newTextEle = textEle.cloneNode(true);
            sf.base.detach(sf.base.select('a', selectParent));
            sf.base.detach(textEle);
            capImgWrap.appendChild(e.item.insertElement);
            capImgWrap.appendChild(newTextEle);
        }
        else {
            sf.base.detach(selectParent);
            if (sf.base.Browser.isIE) {
                e.item.selection.restore();
            }
            InsertHtml.Insert(this.parent.currentDocument, e.item.insertElement, this.parent.editableElement);
        }
        this.callBack(e);
    };
    ImageCommand.prototype.editImageLink = function (e) {
        e.item.selectNode[0].parentElement.href = e.item.url;
        if (sf.base.isNullOrUndefined(e.item.target)) {
            e.item.selectNode[0].parentElement.removeAttribute('target');
        }
        else {
            e.item.selectNode[0].parentElement.target = e.item.target;
        }
        this.callBack(e);
    };
    ImageCommand.prototype.removeImage = function (e) {
        if (sf.base.closest(e.item.selectNode[0], 'a')) {
            if (e.item.selectNode[0].parentElement.nodeName === 'A' && !sf.base.isNullOrUndefined(e.item.selectNode[0].parentElement.innerText)) {
                sf.base.detach(e.item.selectNode[0]);
            }
            else {
                sf.base.detach(sf.base.closest(e.item.selectNode[0], 'a'));
            }
        }
        else if (!sf.base.isNullOrUndefined(sf.base.closest(e.item.selectNode[0], '.' + CLASS_CAPTION))) {
            sf.base.detach(sf.base.closest(e.item.selectNode[0], '.' + CLASS_CAPTION));
        }
        else {
            sf.base.detach(e.item.selectNode[0]);
        }
        this.callBack(e);
    };
    ImageCommand.prototype.insertAltTextImage = function (e) {
        e.item.selectNode[0].setAttribute('alt', e.item.altText);
        this.callBack(e);
    };
    ImageCommand.prototype.imageDimension = function (e) {
        var selectNode = e.item.selectNode[0];
        selectNode.style.height = '';
        selectNode.style.width = '';
        e.item.width !== 'auto' ? selectNode.style.width = sf.base.formatUnit(e.item.width) :
            selectNode.removeAttribute('width');
        e.item.height !== 'auto' ? selectNode.style.height = sf.base.formatUnit(e.item.height) :
            selectNode.removeAttribute('height');
        this.callBack(e);
    };
    ImageCommand.prototype.imageCaption = function (e) {
        InsertHtml.Insert(this.parent.currentDocument, e.item.insertElement, this.parent.editableElement);
        this.callBack(e);
    };
    ImageCommand.prototype.imageJustifyLeft = function (e) {
        var selectNode = e.item.selectNode[0];
        if (!sf.base.isNullOrUndefined(selectNode)) {
            selectNode.removeAttribute('class');
            sf.base.addClass([selectNode], 'e-rte-image');
            if (!sf.base.isNullOrUndefined(sf.base.closest(selectNode, '.' + CLASS_CAPTION))) {
                sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_RIGHT);
                sf.base.addClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_LEFT);
            }
            if (selectNode.parentElement.nodeName === 'A') {
                sf.base.removeClass([selectNode.parentElement], CLASS_IMAGE_RIGHT);
                sf.base.addClass([selectNode.parentElement], CLASS_IMAGE_LEFT);
                sf.base.addClass([selectNode], CLASS_IMAGE_LEFT);
            }
            else {
                sf.base.addClass([selectNode], CLASS_IMAGE_LEFT);
            }
            this.callBack(e);
        }
    };
    ImageCommand.prototype.imageJustifyCenter = function (e) {
        var selectNode = e.item.selectNode[0];
        if (!sf.base.isNullOrUndefined(selectNode)) {
            selectNode.removeAttribute('class');
            sf.base.addClass([selectNode], 'e-rte-image');
            if (!sf.base.isNullOrUndefined(sf.base.closest(selectNode, '.' + CLASS_CAPTION))) {
                sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_LEFT);
                sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_RIGHT);
                sf.base.addClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_CENTER);
            }
            if (selectNode.parentElement.nodeName === 'A') {
                sf.base.removeClass([selectNode.parentElement], CLASS_IMAGE_LEFT);
                sf.base.removeClass([selectNode.parentElement], CLASS_IMAGE_RIGHT);
                sf.base.addClass([selectNode.parentElement], CLASS_IMAGE_CENTER);
                sf.base.addClass([selectNode], CLASS_IMAGE_CENTER);
            }
            else {
                sf.base.addClass([selectNode], CLASS_IMAGE_CENTER);
            }
            this.callBack(e);
        }
    };
    ImageCommand.prototype.imageJustifyRight = function (e) {
        var selectNode = e.item.selectNode[0];
        if (!sf.base.isNullOrUndefined(selectNode)) {
            selectNode.removeAttribute('class');
            sf.base.addClass([selectNode], 'e-rte-image');
            if (!sf.base.isNullOrUndefined(sf.base.closest(selectNode, '.' + CLASS_CAPTION))) {
                sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_LEFT);
                sf.base.addClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_RIGHT);
            }
            if (selectNode.parentElement.nodeName === 'A') {
                sf.base.removeClass([selectNode.parentElement], CLASS_IMAGE_LEFT);
                sf.base.addClass([selectNode.parentElement], CLASS_IMAGE_RIGHT);
                sf.base.addClass([selectNode], CLASS_IMAGE_RIGHT);
            }
            else {
                sf.base.addClass([selectNode], CLASS_IMAGE_RIGHT);
            }
            this.callBack(e);
        }
    };
    ImageCommand.prototype.imageInline = function (e) {
        var selectNode = e.item.selectNode[0];
        selectNode.removeAttribute('class');
        sf.base.addClass([selectNode], 'e-rte-image');
        sf.base.addClass([selectNode], CLASS_IMAGE_INLINE);
        if (!sf.base.isNullOrUndefined(sf.base.closest(selectNode, '.' + CLASS_CAPTION))) {
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_BREAK);
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_CENTER);
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_LEFT);
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_RIGHT);
            sf.base.addClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_CAPTION_INLINE);
        }
        this.callBack(e);
    };
    ImageCommand.prototype.imageBreak = function (e) {
        var selectNode = e.item.selectNode[0];
        selectNode.removeAttribute('class');
        sf.base.addClass([selectNode], CLASS_IMAGE_BREAK);
        sf.base.addClass([selectNode], 'e-rte-image');
        if (!sf.base.isNullOrUndefined(sf.base.closest(selectNode, '.' + CLASS_CAPTION))) {
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_CAPTION_INLINE);
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_CENTER);
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_LEFT);
            sf.base.removeClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_RIGHT);
            sf.base.addClass([sf.base.closest(selectNode, '.' + CLASS_CAPTION)], CLASS_IMAGE_BREAK);
        }
        this.callBack(e);
    };
    ImageCommand.prototype.callBack = function (e) {
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    return ImageCommand;
}());

/**
 * Link internal component
 *
 * @hidden
 * @deprecated
 */
var TableCommand = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function TableCommand(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    TableCommand.prototype.addEventListener = function () {
        this.parent.observer.on(TABLE, this.createTable, this);
        this.parent.observer.on(INSERT_ROW, this.insertRow, this);
        this.parent.observer.on(INSERT_COLUMN, this.insertColumn, this);
        this.parent.observer.on(DELETEROW, this.deleteRow, this);
        this.parent.observer.on(DELETECOLUMN, this.deleteColumn, this);
        this.parent.observer.on(REMOVETABLE, this.removeTable, this);
        this.parent.observer.on(TABLEHEADER, this.tableHeader, this);
        this.parent.observer.on(TABLE_VERTICAL_ALIGN, this.tableVerticalAlign, this);
        this.parent.observer.on(TABLE_MERGE, this.cellMerge, this);
        this.parent.observer.on(TABLE_HORIZONTAL_SPLIT, this.HorizontalSplit, this);
        this.parent.observer.on(TABLE_VERTICAL_SPLIT, this.VerticalSplit, this);
        this.parent.observer.on(TABLE_MOVE, this.tableMove, this);
    };
    TableCommand.prototype.createTable = function (e) {
        var table = sf.base.createElement('table', { className: 'e-rte-table' });
        var tblBody = sf.base.createElement('tbody');
        if (!sf.base.isNullOrUndefined(e.item.width.width)) {
            table.style.width = this.calculateStyleValue(e.item.width.width);
        }
        if (!sf.base.isNullOrUndefined(e.item.width.minWidth)) {
            table.style.minWidth = this.calculateStyleValue(e.item.width.minWidth);
        }
        if (!sf.base.isNullOrUndefined(e.item.width.maxWidth)) {
            table.style.maxWidth = this.calculateStyleValue(e.item.width.maxWidth);
        }
        var tdWid = parseInt(e.item.width.width, 10) > 100 ?
            100 / e.item.columns : parseInt(e.item.width.width, 10) / e.item.columns;
        for (var i = 0; i < e.item.rows; i++) {
            var row = sf.base.createElement('tr');
            for (var j = 0; j < e.item.columns; j++) {
                var cell = sf.base.createElement('td');
                cell.appendChild(sf.base.createElement('br'));
                cell.style.width = tdWid + '%';
                row.appendChild(cell);
            }
            tblBody.appendChild(row);
        }
        table.appendChild(tblBody);
        e.item.selection.restore();
        InsertHtml.Insert(this.parent.currentDocument, table, this.parent.editableElement);
        this.removeEmptyNode();
        e.item.selection.setSelectionText(this.parent.currentDocument, table.querySelector('td'), table.querySelector('td'), 0, 0);
        if (table.nextElementSibling === null) {
            var insertElem = void 0;
            if (e.enterAction === 'DIV') {
                insertElem = sf.base.createElement('div');
                insertElem.appendChild(sf.base.createElement('br'));
            }
            else if (e.enterAction === 'BR') {
                insertElem = sf.base.createElement('br');
            }
            else {
                insertElem = sf.base.createElement('p');
                insertElem.appendChild(sf.base.createElement('br'));
            }
            this.insertAfter(insertElem, table);
        }
        table.querySelector('td').classList.add('e-cell-select');
        if (e.callBack) {
            e.callBack({
                requestType: 'Table',
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: [table]
            });
        }
        return table;
    };
    TableCommand.prototype.calculateStyleValue = function (value) {
        var styleValue;
        if (typeof (value) === 'string') {
            if (value.indexOf('px') || value.indexOf('%') || value.indexOf('auto')) {
                styleValue = value;
            }
            else {
                styleValue = value + 'px';
            }
        }
        else {
            styleValue = value + 'px';
        }
        return styleValue;
    };
    TableCommand.prototype.removeEmptyNode = function () {
        var emptyUl = this.parent.editableElement.querySelectorAll('ul:empty, ol:empty');
        for (var i = 0; i < emptyUl.length; i++) {
            sf.base.detach(emptyUl[i]);
        }
        var emptyLiChild = this.parent.editableElement.querySelectorAll('li *:empty');
        for (var i = 0; i < emptyLiChild.length; i++) {
            sf.base.detach(emptyLiChild[i]);
            if (emptyLiChild.length === i + 1) {
                emptyLiChild = this.parent.editableElement.querySelectorAll('li *:empty');
                i = -1;
            }
        }
        var emptyLi = this.parent.editableElement.querySelectorAll('li:empty');
        for (var i = 0; i < emptyLi.length; i++) {
            sf.base.detach(emptyLi[i]);
        }
    };
    TableCommand.prototype.insertAfter = function (newNode, referenceNode) {
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    };
    TableCommand.prototype.getSelectedCellMinMaxIndex = function (e) {
        var selectedCells = this.curTable.querySelectorAll('.e-cell-select');
        var a = 0;
        var minI = e.length;
        var maxI = 0;
        var minJ = e[0].length;
        var maxJ = 0;
        //eslint-disable-next-line
        for (; a < selectedCells.length; a++) {
            var selectedCellIndex = this.getCorrespondingIndex(selectedCells[a], e);
            var minMaxIndex = this.FindIndex(selectedCellIndex[0], selectedCellIndex[1], e);
            //eslint-disable-next-line
            minI = Math.min(selectedCellIndex[0], minI), maxI = Math.max(minMaxIndex[0], maxI), minJ = Math.min(selectedCellIndex[1], minJ), maxJ = Math.max(minMaxIndex[1], maxJ);
        }
        return {
            startRow: minI,
            endRow: maxI,
            startColumn: minJ,
            endColumn: maxJ
        };
    };
    TableCommand.prototype.insertRow = function (e) {
        var isBelow = e.item.subCommand === 'InsertRowBefore' ? false : true;
        var selectedCell = e.item.selection.range.startContainer;
        if (!(selectedCell.nodeName === 'TH' || selectedCell.nodeName === 'TD')) {
            selectedCell = sf.base.closest(selectedCell.parentElement, 'td,th');
        }
        if (selectedCell.nodeName.toLowerCase() === 'th' && e.item.subCommand === 'InsertRowBefore') {
            return;
        }
        this.curTable = sf.base.closest(this.parent.nodeSelection.range.startContainer.parentElement, 'table');
        if (this.curTable.querySelectorAll('.e-cell-select').length === 0) {
            var lastRow = this.curTable.rows[this.curTable.rows.length - 1];
            var cloneRow = lastRow.cloneNode(true);
            cloneRow.removeAttribute('rowspan');
            this.insertAfter(cloneRow, lastRow);
        }
        else {
            var allCells = this.getCorrespondingColumns();
            var minMaxIndex = this.getSelectedCellMinMaxIndex(allCells);
            var minVal = isBelow ? minMaxIndex.endRow : minMaxIndex.startRow;
            var newRow = sf.base.createElement('tr');
            var isHeaderSelect = this.curTable.querySelectorAll('th.e-cell-select').length > 0;
            for (var i = 0; i < allCells[minVal].length; i++) {
                if (isBelow && minVal < allCells.length - 1 && allCells[minVal][i] === allCells[minVal + 1][i] ||
                    !isBelow && 0 < minVal && allCells[minVal][i] === allCells[minVal - 1][i]) {
                    if (0 === i || 0 < i && allCells[minVal][i] !== allCells[minVal][i - 1]) {
                        allCells[minVal][i].setAttribute('rowspan', (parseInt(allCells[minVal][i].getAttribute('rowspan'), 10) + 1).toString());
                    }
                }
                else {
                    var tdElement = sf.base.createElement('td');
                    tdElement.appendChild(sf.base.createElement('br'));
                    newRow.appendChild(tdElement);
                    tdElement.setAttribute('style', allCells[(isHeaderSelect && isBelow) ? (minVal + 1) : minVal][i].getAttribute('style'));
                }
            }
            // eslint-disable-next-line
            var selectedRow = void 0;
            if (isHeaderSelect && isBelow) {
                selectedRow = this.curTable.querySelector('tbody').childNodes[0];
            }
            else {
                selectedRow = this.curTable.rows[minVal];
            }
            // eslint-disable-next-line
            (e.item.subCommand === 'InsertRowBefore') ? selectedRow.parentElement.insertBefore(newRow, selectedRow) :
                (isHeaderSelect ? selectedRow.parentElement.insertBefore(newRow, selectedRow) :
                    this.insertAfter(newRow, selectedRow));
        }
        e.item.selection.setSelectionText(this.parent.currentDocument, e.item.selection.range.startContainer, e.item.selection.range.startContainer, 0, 0);
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.insertColumn = function (e) {
        var selectedCell = e.item.selection.range.startContainer;
        if (!(selectedCell.nodeName === 'TH' || selectedCell.nodeName === 'TD')) {
            selectedCell = sf.base.closest(selectedCell.parentElement, 'td,th');
        }
        var curRow = sf.base.closest(selectedCell, 'tr');
        var curCell;
        var allRows = sf.base.closest((curRow), 'table').rows;
        var colIndex = Array.prototype.slice.call(curRow.querySelectorAll(':scope > td, :scope > th')).indexOf(selectedCell);
        var previousWidth = parseInt(e.item.width, 10) / (curRow.querySelectorAll(':scope > td, :scope > th').length);
        var currentWidth = parseInt(e.item.width, 10) / (curRow.querySelectorAll(':scope > td, :scope > th').length + 1);
        var currentTabElm = sf.base.closest(curRow, 'table');
        var thTdElm = sf.base.closest(curRow, 'table').querySelectorAll('th,td');
        for (var i = 0; i < thTdElm.length; i++) {
            thTdElm[i].dataset.oldWidth = (thTdElm[i].offsetWidth / currentTabElm.offsetWidth * 100) + "%";
        }
        for (var i = 0; i < allRows.length; i++) {
            curCell = allRows[i].querySelectorAll(':scope > td, :scope > th')[colIndex];
            var colTemplate = curCell.cloneNode(true);
            colTemplate.innerHTML = '';
            colTemplate.appendChild(sf.base.createElement('br'));
            colTemplate.removeAttribute('class');
            colTemplate.removeAttribute('colspan');
            colTemplate.removeAttribute('rowspan');
            // eslint-disable-next-line
            (e.item.subCommand === 'InsertColumnLeft') ? curCell.parentElement.insertBefore(colTemplate, curCell) :
                this.insertAfter(colTemplate, curCell);
            colTemplate.style.width = currentWidth.toFixed(4) + "%";
            delete colTemplate.dataset.oldWidth;
        }
        for (var i = 0; i < thTdElm.length; i++) {
            thTdElm[i].style.width = (Number(thTdElm[i].dataset.oldWidth.split('%')[0]) * currentWidth / previousWidth).toFixed(4) + "%";
            delete thTdElm[i].dataset.oldWidth;
        }
        e.item.selection.setSelectionText(this.parent.currentDocument, selectedCell, selectedCell, 0, 0);
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.deleteColumn = function (e) {
        var selectedCell = e.item.selection.range.startContainer;
        if (selectedCell.nodeType === 3) {
            selectedCell = sf.base.closest(selectedCell.parentElement, 'td,th');
        }
        var tBodyHeadEle = sf.base.closest(selectedCell, selectedCell.tagName === 'TH' ? 'thead' : 'tbody');
        var rowIndex = tBodyHeadEle && Array.prototype.indexOf.call(tBodyHeadEle.childNodes, selectedCell.parentNode);
        this.curTable = sf.base.closest(selectedCell, 'table');
        var curRow = sf.base.closest(selectedCell, 'tr');
        if (curRow.querySelectorAll('th,td').length === 1) {
            e.item.selection.restore();
            sf.base.detach(sf.base.closest(selectedCell.parentElement, 'table'));
        }
        else {
            var deleteIndex = void 0;
            var allCells = this.getCorrespondingColumns();
            //eslint-disable-next-line
            var selectedMinMaxIndex = this.getSelectedCellMinMaxIndex(allCells);
            var minCol = selectedMinMaxIndex.startColumn;
            var maxCol = selectedMinMaxIndex.endColumn;
            for (var i = 0; i < allCells.length; i++) {
                var currentRow = allCells[i];
                for (var j = 0; j < currentRow.length; j++) {
                    var currentCell = currentRow[j];
                    //eslint-disable-next-line
                    var currentCellIndex = this.getCorrespondingIndex(currentCell, allCells);
                    var colSpanVal = parseInt(currentCell.getAttribute('colspan'), 10) || 1;
                    if (currentCellIndex[1] + (colSpanVal - 1) >= minCol && currentCellIndex[1] <= maxCol) {
                        if (colSpanVal > 1) {
                            currentCell.setAttribute('colspan', (colSpanVal - 1).toString());
                        }
                        else {
                            sf.base.detach(currentCell);
                            deleteIndex = j;
                            if (sf.base.Browser.isIE) {
                                e.item.selection.setSelectionText(this.parent.currentDocument, this.curTable.querySelector('td'), this.curTable.querySelector('td'), 0, 0);
                                this.curTable.querySelector('td, th').classList.add('e-cell-select');
                            }
                        }
                    }
                }
            }
            if (deleteIndex > -1) {
                var rowHeadEle = tBodyHeadEle.children[rowIndex];
                var nextFocusCell = rowHeadEle &&
                    rowHeadEle.children[(deleteIndex <= rowHeadEle.children.length - 1 ? deleteIndex : deleteIndex - 1)];
                if (nextFocusCell) {
                    e.item.selection.setSelectionText(this.parent.currentDocument, nextFocusCell, nextFocusCell, 0, 0);
                    nextFocusCell.classList.add('e-cell-select');
                }
            }
        }
        if (e.callBack) {
            var sContainer = this.parent.nodeSelection.getRange(this.parent.currentDocument).startContainer;
            if (sContainer.nodeName !== 'TD') {
                var startChildLength = this.parent.nodeSelection.getRange(this.parent.currentDocument).startOffset;
                var focusNode = sContainer.children[startChildLength];
                if (focusNode) {
                    this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, focusNode, 0);
                }
            }
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.deleteRow = function (e) {
        var selectedCell = e.item.selection.range.startContainer;
        if (selectedCell.nodeType === 3) {
            selectedCell = sf.base.closest(selectedCell.parentElement, 'td,th');
        }
        var colIndex = Array.prototype.indexOf.call(selectedCell.parentNode.childNodes, selectedCell);
        this.curTable = sf.base.closest(selectedCell, 'table');
        var currentRow;
        var allCells = this.getCorrespondingColumns();
        var minMaxIndex = this.getSelectedCellMinMaxIndex(allCells);
        var maxI;
        var j;
        if (this.curTable.rows.length === 1) {
            e.item.selection.restore();
            sf.base.detach(sf.base.closest(selectedCell.parentElement, 'table'));
        }
        else {
            for (maxI = minMaxIndex.endRow; maxI >= minMaxIndex.startRow; maxI--) {
                currentRow = this.curTable.rows[maxI];
                for (j = 0; j < allCells[maxI].length; j++) {
                    if (j === 0 || allCells[maxI][j] !== allCells[maxI][j - 1]) {
                        if (1 < parseInt(allCells[maxI][j].getAttribute('rowspan'), 10)) {
                            var rowSpanVal = parseInt(allCells[maxI][j].getAttribute('rowspan'), 10) - 1;
                            //eslint-disable-next-line
                            1 === rowSpanVal ? allCells[maxI][j].removeAttribute('rowspan') : allCells[maxI][j].setAttribute('rowspan', rowSpanVal.toString());
                        }
                    }
                    if (maxI < allCells.length - 1 && allCells[maxI][j] === allCells[maxI + 1][j] && (0 === maxI ||
                        allCells[maxI][j] !== allCells[maxI - 1][j])) {
                        var element = allCells[maxI][j];
                        var index = void 0;
                        for (index = j; 0 < index && allCells[maxI][index] === allCells[maxI][index - 1]; index--) {
                            if (index === 0) {
                                this.curTable.rows[maxI + 1].prepend(element);
                            }
                            else {
                                allCells[maxI + 1][index - 1].insertAdjacentElement('afterend', element);
                            }
                        }
                    }
                }
                var deleteIndex = currentRow.rowIndex;
                this.curTable.deleteRow(deleteIndex);
                var focusTrEle = !sf.base.isNullOrUndefined(this.curTable.rows[deleteIndex]) ? this.curTable.querySelectorAll('tbody tr')[deleteIndex]
                    : this.curTable.querySelectorAll('tbody tr')[deleteIndex - 1];
                var nextFocusCell = focusTrEle && focusTrEle.querySelectorAll('td')[colIndex];
                if (nextFocusCell) {
                    e.item.selection.setSelectionText(this.parent.currentDocument, nextFocusCell, nextFocusCell, 0, 0);
                    nextFocusCell.classList.add('e-cell-select');
                }
                else {
                    e.item.selection.setSelectionText(this.parent.currentDocument, this.curTable.querySelector('td'), this.curTable.querySelector('td'), 0, 0);
                    this.curTable.querySelector('td, th').classList.add('e-cell-select');
                }
            }
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.removeTable = function (e) {
        var selectedCell = e.item.selection.range.startContainer;
        selectedCell = (selectedCell.nodeType === 3) ? selectedCell.parentNode : selectedCell;
        var selectedTable = sf.base.closest(selectedCell.parentElement, 'table');
        if (selectedTable) {
            e.item.selection.restore();
            sf.base.detach(selectedTable);
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.tableHeader = function (e) {
        var headerExit = false;
        var selectedCell = e.item.selection.range.startContainer;
        selectedCell = (selectedCell.nodeType === 3) ? selectedCell.parentNode : selectedCell;
        var table = sf.base.closest(selectedCell.parentElement, 'table');
        [].slice.call(table.childNodes).forEach(function (el) {
            if (el.nodeName === 'THEAD') {
                headerExit = true;
            }
        });
        if (table && !headerExit) {
            var cellCount = table.querySelector('tr').childElementCount;
            var colSpanCount = 0;
            for (var i = 0; i < cellCount; i++) {
                colSpanCount = colSpanCount + (parseInt(table.querySelector('tr').children[i].getAttribute('colspan'), 10) || 1);
            }
            var header = table.createTHead();
            var row = header.insertRow(0);
            for (var j = 0; j < colSpanCount; j++) {
                var th = sf.base.createElement('th');
                th.appendChild(sf.base.createElement('br'));
                row.appendChild(th);
            }
        }
        else {
            table.deleteTHead();
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.tableVerticalAlign = function (e) {
        if (e.item.subCommand === 'AlignTop') {
            e.item.tableCell.style.verticalAlign = 'top';
        }
        else if (e.item.subCommand === 'AlignMiddle') {
            e.item.tableCell.style.verticalAlign = 'middle';
        }
        else {
            e.item.tableCell.style.verticalAlign = 'bottom';
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.cellMerge = function (e) {
        if (sf.base.isNullOrUndefined(this.curTable)) {
            this.curTable = sf.base.closest(this.parent.nodeSelection.range.startContainer.parentElement, 'table');
        }
        var selectedCells = this.curTable.querySelectorAll('.e-cell-select');
        if (selectedCells.length < 2) {
            return;
        }
        this.mergeCellContent();
        var minMaxIndexes = this.getSelectedMinMaxIndexes(this.getCorrespondingColumns());
        var firstCell = selectedCells[0];
        var rowSelectedCells = firstCell.parentElement.querySelectorAll('.e-cell-select');
        if (minMaxIndexes.startColumn < minMaxIndexes.endColumn) {
            firstCell.setAttribute('colspan', (minMaxIndexes.endColumn - minMaxIndexes.startColumn + 1).toString());
        }
        if (minMaxIndexes.startRow < minMaxIndexes.endRow) {
            firstCell.setAttribute('rowspan', (minMaxIndexes.endRow - minMaxIndexes.startRow + 1).toString());
        }
        var totalWidth = 0;
        for (var j = rowSelectedCells.length - 1; j >= 0; j--) {
            totalWidth = totalWidth + parseFloat(rowSelectedCells[j].style.width);
        }
        firstCell.style.width = totalWidth + '%';
        for (var i = 1; i <= selectedCells.length - 1; i++) {
            sf.base.detach(selectedCells[i]);
        }
        for (var i = 0; i < this.curTable.rows.length; i++) {
            if (this.curTable.rows[i].innerHTML === '') {
                sf.base.detach(this.curTable.rows[i]);
            }
        }
        this.updateRowSpanStyle(minMaxIndexes.startRow, minMaxIndexes.endRow, this.getCorrespondingColumns());
        this.updateColSpanStyle(minMaxIndexes.startColumn, minMaxIndexes.endColumn, this.getCorrespondingColumns());
        e.item.selection.setSelectionText(this.parent.currentDocument, e.item.selection.range.startContainer, e.item.selection.range.startContainer, 0, 0);
        if (this.parent.nodeSelection.range) {
            this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, 
            // eslint-disable-next-line
            this.parent.nodeSelection.range.endContainer, 0);
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.updateColSpanStyle = function (min, max, elements) {
        var colValue;
        var colIndex;
        var colMin;
        var index = 0;
        var attrValue;
        var count = 0;
        var eleArray = elements;
        //eslint-disable-next-line
        if (min < (max = Math.min(max, eleArray[0].length - 1))) {
            for (colIndex === min; colIndex <= max; colIndex++) {
                // eslint-disable-next-line
                if (!(min < colIndex && eleArray[0][colIndex] === eleArray[0][colIndex - 1]) && 1 < (index =
                    Math.min(parseInt(eleArray[0][colIndex].getAttribute('colspan'), 10) || 1, max - min + 1)) &&
                    eleArray[0][colIndex] === eleArray[0][colIndex + 1]) {
                    for (count = index - 1, colValue = 1; colValue < eleArray.length; colValue++) {
                        if (eleArray[colValue][colIndex] !== eleArray[colValue - 1][colIndex]) {
                            /* eslint-disable */
                            for (colMin = colIndex; colMin < colIndex + index; colMin++) {
                                if (1 < (attrValue = parseInt(eleArray[colValue][colMin].getAttribute('colspan'), 10) || 1) &&
                                    eleArray[colValue][colMin] === eleArray[colValue][colMin + 1]) {
                                    colMin += count = Math.min(count, attrValue - 1);
                                }
                                else if (!(count = Math.max(0, count - 1))) {
                                    break;
                                }
                                /* eslint-enable */
                            }
                        }
                        if (!count) {
                            break;
                        }
                    }
                }
            }
            if (count) {
                this.updateCellAttribute(eleArray, count, 'colspan', 0, eleArray.length - 1, min, max);
            }
        }
    };
    TableCommand.prototype.updateRowSpanStyle = function (min, max, ele) {
        var rowValue;
        var colIndex;
        var rowMin;
        var index = 0;
        var attrValue;
        var count = 0;
        var eleArray = ele;
        // eslint-disable-next-line
        if (min < (max = Math.min(max, eleArray.length - 1))) {
            for (rowValue = min; rowValue <= max; rowValue++) {
                // eslint-disable-next-line
                if (!(min < rowValue && eleArray[rowValue][0] === eleArray[rowValue - 1][0]) && 1 < (index = Math.min(parseInt(eleArray[rowValue][0].getAttribute('rowspan'), 10) || 1, max - min + 1)) && eleArray[rowValue][0] === eleArray[rowValue + 1][0]) {
                    for (count = index - 1, colIndex = 1; colIndex < eleArray[0].length; colIndex++) {
                        if (eleArray[rowValue][colIndex] !== eleArray[rowValue][colIndex - 1]) {
                            for (rowMin = rowValue; rowMin < rowValue + index; rowMin++) {
                                // eslint-disable-next-line
                                if (1 < (attrValue = parseInt(eleArray[rowMin][colIndex].getAttribute('rowspan'), 10) || 1) && eleArray[rowMin][colIndex] === eleArray[rowMin + 1][colIndex]) {
                                    rowMin += count = Math.min(count, attrValue - 1);
                                }
                                // eslint-disable-next-line
                                else if (!(count = Math.max(0, count - 1))) {
                                    break;
                                }
                            }
                            if (!count) {
                                break;
                            }
                        }
                    }
                }
            }
            if (count) {
                this.updateCellAttribute(eleArray, count, 'rowspan', min, max, 0, eleArray[0].length - 1);
            }
        }
    };
    TableCommand.prototype.updateCellAttribute = function (elements, index, attr, min, max, firstIndex, length) {
        var rowIndex;
        var colIndex;
        var spanCount;
        for (rowIndex = min; rowIndex <= max; rowIndex++) {
            for (colIndex = firstIndex; colIndex <= length; colIndex++) {
                // eslint-disable-next-line
                min < rowIndex && elements[rowIndex][colIndex] === elements[rowIndex - 1][colIndex] ||
                    firstIndex < colIndex && elements[rowIndex][colIndex] === elements[rowIndex][colIndex - 1] ||
                    1 < (spanCount = parseInt(elements[rowIndex][colIndex].getAttribute(attr), 10) || 1) &&
                        (1 < spanCount - index ? elements[rowIndex][colIndex].setAttribute(attr, (spanCount - index).toString()) :
                            elements[rowIndex][colIndex].removeAttribute(attr));
            }
        }
    };
    TableCommand.prototype.mergeCellContent = function () {
        var selectedCells = this.curTable.querySelectorAll('.e-cell-select');
        var innerHtml = selectedCells[0].innerHTML;
        for (var i = 1; i < selectedCells.length - 1; i++) {
            if ('<br>' !== selectedCells[i].innerHTML) {
                innerHtml = innerHtml + selectedCells[i].innerHTML;
            }
        }
        selectedCells[0].innerHTML = innerHtml;
    };
    TableCommand.prototype.getSelectedMinMaxIndexes = function (correspondingCells) {
        var selectedCells = this.curTable.querySelectorAll('.e-cell-select');
        if (0 < selectedCells.length) {
            var minRow = correspondingCells.length;
            var maxRow = 0;
            var minCol = correspondingCells[0].length;
            var maxCol = 0;
            for (var i = 0; i < selectedCells.length; i++) {
                var currentRowCol = this.getCorrespondingIndex(selectedCells[i], correspondingCells);
                var targetRowCol = this.FindIndex(currentRowCol[0], currentRowCol[1], correspondingCells);
                minRow = Math.min(currentRowCol[0], minRow);
                maxRow = Math.max(targetRowCol[0], maxRow);
                minCol = Math.min(currentRowCol[1], minCol);
                maxCol = Math.max(targetRowCol[1], maxCol);
            }
            return {
                startRow: minRow,
                endRow: maxRow,
                startColumn: minCol,
                endColumn: maxCol
            };
        }
        return null;
    };
    TableCommand.prototype.HorizontalSplit = function (e) {
        var selectedCell = e.item.selection.range.startContainer;
        this.curTable = sf.base.closest(selectedCell.parentElement, 'table');
        if (this.curTable.querySelectorAll('.e-cell-select').length > 1) {
            return;
        }
        this.activeCell = this.curTable.querySelector('.e-cell-select');
        var newCell = this.activeCell.cloneNode(true);
        newCell.removeAttribute('class');
        newCell.innerHTML = '</br>';
        var activeCellIndex = this.getCorrespondingIndex(this.activeCell, this.getCorrespondingColumns());
        var correspondingCells = this.getCorrespondingColumns();
        var activeCellRowSpan = this.activeCell.getAttribute('rowspan') ? parseInt(this.activeCell.getAttribute('rowspan'), 10) : 1;
        if (activeCellRowSpan > 1) {
            var avgCount = Math.ceil(activeCellRowSpan / 2);
            // eslint-disable-next-line
            1 < avgCount ? this.activeCell.setAttribute('rowspan', avgCount.toString()) :
                this.activeCell.removeAttribute('rowspan');
            // eslint-disable-next-line
            1 < (activeCellRowSpan - avgCount) ? newCell.setAttribute('rowspan', (activeCellRowSpan - avgCount).toString()) : newCell.removeAttribute('rowspan');
            var avgRowIndex = void 0;
            var colIndex = void 0;
            for (avgRowIndex = activeCellIndex[0] + Math.ceil(activeCellRowSpan / 2), colIndex = 0 === activeCellIndex[1] ? activeCellIndex[1]
                    : activeCellIndex[1] - 1; 0 <= colIndex && (correspondingCells[avgRowIndex][colIndex] ===
                correspondingCells[avgRowIndex][colIndex - 1] || 0 < avgRowIndex && correspondingCells[avgRowIndex][colIndex]
                === correspondingCells[avgRowIndex - 1][colIndex]);) {
                colIndex--;
            }
            if (colIndex === -1) {
                // eslint-disable-next-line
                this.curTable.rows[avgRowIndex].firstChild ? this.curTable.rows[avgRowIndex].prepend(newCell) : this.curTable.appendChild(newCell);
            }
            else {
                correspondingCells[avgRowIndex][colIndex].insertAdjacentElement('afterend', newCell);
            }
        }
        else {
            var newTrEle = sf.base.createElement('tr');
            newTrEle.appendChild(newCell);
            var selectedRow = correspondingCells[activeCellIndex[0]];
            for (var j = 0; j <= selectedRow.length - 1; j++) {
                if (selectedRow[j] !== selectedRow[j - 1] && selectedRow[j] !== this.activeCell) {
                    selectedRow[j].setAttribute('rowspan', ((parseInt(selectedRow[j].getAttribute('rowspan'), 10) ?
                        parseInt(selectedRow[j].getAttribute('rowspan'), 10) : 1) + 1).toString());
                }
            }
            this.activeCell.parentNode.insertAdjacentElement('afterend', newTrEle);
        }
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.VerticalSplit = function (e) {
        var selectedCell = e.item.selection.range.startContainer;
        this.curTable = sf.base.closest(selectedCell.parentElement, 'table');
        if (this.curTable.querySelectorAll('.e-cell-select').length > 1) {
            return;
        }
        this.activeCell = this.curTable.querySelector('.e-cell-select');
        var allRows = this.curTable.rows;
        var newCell = this.activeCell.cloneNode(true);
        newCell.removeAttribute('class');
        newCell.innerHTML = '</br>';
        var avgWidth = parseFloat(this.activeCell.style.width) / 2;
        if (this.activeCell.tagName === 'TH' && isNaN(avgWidth)) {
            var cellCount = this.curTable.querySelector('tr').childElementCount;
            var colSpanCount = 0;
            for (var i = 0; i < cellCount; i++) {
                colSpanCount = colSpanCount + (parseInt(this.curTable.querySelector('tr').children[i].getAttribute('colspan'), 10) || 1);
            }
            avgWidth = parseFloat((((this.activeCell.offsetWidth / 2) / this.curTable.offsetWidth) * 100).toFixed(1));
        }
        var activeCellIndex = this.getCorrespondingIndex(this.activeCell, this.getCorrespondingColumns());
        var correspondingColumns = this.getCorrespondingColumns();
        var activeCellcolSpan = parseInt(this.activeCell.getAttribute('colspan'), 10);
        if (activeCellcolSpan > 1) {
            // eslint-disable-next-line
            1 < Math.ceil(activeCellcolSpan / 2) ? this.activeCell.setAttribute('colspan', (activeCellcolSpan / 2).toString())
                : this.activeCell.removeAttribute('colspan');
            // eslint-disable-next-line
            1 < (activeCellcolSpan - activeCellcolSpan / 2) ? newCell.setAttribute('colspan', 
            // eslint-disable-next-line
            (activeCellcolSpan - activeCellcolSpan / 2).toString()) : newCell.removeAttribute('colspan');
        }
        else {
            for (var i = 0; i <= allRows.length - 1; i++) {
                if (0 === i || correspondingColumns[i][activeCellIndex[1]] !== correspondingColumns[i - 1][activeCellIndex[1]]) {
                    var currentCell = correspondingColumns[i][activeCellIndex[1]];
                    if (currentCell !== this.activeCell) {
                        currentCell.setAttribute('colspan', ((parseInt(currentCell.getAttribute('colspan'), 10) ?
                            parseInt(currentCell.getAttribute('colspan'), 10) : 1) + 1).toString());
                    }
                }
            }
        }
        this.activeCell.style.width = avgWidth + '%';
        newCell.style.width = avgWidth + '%';
        this.activeCell.parentNode.insertBefore(newCell, this.activeCell.nextSibling);
        if (e.callBack) {
            e.callBack({
                requestType: e.item.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    TableCommand.prototype.getCorrespondingColumns = function () {
        var elementArray = [];
        // eslint-disable-next-line
        var _this = this;
        var colspan = 0;
        var allRows = _this.curTable.rows;
        for (var i = 0; i <= allRows.length - 1; i++) {
            var ele = allRows[i];
            var index = 0;
            for (var j = 0; j <= ele.children.length - 1; j++) {
                /* eslint-disable */
                var colEle = ele.children[j];
                for (var ele_1 = colEle, colspan_1 = parseInt(ele_1.getAttribute('colspan'), 10) || 1, rowSpan = parseInt(ele_1.getAttribute('rowspan'), 10) || 1, rowIndex = i; rowIndex < i + rowSpan; rowIndex++) {
                    for (var colIndex = index; colIndex < index + colspan_1; colIndex++) {
                        elementArray[rowIndex] || (elementArray[rowIndex] = []);
                        elementArray[rowIndex][colIndex] ? index++ : elementArray[rowIndex][colIndex] = colEle;
                    }
                }
                index += colspan;
            }
            /* eslint-enable */
        }
        return elementArray;
    };
    // eslint-disable-next-line
    TableCommand.prototype.FindIndex = function (rowIndex, columnIndex, cells) {
        var nextIndex;
        var nextCol;
        for (nextIndex = rowIndex + 1, nextCol = columnIndex + 1; nextIndex < cells.length;) {
            if (cells[nextIndex][columnIndex] !== cells[rowIndex][columnIndex]) {
                nextIndex--;
                break;
            }
            nextIndex++;
        }
        for (nextIndex === cells.length && nextIndex--; nextCol < cells[rowIndex].length;) {
            if (cells[rowIndex][nextCol] !== cells[rowIndex][columnIndex]) {
                nextCol--;
                break;
            }
            nextCol++;
        }
        return nextCol === cells[rowIndex].length && nextCol--, [
                nextIndex,
                nextCol
            ];
    };
    TableCommand.prototype.getCorrespondingIndex = function (cell, allCells) {
        //let value: RowCol = new RowCol();
        for (var i = 0; i < allCells.length; i++) {
            for (var j = 0; j < allCells[i].length; j++) {
                if (allCells[i][j] === cell) {
                    return [i, j];
                }
            }
        }
        return [];
    };
    TableCommand.prototype.highlightCells = function (minRow, maxRow, minCol, maxCol, eleArray) {
        var j;
        var k;
        var startCell;
        var endCell;
        var minRowIndex = minRow;
        var maxRowIndex = maxRow;
        var minColIndex = minCol;
        var maxColIndex = maxCol;
        var minMaxValues = new MinMax();
        for (j = minRowIndex; j <= maxRowIndex; j++) {
            /* eslint-disable */
            if ((1 < (parseInt(eleArray[j][minColIndex].getAttribute('rowspan'), 10) || 1) ||
                1 < (parseInt(eleArray[j][minColIndex].getAttribute('colspan'), 10) || 1)) &&
                (endCell = this.FindIndex((startCell = this.getCorrespondingIndex(eleArray[j][minColIndex], eleArray))[0], startCell[1], eleArray))) {
                minRowIndex = Math.min(startCell[0], minRowIndex);
                maxRowIndex = Math.max(endCell[0], maxRowIndex);
                minColIndex = Math.min(startCell[1], minColIndex);
                maxColIndex = Math.max(endCell[1], maxColIndex);
            }
            else if ((1 < (parseInt(eleArray[j][maxColIndex].getAttribute('rowspan'), 10) || 1) ||
                1 < (parseInt(eleArray[j][maxColIndex].getAttribute('colspan'), 10) || 1)) &&
                (endCell = this.FindIndex((startCell = this.getCorrespondingIndex(eleArray[j][maxColIndex], eleArray))[0], startCell[1], eleArray))) {
                minRowIndex = Math.min(startCell[0], minRowIndex);
                maxRowIndex = Math.max(endCell[0], maxRowIndex);
                minColIndex = Math.min(startCell[1], minColIndex);
                maxColIndex = Math.max(endCell[1], maxColIndex);
            }
            for (k = minColIndex; k <= maxColIndex; k++) {
                if ((1 < (parseInt(eleArray[minRowIndex][k].getAttribute('rowspan'), 10) || 1) ||
                    1 < (parseInt(eleArray[minRowIndex][k].getAttribute('colspan'), 10) || 1)) &&
                    (endCell = this.FindIndex((startCell = this.getCorrespondingIndex(eleArray[minRowIndex][k], eleArray))[0], startCell[1], eleArray))) {
                    minRowIndex = Math.min(startCell[0], minRowIndex);
                    maxRowIndex = Math.max(endCell[0], maxRowIndex);
                    minColIndex = Math.min(startCell[1], minColIndex);
                    maxColIndex = Math.max(endCell[1], maxColIndex);
                }
                else if ((1 < (parseInt(eleArray[maxRowIndex][k].getAttribute('rowspan'), 10) || 1) ||
                    1 < (parseInt(eleArray[maxRowIndex][k].getAttribute('colspan'), 10) || 1)) &&
                    (endCell = this.FindIndex((startCell = this.getCorrespondingIndex(eleArray[maxRowIndex][k], eleArray))[0], startCell[1], eleArray))) {
                    minRowIndex = Math.min(startCell[0], minRowIndex);
                    maxRowIndex = Math.max(endCell[0], maxRowIndex);
                    minColIndex = Math.min(startCell[1], minColIndex);
                    maxColIndex = Math.max(endCell[1], maxColIndex);
                }
            }
            minMaxValues = minRowIndex === minRow && maxRowIndex === maxRow && minColIndex === minCol && maxColIndex === maxCol ? {
                startRow: minRow,
                endRow: maxRow,
                startColumn: minCol,
                endColumn: maxCol
            } : this.highlightCells(minRowIndex, maxRowIndex, minColIndex, maxColIndex, eleArray);
        }
        return minMaxValues;
        /* eslint-enable */
    };
    TableCommand.prototype.tableMove = function (e) {
        this.activeCell = e.selectNode[0];
        var target = e.event.target;
        var activeCellTag = this.activeCell.tagName;
        var targetCellTag = target.tagName;
        this.curTable = sf.base.closest(target, 'table');
        if (this.curTable.querySelectorAll('.e-cell-select').length > 1) {
            this.parent.nodeSelection.Clear(this.parent.currentDocument);
        }
        if ((target.tagName !== 'TD' && target.tagName !== 'TH') && activeCellTag !== targetCellTag) {
            return;
        }
        var activeRowIndex = Array.prototype.slice.call((this.activeCell).parentElement.parentElement.children)
            .indexOf((this.activeCell).parentElement);
        var activeColumnIndex = Array.prototype.slice.call((this.activeCell).parentElement.children).indexOf(this.activeCell);
        var targetRowIndex = Array.prototype.slice.call(target.parentElement.parentElement.children)
            .indexOf(target.parentElement);
        var targetColumnIndex = Array.prototype.slice.call(target.parentElement.children).indexOf(target);
        var activeCellList = this.curTable.querySelectorAll('.e-cell-select');
        for (var i = activeCellList.length - 1; i >= 0; i--) {
            if (this.activeCell !== activeCellList[i]) {
                activeCellList[i].classList.remove('e-cell-select');
            }
        }
        if (activeRowIndex === targetRowIndex && activeColumnIndex === targetColumnIndex) {
            return;
        }
        var correspondingCells = this.getCorrespondingColumns();
        var activeIndexes = this.getCorrespondingIndex(this.activeCell, correspondingCells);
        var targetIndexes = this.getCorrespondingIndex(target, correspondingCells);
        var minMaxIndexes = this.highlightCells(Math.min(activeIndexes[0], targetIndexes[0]), Math.max(activeIndexes[0], 
        /* eslint-disable */
        targetIndexes[0]), Math.min(activeIndexes[1], targetIndexes[1]), Math.max(activeIndexes[1], targetIndexes[1]), correspondingCells);
        for (var rowIndex = minMaxIndexes.startRow; rowIndex <= minMaxIndexes.endRow; rowIndex++) {
            for (var colIndex = minMaxIndexes.startColumn; colIndex <= minMaxIndexes.endColumn; colIndex++) {
                correspondingCells[rowIndex][colIndex].classList.add('e-cell-select');
            }
        }
        if (this.parent.nodeSelection.range) {
            this.parent.nodeSelection.setSelectionText(this.parent.currentDocument, this.parent.nodeSelection.range.endContainer, this.parent.nodeSelection.range.endContainer, 0, 0);
            this.parent.nodeSelection.setCursorPoint(this.parent.currentDocument, this.parent.nodeSelection.range.endContainer, 0);
        }
    };
    
    return TableCommand;
}());
var MinMax = /** @class */ (function () {
    function MinMax() {
    }
    return MinMax;
}());

/**
 * `Selection` module is used to handle RTE Selections.
 */
var SelectionCommands = /** @class */ (function () {
    function SelectionCommands() {
    }
    /**
     * applyFormat method
     *
     * @param {Document} docElement - specifies the document
     * @param {string} format - specifies the string value
     * @param {Node} endNode - specifies the end node
     * @param {string} value - specifies the string value
     * @param {string} selector - specifies the string
     * @returns {void}
     * @hidden
     * @deprecated
     */
    SelectionCommands.applyFormat = function (docElement, format, endNode, enterAction, value, selector) {
        this.enterAction = enterAction;
        var validFormats = ['bold', 'italic', 'underline', 'strikethrough', 'superscript',
            'subscript', 'uppercase', 'lowercase', 'fontcolor', 'fontname', 'fontsize', 'backgroundcolor'];
        if (validFormats.indexOf(format) > -1) {
            if (format === 'backgroundcolor' && value === '') {
                value = 'transparent';
            }
            var preventRestore = false;
            var domSelection = new NodeSelection();
            var domNode = new DOMNode(endNode, docElement);
            var nodeCutter = new NodeCutter();
            var isFormatted = new IsFormatted();
            var range = domSelection.getRange(docElement);
            var save = domSelection.save(range, docElement);
            var nodes = range.collapsed ? domSelection.getSelectionNodeCollection(range) :
                domSelection.getSelectionNodeCollectionBr(range);
            var isCollapsed = false;
            var isFormat = false;
            var isCursor = false;
            var isFontStyle = (['fontcolor', 'fontname', 'fontsize', 'backgroundcolor'].indexOf(format) > -1);
            if (range.collapsed) {
                if (nodes.length > 0) {
                    isCollapsed = true;
                    range = nodeCutter.GetCursorRange(docElement, range, nodes[0]);
                }
                else if (range.startContainer.nodeType === 3 && range.startContainer.parentElement.childElementCount > 0 &&
                    range.startOffset > 0 && range.startContainer.parentElement.firstElementChild.tagName.toLowerCase() !== 'br') {
                    isCollapsed = true;
                    range = nodeCutter.GetCursorRange(docElement, range, range.startContainer);
                    nodes.push(range.startContainer);
                }
                else {
                    var cursorNode = this.insertCursorNode(docElement, domSelection, range, isFormatted, nodeCutter, format, value, endNode);
                    domSelection.endContainer = domSelection.startContainer = domSelection.getNodeArray(cursorNode, true);
                    var childNodes = cursorNode.nodeName === 'BR' && cursorNode.parentNode.childNodes;
                    if (!sf.base.isNullOrUndefined(childNodes) && childNodes.length === 1 && childNodes[0].nodeName === 'BR' && nodes.length === 0) {
                        domSelection.setSelectionText(docElement, range.startContainer, range.endContainer, 0, 0);
                        preventRestore = true;
                    }
                    else {
                        domSelection.endOffset = domSelection.startOffset = 1;
                    }
                }
            }
            isCursor = range.collapsed;
            var isSubSup = false;
            for (var index = 0; index < nodes.length; index++) {
                var formatNode = isFormatted.getFormattedNode(nodes[index], format, endNode);
                if (formatNode === null) {
                    if (format === 'subscript') {
                        formatNode = isFormatted.getFormattedNode(nodes[index], 'superscript', endNode);
                        isSubSup = formatNode === null ? false : true;
                    }
                    else if (format === 'superscript') {
                        formatNode = isFormatted.getFormattedNode(nodes[index], 'subscript', endNode);
                        isSubSup = formatNode === null ? false : true;
                    }
                }
                if (index === 0 && formatNode === null) {
                    isFormat = true;
                }
                if (formatNode !== null && (!isFormat || isFontStyle)) {
                    nodes[index] = this.removeFormat(nodes, index, formatNode, isCursor, isFormat, isFontStyle, range, nodeCutter, format, value, domSelection, endNode, domNode);
                }
                else {
                    nodes[index] = this.insertFormat(docElement, nodes, index, formatNode, isCursor, isFormat, isFontStyle, range, nodeCutter, format, value);
                }
                domSelection = this.applySelection(nodes, domSelection, nodeCutter, index, isCollapsed);
            }
            if (isIDevice$1()) {
                setEditFrameFocus(endNode, selector);
            }
            if (!preventRestore) {
                save.restore();
            }
            if (isSubSup) {
                this.applyFormat(docElement, format, endNode, enterAction);
            }
        }
    };
    SelectionCommands.insertCursorNode = function (docElement, domSelection, range, isFormatted, nodeCutter, format, value, endNode) {
        var cursorNodes = domSelection.getNodeCollection(range);
        var cursorFormat = (cursorNodes.length > 0) ?
            (cursorNodes.length > 1 && range.startContainer === range.endContainer) ?
                this.getCursorFormat(isFormatted, cursorNodes, format, endNode) :
                isFormatted.getFormattedNode(cursorNodes[0], format, endNode) : null;
        var cursorNode = null;
        if (cursorFormat) {
            cursorNode = cursorNodes[0];
            InsertMethods.unwrap(cursorFormat);
        }
        else {
            if (cursorNodes.length > 1 && range.startOffset > 0 && (cursorNodes[0].firstElementChild &&
                cursorNodes[0].firstElementChild.tagName.toLowerCase() === 'br')) {
                cursorNodes[0].innerHTML = '';
            }
            if (cursorNodes.length === 1 && range.startOffset === 0 && (cursorNodes[0].nodeName === 'BR' ||
                cursorNodes[0].nextSibling.nodeName === 'BR')) {
                sf.base.detach(cursorNodes[0].nodeName === '#text' ? cursorNodes[0].nextSibling : cursorNodes[0]);
            }
            cursorNode = this.getInsertNode(docElement, range, format, value).firstChild;
        }
        return cursorNode;
    };
    SelectionCommands.getCursorFormat = function (isFormatted, cursorNodes, format, endNode) {
        var currentNode;
        for (var index = 0; index < cursorNodes.length; index++) {
            currentNode = cursorNodes[index].lastElementChild ?
                cursorNodes[index].lastElementChild : cursorNodes[index];
        }
        return isFormatted.getFormattedNode(currentNode, format, endNode);
    };
    SelectionCommands.removeFormat = function (nodes, index, formatNode, isCursor, isFormat, isFontStyle, range, nodeCutter, format, value, domSelection, endNode, domNode) {
        var splitNode = null;
        if (!(range.startContainer === range.endContainer && range.startOffset === 0
            && range.endOffset === range.startContainer.length)) {
            var nodeIndex = [];
            var cloneNode = nodes[index];
            do {
                nodeIndex.push(domSelection.getIndex(cloneNode));
                cloneNode = cloneNode.parentNode;
            } while (cloneNode && (cloneNode !== formatNode));
            if (nodes[index].nodeName !== 'BR') {
                cloneNode = splitNode = (isCursor && (formatNode.textContent.length - 1) === range.startOffset) ?
                    nodeCutter.SplitNode(range, formatNode, true)
                    : nodeCutter.GetSpliceNode(range, formatNode);
            }
            if (!isCursor) {
                while (cloneNode && cloneNode.childNodes.length > 0 && ((nodeIndex.length - 1) >= 0)
                    && (cloneNode.childNodes.length > nodeIndex[nodeIndex.length - 1])) {
                    cloneNode = cloneNode.childNodes[nodeIndex[nodeIndex.length - 1]];
                    nodeIndex.pop();
                }
                if (nodes[index].nodeName !== 'BR') {
                    if (cloneNode.nodeType === 3 && !(isCursor && cloneNode.nodeValue === '')) {
                        nodes[index] = cloneNode;
                    }
                    else {
                        var divNode = document.createElement('div');
                        divNode.innerHTML = '&#8203;';
                        if (cloneNode.nodeType !== 3) {
                            cloneNode.insertBefore(divNode.firstChild, cloneNode.firstChild);
                            nodes[index] = cloneNode.firstChild;
                        }
                        else {
                            cloneNode.parentNode.insertBefore(divNode.firstChild, cloneNode);
                            nodes[index] = cloneNode.previousSibling;
                            cloneNode.parentNode.removeChild(cloneNode);
                        }
                    }
                }
            }
            else {
                var lastNode = splitNode;
                for (; lastNode.firstChild !== null && lastNode.firstChild.nodeType !== 3; null) {
                    lastNode = lastNode.firstChild;
                }
                lastNode.innerHTML = '&#8203;';
                nodes[index] = lastNode.firstChild;
            }
        }
        var fontStyle;
        if (format === 'backgroundcolor') {
            fontStyle = formatNode.style.fontSize;
        }
        var bgStyle;
        if (format === 'fontsize') {
            var bg = sf.base.closest(nodes[index].parentElement, 'span[style*=' + 'background-color' + ']');
            if (!sf.base.isNullOrUndefined(bg)) {
                bgStyle = bg.style.backgroundColor;
            }
        }
        var formatNodeStyles = formatNode.getAttribute('style');
        var formatNodeTagName = formatNode.tagName;
        var child = InsertMethods.unwrap(formatNode);
        if (child[0] && !isFontStyle) {
            var nodeTraverse = child[index] ? child[index] : child[0];
            var textNode = nodeTraverse;
            for (; nodeTraverse && nodeTraverse.parentElement && nodeTraverse.parentElement !== endNode; 
            // eslint-disable-next-line
            nodeTraverse = nodeTraverse) {
                if (nodeTraverse.parentElement && nodeTraverse.parentElement.tagName.toLocaleLowerCase()
                    === formatNode.tagName.toLocaleLowerCase() &&
                    (nodeTraverse.parentElement.childElementCount > 1 || range.startOffset > 1)) {
                    if (textNode.parentElement && textNode.parentElement.tagName.toLocaleLowerCase()
                        === formatNode.tagName.toLocaleLowerCase()) {
                        if ((range.startOffset === range.endOffset) && textNode.nodeType !== 1 &&
                            !sf.base.isNullOrUndefined(textNode.textContent) && textNode.parentElement.childElementCount > 1) {
                            range.setStart(textNode, 0);
                            range.setEnd(textNode, textNode.textContent.length);
                            nodeCutter.SplitNode(range, textNode.parentElement, false);
                        }
                    }
                    if (nodeTraverse.parentElement.tagName.toLocaleLowerCase() === 'span') {
                        if (formatNode.style.textDecoration === 'underline' &&
                            nodeTraverse.parentElement.style.textDecoration !== 'underline') {
                            nodeTraverse = nodeTraverse.parentElement;
                            continue;
                        }
                    }
                    InsertMethods.unwrap(nodeTraverse.parentElement);
                    nodeTraverse = !sf.base.isNullOrUndefined(nodeTraverse.parentElement) && !domNode.isBlockNode(nodeTraverse.parentElement) ? textNode :
                        nodeTraverse.parentElement;
                }
                else {
                    nodeTraverse = nodeTraverse.parentElement;
                }
            }
        }
        if (child.length > 0 && isFontStyle) {
            for (var num = 0; num < child.length; num++) {
                if (child[num].nodeType !== 3 || (child[num].textContent && child[num].textContent.trim().length > 0)) {
                    child[num] = InsertMethods.Wrap(child[num], this.GetFormatNode(format, value, formatNodeTagName, formatNodeStyles));
                    if (num === 0) {
                        range.setStartBefore(child[num]);
                    }
                    else if (num === child.length - 1) {
                        range.setEndAfter(child[num]);
                    }
                }
            }
            var currentNodeElem = nodes[index].parentElement;
            if (!sf.base.isNullOrUndefined(fontStyle) && fontStyle !== '') {
                currentNodeElem.style.fontSize = fontStyle;
            }
            if (!sf.base.isNullOrUndefined(bgStyle) && bgStyle !== '') {
                currentNodeElem.style.backgroundColor = bgStyle;
            }
            if ((format === 'backgroundcolor' && !sf.base.isNullOrUndefined(fontStyle) && fontStyle !== '') &&
                currentNodeElem.parentElement.innerHTML === currentNodeElem.outerHTML) {
                var curParentElem = currentNodeElem.parentElement;
                curParentElem.parentElement.insertBefore(currentNodeElem, curParentElem);
                sf.base.detach(curParentElem);
            }
            if (format === 'fontsize' || format === 'fontcolor') {
                var liElement = nodes[index].parentElement;
                var parentElement = nodes[index].parentElement;
                while (!sf.base.isNullOrUndefined(parentElement) && parentElement.tagName.toLowerCase() !== 'li') {
                    parentElement = parentElement.parentElement;
                    liElement = parentElement;
                }
                if (!sf.base.isNullOrUndefined(liElement) && liElement.tagName.toLowerCase() === 'li' &&
                    liElement.textContent.trim() === nodes[index].textContent.trim()) {
                    if (format === 'fontsize') {
                        liElement.style.fontSize = value;
                    }
                    else {
                        liElement.style.color = value;
                        liElement.style.textDecoration = 'inherit';
                    }
                }
            }
        }
        return nodes[index];
    };
    SelectionCommands.insertFormat = function (docElement, nodes, index, formatNode, isCursor, isFormat, isFontStyle, range, nodeCutter, format, value) {
        if (!isCursor) {
            if ((formatNode === null && isFormat) || isFontStyle) {
                if (nodes[index].nodeName !== 'BR') {
                    nodes[index] = nodeCutter.GetSpliceNode(range, nodes[index]);
                    nodes[index].textContent = nodeCutter.TrimLineBreak(nodes[index].textContent);
                }
                if (format === 'uppercase' || format === 'lowercase') {
                    nodes[index].textContent = (format === 'uppercase') ? nodes[index].textContent.toLocaleUpperCase()
                        : nodes[index].textContent.toLocaleLowerCase();
                }
                else if (!(isFontStyle === true && value === '')) {
                    var element = this.GetFormatNode(format, value);
                    if (format === 'fontsize' || format === 'fontcolor') {
                        var liElement = nodes[index].parentElement;
                        var parentElement = nodes[index].parentElement;
                        while (!sf.base.isNullOrUndefined(parentElement) && parentElement.tagName.toLowerCase() !== 'li') {
                            parentElement = parentElement.parentElement;
                            liElement = parentElement;
                        }
                        if (!sf.base.isNullOrUndefined(liElement) && liElement.tagName.toLowerCase() === 'li' &&
                            liElement.textContent.trim() === nodes[index].textContent.trim()) {
                            if (format === 'fontsize') {
                                liElement.style.fontSize = value;
                            }
                            else {
                                liElement.style.color = value;
                                liElement.style.textDecoration = 'inherit';
                            }
                        }
                        nodes[index] = this.applyStyles(nodes, index, element);
                        if (format === 'fontsize') {
                            var bg = sf.base.closest(nodes[index].parentElement, 'span[style*=' + 'background-color' + ']');
                            if (!sf.base.isNullOrUndefined(bg)) {
                                nodes[index].parentElement.style.backgroundColor = bg.style.backgroundColor;
                            }
                        }
                    }
                    else {
                        nodes[index] = this.applyStyles(nodes, index, element);
                    }
                }
            }
            else {
                nodes[index] = nodeCutter.GetSpliceNode(range, nodes[index]);
            }
        }
        else {
            if (format !== 'uppercase' && format !== 'lowercase') {
                var element = this.getInsertNode(docElement, range, format, value);
                nodes[index] = element.firstChild;
                nodeCutter.position = 1;
            }
            else {
                nodeCutter.position = range.startOffset;
            }
        }
        return nodes[index];
    };
    SelectionCommands.applyStyles = function (nodes, index, element) {
        if (!(nodes[index].nodeName === 'BR' && this.enterAction === 'BR')) {
            nodes[index] = (index === (nodes.length - 1)) || nodes[index].nodeName === 'BR' ?
                InsertMethods.Wrap(nodes[index], element)
                : InsertMethods.WrapBefore(nodes[index], element, true);
            nodes[index] = this.getChildNode(nodes[index], element);
        }
        return nodes[index];
    };
    SelectionCommands.getInsertNode = function (docElement, range, format, value) {
        var element = this.GetFormatNode(format, value);
        element.innerHTML = '&#8203;';
        if (sf.base.Browser.isIE) {
            var frag = docElement.createDocumentFragment();
            frag.appendChild(element);
            range.insertNode(frag);
        }
        else {
            range.insertNode(element);
        }
        return element;
    };
    SelectionCommands.getChildNode = function (node, element) {
        if (node === undefined || node === null) {
            element.innerHTML = '&#8203;';
            node = element.firstChild;
        }
        return node;
    };
    SelectionCommands.applySelection = function (nodes, domSelection, nodeCutter, index, isCollapsed) {
        if (nodes.length === 1 && !isCollapsed) {
            domSelection.startContainer = domSelection.getNodeArray(nodes[index], true);
            domSelection.endContainer = domSelection.startContainer;
            domSelection.startOffset = 0;
            domSelection.endOffset = nodes[index].textContent.length;
        }
        else if (nodes.length === 1 && isCollapsed) {
            domSelection.startContainer = domSelection.getNodeArray(nodes[index], true);
            domSelection.endContainer = domSelection.startContainer;
            domSelection.startOffset = nodeCutter.position;
            domSelection.endOffset = nodeCutter.position;
        }
        else if (index === 0) {
            domSelection.startContainer = domSelection.getNodeArray(nodes[index], true);
            domSelection.startOffset = 0;
        }
        else if (index === nodes.length - 1) {
            domSelection.endContainer = domSelection.getNodeArray(nodes[index], false);
            domSelection.endOffset = nodes[index].textContent.length;
        }
        return domSelection;
    };
    SelectionCommands.GetFormatNode = function (format, value, tagName, styles) {
        var node;
        switch (format) {
            case 'bold':
                return document.createElement('strong');
            case 'italic':
                return document.createElement('em');
            case 'underline':
                node = document.createElement('span');
                this.updateStyles(node, tagName, styles);
                node.style.textDecoration = 'underline';
                return node;
            case 'strikethrough':
                node = document.createElement('span');
                this.updateStyles(node, tagName, styles);
                node.style.textDecoration = 'line-through';
                return node;
            case 'superscript':
                return document.createElement('sup');
            case 'subscript':
                return document.createElement('sub');
            case 'fontcolor':
                node = document.createElement('span');
                this.updateStyles(node, tagName, styles);
                node.style.color = value;
                node.style.textDecoration = 'inherit';
                return node;
            case 'fontname':
                node = document.createElement('span');
                this.updateStyles(node, tagName, styles);
                node.style.fontFamily = value;
                return node;
            case 'fontsize':
                node = document.createElement('span');
                this.updateStyles(node, tagName, styles);
                node.style.fontSize = value;
                return node;
            default:
                node = document.createElement('span');
                this.updateStyles(node, tagName, styles);
                node.style.backgroundColor = value;
                return node;
        }
    };
    SelectionCommands.updateStyles = function (ele, tag, styles) {
        if (styles !== null && tag === 'SPAN') {
            ele.setAttribute('style', styles);
        }
    };
    SelectionCommands.enterAction = 'P';
    return SelectionCommands;
}());

/**
 * Selection EXEC internal component
 *
 * @hidden
 * @deprecated
 */
var SelectionBasedExec = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function SelectionBasedExec(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    SelectionBasedExec.prototype.addEventListener = function () {
        this.parent.observer.on(SELECTION_TYPE, this.applySelection, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.keyDownHandler, this);
    };
    SelectionBasedExec.prototype.keyDownHandler = function (e) {
        var validFormats = ['bold', 'italic', 'underline', 'strikethrough', 'superscript',
            'subscript', 'uppercase', 'lowercase'];
        if (e.event.ctrlKey && validFormats.indexOf(e.event.action) > -1) {
            e.event.preventDefault();
            SelectionCommands.applyFormat(this.parent.currentDocument, e.event.action, this.parent.editableElement, e.enterAction);
            this.callBack(e, e.event.action);
        }
    };
    SelectionBasedExec.prototype.applySelection = function (e) {
        SelectionCommands.applyFormat(this.parent.currentDocument, e.subCommand.toLocaleLowerCase(), this.parent.editableElement, e.enterAction, e.value, e.selector);
        this.callBack(e, e.subCommand);
    };
    SelectionBasedExec.prototype.callBack = function (event, action) {
        if (event.callBack) {
            event.callBack({
                requestType: action,
                event: event.event,
                editorMode: 'HTML',
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    return SelectionBasedExec;
}());

/**
 * Selection EXEC internal component
 *
 * @hidden
 * @deprecated
 */
var InsertHtmlExec = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - sepcifies the parent element
     * @hidden
     * @deprecated
     */
    function InsertHtmlExec(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    InsertHtmlExec.prototype.addEventListener = function () {
        this.parent.observer.on(INSERTHTML_TYPE, this.applyHtml, this);
    };
    InsertHtmlExec.prototype.applyHtml = function (e) {
        InsertHtml.Insert(this.parent.currentDocument, e.value, this.parent.editableElement, true);
        if (e.subCommand === 'pasteCleanup') {
            var pastedElements = this.parent.editableElement.querySelectorAll('.pasteContent_RTE');
            var allPastedElements = [].slice.call(pastedElements);
            var imgElements = this.parent.editableElement.querySelectorAll('.pasteContent_Img');
            var allImgElm = [].slice.call(imgElements);
            e.callBack({
                requestType: e.subCommand,
                editorMode: 'HTML',
                elements: allPastedElements,
                imgElem: allImgElm
            });
        }
        else {
            if (e.callBack) {
                e.callBack({
                    requestType: e.subCommand,
                    editorMode: 'HTML',
                    event: e.event,
                    range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                    elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
                });
            }
        }
    };
    return InsertHtmlExec;
}());

/**
 * `Clear Format` module is used to handle Clear Format.
 */
var ClearFormat = /** @class */ (function () {
    function ClearFormat() {
    }
    /**
     * clear method
     *
     * @param {Document} docElement - specifies the document element.
     * @param {Node} endNode - specifies the end node
     * @param {string} selector - specifies the string value
     * @returns {void}
     * @hidden
     * @deprecated
     */
    ClearFormat.clear = function (docElement, endNode, enterAction, selector) {
        this.domNode = new DOMNode(endNode, docElement);
        this.defaultTag = enterAction === 'P' ? this.defaultTag : 'div';
        var nodeSelection = new NodeSelection();
        var nodeCutter = new NodeCutter();
        var range = nodeSelection.getRange(docElement);
        var isCollapsed = range.collapsed;
        var nodes = nodeSelection.getInsertNodeCollection(range);
        var save = nodeSelection.save(range, docElement);
        if (!isCollapsed) {
            var preNode = void 0;
            if (nodes[0].nodeName === 'BR' && sf.base.closest(nodes[0], 'table')) {
                preNode = nodeCutter.GetSpliceNode(range, sf.base.closest(nodes[0], 'table'));
            }
            else {
                preNode = nodeCutter.GetSpliceNode(range, nodes[nodes.length > 1 && nodes[0].nodeName === 'IMG' ? 1 : 0]);
            }
            if (nodes.length === 1) {
                nodeSelection.setSelectionContents(docElement, preNode);
                range = nodeSelection.getRange(docElement);
            }
            else {
                var i = 1;
                var lastText = nodes[nodes.length - i];
                while (nodes.length <= i && nodes[nodes.length - i].nodeName === 'BR') {
                    i++;
                    lastText = nodes[nodes.length - i];
                }
                var lasNode = nodeCutter.GetSpliceNode(range, lastText);
                nodeSelection.setSelectionText(docElement, preNode, lasNode, 0, (lasNode.nodeType === 3) ?
                    lasNode.textContent.length : lasNode.childNodes.length);
                range = nodeSelection.getRange(docElement);
            }
            var exactNodes = nodeSelection.getNodeCollection(range);
            var cloneSelectNodes = exactNodes.slice();
            this.clearInlines(nodeSelection.getSelectionNodes(cloneSelectNodes), cloneSelectNodes, nodeSelection.getRange(docElement), nodeCutter, endNode);
            this.reSelection(docElement, save, exactNodes);
            range = nodeSelection.getRange(docElement);
            exactNodes = nodeSelection.getNodeCollection(range);
            var cloneParentNodes = exactNodes.slice();
            this.clearBlocks(docElement, cloneParentNodes, endNode, nodeCutter, nodeSelection);
            if (isIDevice$1()) {
                setEditFrameFocus(endNode, selector);
            }
            this.reSelection(docElement, save, exactNodes);
        }
    };
    ClearFormat.reSelection = function (docElement, save, exactNodes) {
        var selectionNodes = save.getInsertNodes(exactNodes);
        save.startContainer = save.getNodeArray(selectionNodes[0], true, docElement);
        save.startOffset = 0;
        save.endContainer = save.getNodeArray(selectionNodes[selectionNodes.length - 1], false, docElement);
        var endIndexNode = selectionNodes[selectionNodes.length - 1];
        save.endOffset = (endIndexNode.nodeType === 3) ? endIndexNode.textContent.length
            : endIndexNode.childNodes.length;
        save.restore();
    };
    ClearFormat.clearBlocks = function (docElement, nodes, endNode, nodeCutter, nodeSelection) {
        var parentNodes = [];
        for (var index = 0; index < nodes.length; index++) {
            if (this.BLOCK_TAGS.indexOf(nodes[index].nodeName.toLocaleLowerCase()) > -1
                && parentNodes.indexOf(nodes[index]) === -1) {
                parentNodes.push(nodes[index]);
            }
            else if ((this.BLOCK_TAGS.indexOf(nodes[index].parentNode.nodeName.toLocaleLowerCase()) > -1)
                && parentNodes.indexOf(nodes[index].parentNode) === -1
                && endNode !== nodes[index].parentNode) {
                parentNodes.push(nodes[index].parentNode);
            }
        }
        parentNodes = this.spliceParent(parentNodes, nodes)[0];
        parentNodes = this.removeParent(parentNodes);
        this.unWrap(docElement, parentNodes, nodeCutter, nodeSelection);
    };
    ClearFormat.spliceParent = function (parentNodes, nodes) {
        for (var index1 = 0; index1 < parentNodes.length; index1++) {
            var len = parentNodes[index1].childNodes.length;
            for (var index2 = 0; index2 < len; index2++) {
                if ((nodes.indexOf(parentNodes[index1].childNodes[index2]) > 0)
                    && (parentNodes[index1].childNodes[index2].childNodes.length > 0)) {
                    nodes = this.spliceParent([parentNodes[index1].childNodes[index2]], nodes)[1];
                }
                if ((nodes.indexOf(parentNodes[index1].childNodes[index2]) <= -1) &&
                    (parentNodes[index1].childNodes[index2].textContent.trim() !== '')) {
                    for (var index3 = 0; index3 < len; index3++) {
                        if (nodes.indexOf(parentNodes[index1].childNodes[index3]) > -1) {
                            nodes.splice(nodes.indexOf(parentNodes[index1].childNodes[index3]), 1);
                        }
                    }
                    index2 = parentNodes[index1].childNodes.length;
                    var parentIndex = parentNodes.indexOf(parentNodes[index1].parentNode);
                    var nodeIndex = nodes.indexOf(parentNodes[index1].parentNode);
                    if (parentIndex > -1) {
                        parentNodes.splice(parentIndex, 1);
                    }
                    if (nodeIndex > -1) {
                        nodes.splice(nodeIndex, 1);
                    }
                    var elementIndex = nodes.indexOf(parentNodes[index1]);
                    if (elementIndex > -1) {
                        nodes.splice(elementIndex, 1);
                    }
                    parentNodes.splice(index1, 1);
                    index1--;
                }
            }
        }
        return [parentNodes, nodes];
    };
    ClearFormat.removeChild = function (parentNodes, parentNode) {
        var count = parentNode.childNodes.length;
        if (count > 0) {
            for (var index = 0; index < count; index++) {
                if (parentNodes.indexOf(parentNode.childNodes[index]) > -1) {
                    parentNodes = this.removeChild(parentNodes, parentNode.childNodes[index]);
                    parentNodes.splice(parentNodes.indexOf(parentNode.childNodes[index]), 1);
                }
            }
        }
        return parentNodes;
    };
    ClearFormat.removeParent = function (parentNodes) {
        for (var index = 0; index < parentNodes.length; index++) {
            if (parentNodes.indexOf(parentNodes[index].parentNode) > -1) {
                parentNodes = this.removeChild(parentNodes, parentNodes[index]);
                parentNodes.splice(index, 1);
                index--;
            }
        }
        return parentNodes;
    };
    ClearFormat.unWrap = function (docElement, parentNodes, nodeCutter, nodeSelection) {
        for (var index1 = 0; index1 < parentNodes.length; index1++) {
            if (this.NONVALID_TAGS.indexOf(parentNodes[index1].nodeName.toLowerCase()) > -1
                && parentNodes[index1].parentNode
                && this.NONVALID_PARENT_TAGS.indexOf(parentNodes[index1].parentNode.nodeName.toLowerCase()) > -1) {
                nodeSelection.setSelectionText(docElement, parentNodes[index1], parentNodes[index1], 0, parentNodes[index1].childNodes.length);
                InsertMethods.unwrap(nodeCutter.GetSpliceNode(nodeSelection.getRange(docElement), parentNodes[index1].parentNode));
            }
            if (parentNodes[index1].nodeName.toLocaleLowerCase() !== 'p') {
                if (this.NONVALID_PARENT_TAGS.indexOf(parentNodes[index1].nodeName.toLowerCase()) < 0
                    && parentNodes[index1].parentNode.nodeName.toLocaleLowerCase() !== 'p'
                    && !((parentNodes[index1].nodeName.toLocaleLowerCase() === 'blockquote'
                        || parentNodes[index1].nodeName.toLocaleLowerCase() === 'li')
                        && this.IGNORE_PARENT_TAGS.indexOf(parentNodes[index1].childNodes[0].nodeName.toLocaleLowerCase()) > -1)
                    && !(parentNodes[index1].childNodes.length === 1
                        && parentNodes[index1].childNodes[0].nodeName.toLocaleLowerCase() === 'p')) {
                    InsertMethods.Wrap(parentNodes[index1], docElement.createElement(this.defaultTag));
                }
                var childNodes = InsertMethods.unwrap(parentNodes[index1]);
                if (childNodes.length === 1
                    && childNodes[0].parentNode.nodeName.toLocaleLowerCase() === 'p') {
                    InsertMethods.Wrap(parentNodes[index1], docElement.createElement(this.defaultTag));
                    InsertMethods.unwrap(parentNodes[index1]);
                }
                for (var index2 = 0; index2 < childNodes.length; index2++) {
                    if (this.NONVALID_TAGS.indexOf(childNodes[index2].nodeName.toLowerCase()) > -1) {
                        this.unWrap(docElement, [childNodes[index2]], nodeCutter, nodeSelection);
                    }
                    else if (this.BLOCK_TAGS.indexOf(childNodes[index2].nodeName.toLocaleLowerCase()) > -1 &&
                        childNodes[index2].nodeName.toLocaleLowerCase() !== 'p') {
                        var blockNodes = this.removeParent([childNodes[index2]]);
                        this.unWrap(docElement, blockNodes, nodeCutter, nodeSelection);
                    }
                    else if (this.BLOCK_TAGS.indexOf(childNodes[index2].nodeName.toLocaleLowerCase()) > -1 &&
                        childNodes[index2].parentNode.nodeName.toLocaleLowerCase() === childNodes[index2].nodeName.toLocaleLowerCase()) {
                        InsertMethods.unwrap(childNodes[index2]);
                    }
                    else if (this.BLOCK_TAGS.indexOf(childNodes[index2].nodeName.toLocaleLowerCase()) > -1 &&
                        childNodes[index2].nodeName.toLocaleLowerCase() === 'p') {
                        InsertMethods.Wrap(childNodes[index2], docElement.createElement(this.defaultTag));
                        InsertMethods.unwrap(childNodes[index2]);
                    }
                }
            }
            else {
                InsertMethods.Wrap(parentNodes[index1], docElement.createElement(this.defaultTag));
                InsertMethods.unwrap(parentNodes[index1]);
            }
        }
    };
    ClearFormat.clearInlines = function (textNodes, nodes, range, nodeCutter, 
    // eslint-disable-next-line
    endNode) {
        for (var index = 0; index < textNodes.length; index++) {
            var currentInlineNode = textNodes[index];
            var currentNode = void 0;
            while (!this.domNode.isBlockNode(currentInlineNode)) {
                currentNode = currentInlineNode;
                currentInlineNode = currentInlineNode.parentElement;
            }
            if (currentNode &&
                IsFormatted.inlineTags.indexOf(currentNode.nodeName.toLocaleLowerCase()) > -1) {
                nodeCutter.GetSpliceNode(range, currentNode);
                this.removeInlineParent(currentNode);
            }
        }
    };
    ClearFormat.removeInlineParent = function (textNodes) {
        var nodes = InsertMethods.unwrap(textNodes);
        for (var index = 0; index < nodes.length; index++) {
            if (nodes[index].parentNode.childNodes.length === 1
                && IsFormatted.inlineTags.indexOf(nodes[index].parentNode.nodeName.toLocaleLowerCase()) > -1) {
                this.removeInlineParent(nodes[index].parentNode);
            }
            else if (IsFormatted.inlineTags.indexOf(nodes[index].nodeName.toLocaleLowerCase()) > -1) {
                this.removeInlineParent(nodes[index]);
            }
        }
    };
    ClearFormat.BLOCK_TAGS = ['address', 'article', 'aside', 'blockquote',
        'details', 'dd', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer',
        'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'li', 'main', 'nav',
        'noscript', 'ol', 'p', 'pre', 'section', 'ul'];
    ClearFormat.NONVALID_PARENT_TAGS = ['thead', 'tbody', 'ul', 'ol', 'table', 'tfoot', 'tr'];
    ClearFormat.IGNORE_PARENT_TAGS = ['ul', 'ol', 'table'];
    ClearFormat.NONVALID_TAGS = ['thead', 'tbody', 'figcaption', 'td', 'tr', 'th', 'tfoot', 'figcaption', 'li'];
    ClearFormat.defaultTag = 'p';
    return ClearFormat;
}());

/**
 * Clear Format EXEC internal component
 *
 * @hidden
 * @deprecated
 */
var ClearFormatExec = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {EditorManager} parent - specifies the parent element.
     * @returns {void}
     * @hidden
     * @deprecated
     */
    function ClearFormatExec(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    ClearFormatExec.prototype.addEventListener = function () {
        this.parent.observer.on(CLEAR_TYPE, this.applyClear, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.onKeyDown, this);
    };
    ClearFormatExec.prototype.onKeyDown = function (e) {
        switch (e.event.action) {
            case 'clear-format':
                this.applyClear({ subCommand: 'ClearFormat', callBack: e.callBack, enterAction: e.enterAction });
                e.event.preventDefault();
                break;
        }
    };
    ClearFormatExec.prototype.applyClear = function (e) {
        if (e.subCommand === 'ClearFormat') {
            ClearFormat.clear(this.parent.currentDocument, this.parent.editableElement, e.enterAction, e.selector);
            if (e.callBack) {
                e.callBack({
                    requestType: e.subCommand,
                    event: e.event,
                    editorMode: 'HTML',
                    range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                    elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
                });
            }
        }
    };
    return ClearFormatExec;
}());

/**
 * `Undo` module is used to handle undo actions.
 */
var UndoRedoManager = /** @class */ (function () {
    function UndoRedoManager(parent, options) {
        this.undoRedoStack = [];
        this.parent = parent;
        this.undoRedoSteps = !sf.base.isNullOrUndefined(options) ? options.undoRedoSteps : 30;
        this.undoRedoTimer = !sf.base.isNullOrUndefined(options) ? options.undoRedoTimer : 300;
        this.addEventListener();
    }
    UndoRedoManager.prototype.addEventListener = function () {
        var debounceListener = sf.base.debounce(this.keyUp, this.undoRedoTimer);
        this.parent.observer.on(KEY_UP_HANDLER, debounceListener, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.keyDown, this);
        this.parent.observer.on(ACTION, this.onAction, this);
        this.parent.observer.on(MODEL_CHANGED_PLUGIN, this.onPropertyChanged, this);
    };
    UndoRedoManager.prototype.onPropertyChanged = function (props) {
        for (var _i = 0, _a = Object.keys(props.newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'undoRedoSteps':
                    this.undoRedoSteps = props.newProp.undoRedoSteps;
                    break;
                case 'undoRedoTimer':
                    this.undoRedoTimer = props.newProp.undoRedoTimer;
                    break;
            }
        }
    };
    UndoRedoManager.prototype.removeEventListener = function () {
        this.parent.observer.off(KEY_UP_HANDLER, this.keyUp);
        this.parent.observer.off(KEY_DOWN_HANDLER, this.keyDown);
        this.parent.observer.off(ACTION, this.onAction);
    };
    /**
     * onAction method
     *
     * @param {IHtmlSubCommands} e - specifies the sub command
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoManager.prototype.onAction = function (e) {
        if (e.subCommand === 'Undo') {
            this.undo(e);
        }
        else {
            this.redo(e);
        }
    };
    /**
     * Destroys the ToolBar.
     *
     * @function destroy
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoManager.prototype.destroy = function () {
        this.removeEventListener();
    };
    UndoRedoManager.prototype.keyDown = function (e) {
        var event = e.event;
        // eslint-disable-next-line
        var proxy = this;
        switch (event.action) {
            case 'undo':
                event.preventDefault();
                proxy.undo(e);
                break;
            case 'redo':
                event.preventDefault();
                proxy.redo(e);
                break;
        }
    };
    UndoRedoManager.prototype.keyUp = function (e) {
        if (e.event.keyCode !== 17 && !e.event.ctrlKey) {
            this.saveData(e);
        }
    };
    /**
     * RTE collection stored html format.
     *
     * @function saveData
     * @param {KeyboardEvent} e - specifies the keyboard event
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoManager.prototype.saveData = function (e) {
        var range = new NodeSelection().getRange(this.parent.currentDocument);
        var save = new NodeSelection().save(range, this.parent.currentDocument);
        var htmlText = this.parent.editableElement.innerHTML;
        var changEle = { text: htmlText, range: save };
        if (this.undoRedoStack.length >= this.steps) {
            this.undoRedoStack = this.undoRedoStack.slice(0, this.steps + 1);
        }
        if (this.undoRedoStack.length > 1 && (this.undoRedoStack[this.undoRedoStack.length - 1].range.range.collapsed === range.collapsed)
            && (this.undoRedoStack[this.undoRedoStack.length - 1].range.startOffset === save.range.startOffset) &&
            (this.undoRedoStack[this.undoRedoStack.length - 1].range.endOffset === save.range.endOffset) &&
            (this.undoRedoStack[this.undoRedoStack.length - 1].range.range.startContainer === save.range.startContainer) &&
            (this.undoRedoStack[this.undoRedoStack.length - 1].text.trim() === changEle.text.trim())) {
            return;
        }
        this.undoRedoStack.push(changEle);
        this.steps = this.undoRedoStack.length - 1;
        if (this.steps > this.undoRedoSteps) {
            this.undoRedoStack.shift();
            this.steps--;
        }
        if (e && e.callBack) {
            e.callBack();
        }
    };
    /**
     * Undo the editable text.
     *
     * @function undo
     * @param {IHtmlSubCommands} e - specifies the sub commands
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoManager.prototype.undo = function (e) {
        if (this.steps > 0) {
            var range = this.undoRedoStack[this.steps - 1].range;
            var removedContent = this.undoRedoStack[this.steps - 1].text;
            this.parent.editableElement.innerHTML = removedContent;
            this.parent.editableElement.focus();
            if (isIDevice$1()) {
                setEditFrameFocus(this.parent.editableElement, e.selector);
            }
            range.restore();
            this.steps--;
            if (e.callBack) {
                e.callBack({
                    requestType: 'Undo',
                    editorMode: 'HTML',
                    range: range,
                    elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument),
                    event: e.event
                });
            }
        }
    };
    /**
     * Redo the editable text.
     *
     * @param {IHtmlSubCommands} e - specifies the sub commands
     * @function redo
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoManager.prototype.redo = function (e) {
        if (this.undoRedoStack[this.steps + 1] != null) {
            var range = this.undoRedoStack[this.steps + 1].range;
            this.parent.editableElement.innerHTML = this.undoRedoStack[this.steps + 1].text;
            this.parent.editableElement.focus();
            if (isIDevice$1()) {
                setEditFrameFocus(this.parent.editableElement, e.selector);
            }
            range.restore();
            this.steps++;
            if (e.callBack) {
                e.callBack({
                    requestType: 'Redo',
                    editorMode: 'HTML',
                    range: range,
                    elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument),
                    event: e.event
                });
            }
        }
    };
    /**
     * getUndoStatus method
     *
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    UndoRedoManager.prototype.getUndoStatus = function () {
        var status = { undo: false, redo: false };
        if (this.steps > 0) {
            status.undo = true;
        }
        if (this.undoRedoStack[this.steps + 1] != null) {
            status.redo = true;
        }
        return status;
    };
    return UndoRedoManager;
}());

/**
 * PasteCleanup for MsWord content
 *
 * @hidden
 * @deprecated
 */
var MsWordPaste = /** @class */ (function () {
    function MsWordPaste(parent) {
        this.olData = [
            'decimal',
            'lower-alpha',
            'lower-roman',
            'upper-alpha',
            'upper-roman',
            'lower-greek'
        ];
        this.ulData = [
            'disc',
            'square',
            'circle',
            'disc',
            'square',
            'circle'
        ];
        this.ignorableNodes = ['A', 'APPLET', 'B', 'BLOCKQUOTE', 'BR',
            'BUTTON', 'CENTER', 'CODE', 'COL', 'COLGROUP', 'DD', 'DEL', 'DFN', 'DIR', 'DIV',
            'DL', 'DT', 'EM', 'FIELDSET', 'FONT', 'FORM', 'FRAME', 'FRAMESET', 'H1', 'H2',
            'H3', 'H4', 'H5', 'H6', 'HR', 'I', 'IMG', 'IFRAME', 'INPUT', 'INS', 'LABEL',
            'LI', 'OL', 'OPTION', 'P', 'PARAM', 'PRE', 'Q', 'S', 'SELECT', 'SPAN', 'STRIKE',
            'STRONG', 'SUB', 'SUP', 'TABLE', 'TBODY', 'TD', 'TEXTAREA', 'TFOOT', 'TH',
            'THEAD', 'TITLE', 'TR', 'TT', 'U', 'UL'];
        this.blockNode = ['div', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
            'address', 'blockquote', 'button', 'center', 'dd', 'dir', 'dl', 'dt', 'fieldset',
            'frameset', 'hr', 'iframe', 'isindex', 'li', 'map', 'menu', 'noframes', 'noscript',
            'object', 'ol', 'pre', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'ul',
            'header', 'article', 'nav', 'footer', 'section', 'aside', 'main', 'figure', 'figcaption'];
        this.borderStyle = ['border-top', 'border-right', 'border-bottom', 'border-left'];
        this.removableElements = ['o:p', 'style'];
        this.listContents = [];
        this.parent = parent;
        this.addEventListener();
    }
    MsWordPaste.prototype.addEventListener = function () {
        this.parent.observer.on(MS_WORD_CLEANUP_PLUGIN$1, this.wordCleanup, this);
    };
    MsWordPaste.prototype.wordCleanup = function (e) {
        var wordPasteStyleConfig = e.allowedStylePropertiesArray;
        var listNodes = [];
        var tempHTMLContent = e.args.clipboardData.getData('text/HTML');
        var rtfData = e.args.clipboardData.getData('text/rtf');
        var elm = sf.base.createElement('p');
        elm.setAttribute('id', 'MSWord-Content');
        elm.innerHTML = tempHTMLContent;
        var patern = /class='?Mso|style='[^ ]*\bmso-/i;
        var patern2 = /class="?Mso|style="[^ ]*\bmso-/i;
        var patern3 = /(class="?Mso|class='?Mso|class="?Xl|class='?Xl|class=Xl|style="[^"]*\bmso-|style='[^']*\bmso-|w:WordDocument)/gi;
        var pattern4 = /style='mso-width-source:/i;
        if (patern.test(tempHTMLContent) || patern2.test(tempHTMLContent) || patern3.test(tempHTMLContent) ||
            pattern4.test(tempHTMLContent)) {
            this.imageConversion(elm, rtfData);
            tempHTMLContent = tempHTMLContent.replace(/<img[^>]+>/i, '');
            this.addListClass(elm);
            listNodes = this.cleanUp(elm, listNodes);
            if (!sf.base.isNullOrUndefined(listNodes[0]) && listNodes[0].parentElement.tagName !== 'UL' &&
                listNodes[0].parentElement.tagName !== 'OL') {
                this.listConverter(listNodes);
            }
            this.styleCorrection(elm, wordPasteStyleConfig);
            this.removingComments(elm);
            this.removeUnwantedElements(elm);
            this.removeEmptyElements(elm);
            this.breakLineAddition(elm);
            this.removeClassName(elm);
            if (pattern4.test(tempHTMLContent)) {
                this.addTableBorderClass(elm);
            }
            e.callBack(elm.innerHTML);
        }
        else {
            e.callBack(elm.innerHTML);
        }
    };
    MsWordPaste.prototype.addListClass = function (elm) {
        var allNodes = elm.querySelectorAll('*');
        for (var index = 0; index < allNodes.length; index++) {
            if (!sf.base.isNullOrUndefined(allNodes[index].getAttribute('style')) && allNodes[index].getAttribute('style').replace(/ /g, '').replace('\n', '').indexOf('mso-list:l') >= 0 &&
                allNodes[index].className.toLowerCase().indexOf('msolistparagraph') === -1 && allNodes[index].tagName.charAt(0) !== 'H') {
                allNodes[index].classList.add('msolistparagraph');
            }
        }
    };
    MsWordPaste.prototype.addTableBorderClass = function (elm) {
        var allTableElm = elm.querySelectorAll('table');
        var hasTableBorder = false;
        for (var i = 0; i < allTableElm.length; i++) {
            for (var j = 0; j < this.borderStyle.length; j++) {
                if (allTableElm[i].innerHTML.indexOf(this.borderStyle[j]) >= 0) {
                    hasTableBorder = true;
                    break;
                }
            }
            if (hasTableBorder) {
                allTableElm[i].classList.add('e-rte-table-border');
                hasTableBorder = false;
            }
        }
    };
    MsWordPaste.prototype.imageConversion = function (elm, rtfData) {
        this.checkVShape(elm);
        var imgElem = elm.querySelectorAll('img');
        var imgSrc = [];
        var base64Src = [];
        var imgName = [];
        var linkRegex = new RegExp(/([^\S]|^)(((https?\:\/\/)|(www\.))(\S+))/gi);
        if (imgElem.length > 0) {
            for (var i = 0; i < imgElem.length; i++) {
                imgSrc.push(imgElem[i].getAttribute('src'));
                imgName.push(imgElem[i].getAttribute('src').split('/')[imgElem[i].getAttribute('src').split('/').length - 1].split('.')[0]);
            }
            var hexValue = this.hexConversion(rtfData);
            for (var i = 0; i < hexValue.length; i++) {
                base64Src.push(this.convertToBase64(hexValue[i]));
            }
            for (var i = 0; i < imgElem.length; i++) {
                if (imgSrc[i].match(linkRegex)) {
                    imgElem[i].setAttribute('src', imgSrc[i]);
                }
                else {
                    imgElem[i].setAttribute('src', base64Src[i]);
                }
                imgElem[i].setAttribute('id', 'msWordImg-' + imgName[i]);
            }
        }
    };
    MsWordPaste.prototype.checkVShape = function (elm) {
        var allNodes = elm.querySelectorAll('*');
        for (var i = 0; i < allNodes.length; i++) {
            switch (allNodes[i].nodeName) {
                case 'V:SHAPETYPE':
                    sf.base.detach(allNodes[i]);
                    break;
                case 'V:SHAPE':
                    if (allNodes[i].firstElementChild.nodeName === 'V:IMAGEDATA') {
                        var src = allNodes[i].firstElementChild.getAttribute('src');
                        var imgElement = sf.base.createElement('img');
                        imgElement.setAttribute('src', src);
                        allNodes[i].parentElement.insertBefore(imgElement, allNodes[i]);
                        sf.base.detach(allNodes[i]);
                    }
                    break;
            }
        }
    };
    MsWordPaste.prototype.convertToBase64 = function (hexValue) {
        var byteArr = this.conHexStringToBytes(hexValue.hex);
        var base64String = this.conBytesToBase64(byteArr);
        var base64 = hexValue.type ? 'data:' + hexValue.type + ';base64,' + base64String : null;
        return base64;
    };
    MsWordPaste.prototype.conBytesToBase64 = function (byteArr) {
        var base64Str = '';
        var base64Char = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        var byteArrLen = byteArr.length;
        for (var i = 0; i < byteArrLen; i += 3) {
            var array3 = byteArr.slice(i, i + 3);
            var array3length = array3.length;
            var array4 = [];
            if (array3length < 3) {
                for (var j = array3length; j < 3; j++) {
                    array3[j] = 0;
                }
            }
            array4[0] = (array3[0] & 0xFC) >> 2;
            array4[1] = ((array3[0] & 0x03) << 4) | (array3[1] >> 4);
            array4[2] = ((array3[1] & 0x0F) << 2) | ((array3[2] & 0xC0) >> 6);
            array4[3] = array3[2] & 0x3F;
            for (var j = 0; j < 4; j++) {
                if (j <= array3length) {
                    base64Str += base64Char.charAt(array4[j]);
                }
                else {
                    base64Str += '=';
                }
            }
        }
        return base64Str;
    };
    MsWordPaste.prototype.conHexStringToBytes = function (hex) {
        var byteArr = [];
        var byteArrLen = hex.length / 2;
        for (var i = 0; i < byteArrLen; i++) {
            byteArr.push(parseInt(hex.substr(i * 2, 2), 16));
        }
        return byteArr;
    };
    MsWordPaste.prototype.hexConversion = function (rtfData) {
        // eslint-disable-next-line
        var picHead = /\{\\pict[\s\S]+?\\bliptag\-?\d+(\\blipupi\-?\d+)?(\{\\\*\\blipuid\s?[\da-fA-F]+)?[\s\}]*?/;
        var pic = new RegExp('(?:(' + picHead.source + '))([\\da-fA-F\\s]+)\\}', 'g');
        var fullImg = rtfData.match(pic);
        var imgType;
        var result = [];
        if (!sf.base.isNullOrUndefined(fullImg)) {
            for (var i = 0; i < fullImg.length; i++) {
                if (picHead.test(fullImg[i])) {
                    if (fullImg[i].indexOf('\\pngblip') !== -1) {
                        imgType = 'image/png';
                    }
                    else if (fullImg[i].indexOf('\\jpegblip') !== -1) {
                        imgType = 'image/jpeg';
                    }
                    else {
                        continue;
                    }
                    result.push({
                        hex: imgType ? fullImg[i].replace(picHead, '').replace(/[^\da-fA-F]/g, '') : null,
                        type: imgType
                    });
                }
            }
        }
        return result;
    };
    MsWordPaste.prototype.removeClassName = function (elm) {
        var elmWithClass = elm.querySelectorAll('*[class]');
        for (var i = 0; i < elmWithClass.length; i++) {
            elmWithClass[i].removeAttribute('class');
        }
    };
    MsWordPaste.prototype.breakLineAddition = function (elm) {
        var allElements = elm.querySelectorAll('*');
        for (var i = 0; i < allElements.length; i++) {
            if (allElements[i].children.length === 0 && allElements[i].innerHTML === '&nbsp;' &&
                (allElements[i].innerHTML === '&nbsp;' && !allElements[i].closest('li')) &&
                !allElements[i].closest('td')) {
                var detachableElement = this.findDetachElem(allElements[i]);
                var brElement = sf.base.createElement('br');
                if (!sf.base.isNullOrUndefined(detachableElement.parentElement)) {
                    detachableElement.parentElement.insertBefore(brElement, detachableElement);
                    sf.base.detach(detachableElement);
                }
            }
        }
    };
    MsWordPaste.prototype.findDetachElem = function (element) {
        var removableElement;
        if (!sf.base.isNullOrUndefined(element.parentElement) &&
            element.parentElement.textContent.trim() === '' && element.parentElement.tagName !== 'TD' &&
            sf.base.isNullOrUndefined(element.parentElement.querySelector('img'))) {
            removableElement = this.findDetachElem(element.parentElement);
        }
        else {
            removableElement = element;
        }
        return removableElement;
    };
    MsWordPaste.prototype.removeUnwantedElements = function (elm) {
        var innerElement = elm.innerHTML;
        for (var i = 0; i < this.removableElements.length; i++) {
            var regExpStartElem = new RegExp('<' + this.removableElements[i] + '>', 'g');
            var regExpEndElem = new RegExp('</' + this.removableElements[i] + '>', 'g');
            innerElement = innerElement.replace(regExpStartElem, '');
            innerElement = innerElement.replace(regExpEndElem, '');
        }
        elm.innerHTML = innerElement;
        elm.querySelectorAll(':empty');
    };
    MsWordPaste.prototype.findDetachEmptyElem = function (element) {
        var removableElement;
        if (!sf.base.isNullOrUndefined(element.parentElement)) {
            if (element.parentElement.textContent.trim() === '' &&
                element.parentElement.getAttribute('id') !== 'MSWord-Content' &&
                sf.base.isNullOrUndefined(element.parentElement.querySelector('img'))) {
                removableElement = this.findDetachEmptyElem(element.parentElement);
            }
            else {
                removableElement = element;
            }
        }
        else {
            removableElement = null;
        }
        return removableElement;
    };
    MsWordPaste.prototype.removeEmptyElements = function (element) {
        var emptyElements = element.querySelectorAll(':empty');
        for (var i = 0; i < emptyElements.length; i++) {
            if (!sf.base.isNullOrUndefined(emptyElements[i].closest('td')) &&
                !sf.base.isNullOrUndefined(emptyElements[i].closest('td').querySelector('.MsoNormal'))) {
                emptyElements[i].innerHTML = '-';
            }
            if (emptyElements[i].tagName !== 'IMG' && emptyElements[i].tagName !== 'BR' &&
                emptyElements[i].tagName !== 'IFRAME' && emptyElements[i].tagName !== 'TD' &&
                emptyElements[i].tagName !== 'HR') {
                var detachableElement = this.findDetachEmptyElem(emptyElements[i]);
                if (!sf.base.isNullOrUndefined(detachableElement)) {
                    sf.base.detach(detachableElement);
                }
            }
        }
    };
    MsWordPaste.prototype.styleCorrection = function (elm, wordPasteStyleConfig) {
        var styleElement = elm.querySelectorAll('style');
        if (styleElement.length > 0) {
            var styles = styleElement[0].innerHTML.match(/[\S ]+\s+{[\s\S]+?}/gi);
            var styleClassObject_1 = !sf.base.isNullOrUndefined(styles) ? this.findStyleObject(styles) : null;
            var keys = Object.keys(styleClassObject_1);
            var values = keys.map(function (key) {
                return styleClassObject_1[key];
            });
            values = this.removeUnwantedStyle(values, wordPasteStyleConfig);
            this.filterStyles(elm, wordPasteStyleConfig);
            var resultElem = void 0;
            var fromClass = false;
            for (var i = 0; i < keys.length; i++) {
                if (keys[i].split('.')[0] === '') {
                    resultElem = elm.getElementsByClassName(keys[i].split('.')[1]);
                    fromClass = true;
                }
                else if (keys[i].split('.').length === 1 && keys[i].split('.')[0].indexOf('@') >= 0) {
                    continue;
                }
                else if (keys[i].split('.').length === 1 && keys[i].split('.')[0].indexOf('@') < 0) {
                    resultElem = elm.getElementsByTagName(keys[i]);
                }
                else {
                    resultElem = elm.querySelectorAll(keys[i]);
                }
                for (var j = 0; j < resultElem.length; j++) {
                    var styleProperty = resultElem[j].getAttribute('style');
                    if (!sf.base.isNullOrUndefined(styleProperty) && styleProperty.trim() !== '') {
                        var valueSplit = values[i].split(';');
                        if (!fromClass) {
                            for (var k = 0; k < valueSplit.length; k++) {
                                if (styleProperty.indexOf(valueSplit[k].split(':')[0]) >= 0) {
                                    valueSplit.splice(k, 1);
                                    k--;
                                }
                            }
                        }
                        values[i] = valueSplit.join(';') + ';';
                        var changedValue = styleProperty + values[i];
                        resultElem[j].setAttribute('style', changedValue);
                    }
                    else {
                        values[i] = values[i].replace(/text-indent:-(.*?)(?=;|$)/gm, '');
                        resultElem[j].setAttribute('style', values[i]);
                    }
                }
                fromClass = false;
            }
        }
    };
    MsWordPaste.prototype.filterStyles = function (elm, wordPasteStyleConfig) {
        var elmWithStyles = elm.querySelectorAll('*[style]');
        for (var i = 0; i < elmWithStyles.length; i++) {
            var elemStyleProperty = elmWithStyles[i].getAttribute('style').split(';');
            var styleValue = '';
            for (var j = 0; j < elemStyleProperty.length; j++) {
                if (wordPasteStyleConfig.indexOf(elemStyleProperty[j].split(':')[0].trim()) >= 0) {
                    styleValue += elemStyleProperty[j] + ';';
                }
            }
            elmWithStyles[i].setAttribute('style', styleValue);
        }
    };
    MsWordPaste.prototype.removeUnwantedStyle = function (values, wordPasteStyleConfig) {
        for (var i = 0; i < values.length; i++) {
            var styleValues = values[i].split(';');
            values[i] = '';
            for (var j = 0; j < styleValues.length; j++) {
                if (wordPasteStyleConfig.indexOf(styleValues[j].split(':')[0]) >= 0) {
                    values[i] += styleValues[j] + ';';
                }
            }
        }
        return values;
    };
    MsWordPaste.prototype.findStyleObject = function (styles) {
        var styleClassObject = {};
        for (var i = 0; i < styles.length; i++) {
            var tempStyle = styles[i];
            var classNameCollection = tempStyle.replace(/([\S ]+\s+){[\s\S]+?}/gi, '$1');
            var stylesCollection = tempStyle.replace(/[\S ]+\s+{([\s\S]+?)}/gi, '$1');
            classNameCollection = classNameCollection.replace(/^[\s]|[\s]$/gm, '');
            stylesCollection = stylesCollection.replace(/^[\s]|[\s]$/gm, '');
            classNameCollection = classNameCollection.replace(/\n|\r|\n\r/g, '');
            stylesCollection = stylesCollection.replace(/\n|\r|\n\r/g, '');
            for (var classNames = classNameCollection.split(', '), j = 0; j < classNames.length; j++) {
                styleClassObject[classNames[j]] = stylesCollection;
            }
        }
        return styleClassObject;
    };
    MsWordPaste.prototype.removingComments = function (elm) {
        var innerElement = elm.innerHTML;
        innerElement = innerElement.replace(/<!--[\s\S]*?-->/g, '');
        elm.innerHTML = innerElement;
    };
    MsWordPaste.prototype.cleanUp = function (node, listNodes) {
        // eslint-disable-next-line
        var tempCleaner = [];
        var prevflagState;
        var allNodes = node.querySelectorAll('*');
        for (var index = 0; index < allNodes.length; index++) {
            if (this.ignorableNodes.indexOf(allNodes[index].nodeName) === -1 ||
                (allNodes[index].nodeType === 3 && allNodes[index].textContent.trim() === '')) {
                tempCleaner.push(allNodes[index]);
                continue;
            }
            else if (allNodes[index].className &&
                allNodes[index].className.toLowerCase().indexOf('msolistparagraph') !== -1 &&
                allNodes[index].childElementCount !== 1 && !sf.base.isNullOrUndefined(allNodes[index].getAttribute('style')) &&
                allNodes[index].getAttribute('style').indexOf('mso-list:') >= 0) {
                if (allNodes[index].className.indexOf('MsoListParagraphCxSpFirst') >= 0 && listNodes.length > 0 &&
                    listNodes[listNodes.length - 1] !== null) {
                    listNodes.push(null);
                }
                listNodes.push(allNodes[index]);
            }
            if (prevflagState && (this.blockNode.indexOf(allNodes[index].nodeName.toLowerCase()) !== -1) &&
                !(allNodes[index].className &&
                    allNodes[index].className.toLowerCase().indexOf('msolistparagraph') !== -1 && !sf.base.isNullOrUndefined(allNodes[index].getAttribute('style')) &&
                    allNodes[index].getAttribute('style').indexOf('mso-list:') >= 0)) {
                listNodes.push(null);
            }
            if (this.blockNode.indexOf(allNodes[index].nodeName.toLowerCase()) !== -1) {
                if (allNodes[index].className &&
                    allNodes[index].className.toLowerCase().indexOf('msolistparagraph') !== -1 && !sf.base.isNullOrUndefined(allNodes[index].getAttribute('style')) &&
                    allNodes[index].getAttribute('style').indexOf('mso-list:') >= 0) {
                    prevflagState = true;
                }
                else {
                    prevflagState = false;
                }
            }
        }
        if (listNodes.length && (listNodes[listNodes.length - 1] !== null)) {
            listNodes.push(null);
        }
        return listNodes;
    };
    MsWordPaste.prototype.listConverter = function (listNodes) {
        var level;
        var data = [];
        var collection = [];
        var content = '';
        var stNode;
        var currentListStyle = '';
        for (var i = 0; i < listNodes.length; i++) {
            if (listNodes[i] === null) {
                data.push({ content: this.makeConversion(collection), node: listNodes[i - 1] });
                collection = [];
                continue;
            }
            if (listNodes[i].getAttribute('style') && listNodes[i].getAttribute('style').indexOf('mso-outline-level') !== -1) {
                listNodes[i].setAttribute('style', listNodes[i].getAttribute('style').replace('mso-outline-level', 'mso-outline'));
            }
            content = listNodes[i].getAttribute('style');
            if (content && content.indexOf('level') !== -1) {
                // eslint-disable-next-line
                level = parseInt(content.charAt(content.indexOf('level') + 5), null);
            }
            else {
                level = 1;
            }
            this.listContents = [];
            this.getListContent(listNodes[i]);
            var type = void 0;
            if (!sf.base.isNullOrUndefined(this.listContents[0])) {
                type = this.listContents[0].trim().length > 1 ? 'ol' : 'ul';
                var tempNode = [];
                for (var j = 1; j < this.listContents.length; j++) {
                    tempNode.push(this.listContents[j]);
                }
                var currentClassName = void 0;
                if (!sf.base.isNullOrUndefined(listNodes[i].className)) {
                    currentClassName = listNodes[i].className;
                }
                if (!sf.base.isNullOrUndefined(listNodes[i].getAttribute('style'))) {
                    listNodes[i].setAttribute('style', listNodes[i].getAttribute('style').replace('text-align:start;', ''));
                    if (listNodes[i].style.textAlign !== '') {
                        listNodes[i].setAttribute('style', 'text-align:' + listNodes[i].style.textAlign);
                        currentListStyle = listNodes[i].getAttribute('style');
                    }
                }
                collection.push({ listType: type, content: tempNode, nestedLevel: level, class: currentClassName,
                    listStyle: currentListStyle });
            }
        }
        stNode = listNodes.shift();
        while (stNode) {
            var elemColl = [];
            for (var temp1 = 0; temp1 < data.length; temp1++) {
                if (data[temp1].node === stNode) {
                    for (var index = 0; index < data[temp1].content.childNodes.length; index++) {
                        elemColl.push(data[temp1].content.childNodes[index]);
                    }
                    for (var index = 0; index < elemColl.length; index++) {
                        stNode.parentElement.insertBefore(elemColl[index], stNode);
                    }
                    break;
                }
            }
            stNode.remove();
            stNode = listNodes.shift();
            if (!stNode) {
                stNode = listNodes.shift();
            }
        }
    };
    MsWordPaste.prototype.makeConversion = function (collection) {
        var root = sf.base.createElement('div');
        var temp;
        var pLevel = 1;
        var prevList;
        var listCount = 0;
        var elem;
        for (var index = 0; index < collection.length; index++) {
            var pElement = sf.base.createElement('p');
            pElement.innerHTML = collection[index].content.join(' ');
            if ((collection[index].nestedLevel === 1) && listCount === 0 && collection[index].content) {
                root.appendChild(temp = sf.base.createElement(collection[index].listType));
                prevList = sf.base.createElement('li');
                prevList.appendChild(pElement);
                temp.appendChild(prevList);
                temp.setAttribute('level', collection[index].nestedLevel.toString());
                temp.style.listStyle = this.getListStyle(collection[index].listType, collection[index].nestedLevel);
            }
            else if (collection[index].nestedLevel === pLevel) {
                if (prevList.parentElement.tagName.toLowerCase() === collection[index].listType) {
                    prevList.parentElement.appendChild(prevList = sf.base.createElement('li'));
                    prevList.appendChild(pElement);
                }
                else {
                    temp = sf.base.createElement(collection[index].listType);
                    prevList.parentElement.parentElement.appendChild(temp);
                    prevList = sf.base.createElement('li');
                    prevList.appendChild(pElement);
                    temp.appendChild(prevList);
                    temp.setAttribute('level', collection[index].nestedLevel.toString());
                }
            }
            else if (collection[index].nestedLevel > pLevel) {
                if (!sf.base.isNullOrUndefined(prevList)) {
                    for (var j = 0; j < collection[index].nestedLevel - pLevel; j++) {
                        prevList.appendChild(temp = sf.base.createElement(collection[index].listType));
                        prevList = sf.base.createElement('li', { styles: 'list-style-type: none;' });
                        temp.appendChild(prevList);
                    }
                    prevList.appendChild(pElement);
                    temp.setAttribute('level', collection[index].nestedLevel.toString());
                    temp.style.listStyle = this.getListStyle(collection[index].listType, collection[index].nestedLevel);
                    temp.childNodes[0].style.listStyle =
                        this.getListStyle(collection[index].listType, collection[index].nestedLevel);
                }
                else {
                    root.appendChild(temp = sf.base.createElement(collection[index].listType));
                    prevList = sf.base.createElement('li');
                    prevList.appendChild(pElement);
                    temp.appendChild(prevList);
                    temp.setAttribute('level', collection[index].nestedLevel.toString());
                    temp.style.listStyle = this.getListStyle(collection[index].listType, collection[index].nestedLevel);
                }
            }
            else if (collection[index].nestedLevel === 1) {
                if (root.lastChild.tagName.toLowerCase() === collection[index].listType) {
                    temp = root.lastChild;
                }
                else {
                    root.appendChild(temp = sf.base.createElement(collection[index].listType));
                }
                prevList = sf.base.createElement('li');
                prevList.appendChild(pElement);
                temp.appendChild(prevList);
                temp.setAttribute('level', collection[index].nestedLevel.toString());
                temp.style.listStyle = this.getListStyle(collection[index].listType, collection[index].nestedLevel);
            }
            else {
                elem = prevList;
                while (elem.parentElement) {
                    elem = elem.parentElement;
                    if (elem.attributes.getNamedItem('level')) {
                        // eslint-disable-next-line
                        if (parseInt(elem.attributes.getNamedItem('level').textContent, null) === collection[index].nestedLevel) {
                            prevList = sf.base.createElement('li');
                            prevList.appendChild(pElement);
                            elem.appendChild(prevList);
                            break;
                            // eslint-disable-next-line
                        }
                        else if (collection[index].nestedLevel > parseInt(elem.attributes.getNamedItem('level').textContent, null)) {
                            elem.appendChild(temp = sf.base.createElement(collection[index].listType));
                            prevList = sf.base.createElement('li');
                            prevList.appendChild(pElement);
                            temp.appendChild(prevList);
                            temp.setAttribute('level', collection[index].nestedLevel.toString());
                            temp.style.listStyle = this.getListStyle(collection[index].listType, collection[index].nestedLevel);
                            break;
                        }
                    }
                    continue;
                }
            }
            prevList.setAttribute('class', collection[index].class);
            var currentStyle = prevList.getAttribute('style');
            prevList.setAttribute('style', (!sf.base.isNullOrUndefined(currentStyle) ? currentStyle : '') + collection[index].listStyle);
            pLevel = collection[index].nestedLevel;
            listCount++;
        }
        return root;
    };
    MsWordPaste.prototype.getListStyle = function (listType, nestedLevel) {
        nestedLevel = (nestedLevel > 0) ? nestedLevel - 1 : nestedLevel;
        if (listType === 'ol') {
            return (nestedLevel < this.olData.length ? this.olData[nestedLevel] : this.olData[0]);
        }
        else {
            return (nestedLevel < this.ulData.length ? this.ulData[nestedLevel] : this.ulData[0]);
        }
    };
    MsWordPaste.prototype.getListContent = function (elem) {
        var pushContent = '';
        var firstChild = elem.firstElementChild;
        if (firstChild.textContent.trim() === '' && !sf.base.isNullOrUndefined(firstChild.firstElementChild) &&
            firstChild.firstElementChild.nodeName === 'IMG') {
            pushContent = elem.innerHTML.trim();
            this.listContents.push('');
            this.listContents.push(pushContent);
        }
        else {
            var styleNodes = ['b', 'em'];
            if (firstChild.childNodes.length > 0 && (firstChild.querySelectorAll('b').length > 0
                || firstChild.querySelectorAll('em').length > 0)) {
                for (var i = 0; i < firstChild.childNodes.length; i++) {
                    var nodeName = firstChild.childNodes[i].nodeName.toLowerCase();
                    if (firstChild.childNodes[i].textContent.trim().length > 1 && styleNodes.indexOf(nodeName) !== -1) {
                        pushContent = '<' + nodeName + '>' + firstChild.childNodes[i].textContent + '</' + nodeName + '>';
                        this.listContents.push(pushContent);
                    }
                    else if (firstChild.childNodes[i].textContent.trim().length === 1) {
                        this.listContents.push(firstChild.childNodes[i].textContent.trim());
                    }
                }
            }
            else {
                pushContent = firstChild.textContent.trim();
                this.listContents.push(pushContent);
            }
        }
        sf.base.detach(firstChild);
        this.listContents.push(elem.innerHTML);
    };
    return MsWordPaste;
}());

/**
 * Insert a Text Node or Text
 *
 * @hidden
 * @deprecated
 */
var InsertTextExec = /** @class */ (function () {
    /**
     * Constructor for creating the InsertText plugin
     *
     * @param {EditorManager} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function InsertTextExec(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    InsertTextExec.prototype.addEventListener = function () {
        this.parent.observer.on(INSERT_TEXT_TYPE, this.insertText, this);
    };
    InsertTextExec.prototype.insertText = function (e) {
        var node = document.createTextNode(e.value);
        InsertHtml.Insert(this.parent.currentDocument, node);
        if (e.callBack) {
            e.callBack({
                requestType: e.subCommand,
                editorMode: 'HTML',
                event: e.event,
                range: this.parent.nodeSelection.getRange(this.parent.currentDocument),
                elements: this.parent.nodeSelection.getSelectedNodes(this.parent.currentDocument)
            });
        }
    };
    return InsertTextExec;
}());

/**
 * EditorManager internal component
 *
 * @hidden
 * @deprecated
 */
var EditorManager = /** @class */ (function () {
    /**
     * Constructor for creating the component
     *
     * @hidden
     * @deprecated
     * @param {ICommandModel} options - specifies the command Model
     */
    function EditorManager(options) {
        this.currentDocument = options.document;
        this.editableElement = options.editableElement;
        this.nodeSelection = new NodeSelection();
        this.nodeCutter = new NodeCutter();
        this.domNode = new DOMNode(this.editableElement, this.currentDocument);
        this.observer = new sf.base.Observer(this);
        this.listObj = new Lists(this);
        this.formatObj = new Formats(this);
        this.alignmentObj = new Alignments(this);
        this.indentsObj = new Indents(this);
        this.linkObj = new LinkCommand(this);
        this.imgObj = new ImageCommand(this);
        this.selectionObj = new SelectionBasedExec(this);
        this.inserthtmlObj = new InsertHtmlExec(this);
        this.insertTextObj = new InsertTextExec(this);
        this.clearObj = new ClearFormatExec(this);
        this.tableObj = new TableCommand(this);
        this.undoRedoManager = new UndoRedoManager(this, options.options);
        this.msWordPaste = new MsWordPaste(this);
        this.wireEvents();
    }
    EditorManager.prototype.wireEvents = function () {
        this.observer.on(KEY_DOWN, this.editorKeyDown, this);
        this.observer.on(KEY_UP, this.editorKeyUp, this);
        this.observer.on(KEY_UP, this.editorKeyUp, this);
        this.observer.on(MODEL_CHANGED, this.onPropertyChanged, this);
        this.observer.on(MS_WORD_CLEANUP$1, this.onWordPaste, this);
        this.observer.on(ON_BEGIN$1, this.onBegin, this);
    };
    EditorManager.prototype.onWordPaste = function (e) {
        this.observer.notify(MS_WORD_CLEANUP_PLUGIN$1, e);
    };
    EditorManager.prototype.onPropertyChanged = function (props) {
        this.observer.notify(MODEL_CHANGED_PLUGIN, props);
    };
    EditorManager.prototype.editorKeyDown = function (e) {
        this.observer.notify(KEY_DOWN_HANDLER, e);
    };
    EditorManager.prototype.editorKeyUp = function (e) {
        this.observer.notify(KEY_UP_HANDLER, e);
    };
    EditorManager.prototype.onBegin = function (e) {
        this.observer.notify(SPACE_ACTION, e);
    };
    /* eslint-disable */
    /**
     * execCommand
     *
     * @param {ExecCommand} command - specifies the execution command
     * @param {T} value - specifes the value.
     * @param {Event} event - specifies the call back event
     * @param {Function} callBack - specifies the function
     * @param {string} text - specifies the string value
     * @param {T} exeValue - specifies the values to be executed
     * @param {string} selector - specifies the selector values
     * @returns {void}
     * @hidden
     * @deprecated
     */
    /* eslint-enable */
    EditorManager.prototype.execCommand = function (command, value, event, callBack, text, exeValue, selector, enterAction) {
        switch (command.toLowerCase()) {
            case 'lists':
                this.observer.notify(LIST_TYPE, { subCommand: value, event: event, callBack: callBack,
                    selector: selector, item: exeValue, enterAction: enterAction });
                break;
            case 'formats':
                this.observer.notify(FORMAT_TYPE, { subCommand: value, event: event, callBack: callBack,
                    selector: selector, exeValue: exeValue, enterAction: enterAction
                });
                break;
            case 'alignments':
                this.observer.notify(ALIGNMENT_TYPE, {
                    subCommand: value, event: event, callBack: callBack,
                    selector: selector,
                    value: exeValue
                });
                break;
            case 'indents':
                this.observer.notify(INDENT_TYPE, { subCommand: value, event: event, callBack: callBack, selector: selector });
                break;
            case 'links':
                this.observer.notify(LINK, { command: command, value: value, item: exeValue, event: event, callBack: callBack });
                break;
            case 'files':
                this.observer.notify(IMAGE, {
                    command: command, value: 'Image', item: exeValue, event: event, callBack: callBack, selector: selector
                });
                break;
            case 'images':
                this.observer.notify(IMAGE, {
                    command: command, value: value, item: exeValue, event: event, callBack: callBack, selector: selector
                });
                break;
            case 'table':
                switch (value.toString().toLocaleLowerCase()) {
                    case 'createtable':
                        this.observer.notify(TABLE, { item: exeValue, event: event, callBack: callBack, enterAction: enterAction });
                        break;
                    case 'insertrowbefore':
                    case 'insertrowafter':
                        this.observer.notify(INSERT_ROW, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'insertcolumnleft':
                    case 'insertcolumnright':
                        this.observer.notify(INSERT_COLUMN, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'deleterow':
                        this.observer.notify(DELETEROW, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'deletecolumn':
                        this.observer.notify(DELETECOLUMN, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'tableremove':
                        this.observer.notify(REMOVETABLE, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'tableheader':
                        this.observer.notify(TABLEHEADER, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'aligntop':
                    case 'alignmiddle':
                    case 'alignbottom':
                        this.observer.notify(TABLE_VERTICAL_ALIGN, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'merge':
                        this.observer.notify(TABLE_MERGE, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'horizontalsplit':
                        this.observer.notify(TABLE_HORIZONTAL_SPLIT, { item: exeValue, event: event, callBack: callBack });
                        break;
                    case 'verticalsplit':
                        this.observer.notify(TABLE_VERTICAL_SPLIT, { item: exeValue, event: event, callBack: callBack });
                        break;
                }
                break;
            case 'font':
            case 'style':
            case 'effects':
            case 'casing':
                this.observer.notify(SELECTION_TYPE, { subCommand: value, event: event, callBack: callBack, value: text, selector: selector, enterAction: enterAction });
                break;
            case 'inserthtml':
                this.observer.notify(INSERTHTML_TYPE, { subCommand: value, callBack: callBack, value: text });
                break;
            case 'inserttext':
                this.observer.notify(INSERT_TEXT_TYPE, { subCommand: value, callBack: callBack, value: text });
                break;
            case 'clear':
                this.observer.notify(CLEAR_TYPE, { subCommand: value, event: event, callBack: callBack, selector: selector, enterAction: enterAction });
                break;
            case 'actions':
                this.observer.notify(ACTION, { subCommand: value, event: event, callBack: callBack, selector: selector });
                break;
        }
    };
    return EditorManager;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * HTML adapter
 */
var HTMLFormatter = /** @class */ (function (_super) {
    __extends(HTMLFormatter, _super);
    function HTMLFormatter(options) {
        var _this = _super.call(this) || this;
        _this.initialize();
        sf.base.extend(_this, _this, options, true);
        if (_this.currentDocument && _this.element) {
            _this.updateFormatter(_this.element, _this.currentDocument, options.options);
        }
        return _this;
    }
    HTMLFormatter.prototype.initialize = function () {
        this.keyConfig = htmlKeyConfig;
    };
    HTMLFormatter.prototype.updateFormatter = function (editElement, doc, options) {
        if (editElement && doc) {
            this.editorManager = new EditorManager({
                document: doc,
                editableElement: editElement,
                options: options
            });
        }
    };
    return HTMLFormatter;
}(Formatter));

/**
 * `HtmlEditor` module is used to HTML editor
 */
var HtmlEditor = /** @class */ (function () {
    function HtmlEditor(parent) {
        this.rangeCollection = [];
        this.parent = parent;
        this.xhtmlValidation = new XhtmlValidation(parent);
        this.addEventListener();
    }
    HtmlEditor.prototype.addEventListener = function () {
        this.nodeSelectionObj = new NodeSelection();
        this.parent.observer.on(htmlToolbarClick, this.onToolbarClick, this);
        this.parent.observer.on(keyDown, this.onKeyDown, this);
        this.parent.observer.on(initialEnd, this.render, this);
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(selectAll$1, this.selectAll, this);
        this.parent.observer.on(selectRange, this.selectRange, this);
        this.parent.observer.on(getSelectedHtml, this.getSelectedHtml, this);
        this.parent.observer.on(selectionSave, this.onSelectionSave, this);
        this.parent.observer.on(selectionRestore, this.onSelectionRestore, this);
        this.parent.observer.on(readOnlyMode, this.updateReadOnly, this);
        this.parent.observer.on(paste, this.onPaste, this);
    };
    HtmlEditor.prototype.sanitizeHelper = function (value) {
        value = sanitizeHelper(value, this.parent);
        return value;
    };
    HtmlEditor.prototype.updateReadOnly = function () {
        if (this.parent.readonly) {
            sf.base.attributes(this.parent.getEditPanel(), { contenteditable: 'false' });
            sf.base.addClass([this.parent.element], CLS_RTE_READONLY);
        }
        else {
            sf.base.attributes(this.parent.getEditPanel(), { contenteditable: 'true' });
            sf.base.removeClass([this.parent.element], CLS_RTE_READONLY);
        }
    };
    HtmlEditor.prototype.onSelectionSave = function () {
        var currentDocument = this.parent.getDocument();
        var range = this.nodeSelectionObj.getRange(currentDocument);
        this.saveSelection = this.nodeSelectionObj.save(range, currentDocument);
    };
    HtmlEditor.prototype.onSelectionRestore = function (e) {
        this.parent.isBlur = false;
        this.parent.getEditPanel().focus();
        if (sf.base.isNullOrUndefined(e.items) || e.items) {
            this.saveSelection.restore();
        }
    };
    HtmlEditor.prototype.onKeyDown = function (e) {
        var _this = this;
        var currentRange;
        var args = e.args;
        if (sf.base.Browser.info.name === 'chrome') {
            currentRange = this.parent.getRange();
            this.backSpaceCleanup(e, currentRange);
            this.deleteCleanup(e, currentRange);
        }
        if (args.keyCode === 9 && sf.base.isNullOrUndefined(sf.base.closest(args.target, '.e-rte-toolbar')) && this.parent.enableTabKey) {
            var range = this.nodeSelectionObj.getRange(this.parent.getDocument());
            var parentNode = this.nodeSelectionObj.getParentNodeCollection(range);
            if (!((parentNode[0].nodeName === 'LI' || sf.base.closest(parentNode[0], 'li') ||
                sf.base.closest(parentNode[0], 'table')) && range.startOffset === 0)) {
                args.preventDefault();
                if (!args.shiftKey) {
                    InsertHtml.Insert(this.parent.getDocument(), '&nbsp;&nbsp;&nbsp;&nbsp;');
                    this.rangeCollection.push(this.nodeSelectionObj.getRange(this.parent.getDocument()));
                }
                else if (this.rangeCollection.length > 0 &&
                    this.rangeCollection[this.rangeCollection.length - 1].startContainer.textContent.length === 4) {
                    var textCont = this.rangeCollection[this.rangeCollection.length - 1].startContainer;
                    this.nodeSelectionObj.setSelectionText(this.parent.getDocument(), textCont, textCont, 0, textCont.textContent.length);
                    InsertHtml.Insert(this.parent.getDocument(), document.createTextNode(''));
                    this.rangeCollection.pop();
                }
            }
        }
        if (e.args.action === 'space') {
            var currentRange_1 = this.parent.getRange();
            var editorValue = currentRange_1.startContainer.textContent.slice(0, currentRange_1.startOffset);
            var orderedList_1 = this.isOrderedList(editorValue);
            var unOrderedList = this.isUnOrderedList(editorValue);
            if (orderedList_1 && !unOrderedList || unOrderedList && !orderedList_1) {
                var eventArgs_1 = {
                    callBack: null,
                    event: e.args,
                    name: 'keydown-handler'
                };
                this.parent.dotNetRef.invokeMethodAsync(
                // @ts-ignore-start
                actionBeginEvent, { requestType: orderedList_1 ? 'OL' : 'UL', cancel: false }).then(function (actionBeginArgs) {
                    // @ts-ignore-end
                    if (!actionBeginArgs.cancel) {
                        _this.parent.formatter.editorManager.observer.notify(ON_BEGIN, eventArgs_1);
                        _this.parent.dotNetRef.invokeMethodAsync(
                        // @ts-ignore-start
                        actionCompleteEvent, { editorMode: _this.parent.editorMode, name: actionCompleteEvent, requestType: orderedList_1 ? 'OL' : 'UL'
                            // @ts-ignore-end
                        });
                    }
                });
            }
        }
        if (e.args.action === 'space' ||
            e.args.action === 'enter') {
            this.spaceLink(args);
        }
        if (sf.base.Browser.info.name === 'chrome' && (!sf.base.isNullOrUndefined(this.rangeElement) && !sf.base.isNullOrUndefined(this.oldRangeElement) ||
            !sf.base.isNullOrUndefined(this.deleteRangeElement) && !sf.base.isNullOrUndefined(this.deleteOldRangeElement)) &&
            currentRange.startContainer.parentElement.tagName !== 'TD' && currentRange.startContainer.parentElement.tagName !== 'TH') {
            this.rangeElement = null;
            this.oldRangeElement = null;
            this.deleteRangeElement = null;
            this.deleteOldRangeElement = null;
            args.preventDefault();
        }
    };
    HtmlEditor.prototype.isOrderedList = function (editorValue) {
        editorValue = editorValue.replace(/\u200B/g, '');
        var olListStartRegex = [/^[1]+[.]+$/, /^[i]+[.]+$/, /^[a]+[.]+$/];
        if (!sf.base.isNullOrUndefined(editorValue)) {
            for (var i = 0; i < olListStartRegex.length; i++) {
                if (olListStartRegex[i].test(editorValue)) {
                    return true;
                }
            }
        }
        return false;
    };
    HtmlEditor.prototype.isUnOrderedList = function (editorValue) {
        editorValue = editorValue.replace(/\u200B/g, '');
        var ulListStartRegex = [/^[*]$/, /^[-]$/];
        if (!sf.base.isNullOrUndefined(editorValue)) {
            for (var i = 0; i < ulListStartRegex.length; i++) {
                if (ulListStartRegex[i].test(editorValue)) {
                    return true;
                }
            }
        }
        return false;
    };
    HtmlEditor.prototype.backSpaceCleanup = function (e, currentRange) {
        var isLiElement = false;
        if (e.args.code === 'Backspace' && e.args.keyCode === 8 && currentRange.startOffset === 0 &&
            currentRange.endOffset === 0 && this.parent.getSelection().length === 0 && currentRange.startContainer.textContent.length > 0 &&
            currentRange.startContainer.parentElement.tagName !== 'TD' && currentRange.startContainer.parentElement.tagName !== 'TH') {
            this.rangeElement = this.getRootBlockNode(currentRange.startContainer);
            if (this.rangeElement.tagName === 'OL' || this.rangeElement.tagName === 'UL') {
                var liElement = this.getRangeLiNode(currentRange.startContainer);
                if (liElement.previousElementSibling && liElement.previousElementSibling.childElementCount > 0) {
                    this.oldRangeElement = liElement.previousElementSibling.lastElementChild;
                    if (!sf.base.isNullOrUndefined(liElement.lastElementChild)) {
                        this.rangeElement = liElement.lastElementChild;
                        isLiElement = true;
                    }
                    else {
                        this.rangeElement = liElement;
                    }
                }
            }
            else if (this.rangeElement.tagName === 'TABLE' || (!sf.base.isNullOrUndefined(this.rangeElement.previousElementSibling) &&
                this.rangeElement.previousElementSibling.tagName === 'TABLE')) {
                return;
            }
            else {
                this.oldRangeElement = this.rangeElement.previousElementSibling;
            }
            if (sf.base.isNullOrUndefined(this.oldRangeElement)) {
                return;
            }
            else {
                if (this.oldRangeElement.tagName === 'OL' || this.oldRangeElement.tagName === 'UL') {
                    this.oldRangeElement = this.oldRangeElement.lastElementChild.lastElementChild ? this.oldRangeElement.lastElementChild.lastElementChild :
                        this.oldRangeElement.lastElementChild;
                }
                this.parent.formatter.editorManager.nodeSelection.setCursorPoint(this.parent.getDocument(), this.oldRangeElement, this.oldRangeElement.childNodes.length);
                if (this.oldRangeElement.querySelector('BR')) {
                    sf.base.detach(this.oldRangeElement.querySelector('BR'));
                }
                if (!sf.base.isNullOrUndefined(this.rangeElement) && this.oldRangeElement != this.rangeElement) {
                    while (this.rangeElement.firstChild) {
                        this.oldRangeElement.appendChild(this.rangeElement.childNodes[0]);
                    }
                    !isLiElement ? sf.base.detach(this.rangeElement) : sf.base.detach(this.rangeElement.parentElement);
                    this.oldRangeElement.normalize();
                }
            }
        }
    };
    HtmlEditor.prototype.deleteCleanup = function (e, currentRange) {
        var isLiElement = false;
        var liElement;
        var rootElement;
        if (e.args.code === 'Delete' && e.args.keyCode === 46 &&
            this.parent.getText().trim().length !== 0 && this.parent.getSelection().length === 0 && currentRange.startContainer.parentElement.tagName !== 'TD' &&
            currentRange.startContainer.parentElement.tagName !== 'TH') {
            this.deleteRangeElement = rootElement = this.getRootBlockNode(currentRange.startContainer);
            if (this.deleteRangeElement.tagName === 'OL' || this.deleteRangeElement.tagName === 'UL') {
                liElement = this.getRangeLiNode(currentRange.startContainer);
                if (liElement.nextElementSibling && liElement.nextElementSibling.childElementCount > 0
                    && !liElement.nextElementSibling.querySelector('BR')) {
                    if (!sf.base.isNullOrUndefined(liElement.lastElementChild)) {
                        this.deleteRangeElement = liElement.lastElementChild;
                        isLiElement = true;
                    }
                    else {
                        this.deleteRangeElement = liElement;
                    }
                }
                else {
                    this.deleteRangeElement = this.getRangeElement(liElement);
                }
            }
            else if (this.deleteRangeElement.nodeType === 3 || (this.deleteRangeElement.tagName === 'TABLE' ||
                (!sf.base.isNullOrUndefined(this.deleteRangeElement.nextElementSibling) && this.deleteRangeElement.nextElementSibling.tagName === 'TABLE'))) {
                return;
            }
            if (this.getCaretIndex(currentRange, this.deleteRangeElement) === this.deleteRangeElement.textContent.length) {
                if (!sf.base.isNullOrUndefined(liElement)) {
                    if (isLiElement || !sf.base.isNullOrUndefined(liElement.nextElementSibling)) {
                        this.deleteOldRangeElement = this.getRangeElement(liElement.nextElementSibling);
                    }
                    else {
                        this.deleteOldRangeElement = rootElement.nextElementSibling;
                    }
                }
                else {
                    this.deleteOldRangeElement = this.deleteRangeElement.nextElementSibling;
                }
                if (sf.base.isNullOrUndefined(this.deleteOldRangeElement)) {
                    return;
                }
                else {
                    this.parent.formatter.editorManager.nodeSelection.setCursorPoint(this.parent.getDocument(), this.deleteRangeElement, this.deleteRangeElement.childNodes.length);
                    if (this.deleteRangeElement.querySelector('BR')) {
                        sf.base.detach(this.deleteRangeElement.querySelector('BR'));
                    }
                    if (!sf.base.isNullOrUndefined(this.deleteRangeElement) && (this.deleteOldRangeElement.tagName !== 'OL' && this.deleteOldRangeElement.tagName !== 'UL')
                        && this.deleteOldRangeElement !== this.deleteRangeElement) {
                        while (this.deleteOldRangeElement.firstChild) {
                            this.deleteRangeElement.appendChild(this.deleteOldRangeElement.childNodes[0]);
                        }
                        !isLiElement ? sf.base.detach(this.deleteOldRangeElement) : sf.base.detach(this.deleteOldRangeElement.parentElement);
                        this.deleteRangeElement.normalize();
                    }
                    else {
                        this.deleteRangeElement = null;
                        this.deleteOldRangeElement = null;
                    }
                }
            }
            else {
                this.deleteRangeElement = null;
            }
        }
    };
    HtmlEditor.prototype.getCaretIndex = function (currentRange, element) {
        var position = 0;
        if (this.parent.getDocument().getSelection().rangeCount !== 0) {
            var preCaretRange = currentRange.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(currentRange.endContainer, currentRange.endOffset);
            position = preCaretRange.toString().length;
        }
        return position;
    };
    HtmlEditor.prototype.getRangeElement = function (element) {
        var rangeElement = element.lastElementChild ? element.lastElementChild.tagName === 'BR' ?
            element.lastElementChild.previousElementSibling ? element.lastElementChild.previousElementSibling
                : element : element.lastElementChild : element;
        return rangeElement;
    };
    HtmlEditor.prototype.getRootBlockNode = function (rangeBlockNode) {
        for (; rangeBlockNode && this.parent && this.parent.inputElement != rangeBlockNode; rangeBlockNode = rangeBlockNode) {
            if (rangeBlockNode.parentElement === this.parent.inputElement) {
                break;
            }
            else {
                rangeBlockNode = rangeBlockNode.parentElement;
            }
        }
        return rangeBlockNode;
    };
    HtmlEditor.prototype.getRangeLiNode = function (rangeLiNode) {
        var node = rangeLiNode.parentElement;
        while (node != this.parent.inputElement) {
            if (node.nodeType === 1 && node.tagName === 'LI') {
                break;
            }
            node = node.parentElement;
        }
        return node;
    };
    HtmlEditor.prototype.onPaste = function (e) {
        var regex = new RegExp(/([^\S]|^)(((https?\:\/\/)|(www\.))(\S+))/gi);
        if (e.text.match(regex)) {
            e.args.preventDefault();
            var range = this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument());
            var saveSelection = this.parent.formatter.editorManager.nodeSelection.save(range, this.parent.getDocument());
            var httpRegex = new RegExp(/([^\S]|^)(((https?\:\/\/)))/gi);
            var wwwRegex = new RegExp(/([^\S]|^)(((www\.))(\S+))/gi);
            var enterSplitText = e.text.split('\n');
            var contentInnerElem = '';
            for (var i = 0; i < enterSplitText.length; i++) {
                if (enterSplitText[i].trim() === '') {
                    contentInnerElem += '<p><br></p>';
                }
                else {
                    var contentWithSpace = '';
                    var spaceBetweenContent = true;
                    var spaceSplit = enterSplitText[i].split(' ');
                    for (var j = 0; j < spaceSplit.length; j++) {
                        if (spaceSplit[j].trim() === '') {
                            contentWithSpace += spaceBetweenContent ? '&nbsp;' : ' ';
                        }
                        else {
                            spaceBetweenContent = false;
                            contentWithSpace += spaceSplit[j] + ' ';
                        }
                    }
                    if (i === 0) {
                        contentInnerElem += '<span>' + contentWithSpace.trim() + '</span>';
                    }
                    else {
                        contentInnerElem += '<p>' + contentWithSpace.trim() + '</p>';
                    }
                }
            }
            var divElement = document.createElement('div');
            divElement.setAttribute('class', 'pasteContent');
            divElement.style.display = 'inline';
            divElement.innerHTML = contentInnerElem;
            var paraElem = divElement.querySelectorAll('span, p');
            for (var i = 0; i < paraElem.length; i++) {
                var splitTextContent = paraElem[i].innerHTML.split(' ');
                var resultSplitContent = '';
                for (var j = 0; j < splitTextContent.length; j++) {
                    if (splitTextContent[j].match(httpRegex) || splitTextContent[j].match(wwwRegex)) {
                        resultSplitContent += '<a className="e-rte-anchor" href="' + splitTextContent[j] +
                            '" title="' + splitTextContent[j] + '">' + splitTextContent[j] + ' </a>';
                    }
                    else {
                        resultSplitContent += splitTextContent[j] + ' ';
                    }
                }
                paraElem[i].innerHTML = resultSplitContent.trim();
            }
            // if (!isNullOrUndefined(this.parent.pasteCleanupModule)) {
            e.callBack(divElement.innerHTML);
            // } else {
            //     this.parent.executeCommand('insertHTML', divElement);
            // }
        }
    };
    HtmlEditor.prototype.spaceLink = function (e) {
        var range = this.nodeSelectionObj.getRange(this.parent.getDocument());
        var selectNodeEle = this.nodeSelectionObj.getParentNodeCollection(range);
        var text = range.startContainer.textContent.substr(0, range.endOffset);
        var splitText = text.split(' ');
        var urlText = splitText[splitText.length - 1];
        var urlTextRange = range.startOffset - (text.length - splitText[splitText.length - 1].length);
        urlText = urlText.slice(0, urlTextRange);
        var regex = new RegExp(/([^\S]|^)(((https?\:\/\/)|(www\.))(\S+))/gi);
        if (selectNodeEle[0].nodeName !== 'A' && urlText.match(regex)) {
            var selection = this.nodeSelectionObj.save(range, this.parent.getDocument());
            var url = urlText.indexOf('http') > -1 ? urlText : 'http://' + urlText;
            var selectParent = this.parent.formatter.editorManager.nodeSelection.getParentNodeCollection(range);
            var value = {
                url: url,
                selection: selection, selectParent: selectParent,
                text: urlText,
                title: '',
                target: '_blank'
            };
            this.parent.formatter.process(this.parent, {
                item: {
                    'command': 'Links',
                    'subCommand': 'CreateLink'
                }
            }, e, value);
        }
    };
    HtmlEditor.prototype.onToolbarClick = function (args) {
        var save;
        var selectNodeEle;
        var selectParentEle;
        var item = args.item;
        var target = args.originalEvent.target;
        var closestElement = target && sf.base.closest(target, '.' + CLS_QUICK_POP);
        if (closestElement && !closestElement.classList.contains(CLS_INLINE_POP)) {
            if (!(item.subCommand === 'SourceCode' || item.subCommand === 'Preview' ||
                item.subCommand === 'FontColor' || item.subCommand === 'BackgroundColor')) {
                if (isIDevice$1() && item.command === 'Images') {
                    this.nodeSelectionObj.restore();
                }
                var range = this.nodeSelectionObj.getRange(this.parent.getDocument());
                save = this.nodeSelectionObj.save(range, this.parent.getDocument());
                selectNodeEle = this.nodeSelectionObj.getNodeCollection(range);
                selectParentEle = this.nodeSelectionObj.getParentNodeCollection(range);
            }
            if (item.command === 'Images') {
                this.parent.observer.notify(imageToolbarAction, {
                    member: 'image', args: args, selectNode: selectNodeEle, selection: save, selectParent: selectParentEle
                });
            }
            if (item.command === 'Links') {
                this.parent.observer.notify(linkToolbarAction, {
                    member: 'link', args: args, selectNode: selectNodeEle, selection: save, selectParent: selectParentEle
                });
            }
            if (item.command === 'Table') {
                this.parent.observer.notify(tableToolbarAction, {
                    member: 'table', args: args, selectNode: selectNodeEle, selection: save, selectParent: selectParentEle
                });
            }
        }
        else {
            if (!(item.subCommand === 'SourceCode' || item.subCommand === 'Preview' ||
                item.subCommand === 'FontColor' || item.subCommand === 'BackgroundColor')) {
                var range = this.nodeSelectionObj.getRange(this.parent.getDocument());
                save = this.nodeSelectionObj.save(range, this.parent.getDocument());
                selectNodeEle = this.nodeSelectionObj.getNodeCollection(range);
                selectParentEle = this.nodeSelectionObj.getParentNodeCollection(range);
            }
            switch (item.subCommand) {
                case 'Maximize':
                    this.parent.observer.notify(enableFullScreen, { args: args });
                    break;
                case 'Minimize':
                    this.parent.observer.notify(disableFullScreen, { args: args });
                    break;
                case 'CreateLink':
                    this.parent.observer.notify(insertLink, {
                        member: 'link', args: args, selectNode: selectNodeEle, selection: save, selectParent: selectParentEle
                    });
                    break;
                case 'RemoveLink':
                    this.parent.observer.notify(unLink, {
                        member: 'link', args: args, selectNode: selectNodeEle, selection: save, selectParent: selectParentEle
                    });
                    break;
                case 'Print':
                    this.parent.print();
                    break;
                case 'Image':
                    this.parent.observer.notify(insertImage, {
                        member: 'image', args: args, selectNode: selectNodeEle, selection: save, selectParent: selectParentEle
                    });
                    break;
                case 'CreateTable':
                    this.parent.observer.notify(createTable, {
                        member: 'table', args: args, selection: save
                    });
                    break;
                case 'SourceCode':
                    this.parent.observer.notify(sourceCode, { member: 'viewSource', args: args });
                    break;
                case 'Preview':
                    this.parent.observer.notify(updateSource, { member: 'updateSource', args: args });
                    break;
                case 'FontColor':
                case 'BackgroundColor':
                    break;
                default:
                    this.parent.formatter.process(this.parent, args, args.originalEvent, null);
                    break;
            }
        }
    };
    HtmlEditor.prototype.render = function () {
        var editElement = this.parent.getEditPanel();
        var option = { undoRedoSteps: this.parent.undoRedoSteps, undoRedoTimer: this.parent.undoRedoTimer };
        this.parent.formatter = new HTMLFormatter({
            currentDocument: this.parent.getDocument(),
            element: editElement,
            options: option
        });
        if (this.parent.toolbarSettings.enable) {
            this.toolbarUpdate = new HtmlToolbarStatus(this.parent);
        }
        if (this.parent.inlineMode.enable) {
            if (!sf.base.isNullOrUndefined(this.parent.fontFamily.default)) {
                editElement.style.fontFamily = this.parent.fontFamily.default;
            }
            if (!sf.base.isNullOrUndefined(this.parent.fontSize.default)) {
                editElement.style.fontSize = this.parent.fontSize.default;
            }
        }
        this.parent.observer.notify(bindOnEnd, {});
    };
    HtmlEditor.prototype.selectAll = function () {
        var nodes = getTextNodesUnder(this.parent.getDocument(), this.parent.getEditPanel());
        if (nodes.length > 0) {
            this.parent.formatter.editorManager.nodeSelection.setSelectionText(this.parent.getDocument(), nodes[0], nodes[nodes.length - 1], 0, nodes[nodes.length - 1].textContent.length);
        }
    };
    HtmlEditor.prototype.selectRange = function (e) {
        this.parent.formatter.editorManager.nodeSelection.setRange(this.parent.getDocument(), e.range);
    };
    HtmlEditor.prototype.getSelectedHtml = function (e) {
        e.callBack(this.parent.formatter.editorManager.nodeSelection.getRange(this.parent.getDocument()).toString());
    };
    HtmlEditor.prototype.removeEventListener = function () {
        this.parent.observer.off(initialEnd, this.render);
        this.parent.observer.off(htmlToolbarClick, this.onToolbarClick);
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(keyDown, this.onKeyDown);
        this.parent.observer.off(selectAll$1, this.selectAll);
        this.parent.observer.off(selectRange, this.selectRange);
        this.parent.observer.off(getSelectedHtml, this.getSelectedHtml);
        this.parent.observer.off(selectionSave, this.onSelectionSave);
        this.parent.observer.off(selectionRestore, this.onSelectionRestore);
        this.parent.observer.off(readOnlyMode, this.updateReadOnly);
        this.parent.observer.off(paste, this.onPaste);
    };
    HtmlEditor.prototype.destroy = function () {
        this.removeEventListener();
    };
    return HtmlEditor;
}());

/**
 * `FullScreen` module is used to maximize and minimize screen
 */
var FullScreen = /** @class */ (function () {
    function FullScreen(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    FullScreen.prototype.showFullScreen = function (event) {
        var _this = this;
        if (this.parent.toolbarSettings.enable === true && this.parent.editorMode !== 'Markdown') {
            this.parent.quickToolbarModule.hideQuickToolbars();
        }
        this.scrollableParent = sf.popups.getScrollableParent(this.parent.element);
        if (this.parent.actionBeginEnabled) {
            this.parent.dotNetRef.invokeMethodAsync(
            // @ts-ignore-start
            actionBeginEvent, { requestType: 'Maximize', cancel: false }).then(function (fullScreenArgs) {
                // @ts-ignore-end
                if (!fullScreenArgs.cancel) {
                    _this.showActionBeginCallback();
                }
            });
        }
        else {
            this.showActionBeginCallback();
        }
        setTimeout(function () {
            _this.parent.setContentHeight();
            _this.parent.inputElement.focus();
        }, 100);
    };
    FullScreen.prototype.showActionBeginCallback = function () {
        this.toggleParentOverflow(true);
        this.parent.setContentHeight();
        this.invokeActionComplete('Maximize');
    };
    FullScreen.prototype.hideFullScreen = function (event) {
        var _this = this;
        if (this.parent.toolbarSettings.enable === true && this.parent.editorMode !== 'Markdown') {
            this.parent.quickToolbarModule.hideQuickToolbars();
        }
        var elem = document.querySelectorAll('.' + CLS_RTE_OVERFLOW);
        for (var i = 0; i < elem.length; i++) {
            sf.base.removeClass([elem[i]], [CLS_RTE_OVERFLOW]);
        }
        if (this.parent.actionBeginEnabled) {
            this.parent.dotNetRef.invokeMethodAsync(
            // @ts-ignore-start
            actionBeginEvent, { requestType: 'Minimize', cancel: false }).then(function (fullScreenArgs) {
                // @ts-ignore-end
                if (!fullScreenArgs.cancel) {
                    _this.hideActionBeginCallback();
                }
            });
        }
        else {
            this.hideActionBeginCallback();
        }
        setTimeout(function () {
            _this.parent.setContentHeight();
            _this.parent.inputElement.focus();
        }, 100);
    };
    FullScreen.prototype.hideActionBeginCallback = function () {
        this.parent.setContentHeight();
        this.invokeActionComplete('Minimize');
    };
    FullScreen.prototype.invokeActionComplete = function (type) {
        if (this.parent.actionCompleteEnabled) {
            this.parent.dotNetRef.invokeMethodAsync(actionCompleteEvent, { requestType: type });
        }
    };
    FullScreen.prototype.toggleParentOverflow = function (isAdd) {
        if (sf.base.isNullOrUndefined(this.scrollableParent)) {
            return;
        }
        for (var i = 0; i < this.scrollableParent.length; i++) {
            if (this.scrollableParent[i].nodeName === '#document') {
                var elem = document.querySelector('body');
                sf.base.addClass([elem], [CLS_RTE_OVERFLOW]);
            }
            else {
                var elem = this.scrollableParent[i];
                sf.base.addClass([elem], [CLS_RTE_OVERFLOW]);
            }
        }
    };
    FullScreen.prototype.onKeyDown = function (event) {
        var originalEvent = event.args;
        switch (originalEvent.action) {
            case 'full-screen':
                this.parent.dotNetRef.invokeMethodAsync(showFullScreenClient);
                this.showFullScreen(event.args);
                originalEvent.preventDefault();
                break;
            case 'escape':
                this.parent.dotNetRef.invokeMethodAsync(hideFullScreenClient);
                this.hideFullScreen(event.args);
                originalEvent.preventDefault();
                break;
        }
    };
    FullScreen.prototype.addEventListener = function () {
        this.parent.observer.on(enableFullScreen, this.showFullScreen, this);
        this.parent.observer.on(disableFullScreen, this.hideFullScreen, this);
        this.parent.observer.on(keyDown, this.onKeyDown, this);
        this.parent.observer.on(destroy, this.destroy, this);
    };
    FullScreen.prototype.removeEventListener = function () {
        this.parent.observer.off(enableFullScreen, this.showFullScreen);
        this.parent.observer.off(disableFullScreen, this.hideFullScreen);
        this.parent.observer.off(keyDown, this.onKeyDown);
        this.parent.observer.off(destroy, this.destroy);
    };
    FullScreen.prototype.destroy = function () {
        if (this.parent.element.classList.contains(CLS_FULL_SCREEN)) {
            this.toggleParentOverflow(false);
        }
        var elem = document.querySelectorAll('.' + CLS_RTE_OVERFLOW);
        for (var i = 0; i < elem.length; i++) {
            sf.base.removeClass([elem[i]], [CLS_RTE_OVERFLOW]);
        }
        this.removeEventListener();
    };
    return FullScreen;
}());

var keyCode = {
    'backspace': 8,
    'tab': 9,
    'enter': 13,
    'shift': 16,
    'control': 17,
    'alt': 18,
    'pause': 19,
    'capslock': 20,
    'space': 32,
    'escape': 27,
    'pageup': 33,
    'pagedown': 34,
    'end': 35,
    'home': 36,
    'leftarrow': 37,
    'uparrow': 38,
    'rightarrow': 39,
    'downarrow': 40,
    'insert': 45,
    'delete': 46,
    'f1': 112,
    'f2': 113,
    'f3': 114,
    'f4': 115,
    'f5': 116,
    'f6': 117,
    'f7': 118,
    'f8': 119,
    'f9': 120,
    'f10': 121,
    'f11': 122,
    'f12': 123,
    'semicolon': 186,
    'plus': 187,
    'comma': 188,
    'minus': 189,
    'dot': 190,
    'forwardslash': 191,
    'graveaccent': 192,
    'openbracket': 219,
    'backslash': 220,
    'closebracket': 221,
    'singlequote': 222,
    ']': 221,
    '[': 219,
    '=': 187
};
/**
 * Keyboard
 */
var KeyboardEvents$1 = /** @class */ (function () {
    function KeyboardEvents$$1(element, options) {
        var _this = this;
        this.keyPressHandler = function (e) {
            var isAltKey = e.altKey;
            var isCtrlKey = e.ctrlKey;
            var isShiftKey = e.shiftKey;
            var isMetaKey = e.metaKey;
            var curkeyCode = e.which;
            var keys = Object.keys(_this.keyConfigs);
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                var configCollection = _this.keyConfigs[key].split(',');
                for (var _a = 0, configCollection_1 = configCollection; _a < configCollection_1.length; _a++) {
                    var rconfig = configCollection_1[_a];
                    var rKeyObj = KeyboardEvents$$1.getKeyConfigData(rconfig.trim());
                    if (isAltKey === rKeyObj.altKey && (isCtrlKey === rKeyObj.ctrlKey || isMetaKey) &&
                        isShiftKey === rKeyObj.shiftKey && curkeyCode === rKeyObj.keyCode) {
                        e.action = key;
                    }
                }
            }
            if (_this.keyAction) {
                _this.keyAction(e);
            }
        };
        this.element = element;
        sf.base.extend(this, this, options);
        this.onKeyPressHandler = this.keyPressHandler.bind(this);
        this.bind();
    }
    KeyboardEvents$$1.prototype.destroy = function () {
        this.unWireEvents();
    };
    KeyboardEvents$$1.prototype.bind = function () {
        this.wireEvents();
    };
    KeyboardEvents$$1.prototype.wireEvents = function () {
        this.element.addEventListener(this.eventName, this.onKeyPressHandler);
    };
    KeyboardEvents$$1.prototype.unWireEvents = function () {
        this.element.removeEventListener(this.eventName, this.onKeyPressHandler);
    };
    KeyboardEvents$$1.getKeyConfigData = function (config) {
        if (config in this.configCache) {
            return this.configCache[config];
        }
        var keys = config.toLowerCase().split('+');
        var keyData = {
            altKey: (keys.indexOf('alt') !== -1 ? true : false),
            ctrlKey: (keys.indexOf('ctrl') !== -1 ? true : false),
            shiftKey: (keys.indexOf('shift') !== -1 ? true : false),
            keyCode: null
        };
        if (keys[keys.length - 1].length > 1 && !!Number(keys[keys.length - 1])) {
            keyData.keyCode = Number(keys[keys.length - 1]);
        }
        else {
            keyData.keyCode = KeyboardEvents$$1.getKeyCode(keys[keys.length - 1]);
        }
        KeyboardEvents$$1.configCache[config] = keyData;
        return keyData;
    };
    KeyboardEvents$$1.getKeyCode = function (keyVal) {
        return keyCode[keyVal] || keyVal.toUpperCase().charCodeAt(0);
    };
    KeyboardEvents$$1.configCache = {};
    return KeyboardEvents$$1;
}());

/**
 * Content module is used to render Rich Text Editor content
 */
var ViewSource = /** @class */ (function () {
    function ViewSource(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    ViewSource.prototype.addEventListener = function () {
        this.parent.observer.on(sourceCode$1, this.sourceCode, this);
        this.parent.observer.on(initialEnd$1, this.onInitialEnd, this);
        this.parent.observer.on(updateSource$1, this.updateSourceCode, this);
        this.parent.observer.on(destroy$1, this.destroy, this);
    };
    ViewSource.prototype.onInitialEnd = function () {
        this.parent.formatter.editorManager.observer.on('keydown-handler', this.onKeyDown, this);
    };
    ViewSource.prototype.removeEventListener = function () {
        this.unWireEvent();
        this.parent.observer.off(sourceCode$1, this.sourceCode);
        this.parent.observer.off(updateSource$1, this.updateSourceCode);
        this.parent.observer.off(initialEnd$1, this.onInitialEnd);
        this.parent.observer.off(destroy$1, this.destroy);
        this.parent.formatter.editorManager.observer.off('keydown-handler', this.onKeyDown);
    };
    ViewSource.prototype.getSourceCode = function () {
        return sf.base.createElement('textarea', { className: 'e-rte-srctextarea' });
    };
    ViewSource.prototype.wireEvent = function (element) {
        this.keyboardModule = new KeyboardEvents$1(element, {
            keyAction: this.previewKeyDown.bind(this), keyConfigs: this.parent.formatter.keyConfig, eventName: 'keydown'
        });
        sf.base.EventHandler.add(this.previewElement, 'mousedown', this.mouseDownHandler, this);
    };
    ViewSource.prototype.unWireEvent = function () {
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
        if (this.previewElement) {
            sf.base.EventHandler.remove(this.previewElement, 'mousedown', this.mouseDownHandler);
        }
    };
    ViewSource.prototype.wireBaseKeyDown = function () {
        this.keyboardModule = new KeyboardEvents$1(this.parent.getEditPanel(), {
            keyAction: this.parent.keyDown.bind(this.parent), keyConfigs: this.parent.formatter.keyConfig, eventName: 'keydown'
        });
    };
    ViewSource.prototype.unWireBaseKeyDown = function () {
        this.parent.keyboardModule.destroy();
    };
    ViewSource.prototype.mouseDownHandler = function (e) {
        this.parent.observer.notify(sourceCodeMouseDown$1, { args: e });
    };
    ViewSource.prototype.previewKeyDown = function (event) {
        switch (event.action) {
            case 'html-source':
                this.parent.dotNetRef.invokeMethodAsync('PreviewCodeClient');
                this.updateSourceCode(event);
                event.preventDefault();
                break;
            case 'toolbar-focus':
                if (this.parent.toolbarSettings.enable) {
                    var selector = '.e-toolbar-item[aria-disabled="false"][title] [tabindex]';
                    this.parent.getToolbar().querySelector(selector).focus();
                }
                break;
        }
    };
    ViewSource.prototype.onKeyDown = function (e) {
        switch (e.event.action) {
            case 'html-source':
                e.event.preventDefault();
                this.parent.dotNetRef.invokeMethodAsync('ViewSourceClient');
                this.sourceCode(e);
                e.callBack({
                    requestType: 'SourceCode',
                    editorMode: 'HTML',
                    event: e.event
                });
                break;
        }
    };
    ViewSource.prototype.sourceCode = function (args) {
        var _this = this;
        this.parent.isBlur = false;
        // @ts-ignore-start
        this.parent.dotNetRef.invokeMethodAsync('ActionBeginEvent', { requestType: 'SourceCode', cancel: false }).then(function (sourceArgs) {
            // @ts-ignore-end
            if (!sourceArgs.cancel) {
                var tbItems = sf.base.selectAll('.' + CLS_TB_ITEM$1, _this.parent.element);
                if (sf.base.isNullOrUndefined(_this.previewElement)) {
                    _this.previewElement = _this.getSourceCode();
                }
                _this.parent.updateValueData();
                if (_this.parent.iframeSettings.enable) {
                    var rteContent = void 0;
                    if (sf.base.isNullOrUndefined(_this.parent.element.querySelector('#' + _this.parent.element.id + '_source-view'))) {
                        rteContent = sf.base.createElement('div', {
                            className: 'e-source-content', id: _this.parent.element.id + '_source-view'
                        });
                    }
                    else {
                        rteContent = _this.parent.element.querySelector('#' + _this.parent.element.id + '_source-view');
                    }
                    rteContent.appendChild(_this.previewElement);
                    _this.parent.element.appendChild(rteContent);
                    rteContent.style.height = _this.parent.getPanel().style.height;
                    rteContent.style.marginTop = _this.parent.getPanel().style.marginTop;
                    _this.getPanel().value = _this.getTextAreaValue(_this.parent.getEditPanel());
                    _this.parent.getPanel().style.display = 'none';
                    rteContent.style.display = 'block';
                    _this.getPanel().style.display = 'block';
                }
                else {
                    _this.parent.inputElement.parentElement.appendChild(_this.previewElement);
                    _this.getPanel().value = _this.getTextAreaValue(_this.parent.getEditPanel());
                    _this.parent.inputElement.style.display = 'none';
                    _this.previewElement.style.display = 'block';
                }
                _this.parent.isBlur = false;
                if (_this.parent.getToolbar()) {
                    sf.base.removeClass([_this.parent.getToolbar()], [CLS_EXPAND_OPEN$1]);
                }
                sf.base.removeClass(tbItems, [CLS_ACTIVE$1]);
                _this.parent.setContentHeight('sourceCode', true);
                _this.wireEvent(_this.previewElement);
                _this.unWireBaseKeyDown();
                _this.previewElement.focus();
                _this.parent.updateValue();
                if (!sf.base.isNullOrUndefined(_this.parent.placeholder) && !_this.parent.iframeSettings.enable) {
                    var placeHolderContainer = _this.parent.element.querySelector('.rte-placeholder');
                    placeHolderContainer.style.display = 'none';
                }
                _this.parent.dotNetRef.invokeMethodAsync(
                // @ts-ignore-start
                'ActionCompleteEvent', { requestType: 'SourceCode' }).then(function (completeArgs) {
                    // @ts-ignore-end
                    _this.parent.invokeChangeEvent();
                });
            }
        });
    };
    ViewSource.prototype.updateSourceCode = function (args) {
        var _this = this;
        this.parent.isBlur = false;
        // @ts-ignore-start
        this.parent.dotNetRef.invokeMethodAsync('ActionBeginEvent', { requestType: 'Preview', cancel: false }).then(function (previewArgs) {
            // @ts-ignore-end
            if (!previewArgs.cancel) {
                var editHTML = _this.getPanel();
                var serializeValue = _this.parent.serializeValue(editHTML.value);
                var value = (serializeValue === null || serializeValue === '') ? '<p><br/></p>' : serializeValue;
                if (_this.parent.iframeSettings.enable) {
                    editHTML.parentElement.style.display = 'none';
                    editHTML.style.display = 'none';
                    _this.parent.contentPanel.style.display = 'block';
                    _this.parent.getEditPanel().innerHTML = _this.parent.enableHtmlEncode ? decode(value) : value;
                }
                else {
                    editHTML.style.display = 'none';
                    _this.parent.getEditPanel().style.display = 'block';
                    _this.parent.getEditPanel().innerHTML = _this.parent.enableHtmlEncode ? decode(value) : value;
                }
                _this.parent.isBlur = false;
                if (_this.parent.getToolbar()) {
                    sf.base.removeClass([_this.parent.getToolbar()], [CLS_EXPAND_OPEN$1]);
                }
                _this.parent.setContentHeight('preview', true);
                _this.unWireEvent();
                _this.wireBaseKeyDown();
                _this.parent.getEditPanel().focus();
                _this.parent.updateValue();
                if (!sf.base.isNullOrUndefined(_this.parent.placeholder) && _this.parent.getEditPanel().innerText.length === 0) {
                    var placeHolderContainer = _this.parent.element.querySelector('.rte-placeholder');
                    placeHolderContainer.style.display = 'block';
                }
                _this.parent.dotNetRef.invokeMethodAsync(
                // @ts-ignore-start
                'ActionCompleteEvent', { requestType: 'Preview' }).then(function (previewArgs) {
                    // @ts-ignore-end
                    _this.parent.invokeChangeEvent();
                });
            }
        });
    };
    ViewSource.prototype.getTextAreaValue = function (element) {
        var currentValue;
        currentValue = this.parent.enableXhtml ? this.parent.getXhtmlString(this.parent.value) : this.parent.value;
        return (element.innerHTML === '<p><br></p>') ||
            (element.childNodes.length === 1 &&
                element.childNodes[0].tagName === 'P' &&
                element.innerHTML.length === 7) ? '' : currentValue;
    };
    ViewSource.prototype.getPanel = function () {
        return this.parent.element.querySelector('.e-rte-srctextarea');
    };
    ViewSource.prototype.getViewPanel = function () {
        return (this.parent.iframeSettings.enable && this.getPanel()) ? this.getPanel().parentElement : this.getPanel();
    };
    ViewSource.prototype.destroy = function () {
        this.removeEventListener();
    };
    return ViewSource;
}());

/**
 * `Popup renderer` module is used to render popup in RichTextEditor.
 */
var PopupRenderer = /** @class */ (function () {
    function PopupRenderer(parent) {
        this.parent = parent;
    }
    PopupRenderer.prototype.quickToolbarOpen = function () {
        this.parent.dotNetRef.invokeMethodAsync('QuickToolbarOpenEvent', this.popupObj.element.classList.toString(), this.targetType);
    };
    PopupRenderer.prototype.renderPopup = function (args, type) {
        this.targetType = type;
        args.popupObj = new sf.popups.Popup(args.element, {
            targetType: 'relative',
            relateTo: this.parent.element,
            open: this.quickToolbarOpen.bind(this)
        });
        this.popupObj = args.popupObj;
        args.popupObj.hide();
    };
    return PopupRenderer;
}());

/**
 * `Quick toolbar` module is used to handle Quick toolbar actions.
 */
var BaseQuickToolbar = /** @class */ (function () {
    function BaseQuickToolbar(parent) {
        this.parent = parent;
        this.isDOMElement = false;
        this.popupRenderer = new PopupRenderer(parent);
    }
    BaseQuickToolbar.prototype.render = function (element, type) {
        this.element = element;
        this.popupRenderer.renderPopup(this, type);
        this.addEventListener();
    };
    BaseQuickToolbar.prototype.setPosition = function (e) {
        var x;
        var y;
        var imgContainer = sf.base.closest(e.target, '.' + CLS_CAPTION);
        var target = !sf.base.isNullOrUndefined(imgContainer) ? imgContainer : e.target;
        var targetOffsetTop = target.offsetTop;
        var parentOffsetTop = window.pageYOffset + e.parentData.top;
        if ((targetOffsetTop - e.editTop) > e.popHeight) {
            y = parentOffsetTop + e.tBarElementHeight + (targetOffsetTop - e.editTop) - e.popHeight - 5;
        }
        else if (((e.editTop + e.editHeight) - (targetOffsetTop + target.offsetHeight)) > e.popHeight) {
            y = parentOffsetTop + e.tBarElementHeight + (targetOffsetTop - e.editTop) + target.offsetHeight + 5;
        }
        else {
            y = e.y;
        }
        if (target.offsetWidth > e.popWidth) {
            x = (target.offsetWidth / 2) - (e.popWidth / 2) + e.parentData.left + target.offsetLeft;
        }
        else {
            x = e.parentData.left + target.offsetLeft;
        }
        this.popupObj.position.X = ((x + e.popWidth) > e.parentData.right) ? e.parentData.right - e.popWidth : x;
        this.popupObj.position.Y = (y >= 0) ? y : e.y + 5;
        this.popupObj.dataBind();
    };
    BaseQuickToolbar.prototype.checkCollision = function (e, viewPort, type) {
        var x;
        var y;
        var parentTop = e.parentData.top;
        var contentTop = e.windowY + parentTop + e.tBarElementHeight;
        var collision = [];
        if (viewPort === 'document') {
            collision = sf.popups.isCollide(e.popup);
        }
        else {
            collision = sf.popups.isCollide(e.popup, e.parentElement);
        }
        for (var i = 0; i < collision.length; i++) {
            switch (collision[i]) {
                case 'top':
                    if (viewPort === 'document') {
                        y = e.windowY;
                    }
                    else {
                        y = (window.pageYOffset + parentTop) + e.tBarElementHeight;
                    }
                    break;
                case 'bottom':
                    var posY = void 0;
                    if (viewPort === 'document') {
                        if (type === 'inline') {
                            posY = (e.y - e.popHeight - 10);
                        }
                        else {
                            if ((e.windowHeight - (parentTop + e.tBarElementHeight)) > e.popHeight) {
                                if ((contentTop - e.windowHeight) > e.popHeight) {
                                    posY = (contentTop + (e.windowHeight - parentTop)) - e.popHeight;
                                }
                                else {
                                    posY = contentTop;
                                }
                            }
                            else {
                                posY = e.windowY + (parentTop + e.tBarElementHeight);
                            }
                        }
                    }
                    else {
                        if (e.target.tagName !== 'IMG') {
                            posY = (e.parentData.bottom + window.pageYOffset) - e.popHeight - 10;
                        }
                        else {
                            posY = (e.parentData.bottom + window.pageYOffset) - e.popHeight - 5;
                        }
                    }
                    y = posY;
                    break;
                case 'right':
                    if (type === 'inline') {
                        x = window.pageXOffset + (e.windowWidth - (e.popWidth + e.bodyRightSpace + 10));
                    }
                    else {
                        x = e.x - e.popWidth;
                    }
                    break;
                case 'left':
                    if (type === 'inline') {
                        x = 0;
                    }
                    else {
                        x = e.parentData.left;
                    }
                    break;
            }
        }
        this.popupObj.position.X = (x) ? x : this.popupObj.position.X;
        this.popupObj.position.Y = (y) ? y : this.popupObj.position.Y;
        this.popupObj.dataBind();
    };
    BaseQuickToolbar.prototype.showPopup = function (x, y, target, type) {
        var _this = this;
        if (this.parent.onQuickTbOpenEnabled) {
            // @ts-ignore-start
            this.parent.dotNetRef.invokeMethodAsync(beforeQuickToolbarOpenEvent).then(function (args) {
                // @ts-ignore-end
                if (!args.cancel) {
                    _this.onQuickTbOpenCallback(x, y, target, type);
                }
            });
        }
        else {
            this.onQuickTbOpenCallback(x, y, target, type);
        }
    };
    BaseQuickToolbar.prototype.onQuickTbOpenCallback = function (x, y, target, type) {
        var editPanelTop;
        var editPanelHeight;
        var bodyStyle = window.getComputedStyle(document.body);
        var bodyRight = parseFloat(bodyStyle.marginRight.split('px')[0]) + parseFloat(bodyStyle.paddingRight.split('px')[0]);
        var windowHeight = window.innerHeight;
        var windowWidth = window.innerWidth;
        var parent = this.parent.element;
        var toolbarAvail = !sf.base.isNullOrUndefined(this.parent.getToolbar());
        var tbHeight = toolbarAvail && this.parent.toolbarModule.getToolbarHeight();
        var expTBHeight = toolbarAvail && this.parent.toolbarModule.getExpandTBarPopHeight();
        var tBarHeight = (toolbarAvail) ? (tbHeight + expTBHeight) : 0;
        sf.base.addClass([this.element], [CLS_HIDE]);
        if (sf.base.Browser.isDevice && !isIDevice()) {
            sf.base.addClass([this.parent.getToolbar()], [CLS_HIDE]);
        }
        if (this.parent.iframeSettings.enable) {
            var cntEle = this.parent.getPanel().contentWindow;
            editPanelTop = cntEle.pageYOffset;
            editPanelHeight = cntEle.innerHeight;
        }
        else {
            var cntEle = sf.base.closest(target, '.' + CLS_RTE_CONTENT);
            editPanelTop = (cntEle) ? cntEle.scrollTop : 0;
            editPanelHeight = (cntEle) ? cntEle.offsetHeight : 0;
        }
        if (!this.parent.inlineMode.enable && !sf.base.closest(target, 'table')) {
            // this.parent.disableToolbarItem(this.parent.toolbarSettings.items as string[]);
            // this.parent.enableToolbarItem(['Undo', 'Redo']);
        }
        sf.base.append([this.element], document.body);
        this.popupObj.position.X = x + 20;
        this.popupObj.position.Y = y + 20;
        this.popupObj.dataBind();
        this.popupObj.element.classList.add(CLS_POPUP_OPEN);
        var showPopupData = {
            x: x, y: y,
            target: target,
            editTop: editPanelTop,
            editHeight: editPanelHeight,
            popup: this.popupObj.element,
            popHeight: this.popupObj.element.offsetHeight,
            popWidth: this.popupObj.element.offsetWidth,
            parentElement: parent,
            bodyRightSpace: bodyRight,
            windowY: window.pageYOffset,
            windowHeight: windowHeight,
            windowWidth: windowWidth,
            parentData: parent.getBoundingClientRect(),
            tBarElementHeight: tBarHeight
        };
        if (target.tagName === 'IMG') {
            this.setPosition(showPopupData);
        }
        if (!this.parent.inlineMode.enable) {
            this.checkCollision(showPopupData, 'parent', '');
        }
        this.checkCollision(showPopupData, 'document', ((this.parent.inlineMode.enable) ? 'inline' : ''));
        this.popupObj.element.classList.remove(CLS_POPUP_CLOSE);
        sf.base.removeClass([this.element], [CLS_HIDE]);
        this.popupObj.show({ name: 'ZoomIn', duration: 250 });
        sf.base.setStyleAttribute(this.element, {
            maxWidth: window.outerWidth + 'px'
        });
        sf.base.addClass([this.element], [CLS_POP]);
        this.isDOMElement = true;
        this.parent.dotNetRef.invokeMethodAsync(updateClass, this.popupObj.element.classList.toString(), type);
    };
    BaseQuickToolbar.prototype.hidePopup = function () {
        var viewSourcePanel = this.parent.viewSourceModule.getViewPanel();
        if (sf.base.Browser.isDevice && !isIDevice()) {
            sf.base.removeClass([this.parent.getToolbar()], [CLS_HIDE]);
        }
        if (!sf.base.isNullOrUndefined(this.parent.getToolbar()) && !this.parent.inlineMode.enable) {
            if (sf.base.isNullOrUndefined(viewSourcePanel) || viewSourcePanel.style.display === 'none') {
                //this.parent.enableToolbarItem(this.parent.toolbarSettings.items as string[]);
            }
        }
        this.removeEleFromDOM();
        this.isDOMElement = false;
    };
    BaseQuickToolbar.prototype.removeEleFromDOM = function () {
        this.popupObj.hide();
        this.element.classList.add(CLS_HIDE);
        this.element.classList.add(CLS_RTE_QUICK_POPUP_HIDE);
        if (this.isDOMElement) {
            sf.base.removeClass([this.element], [CLS_POP]);
            this.popupObj.element.removeAttribute('style');
            this.popupObj.destroy();
            if (this.parent.quickTbClosedEnabled) {
                this.parent.dotNetRef.invokeMethodAsync(quickToolbarCloseEvent);
            }
        }
    };
    BaseQuickToolbar.prototype.updateStatus = function (args) {
        var tbElements = sf.base.selectAll('.' + CLS_TB_ITEM, this.element);
        if (tbElements.length <= 0) {
            return;
        }
        var options = {
            args: args,
            dropDownModule: null,
            parent: this.parent,
            tbElements: tbElements,
            /* eslint-disable */
            tbItems: this.parent.toolbarSettings.items
            /* eslint-enable */
        };
        setToolbarStatus(options, true);
        // if (!select('.e-rte-srctextarea', this.parent.element)) {
        //     //updateUndoRedoStatus(this.parent.getBaseToolbarObject(),
        //           this.parent.formatter.editorManager.undoRedoManager.getUndoStatus());
        // }
    };
    BaseQuickToolbar.prototype.addEventListener = function () {
        this.parent.observer.on(destroy, this.destroy, this);
        if (this.parent.inlineMode.enable) {
            this.parent.observer.on(toolbarUpdated, this.updateStatus, this);
        }
    };
    BaseQuickToolbar.prototype.removeEventListener = function () {
        this.parent.observer.off(destroy, this.destroy);
        if (this.parent.inlineMode.enable) {
            this.parent.observer.off(toolbarUpdated, this.updateStatus);
        }
    };
    BaseQuickToolbar.prototype.destroy = function () {
        if (this.popupObj && !this.popupObj.isDestroyed) {
            this.popupObj.destroy();
            this.removeEleFromDOM();
        }
        this.removeEventListener();
    };
    return BaseQuickToolbar;
}());

/**
 * `Quick toolbar` module is used to handle Quick toolbar actions.
 */
var QuickToolbar = /** @class */ (function () {
    function QuickToolbar(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    QuickToolbar.prototype.showImageQTBar = function (x, y, target, type) {
        if (this.parent.readonly || !this.parent.quickToolbarSettings.enable) {
            return;
        }
        var popupTarget = document.querySelector('#' + this.parent.element.id + imageQuickPopup);
        this.imageQTBar = new BaseQuickToolbar(this.parent);
        this.imageQTBar.render(popupTarget, type);
        this.parent.dotNetRef.invokeMethodAsync(showImagePopup, this.imageQTBar.popupObj.element.classList.toString(), type);
        this.imageQTBar.showPopup(x, y, target, type);
    };
    QuickToolbar.prototype.hideImageQTBar = function () {
        if (this.imageQTBar) {
            this.imageQTBar.hidePopup();
            this.imageQTBar = undefined;
            this.parent.dotNetRef.invokeMethodAsync(hideImagePopup);
        }
    };
    QuickToolbar.prototype.showLinkQTBar = function (x, y, target, type) {
        if (this.parent.readonly || !this.parent.quickToolbarSettings.enable) {
            return;
        }
        var popupTarget = document.querySelector('#' + this.parent.element.id + linkQuickPopup);
        this.linkQTBar = new BaseQuickToolbar(this.parent);
        this.linkQTBar.render(popupTarget, type);
        this.parent.dotNetRef.invokeMethodAsync(showLinkPopup, this.linkQTBar.popupObj.element.classList.toString());
        this.linkQTBar.showPopup(x, y, target, type);
    };
    QuickToolbar.prototype.hideLinkQTBar = function () {
        if (this.linkQTBar) {
            this.linkQTBar.hidePopup();
            this.linkQTBar = undefined;
            this.parent.dotNetRef.invokeMethodAsync(hideLinkPopup);
        }
    };
    QuickToolbar.prototype.showTableQTBar = function (x, y, target, type) {
        if (this.parent.readonly || !this.parent.quickToolbarSettings.enable) {
            return;
        }
        var popupTarget = document.querySelector('#' + this.parent.element.id + tableQuickPopup);
        this.tableQTBar = new BaseQuickToolbar(this.parent);
        this.tableQTBar.render(popupTarget, type);
        this.parent.dotNetRef.invokeMethodAsync(showTablePopup, this.tableQTBar.popupObj.element.classList.toString());
        this.tableQTBar.showPopup(x, y, target, type);
    };
    QuickToolbar.prototype.hideTableQTBar = function () {
        if (this.tableQTBar) {
            this.tableQTBar.hidePopup();
            this.tableQTBar = undefined;
            this.parent.dotNetRef.invokeMethodAsync(hideTablePopup);
        }
    };
    QuickToolbar.prototype.showInlineQTBar = function (x, y, target) {
        var _this = this;
        if (this.parent.readonly || !this.parent.inlineMode.enable) {
            return;
        }
        if (this.parent.inlineMode.enable && (!sf.base.Browser.isDevice || isIDevice())) {
            var popupTarget = document.querySelector('#' + this.parent.element.id + inlineQuickPopup);
            this.inlineQTBar = new BaseQuickToolbar(this.parent);
            this.inlineQTBar.render(popupTarget, 'Inline');
            sf.base.EventHandler.add(this.inlineQTBar.element, 'mousedown', this.onMouseDown, this);
            var classes = this.inlineQTBar.popupObj.element.classList.toString();
            // @ts-ignore-start
            this.parent.dotNetRef.invokeMethodAsync(showInlinePopup, classes).then(function () {
                // @ts-ignore-end
                _this.inlineQTBar.showPopup(x, y, target, 'Inline');
            });
        }
    };
    QuickToolbar.prototype.hideInlineQTBar = function () {
        if (this.inlineQTBar) {
            this.inlineQTBar.hidePopup();
            this.inlineQTBar = undefined;
            this.parent.dotNetRef.invokeMethodAsync(hideInlinePopup);
        }
    };
    QuickToolbar.prototype.hideQuickToolbars = function () {
        if (!sf.base.isNullOrUndefined(this.linkQTBar)) {
            this.hideLinkQTBar();
        }
        if (!sf.base.isNullOrUndefined(this.imageQTBar)) {
            this.hideImageQTBar();
        }
        if (!sf.base.isNullOrUndefined(this.tableQTBar)) {
            this.hideTableQTBar();
        }
        if (this.parent.inlineMode.enable && (!sf.base.Browser.isDevice || isIDevice())) {
            this.hideInlineQTBar();
        }
    };
    QuickToolbar.prototype.scrollHandler = function () {
        if (this.parent.quickToolbarSettings.actionOnScroll.toLocaleLowerCase() === 'hide') {
            this.hideQuickToolbars();
        }
    };
    QuickToolbar.prototype.selectionChangeHandler = function (e) {
        var _this = this;
        if (!this.parent.inlineMode.onSelection) {
            return;
        }
        clearTimeout(this.deBouncer);
        this.deBouncer = window.setTimeout(function () { _this.onSelectionChange(e); }, 1000);
    };
    QuickToolbar.prototype.onSelectionChange = function (e) {
        if (!sf.base.isNullOrUndefined(sf.base.select('.' + CLS_INLINE_POP + '.' + CLS_POPUP, document.body))) {
            return;
        }
        var selection = this.parent.getDocument().getSelection();
        if (!selection.isCollapsed) {
            this.mouseUpHandler({ args: e });
        }
    };
    QuickToolbar.prototype.toolbarUpdated = function (args) {
        if (!sf.base.isNullOrUndefined(this.linkQTBar)) {
            this.hideLinkQTBar();
        }
        if (!sf.base.isNullOrUndefined(this.imageQTBar)) {
            this.hideImageQTBar();
        }
        if (!sf.base.isNullOrUndefined(this.tableQTBar)) {
            this.hideTableQTBar();
        }
    };
    QuickToolbar.prototype.deBounce = function (x, y, target) {
        var _this = this;
        clearTimeout(this.deBouncer);
        this.deBouncer = window.setTimeout(function () { _this.showInlineQTBar(x, y, target); }, 1000);
    };
    QuickToolbar.prototype.onMouseDown = function (e) {
        this.parent.isBlur = false;
        this.parent.isRTE = true;
    };
    QuickToolbar.prototype.mouseUpHandler = function (e) {
        if (this.parent.inlineMode.enable && (!sf.base.Browser.isDevice || isIDevice())) {
            var args = e.args.touches ? e.args.changedTouches[0]
                : e.args;
            var range = this.parent.getRange();
            var target = e.args.target;
            var inlinePopEle = sf.base.select('.' + CLS_INLINE_POP, document.body);
            if (sf.base.isNullOrUndefined(inlinePopEle) || inlinePopEle.classList.contains(CLS_HIDE)) {
                if (isIDevice() && e.touchData && e.touchData.prevClientX !== e.touchData.clientX
                    && e.touchData.prevClientY !== e.touchData.clientY) {
                    return;
                }
                this.hideInlineQTBar();
                var parentLeft = this.parent.element.getBoundingClientRect().left;
                this.offsetX = this.parent.iframeSettings.enable ? window.pageXOffset + parentLeft + args.clientX : args.pageX;
                this.offsetY = pageYOffset(args, this.parent.element, this.parent.iframeSettings.enable);
                if (target.nodeName === 'TEXTAREA') {
                    this.showInlineQTBar(this.offsetX, this.offsetY, target);
                }
                else {
                    var closestAnchor = sf.base.closest(target, 'a');
                    target = closestAnchor ? closestAnchor : target;
                    if (target.tagName !== 'IMG' && target.tagName !== 'A' && (!sf.base.closest(target, 'td,th') || !range.collapsed)) {
                        if (this.parent.inlineMode.onSelection && range.collapsed) {
                            return;
                        }
                        this.target = target;
                        this.showInlineQTBar(this.offsetX, this.offsetY, target);
                    }
                }
            }
        }
    };
    QuickToolbar.prototype.keyDownHandler = function () {
        if ((this.parent.inlineMode.enable && (!sf.base.Browser.isDevice || isIDevice()))
            && !sf.base.isNullOrUndefined(sf.base.select('.' + CLS_INLINE_POP + '.' + CLS_POPUP, document))) {
            this.hideInlineQTBar();
        }
    };
    QuickToolbar.prototype.inlineQTBarMouseDownHandler = function () {
        if ((this.parent.inlineMode.enable && (!sf.base.Browser.isDevice || isIDevice()))
            && !sf.base.isNullOrUndefined(sf.base.select('.' + CLS_INLINE_POP + '.' + CLS_POPUP, document))) {
            this.hideInlineQTBar();
        }
    };
    QuickToolbar.prototype.keyUpHandler = function (e) {
        if (this.parent.inlineMode.enable && !sf.base.Browser.isDevice) {
            if (this.parent.inlineMode.onSelection) {
                return;
            }
            var args = e.args;
            this.deBounce(this.offsetX, this.offsetY, args.target);
        }
    };
    QuickToolbar.prototype.onKeyDown = function (e) {
        var args = e.args;
        if (args.which === 8 || args.which === 46) {
            if (this.imageQTBar && !hasClass(this.imageQTBar.element, CLS_POPUP_CLOSE)) {
                this.imageQTBar.hidePopup();
            }
        }
    };
    QuickToolbar.prototype.onIframeMouseDown = function () {
        this.hideQuickToolbars();
        this.hideInlineQTBar();
    };
    QuickToolbar.prototype.addEventListener = function () {
        if (this.parent.inlineMode.enable && this.parent.inlineMode.onSelection && isIDevice()) {
            sf.base.EventHandler.add(this.parent.getDocument(), 'selectionchange', this.selectionChangeHandler, this);
        }
        this.parent.observer.on(toolbarUpdated, this.toolbarUpdated, this);
        this.wireInlineQTBarEvents();
        this.parent.observer.on(scroll, this.scrollHandler, this);
        this.parent.observer.on(contentscroll, this.scrollHandler, this);
        this.parent.observer.on(focusChange, this.hideQuickToolbars, this);
        this.parent.observer.on(iframeMouseDown, this.onIframeMouseDown, this);
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(keyDown, this.onKeyDown, this);
    };
    QuickToolbar.prototype.removeEventListener = function () {
        sf.base.EventHandler.remove(this.parent.getDocument(), 'selectionchange', this.selectionChangeHandler);
        this.parent.observer.off(toolbarUpdated, this.toolbarUpdated);
        this.unWireInlineQTBarEvents();
        this.parent.observer.off(scroll, this.scrollHandler);
        this.parent.observer.off(contentscroll, this.scrollHandler);
        this.parent.observer.off(focusChange, this.hideQuickToolbars);
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(iframeMouseDown, this.onIframeMouseDown);
        this.parent.observer.off(keyDown, this.onKeyDown);
    };
    QuickToolbar.prototype.wireInlineQTBarEvents = function () {
        this.parent.observer.on(mouseUp, this.mouseUpHandler, this);
        this.parent.observer.on(mouseDown, this.inlineQTBarMouseDownHandler, this);
        this.parent.observer.on(keyDown, this.keyDownHandler, this);
        this.parent.observer.on(keyUp, this.keyUpHandler, this);
        this.parent.observer.on(sourceCodeMouseDown, this.mouseUpHandler, this);
    };
    QuickToolbar.prototype.unWireInlineQTBarEvents = function () {
        this.parent.observer.off(mouseUp, this.mouseUpHandler);
        this.parent.observer.off(mouseDown, this.inlineQTBarMouseDownHandler);
        this.parent.observer.off(keyDown, this.keyDownHandler);
        this.parent.observer.off(keyUp, this.keyUpHandler);
        this.parent.observer.off(sourceCodeMouseDown, this.mouseUpHandler);
    };
    QuickToolbar.prototype.destroy = function () {
        if (this.linkQTBar) {
            sf.base.EventHandler.remove(this.linkQTBar.element, 'mousedown', this.onMouseDown);
            this.linkQTBar.destroy();
        }
        if (this.imageQTBar) {
            sf.base.EventHandler.remove(this.imageQTBar.element, 'mousedown', this.onMouseDown);
            this.imageQTBar.destroy();
        }
        if (this.tableQTBar) {
            sf.base.EventHandler.remove(this.tableQTBar.element, 'mousedown', this.onMouseDown);
            this.tableQTBar.destroy();
        }
        if (this.inlineQTBar) {
            sf.base.EventHandler.remove(this.inlineQTBar.element, 'mousedown', this.onMouseDown);
            if (isIDevice()) {
                sf.base.EventHandler.remove(document, 'selectionchange', this.selectionChangeHandler);
            }
            this.inlineQTBar.destroy();
        }
        this.removeEventListener();
    };
    return QuickToolbar;
}());

var RTL = 'e-rtl';
var STATUS = 'e-file-status';
var FILE_NAME = 'e-file-name';
var FILE_TYPE = 'e-file-type';
var FILE_SIZE = 'e-file-size';
var FILE = 'e-upload-file-list';
var FORM_UPLOAD = 'e-form-upload';
var LIST_PARENT = 'e-upload-files';
var SPINNER_PANE = 'e-spinner-pane';
var ABORT_ICON = 'e-file-abort-btn';
var INPUT_WRAPPER = 'e-file-select';
var INVALID_FILE = 'e-file-invalid';
var UPLOAD_FAILED = 'e-upload-fails';
var RETRY_ICON = 'e-file-reload-btn';
var RTL_CONTAINER = 'e-rtl-container';
var REMOVE_ICON = 'e-file-remove-btn';
var DELETE_ICON = 'e-file-delete-btn';
var INFORMATION = 'e-file-information';
var TEXT_CONTAINER = 'e-file-container';
var UPLOAD_SUCCESS = 'e-upload-success';
var RESTRICT_RETRY = 'e-restrict-retry';
var DROP_WRAPPER = 'e-file-select-wrap';
var HIDDEN_INPUT = 'e-hidden-file-input';
var PROGRESSBAR = 'e-upload-progress-bar';
var UPLOAD_INPROGRESS = 'e-upload-progress';
var VALIDATION_FAILS = 'e-validation-fails';
var PROGRESSBAR_TEXT = 'e-progress-bar-text';
var PROGRESS_WRAPPER = 'e-upload-progress-wrap';
var PROGRESS_INNER_WRAPPER = 'e-progress-inner-wrap';
var CONTROL_WRAPPER = 'e-upload e-lib e-control-wrapper';
/**
 * `Uploader` module is used to render uploader from RichTextEditor.
 */
var RteUploader = /** @class */ (function () {
    function RteUploader(options, element, parent) {
        this.fileList = [];
        this.filesData = [];
        this.files = [];
        this.minFileSize = 0;
        this.maxFileSize = 30000000;
        this.uploadedFilesData = [];
        this.base64String = [];
        this.isForm = false;
        this.allTypes = false;
        this.btnTabIndex = '0';
        this.disableKeyboardNavigation = false;
        this.actionCompleteCount = 0;
        this.flag = true;
        this.selectedFiles = [];
        this.uploaderName = 'UploadFiles';
        this.element = element;
        this.parent = parent;
        this.cssClass = options.cssClass;
        this.asyncSettings = options.asyncSettings;
        this.allowedExtensions = options.allowedExtensions;
        this.addEventListener();
        this.render();
    }
    RteUploader.prototype.addEventListener = function () {
        this.parent.observer.on(beforePasteUploadCallBack, this.beforePasteUploadCallBack, this);
    };
    RteUploader.prototype.removeEventListener = function () {
        this.parent.observer.off(beforePasteUploadCallBack, this.beforePasteUploadCallBack);
    };
    RteUploader.prototype.render = function () {
        this.browserName = sf.base.Browser.info.name;
        this.uploaderName = this.element.getAttribute('name');
        this.initializeUpload();
        this.wireEvents();
        this.setExtensions(this.allowedExtensions);
        this.setRTL();
        this.setCSSClass();
    };
    RteUploader.prototype.initializeUpload = function () {
        this.element.setAttribute('aria-label', 'Uploader');
        this.element.setAttribute('tabindex', '-1');
        var inputWrapper = sf.base.createElement('span', { className: INPUT_WRAPPER, attrs: { style: 'display: none;' } });
        this.element.parentElement.insertBefore(inputWrapper, this.element);
        this.dropAreaWrapper = sf.base.createElement('div', { className: DROP_WRAPPER });
        this.element.parentElement.insertBefore(this.dropAreaWrapper, this.element);
        inputWrapper.appendChild(this.element);
        this.dropAreaWrapper.appendChild(inputWrapper);
        this.uploadWrapper = sf.base.createElement('div', { className: CONTROL_WRAPPER, attrs: { style: 'background: white' } });
        this.dropAreaWrapper.parentElement.insertBefore(this.uploadWrapper, this.dropAreaWrapper);
        this.uploadWrapper.appendChild(this.dropAreaWrapper);
    };
    RteUploader.prototype.setExtensions = function (extensions) {
        if (extensions !== '' && !sf.base.isNullOrUndefined(extensions)) {
            this.element.setAttribute('accept', extensions);
        }
        else {
            this.element.removeAttribute('accept');
        }
    };
    RteUploader.prototype.setRTL = function () {
        this.enableRtl ? sf.base.addClass([this.uploadWrapper], RTL) : sf.base.removeClass([this.uploadWrapper], RTL);
    };
    RteUploader.prototype.setCSSClass = function (oldCSSClass) {
        var updatedCssClassValue = this.cssClass;
        if (!sf.base.isNullOrUndefined(this.cssClass) && this.cssClass !== '') {
            updatedCssClassValue = (this.cssClass.replace(/\s+/g, ' ')).trim();
        }
        if (!sf.base.isNullOrUndefined(this.cssClass) && updatedCssClassValue !== '') {
            sf.base.addClass([this.uploadWrapper], updatedCssClassValue.split(updatedCssClassValue.indexOf(',') > -1 ? ',' : ' '));
        }
        var updatedOldCssClass = oldCSSClass;
        if (!sf.base.isNullOrUndefined(oldCSSClass)) {
            updatedOldCssClass = (oldCSSClass.replace(/\s+/g, ' ')).trim();
        }
        if (!sf.base.isNullOrUndefined(oldCSSClass) && updatedOldCssClass !== '') {
            sf.base.removeClass([this.uploadWrapper], updatedOldCssClass.split(' '));
        }
    };
    RteUploader.prototype.createFileList = function (fileData, isSelectedFile) {
        this.createParentUL();
        if (this.isFormUpload()) {
            this.uploadWrapper.classList.add(FORM_UPLOAD);
            this.formFileList(fileData, this.element.files);
        }
        else {
            for (var _i = 0, fileData_1 = fileData; _i < fileData_1.length; _i++) {
                var listItem = fileData_1[_i];
                var liElement = sf.base.createElement('li', {
                    className: FILE,
                    attrs: { 'data-file-name': listItem.name, 'data-files-count': '1' }
                });
                var textContainer = sf.base.createElement('span', { className: TEXT_CONTAINER });
                var textElement = sf.base.createElement('span', { className: FILE_NAME, attrs: { 'title': listItem.name } });
                textElement.innerHTML = this.getFileNameOnly(listItem.name);
                var fileExtension = sf.base.createElement('span', { className: FILE_TYPE });
                fileExtension.innerHTML = '.' + this.getFileType(listItem.name);
                if (!this.enableRtl) {
                    textContainer.appendChild(textElement);
                    textContainer.appendChild(fileExtension);
                }
                else {
                    var rtlContainer = sf.base.createElement('span', { className: RTL_CONTAINER });
                    rtlContainer.appendChild(fileExtension);
                    rtlContainer.appendChild(textElement);
                    textContainer.appendChild(rtlContainer);
                }
                var fileSize = sf.base.createElement('span', { className: FILE_SIZE });
                fileSize.innerHTML = this.bytesToSize(listItem.size);
                textContainer.appendChild(fileSize);
                var statusElement = sf.base.createElement('span', { className: STATUS });
                textContainer.appendChild(statusElement);
                statusElement.innerHTML = listItem.status;
                liElement.appendChild(textContainer);
                var iconElement = sf.base.createElement('span', { className: ' e-icons', attrs: { 'tabindex': this.btnTabIndex } });
                /* istanbul ignore next */
                if (this.browserName === 'msie') {
                    iconElement.classList.add('e-msie');
                }
                iconElement.setAttribute('title', 'Remove');
                liElement.appendChild(iconElement);
                sf.base.EventHandler.add(iconElement, 'click', this.removeFiles, this);
                if (listItem.statusCode === '2') {
                    statusElement.classList.add(UPLOAD_SUCCESS);
                    iconElement.classList.add(DELETE_ICON);
                    iconElement.setAttribute('title', 'Delete file');
                }
                else if (listItem.statusCode !== '1') {
                    statusElement.classList.remove(UPLOAD_SUCCESS);
                    statusElement.classList.add(VALIDATION_FAILS);
                }
                if (listItem.statusCode === '1' && this.asyncSettings.saveUrl !== '') {
                    statusElement.innerHTML = '';
                }
                if (!iconElement.classList.contains(DELETE_ICON)) {
                    iconElement.classList.add(REMOVE_ICON);
                }
                this.listParent.appendChild(liElement);
                this.fileList.push(liElement);
                this.truncateName(textElement);
                var preventActionComplete = this.flag;
                if (this.isPreLoadFile(listItem)) {
                    this.flag = false;
                    this.checkActionComplete(true);
                    this.flag = preventActionComplete;
                }
            }
        }
    };
    RteUploader.prototype.createParentUL = function () {
        if (sf.base.isNullOrUndefined(this.listParent)) {
            this.listParent = sf.base.createElement('ul', { className: LIST_PARENT });
            this.uploadWrapper.appendChild(this.listParent);
        }
    };
    RteUploader.prototype.isFormUpload = function () {
        var isFormUpload = false;
        if (this.isForm && ((sf.base.isNullOrUndefined(this.asyncSettings.saveUrl) || this.asyncSettings.saveUrl === '')
            && (sf.base.isNullOrUndefined(this.asyncSettings.removeUrl) || this.asyncSettings.removeUrl === ''))) {
            isFormUpload = true;
        }
        return isFormUpload;
    };
    RteUploader.prototype.getFileType = function (name) {
        var extension;
        var index = name.lastIndexOf('.');
        if (index >= 0) {
            extension = name.substring(index + 1);
        }
        return extension ? extension : '';
    };
    RteUploader.prototype.getFileNameOnly = function (name) {
        var type = this.getFileType(name);
        var names = name.split('.' + type);
        return type = names[0];
    };
    RteUploader.prototype.truncateName = function (name) {
        var nameElement = name;
        if (this.browserName !== 'edge' && nameElement.offsetWidth < nameElement.scrollWidth) {
            this.getSlicedName(nameElement);
            /* istanbul ignore next */
        }
        else if (nameElement.offsetWidth + 1 < nameElement.scrollWidth) {
            this.getSlicedName(nameElement);
        }
    };
    RteUploader.prototype.getSlicedName = function (nameElement) {
        var text;
        text = nameElement.textContent;
        nameElement.dataset.tail = text.slice(text.length - 10);
    };
    RteUploader.prototype.setListToFileInfo = function (fileData, fileList) {
        for (var _i = 0, fileData_2 = fileData; _i < fileData_2.length; _i++) {
            var listItem = fileData_2[_i];
            listItem.list = fileList;
        }
    };
    RteUploader.prototype.getFileSize = function (fileData) {
        var fileSize = 0;
        for (var _i = 0, fileData_3 = fileData; _i < fileData_3.length; _i++) {
            var file = fileData_3[_i];
            fileSize += file.size;
        }
        return fileSize;
    };
    RteUploader.prototype.bytesToSize = function (bytes) {
        var i = -1;
        if (!bytes) {
            return '0.0 KB';
        }
        do {
            bytes = bytes / 1024;
            i++;
        } while (bytes > 99);
        if (i >= 2) {
            bytes = bytes * 1024;
            i = 1;
        }
        return Math.max(bytes, 0).toFixed(1) + ' ' + ['KB', 'MB'][i];
    };
    RteUploader.prototype.createFormInput = function (fileData) {
        var inputElement = this.element.cloneNode(true);
        inputElement.classList.add(HIDDEN_INPUT);
        for (var _i = 0, fileData_4 = fileData; _i < fileData_4.length; _i++) {
            var listItem = fileData_4[_i];
            listItem.input = inputElement;
        }
        inputElement.setAttribute('name', this.uploaderName);
        this.uploadWrapper.querySelector('.' + INPUT_WRAPPER).appendChild(inputElement);
        if (this.browserName !== 'msie' && this.browserName !== 'edge') {
            this.element.value = '';
        }
    };
    RteUploader.prototype.checkActionComplete = function (increment) {
        increment ? ++this.actionCompleteCount : --this.actionCompleteCount;
        if ((this.filesData.length === this.actionCompleteCount) && this.flag) {
            this.flag = false;
        }
    };
    RteUploader.prototype.isPreLoadFile = function (fileData) {
        var isPreload = false;
        for (var i = 0; i < this.files.length; i++) {
            if (this.files[i].name === fileData.name.slice(0, fileData.name.lastIndexOf('.')) && this.files[i].type === fileData.type) {
                isPreload = true;
            }
        }
        return isPreload;
    };
    RteUploader.prototype.validatedFileSize = function (fileSize) {
        var minSizeError = '';
        var maxSizeError = '';
        if (fileSize < this.minFileSize) {
            minSizeError = 'File size is too small';
        }
        else if (fileSize > this.maxFileSize) {
            maxSizeError = 'File size is too large';
        }
        else {
            minSizeError = '';
            maxSizeError = '';
        }
        var errorMessage = { minSize: minSizeError, maxSize: maxSizeError };
        return errorMessage;
    };
    RteUploader.prototype.isBlank = function (str) {
        return (!str || /^\s*$/.test(str));
    };
    RteUploader.prototype.addInvalidClass = function (fileList) {
        fileList.classList.add(INVALID_FILE);
    };
    RteUploader.prototype.checkExtension = function (files) {
        var dropFiles = files;
        if (!this.isBlank(this.allowedExtensions)) {
            var allowedExtensions = [];
            var extensions = this.allowedExtensions.split(',');
            for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
                var extension = extensions_1[_i];
                allowedExtensions.push(extension.trim().toLocaleLowerCase());
            }
            for (var i = 0; i < files.length; i++) {
                if (allowedExtensions.indexOf(('.' + files[i].type).toLocaleLowerCase()) === -1) {
                    files[i].status = 'File type is not allowed';
                    files[i].statusCode = '0';
                }
            }
        }
        return dropFiles;
    };
    RteUploader.prototype.getFilesData = function (index) {
        if (sf.base.isNullOrUndefined(index)) {
            return this.filesData;
        }
        else {
            return this.getSelectedFiles(index);
        }
    };
    RteUploader.prototype.getFilesInArray = function (files) {
        var uploadFiles = [];
        if (files instanceof Array) {
            uploadFiles = files;
        }
        else {
            uploadFiles.push(files);
        }
        return uploadFiles;
    };
    RteUploader.prototype.formValidateFileInfo = function (listItem, fileList) {
        var statusMessage = listItem.status;
        var validationMessages = this.validatedFileSize(listItem.size);
        if (validationMessages.minSize !== '' || validationMessages.maxSize !== '') {
            this.addInvalidClass(fileList);
            statusMessage = validationMessages.minSize !== '' ? 'File size is too small' :
                validationMessages.maxSize !== '' ? 'File size is too large' : statusMessage;
        }
        var typeValidationMessage = this.checkExtension(this.getFilesInArray(listItem))[0].status;
        if (typeValidationMessage === 'File type is not allowed') {
            this.addInvalidClass(fileList);
            statusMessage = typeValidationMessage;
        }
        return statusMessage;
    };
    RteUploader.prototype.clearAll = function () {
        if (sf.base.isNullOrUndefined(this.listParent)) {
            if (this.browserName !== 'msie') {
                this.element.value = '';
            }
            this.filesData = [];
            return;
        }
        this.clearData();
        this.actionCompleteCount = 0;
    };
    RteUploader.prototype.clearData = function (singleUpload) {
        if (!sf.base.isNullOrUndefined(this.listParent)) {
            sf.base.detach(this.listParent);
            this.listParent = null;
        }
        if (this.browserName !== 'msie' && !singleUpload) {
            this.element.value = '';
        }
        this.fileList = [];
        this.filesData = [];
        this.removeActionButtons();
    };
    RteUploader.prototype.removeActionButtons = function () {
        if (this.actionButtons) {
            sf.base.detach(this.actionButtons);
            this.actionButtons = null;
        }
    };
    RteUploader.prototype.checkActionButtonStatus = function () {
        if (this.actionButtons) {
            var length_1 = this.uploadWrapper.querySelectorAll('.' + VALIDATION_FAILS).length +
                this.uploadWrapper.querySelectorAll('.e-upload-fails:not(.e-upload-progress)').length +
                this.uploadWrapper.querySelectorAll('span.' + UPLOAD_SUCCESS).length +
                this.uploadWrapper.querySelectorAll('span.' + UPLOAD_INPROGRESS).length;
            if (length_1 > 0 && length_1 === this.uploadWrapper.querySelectorAll('li').length) {
                this.uploadButton.setAttribute('disabled', 'disabled');
            }
            else {
                this.uploadButton.removeAttribute('disabled');
            }
        }
    };
    RteUploader.prototype.getSelectedFiles = function (index) {
        var data = [];
        var liElement = this.fileList[index];
        var allFiles = this.getFilesData();
        var nameElements = +liElement.getAttribute('data-files-count');
        var startIndex = 0;
        for (var i = 0; i < index; i++) {
            startIndex += (+this.fileList[i].getAttribute('data-files-count'));
        }
        for (var j = startIndex; j < (startIndex + nameElements); j++) {
            data.push(allFiles[j]);
        }
        return data;
    };
    RteUploader.prototype.formFileList = function (fileData, files) {
        var fileList = sf.base.createElement('li', { className: FILE });
        fileList.setAttribute('data-files-count', fileData.length + '');
        var fileContainer = sf.base.createElement('span', { className: TEXT_CONTAINER });
        var statusMessage;
        for (var _i = 0, fileData_5 = fileData; _i < fileData_5.length; _i++) {
            var listItem = fileData_5[_i];
            var fileNameEle = sf.base.createElement('span', { className: FILE_NAME });
            fileNameEle.innerHTML = this.getFileNameOnly(listItem.name);
            var fileTypeEle = sf.base.createElement('span', { className: FILE_TYPE });
            fileTypeEle.innerHTML = '.' + this.getFileType(listItem.name);
            if (!this.enableRtl) {
                fileContainer.appendChild(fileNameEle);
                fileContainer.appendChild(fileTypeEle);
            }
            else {
                var rtlContainer = sf.base.createElement('span', { className: RTL_CONTAINER });
                rtlContainer.appendChild(fileTypeEle);
                rtlContainer.appendChild(fileNameEle);
                fileContainer.appendChild(rtlContainer);
            }
            this.truncateName(fileNameEle);
            statusMessage = this.formValidateFileInfo(listItem, fileList);
        }
        fileList.appendChild(fileContainer);
        this.setListToFileInfo(fileData, fileList);
        var infoEle = sf.base.createElement('span');
        if (fileList.classList.contains(INVALID_FILE)) {
            infoEle.classList.add(STATUS);
            infoEle.classList.add(INVALID_FILE);
            infoEle.innerText = fileData.length > 1 ? 'invalidFileSelection' : statusMessage;
        }
        else {
            infoEle.classList.add(fileData.length > 1 ? INFORMATION : FILE_SIZE);
            infoEle.innerText = fileData.length > 1 ? 'totalFiles: ' + fileData.length + ' , '
                + 'size: ' + this.bytesToSize(this.getFileSize(fileData)) : this.bytesToSize(fileData[0].size);
            this.createFormInput(fileData);
        }
        fileContainer.appendChild(infoEle);
        if (sf.base.isNullOrUndefined(fileList.querySelector('.e-icons'))) {
            var iconElement = sf.base.createElement('span', { className: 'e-icons', attrs: { 'tabindex': this.btnTabIndex } });
            /* istanbul ignore next */
            if (this.browserName === 'msie') {
                iconElement.classList.add('e-msie');
            }
            iconElement.setAttribute('title', 'Remove');
            fileList.appendChild(fileContainer);
            fileList.appendChild(iconElement);
            sf.base.EventHandler.add(iconElement, 'click', this.removeFiles, this);
            iconElement.classList.add(REMOVE_ICON);
        }
        this.listParent.appendChild(fileList);
        this.fileList.push(fileList);
    };
    RteUploader.prototype.removeFiles = function (args) {
        var selectedElement = args.target.parentElement;
        var index = this.fileList.indexOf(selectedElement);
        var liElement = this.fileList[index];
        var formUpload = this.isFormUpload();
        var fileData = formUpload ? this.getSelectedFiles(index) : this.getFilesInArray(this.filesData[index]);
        if (sf.base.isNullOrUndefined(fileData)) {
            return;
        }
        if (args.target.classList.contains(ABORT_ICON) && !formUpload) {
            fileData[0].statusCode = '5';
            if (!sf.base.isNullOrUndefined(liElement)) {
                var spinnerTarget = liElement.querySelector('.' + ABORT_ICON);
                sf.popups.createSpinner({ target: spinnerTarget, width: '20px' });
                sf.popups.showSpinner(spinnerTarget);
            }
            if (!(liElement.classList.contains(RESTRICT_RETRY))) {
                this.checkActionComplete(true);
            }
        }
        else if (!sf.base.closest(args.target, '.' + SPINNER_PANE)) {
            this.remove(fileData, false, false, true, args);
        }
        this.element.value = '';
        this.checkActionButtonStatus();
    };
    RteUploader.prototype.spliceFiles = function (liIndex) {
        var liElement = this.fileList[liIndex];
        var allFiles = this.getFilesData();
        var nameElements = +liElement.getAttribute('data-files-count');
        var startIndex = 0;
        for (var i = 0; i < liIndex; i++) {
            startIndex += (+this.fileList[i].getAttribute('data-files-count'));
        }
        var endIndex = (startIndex + nameElements) - 1;
        for (var j = endIndex; j >= startIndex; j--) {
            allFiles.splice(j, 1);
        }
    };
    RteUploader.prototype.remove = function (fileData, customTemplate, removeDirectly, postRawFile, args) {
        if (sf.base.isNullOrUndefined(postRawFile)) {
            postRawFile = true;
        }
        var eventArgs = {
            event: args,
            cancel: false,
            filesData: [],
            customFormData: [],
            postRawFile: postRawFile,
            currentRequest: null
        };
        if (this.isFormUpload()) {
            eventArgs.filesData = fileData;
            this.parent.observer.notify(removing, eventArgs);
            var removingFiles = this.getFilesInArray(fileData);
            var isLiRemoved = false;
            var liIndex = void 0;
            for (var _i = 0, removingFiles_1 = removingFiles; _i < removingFiles_1.length; _i++) {
                var data = removingFiles_1[_i];
                if (!isLiRemoved) {
                    liIndex = this.fileList.indexOf(data.list);
                }
                if (liIndex > -1) {
                    var inputElement = !sf.base.isNullOrUndefined(data.input) ? data.input : null;
                    if (inputElement) {
                        sf.base.detach(inputElement);
                    }
                    this.spliceFiles(liIndex);
                    sf.base.detach(this.fileList[liIndex]);
                    this.fileList.splice(liIndex, 1);
                    isLiRemoved = true;
                    liIndex = -1;
                }
            }
        }
        else if (this.isForm && (sf.base.isNullOrUndefined(this.asyncSettings.removeUrl) || this.asyncSettings.removeUrl === '')) {
            eventArgs.filesData = this.getFilesData();
            this.parent.observer.notify(removing, eventArgs);
            this.clearAll();
        }
        else {
            var removeFiles = [];
            fileData = !sf.base.isNullOrUndefined(fileData) ? fileData : this.filesData;
            if (fileData instanceof Array) {
                removeFiles = fileData;
            }
            else {
                removeFiles.push(fileData);
            }
            eventArgs.filesData = removeFiles;
            var removeUrl = this.asyncSettings.removeUrl;
            var validUrl = (removeUrl === '' || sf.base.isNullOrUndefined(removeUrl)) ? false : true;
            for (var _a = 0, removeFiles_1 = removeFiles; _a < removeFiles_1.length; _a++) {
                var files = removeFiles_1[_a];
                var fileUploadedIndex = this.uploadedFilesData.indexOf(files);
                if ((files.statusCode === '2' || files.statusCode === '4' || (files.statusCode === '0' &&
                    fileUploadedIndex !== -1)) && validUrl) {
                    this.removeUploadedFile(files, eventArgs, removeDirectly, customTemplate);
                }
                else {
                    if (!removeDirectly) {
                        this.parent.observer.notify(removing, eventArgs);
                        this.removeFilesData(files, customTemplate);
                    }
                    else {
                        this.removeFilesData(files, customTemplate);
                    }
                }
                if (args && !args.target.classList.contains(REMOVE_ICON)) {
                    this.checkActionComplete(false);
                }
            }
        }
    };
    RteUploader.prototype.updateCustomHeader = function (request, currentRequest) {
        if (currentRequest.length > 0 && currentRequest[0]) {
            var _loop_1 = function (i) {
                var data = currentRequest[i];
                // eslint-disable-next-line
                var value = Object.keys(data).map(function (e) {
                    return data[e];
                });
                request.setRequestHeader(Object.keys(data)[0], value);
            };
            for (var i = 0; i < currentRequest.length; i++) {
                _loop_1(i);
            }
        }
    };
    RteUploader.prototype.removeUploadedFile = function (file, eventArgs, removeDirectly, custom) {
        var _this = this;
        var selectedFiles = file;
        var ajax = new sf.base.Ajax(this.asyncSettings.removeUrl, 'POST', true, null);
        ajax.emitError = false;
        var formData = new FormData();
        ajax.beforeSend = function (e) {
            eventArgs.currentRequest = ajax.httpRequest;
            if (_this.currentRequestHeader) {
                _this.updateCustomHeader(ajax.httpRequest, _this.currentRequestHeader);
            }
            if (_this.customFormDatas) {
                _this.updateFormData(formData, _this.customFormDatas);
            }
            if (!removeDirectly) {
                _this.parent.observer.notify(removing, eventArgs);
                _this.removingEventCallback(eventArgs, formData, selectedFiles, file);
            }
            else {
                _this.removingEventCallback(eventArgs, formData, selectedFiles, file);
            }
        };
        ajax.onLoad = function (e) { _this.removeCompleted(e, selectedFiles, custom); return {}; };
        /* istanbul ignore next */
        ajax.onError = function (e) { _this.removeFailed(e, selectedFiles, custom); return {}; };
        ajax.send(formData);
    };
    RteUploader.prototype.getResponse = function (e) {
        // eslint-disable-next-line
        var target = e.currentTarget;
        var response = {
            readyState: target.readyState,
            statusCode: target.status,
            statusText: target.statusText,
            headers: target.getAllResponseHeaders(),
            withCredentials: target.withCredentials
        };
        return response;
    };
    RteUploader.prototype.removeCompleted = function (e, files, customTemplate) {
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var status = e.target;
        if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
            var args = {
                e: e, response: response, operation: 'Remove', file: this.updateStatus(files, 'File removed successfully', '2')
            };
            this.parent.observer.notify(success, args);
            this.removeFilesData(files, customTemplate);
            var index = this.uploadedFilesData.indexOf(files);
            this.uploadedFilesData.splice(index, 1);
        }
        else {
            this.removeFailed(e, files, customTemplate);
        }
    };
    RteUploader.prototype.removeFailed = function (e, files, customTemplate) {
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var args = {
            e: e, response: response, operation: 'Remove', file: this.updateStatus(files, 'Unable to remove file', '0')
        };
        if (!customTemplate) {
            var index = this.filesData.indexOf(files);
            var rootElement = this.fileList[index];
            if (rootElement) {
                rootElement.classList.remove(UPLOAD_SUCCESS);
                rootElement.classList.add(UPLOAD_FAILED);
                var statusElement = rootElement.querySelector('.' + STATUS);
                if (statusElement) {
                    statusElement.classList.remove(UPLOAD_SUCCESS);
                    statusElement.classList.add(UPLOAD_FAILED);
                }
            }
            this.checkActionButtonStatus();
        }
        this.parent.observer.notify(failure, args);
        var liElement = this.getLiElement(files);
        /* istanbul ignore next */
        if (!sf.base.isNullOrUndefined(liElement) && !sf.base.isNullOrUndefined(liElement.querySelector('.' + DELETE_ICON))) {
            var spinnerTarget = liElement.querySelector('.' + DELETE_ICON);
            sf.popups.hideSpinner(spinnerTarget);
            sf.base.detach(liElement.querySelector('.e-spinner-pane'));
        }
    };
    RteUploader.prototype.updateStatus = function (files, status, statusCode, updateLiStatus) {
        if (updateLiStatus === void 0) { updateLiStatus = true; }
        if (!(status === '' || sf.base.isNullOrUndefined(status)) && !(statusCode === '' || sf.base.isNullOrUndefined(statusCode))) {
            files.status = status;
            files.statusCode = statusCode;
        }
        if (updateLiStatus) {
            var li = this.getLiElement(files);
            if (!sf.base.isNullOrUndefined(li)) {
                if (!sf.base.isNullOrUndefined(li.querySelector('.' + STATUS)) && !((status === '' || sf.base.isNullOrUndefined(status)))) {
                    li.querySelector('.' + STATUS).textContent = status;
                }
            }
        }
        return files;
    };
    RteUploader.prototype.removingEventCallback = function (eventArgs, formData, selectedFiles, file) {
        /* istanbul ignore next */
        var name = this.element.getAttribute('name');
        var liElement = this.getLiElement(file);
        if (!sf.base.isNullOrUndefined(liElement) && (!sf.base.isNullOrUndefined(liElement.querySelector('.' + DELETE_ICON)) ||
            !sf.base.isNullOrUndefined(liElement.querySelector('.' + REMOVE_ICON)))) {
            var spinnerTarget = void 0;
            spinnerTarget = liElement.querySelector('.' + DELETE_ICON) ? liElement.querySelector('.' + DELETE_ICON) :
                liElement.querySelector('.' + REMOVE_ICON);
            sf.popups.createSpinner({ target: spinnerTarget, width: '20px' });
            sf.popups.showSpinner(spinnerTarget);
        }
        if (eventArgs.postRawFile && !sf.base.isNullOrUndefined(selectedFiles.rawFile) && selectedFiles.rawFile !== '') {
            formData.append(name, selectedFiles.rawFile, selectedFiles.name);
        }
        else {
            formData.append(name, selectedFiles.name);
        }
        this.updateFormData(formData, eventArgs.customFormData);
    };
    RteUploader.prototype.updateFormData = function (formData, customData) {
        if (customData.length > 0 && customData[0]) {
            var _loop_2 = function (i) {
                var data = customData[i];
                // eslint-disable-next-line
                var value = Object.keys(data).map(function (e) {
                    return data[e];
                });
                formData.append(Object.keys(data)[0], value);
            };
            for (var i = 0; i < customData.length; i++) {
                _loop_2(i);
            }
        }
    };
    RteUploader.prototype.getLiElement = function (files) {
        var index;
        for (var i = 0; i < this.filesData.length; i++) {
            if ((!sf.base.isNullOrUndefined(this.filesData[i].id) && !sf.base.isNullOrUndefined(files.id)) ? (this.filesData[i].name === files.name &&
                this.filesData[i].id === files.id) : this.filesData[i].name === files.name) {
                index = i;
            }
        }
        return this.fileList[index];
    };
    RteUploader.prototype.removeFilesData = function (file, customTemplate) {
        var index;
        if (customTemplate) {
            return;
        }
        var selectedElement = this.getLiElement(file);
        if (sf.base.isNullOrUndefined(selectedElement)) {
            return;
        }
        sf.base.detach(selectedElement);
        index = this.fileList.indexOf(selectedElement);
        this.fileList.splice(index, 1);
        this.filesData.splice(index, 1);
        if (this.fileList.length === 0 && !sf.base.isNullOrUndefined(this.listParent)) {
            sf.base.detach(this.listParent);
            this.listParent = null;
            this.removeActionButtons();
        }
    };
    RteUploader.prototype.upload = function (files, custom) {
        files = files ? files : this.filesData;
        this.beforeUploadCustom = sf.base.isNullOrUndefined(custom) ? false : custom;
        this.beforeUploadFiles = this.getFilesInArray(files);
        var eventArgs = {
            customFormData: [],
            currentRequest: null,
            cancel: false
        };
        this.parent.observer.notify(beforePasteUpload, eventArgs);
    };
    RteUploader.prototype.beforePasteUploadCallBack = function (eventArgs) {
        if (!eventArgs.cancel) {
            this.currentRequestHeader = eventArgs.currentRequest ? eventArgs.currentRequest : this.currentRequestHeader;
            this.customFormDatas = (eventArgs.customFormData && eventArgs.customFormData.length > 0) ?
                eventArgs.customFormData : this.customFormDatas;
            this.uploadFiles(this.beforeUploadFiles, this.beforeUploadCustom);
        }
    };
    RteUploader.prototype.filterfileList = function (files) {
        var filterFiles = [];
        var li;
        for (var i = 0; i < files.length; i++) {
            li = this.getLiElement(files[i]);
            if (!li.classList.contains(UPLOAD_SUCCESS)) {
                filterFiles.push(files[i]);
            }
        }
        return filterFiles;
    };
    RteUploader.prototype.uploadFiles = function (files, custom) {
        var selectedFiles = [];
        if (this.asyncSettings.saveUrl === '' || sf.base.isNullOrUndefined(this.asyncSettings.saveUrl)) {
            return;
        }
        if (!custom || sf.base.isNullOrUndefined(custom)) {
            selectedFiles = this.filterfileList(files);
        }
        else {
            selectedFiles = files;
        }
        for (var i = 0; i < selectedFiles.length; i++) {
            this.uploadFilesRequest(selectedFiles, i, custom);
        }
    };
    RteUploader.prototype.updateCustomheader = function (request, currentRequest) {
        if (currentRequest.length > 0 && currentRequest[0]) {
            var _loop_3 = function (i) {
                var data = currentRequest[i];
                // eslint-disable-next-line
                var value = Object.keys(data).map(function (e) {
                    return data[e];
                });
                request.setRequestHeader(Object.keys(data)[0], value);
            };
            for (var i = 0; i < currentRequest.length; i++) {
                _loop_3(i);
            }
        }
    };
    RteUploader.prototype.eventCancelByArgs = function (e, eventArgs, file) {
        var _this = this;
        e.cancel = true;
        if (eventArgs.fileData.statusCode === '5') {
            return;
        }
        eventArgs.fileData.statusCode = '5';
        eventArgs.fileData.status = 'File upload canceled';
        var liElement = this.getLiElement(eventArgs.fileData);
        if (liElement) {
            if (!sf.base.isNullOrUndefined(liElement.querySelector('.' + STATUS))) {
                liElement.querySelector('.' + STATUS).innerHTML = 'File upload canceled';
                liElement.querySelector('.' + STATUS).classList.add(UPLOAD_FAILED);
            }
            this.pauseButton = sf.base.createElement('span', { className: 'e-icons e-file-reload-btn', attrs: { 'tabindex': this.btnTabIndex } });
            var removeIcon = liElement.querySelector('.' + REMOVE_ICON);
            if (removeIcon) {
                removeIcon.parentElement.insertBefore(this.pauseButton, removeIcon);
            }
            this.pauseButton.setAttribute('title', 'Retry');
            /* istanbul ignore next */
            this.pauseButton.addEventListener('click', function (e) { _this.reloadcanceledFile(e, file, liElement); }, false);
            this.checkActionButtonStatus();
        }
    };
    RteUploader.prototype.reloadcanceledFile = function (e, file, liElement, custom) {
        file.statusCode = '1';
        file.status = 'Ready to upload';
        if (!custom) {
            liElement.querySelector('.' + STATUS).classList.remove(UPLOAD_FAILED);
            if (!sf.base.isNullOrUndefined(liElement.querySelector('.' + RETRY_ICON))) {
                sf.base.detach(liElement.querySelector('.' + RETRY_ICON));
            }
            this.pauseButton = null;
        }
        /* istanbul ignore next */
        liElement.classList.add(RESTRICT_RETRY);
        this.upload([file]);
    };
    RteUploader.prototype.uploadFilesRequest = function (selectedFiles, i, custom) {
        var _this = this;
        var ajax = new sf.base.Ajax(this.asyncSettings.saveUrl, 'POST', true, null);
        ajax.emitError = false;
        /* istanbul ignore next */
        var eventArgs = {
            fileData: selectedFiles[i],
            customFormData: [],
            cancel: false
        };
        var formData = new FormData();
        ajax.beforeSend = function (e) {
            eventArgs.currentRequest = ajax.httpRequest;
            /* istanbul ignore next */
            eventArgs.fileData.rawFile = _this.base64String[i];
            if (_this.currentRequestHeader) {
                _this.updateCustomheader(ajax.httpRequest, _this.currentRequestHeader);
            }
            if (_this.customFormDatas) {
                _this.updateFormData(formData, _this.customFormDatas);
            }
            _this.parent.observer.notify(uploading, eventArgs);
            /* istanbul ignore next */
            if (eventArgs.cancel) {
                _this.eventCancelByArgs(e, eventArgs, selectedFiles[i]);
            }
            _this.updateFormData(formData, eventArgs.customFormData);
        };
        if (selectedFiles[i].statusCode === '1') {
            var name_1 = this.element.getAttribute('name');
            formData.append(name_1, selectedFiles[i].rawFile, selectedFiles[i].name);
            ajax.onLoad = function (e) {
                _this.uploadComplete(e, selectedFiles[i], custom);
                return {};
            };
            ajax.onUploadProgress = function (e) {
                _this.uploadInProgress(e, selectedFiles[i], custom, ajax);
                return {};
            };
            /* istanbul ignore next */
            ajax.onError = function (e) { _this.uploadFailed(e, selectedFiles[i]); return {}; };
            ajax.send(formData);
        }
    };
    RteUploader.prototype.cancelUploadingFile = function (files, e, request, li) {
        var _this = this;
        if (files.statusCode === '5') {
            var eventArgs = {
                event: e,
                fileData: files,
                cancel: false,
                customFormData: []
            };
            this.parent.observer.notify(canceling, eventArgs);
            if (eventArgs.cancel) {
                files.statusCode = '3';
                if (!sf.base.isNullOrUndefined(li)) {
                    var spinnerTarget = li.querySelector('.' + ABORT_ICON);
                    if (!sf.base.isNullOrUndefined(spinnerTarget)) {
                        sf.popups.hideSpinner(spinnerTarget);
                        sf.base.detach(li.querySelector('.e-spinner-pane'));
                    }
                }
            }
            else {
                request.emitError = false;
                request.httpRequest.abort();
                var formData = new FormData();
                if (files.statusCode === '5') {
                    var name_2 = this.element.getAttribute('name');
                    formData.append(name_2, files.name);
                    formData.append('cancel-uploading', files.name);
                    this.updateFormData(formData, eventArgs.customFormData);
                    var ajax = new sf.base.Ajax(this.asyncSettings.removeUrl, 'POST', true, null);
                    ajax.emitError = false;
                    ajax.onLoad = function (e) { _this.removecanceledFile(e, files); return {}; };
                    ajax.send(formData);
                }
            }
        }
    };
    RteUploader.prototype.removecanceledFile = function (e, file) {
        var liElement = this.getLiElement(file);
        if (liElement.querySelector('.' + RETRY_ICON) || sf.base.isNullOrUndefined(liElement.querySelector('.' + ABORT_ICON))) {
            return;
        }
        this.updateStatus(file, 'File upload canceled', '5');
        this.renderFailureState(e, file, liElement);
        var spinnerTarget = liElement.querySelector('.' + REMOVE_ICON);
        if (!sf.base.isNullOrUndefined(liElement)) {
            sf.popups.hideSpinner(spinnerTarget);
            sf.base.detach(liElement.querySelector('.e-spinner-pane'));
        }
        var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
        var args = { event: e, response: requestResponse, operation: 'Cancel', file: file };
        this.parent.observer.notify(success, args);
    };
    RteUploader.prototype.uploadInProgress = function (e, files, customUI, request) {
        var li = this.getLiElement(files);
        if (sf.base.isNullOrUndefined(li) && (!customUI)) {
            return;
        }
        if (!sf.base.isNullOrUndefined(li)) {
            /* istanbul ignore next */
            if (files.statusCode === '5') {
                this.cancelUploadingFile(files, e, request, li);
            }
            if (!(li.querySelectorAll('.' + PROGRESS_WRAPPER).length > 0) && li.querySelector('.' + STATUS)) {
                li.querySelector('.' + STATUS).classList.add(UPLOAD_INPROGRESS);
                this.createProgressBar(li);
                this.updateProgressBarClasses(li, UPLOAD_INPROGRESS);
                li.querySelector('.' + STATUS).classList.remove(UPLOAD_FAILED);
            }
            this.updateProgressbar(e, li);
            var iconEle = li.querySelector('.' + REMOVE_ICON);
            if (!sf.base.isNullOrUndefined(iconEle)) {
                iconEle.classList.add(ABORT_ICON, UPLOAD_INPROGRESS);
                iconEle.setAttribute('title', 'Abort');
                iconEle.classList.remove(REMOVE_ICON);
            }
        }
        else {
            this.cancelUploadingFile(files, e, request);
        }
    };
    RteUploader.prototype.changeProgressValue = function (li, progressValue) {
        li.querySelector('.' + PROGRESSBAR).setAttribute('style', 'width:' + progressValue);
        li.querySelector('.' + PROGRESSBAR_TEXT).textContent = progressValue;
    };
    RteUploader.prototype.updateProgressbar = function (e, li) {
        if (!isNaN(Math.round((e.loaded / e.total) * 100)) && !sf.base.isNullOrUndefined(li.querySelector('.' + PROGRESSBAR))) {
            if (!sf.base.isNullOrUndefined(this.progressInterval) && this.progressInterval !== '') {
                var value = (Math.round((e.loaded / e.total) * 100)) % parseInt(this.progressInterval, 10);
                if (value === 0 || value === 100) {
                    this.changeProgressValue(li, Math.round((e.loaded / e.total) * 100).toString() + '%');
                }
            }
            else {
                this.changeProgressValue(li, Math.round((e.loaded / e.total) * 100).toString() + '%');
            }
        }
    };
    RteUploader.prototype.createProgressBar = function (liElement) {
        var progressbarWrapper = sf.base.createElement('span', { className: PROGRESS_WRAPPER });
        var progressBar = sf.base.createElement('progressbar', { className: PROGRESSBAR, attrs: { value: '0', max: '100' } });
        var progressbarInnerWrapper = sf.base.createElement('span', { className: PROGRESS_INNER_WRAPPER });
        progressBar.setAttribute('style', 'width: 0%');
        var progressbarText = sf.base.createElement('span', { className: PROGRESSBAR_TEXT });
        progressbarText.textContent = '0%';
        progressbarInnerWrapper.appendChild(progressBar);
        progressbarWrapper.appendChild(progressbarInnerWrapper);
        progressbarWrapper.appendChild(progressbarText);
        liElement.querySelector('.' + TEXT_CONTAINER).appendChild(progressbarWrapper);
    };
    RteUploader.prototype.updateProgressBarClasses = function (li, className) {
        var progressBar = li.querySelector('.' + PROGRESSBAR);
        if (!sf.base.isNullOrUndefined(progressBar)) {
            progressBar.classList.add(className);
        }
    };
    RteUploader.prototype.raiseSuccessEvent = function (e, file) {
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var statusMessage = 'File uploaded successfully';
        var args = {
            e: e, response: response, operation: 'upload', file: this.updateStatus(file, statusMessage, '2', false), statusText: statusMessage
        };
        var liElement = this.getLiElement(file);
        if (!sf.base.isNullOrUndefined(liElement)) {
            var spinnerEle = liElement.querySelector('.' + SPINNER_PANE);
            if (!sf.base.isNullOrUndefined(spinnerEle)) {
                sf.popups.hideSpinner(liElement);
                sf.base.detach(spinnerEle);
            }
        }
        this.parent.observer.notify(success, args);
        // eslint-disable-next-line
        this.updateStatus(file, args.statusText, '2');
        this.uploadedFilesData.push(file);
        this.checkActionButtonStatus();
        if (this.fileList.length > 0) {
            if ((!(this.getLiElement(file)).classList.contains(RESTRICT_RETRY))) {
                this.checkActionComplete(true);
            }
            else {
                /* istanbul ignore next */
                (this.getLiElement(file)).classList.remove(RESTRICT_RETRY);
            }
        }
    };
    RteUploader.prototype.uploadComplete = function (e, file, customUI) {
        var status = e.target;
        if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
            var li = this.getLiElement(file);
            if (sf.base.isNullOrUndefined(li) && (!customUI || sf.base.isNullOrUndefined(customUI))) {
                return;
            }
            if (!sf.base.isNullOrUndefined(li)) {
                this.updateProgressBarClasses(li, UPLOAD_SUCCESS);
                this.removeProgressbar(li, 'success');
                var iconEle = li.querySelector('.' + ABORT_ICON);
                if (!sf.base.isNullOrUndefined(iconEle)) {
                    iconEle.classList.add(DELETE_ICON);
                    iconEle.setAttribute('title', 'Delete file');
                    iconEle.classList.remove(ABORT_ICON);
                    iconEle.classList.remove(UPLOAD_INPROGRESS);
                }
            }
            this.raiseSuccessEvent(e, file);
        }
        else {
            this.uploadFailed(e, file);
        }
    };
    RteUploader.prototype.uploadFailed = function (e, file) {
        var li = this.getLiElement(file);
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var statusMessage = 'File failed to upload';
        var args = {
            e: e, response: response, operation: 'upload', file: this.updateStatus(file, statusMessage, '0', false), statusText: statusMessage
        };
        if (!sf.base.isNullOrUndefined(li)) {
            this.renderFailureState(e, file, li);
        }
        this.parent.observer.notify(failure, args);
        // eslint-disable-next-line
        this.updateStatus(file, args.statusText, '0');
        this.checkActionButtonStatus();
        this.checkActionComplete(true);
    };
    RteUploader.prototype.renderFailureState = function (e, file, liElement) {
        var _this = this;
        this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
        this.removeProgressbar(liElement, 'failure');
        if (!sf.base.isNullOrUndefined(liElement.querySelector('.e-file-status'))) {
            liElement.querySelector('.e-file-status').classList.add(UPLOAD_FAILED);
        }
        var deleteIcon = liElement.querySelector('.' + ABORT_ICON);
        if (sf.base.isNullOrUndefined(deleteIcon)) {
            return;
        }
        deleteIcon.classList.remove(ABORT_ICON, UPLOAD_INPROGRESS);
        deleteIcon.classList.add(REMOVE_ICON);
        deleteIcon.setAttribute('title', 'Remove');
        this.pauseButton = sf.base.createElement('span', { className: 'e-icons e-file-reload-btn', attrs: { 'tabindex': this.btnTabIndex } });
        deleteIcon.parentElement.insertBefore(this.pauseButton, deleteIcon);
        this.pauseButton.setAttribute('title', 'Retry');
        var retryElement = liElement.querySelector('.' + RETRY_ICON);
        /* istanbul ignore next */
        retryElement.addEventListener('click', function (e) { _this.reloadcanceledFile(e, file, liElement, false); }, false);
    };
    RteUploader.prototype.removeProgressbar = function (li, callType) {
        var _this = this;
        if (!sf.base.isNullOrUndefined(li.querySelector('.' + PROGRESS_WRAPPER))) {
            this.progressAnimation = new sf.base.Animation({ duration: 1250 });
            this.progressAnimation.animate(li.querySelector('.' + PROGRESS_WRAPPER), { name: 'FadeOut' });
            this.progressAnimation.animate(li.querySelector('.' + PROGRESSBAR_TEXT), { name: 'FadeOut' });
            setTimeout(function () { _this.animateProgressBar(li, callType); }, 750);
        }
    };
    RteUploader.prototype.animateProgressBar = function (li, callType) {
        if (callType === 'success') {
            if (!sf.base.isNullOrUndefined(li.querySelector('.' + STATUS))) {
                li.querySelector('.' + STATUS).classList.remove(UPLOAD_INPROGRESS);
                this.progressAnimation.animate(li.querySelector('.' + STATUS), { name: 'FadeIn' });
                li.querySelector('.' + STATUS).classList.add(UPLOAD_SUCCESS);
            }
        }
        else {
            if (!sf.base.isNullOrUndefined(li.querySelector('.' + STATUS))) {
                li.querySelector('.' + STATUS).classList.remove(UPLOAD_INPROGRESS);
                this.progressAnimation.animate(li.querySelector('.' + STATUS), { name: 'FadeIn' });
                li.querySelector('.' + STATUS).classList.add(UPLOAD_FAILED);
            }
        }
        if (li.querySelector('.' + PROGRESS_WRAPPER)) {
            sf.base.detach(li.querySelector('.' + PROGRESS_WRAPPER));
        }
    };
    RteUploader.prototype.onSelectFiles = function (args) {
        var targetFiles;
        /* istanbul ignore next */
        if (args.type === 'drop') {
            var files = this.sortFilesList = args.dataTransfer.files;
            if (this.browserName !== 'msie' && this.browserName !== 'edge') {
                this.element.files = files;
            }
            if (files.length > 0) {
                targetFiles = this.sortFileList(files);
                this.renderSelectedFiles(args, targetFiles);
            }
        }
        else {
            targetFiles = [].slice.call(args.target.files);
            this.renderSelectedFiles(args, targetFiles);
        }
    };
    RteUploader.prototype.sortFileList = function (filesData) {
        filesData = filesData ? filesData : this.sortFilesList;
        var files = filesData;
        var fileNames = [];
        for (var i = 0; i < files.length; i++) {
            fileNames.push(files[i].name);
        }
        var sortedFileNames = fileNames.sort();
        var sortedFilesData = [];
        for (var _i = 0, sortedFileNames_1 = sortedFileNames; _i < sortedFileNames_1.length; _i++) {
            var name_3 = sortedFileNames_1[_i];
            for (var i = 0; i < files.length; i++) {
                if (name_3 === files[i].name) {
                    sortedFilesData.push(files[i]);
                }
            }
        }
        return sortedFilesData;
    };
    RteUploader.prototype.renderSelectedFiles = function (args, 
    // eslint-disable-next-line
    targetFiles, directory, paste$$1) {
        this.base64String = [];
        // eslint-disable-next-line
        var eventArgs = {
            event: args,
            cancel: false,
            filesData: [],
            isModified: false,
            modifiedFilesData: [],
            progressInterval: '',
            isCanceled: false,
            currentRequest: null,
            customFormData: null
        };
        /* istanbul ignore next */
        if (targetFiles.length < 1) {
            eventArgs.isCanceled = true;
            this.parent.observer.notify(selected, eventArgs);
            return;
        }
        this.flag = true;
        var fileData = [];
        for (var i = 0; i < targetFiles.length; i++) {
            var file = directory ? targetFiles[i].file : targetFiles[i];
            this.updateInitialFileDetails(args, targetFiles, file, i, fileData, directory, paste$$1);
        }
        eventArgs.filesData = fileData;
        if (this.allowedExtensions.indexOf('*') > -1) {
            this.allTypes = true;
        }
        if (!this.allTypes) {
            fileData = this.checkExtension(fileData);
        }
        this.parent.observer.notify(selected, eventArgs);
        eventArgs.cancel = true;
        this._internalRenderSelect(eventArgs, fileData);
    };
    RteUploader.prototype._internalRenderSelect = function (eventArgs, fileData) {
        if (!eventArgs.cancel) {
            /* istanbul ignore next */
            this.currentRequestHeader = eventArgs.currentRequest;
            this.customFormDatas = eventArgs.customFormData;
            this.selectedFiles = this.selectedFiles.concat(fileData);
            this.btnTabIndex = this.disableKeyboardNavigation ? '-1' : '0';
            if (eventArgs.isModified && eventArgs.modifiedFilesData.length > 0) {
                for (var j = 0; j < eventArgs.modifiedFilesData.length; j++) {
                    for (var k = 0; k < fileData.length; k++) {
                        if (eventArgs.modifiedFilesData[j].id === fileData[k].id) {
                            eventArgs.modifiedFilesData[j].rawFile = fileData[k].rawFile;
                        }
                    }
                }
                var dataFiles = this.allTypes ? eventArgs.modifiedFilesData :
                    this.checkExtension(eventArgs.modifiedFilesData);
                this.updateSortedFileList(dataFiles);
                this.filesData = dataFiles;
                if (!this.isForm || this.allowUpload()) {
                    this.checkAutoUpload(dataFiles);
                }
            }
            else {
                this.createFileList(fileData, true);
                this.filesData = this.filesData.concat(fileData);
                if (!this.isForm || this.allowUpload()) {
                    this.checkAutoUpload(fileData);
                }
            }
            if (!sf.base.isNullOrUndefined(eventArgs.progressInterval) && eventArgs.progressInterval !== '') {
                this.progressInterval = eventArgs.progressInterval;
            }
            if ((this.filesData.length === this.actionCompleteCount) && this.flag) {
                this.flag = false;
            }
        }
    };
    RteUploader.prototype.allowUpload = function () {
        var allowFormUpload = false;
        if (this.isForm && (!sf.base.isNullOrUndefined(this.asyncSettings.saveUrl) && this.asyncSettings.saveUrl !== '')) {
            allowFormUpload = true;
        }
        return allowFormUpload;
    };
    RteUploader.prototype.checkAutoUpload = function (fileData) {
        this.upload(fileData);
        this.removeActionButtons();
        this.checkActionButtonStatus();
    };
    RteUploader.prototype.updateSortedFileList = function (filesData) {
        var previousListClone = sf.base.createElement('div', { id: 'clonewrapper' });
        var added = -1;
        var removedList;
        if (this.listParent) {
            for (var i = 0; i < this.listParent.querySelectorAll('li').length; i++) {
                var liElement = this.listParent.querySelectorAll('li')[i];
                previousListClone.appendChild(liElement.cloneNode(true));
            }
            removedList = this.listParent.querySelectorAll('li');
            for (var _i = 0, removedList_1 = removedList; _i < removedList_1.length; _i++) {
                var item = removedList_1[_i];
                sf.base.detach(item);
            }
            this.removeActionButtons();
            var oldList = [].slice.call(previousListClone.childNodes);
            sf.base.detach(this.listParent);
            this.listParent = null;
            this.fileList = [];
            this.createParentUL();
            for (var index = 0; index < filesData.length; index++) {
                for (var j = 0; j < this.filesData.length; j++) {
                    if (this.filesData[j].name === filesData[index].name) {
                        this.listParent.appendChild(oldList[j]);
                        sf.base.EventHandler.add(oldList[j].querySelector('.e-icons'), 'click', this.removeFiles, this);
                        this.fileList.push(oldList[j]);
                        added = index;
                    }
                }
                if (added !== index) {
                    this.createFileList([filesData[index]]);
                }
            }
        }
        else {
            this.createFileList(filesData);
        }
    };
    RteUploader.prototype.updateInitialFileDetails = function (args, 
    // eslint-disable-next-line
    targetFiles, file, i, fileData, directory, paste$$1) {
        var fileName = directory ? targetFiles[i].path.substring(1, targetFiles[i].path.length) : paste$$1 ?
            sf.base.getUniqueID(file.name.substring(0, file.name.lastIndexOf('.'))) + '.' + this.getFileType(file.name) : file.name;
        var fileDetails = {
            name: fileName,
            rawFile: file,
            size: file.size,
            status: 'Ready to upload',
            type: this.getFileType(file.name),
            validationMessages: this.validatedFileSize(file.size),
            statusCode: '1',
            id: sf.base.getUniqueID(file.name.substring(0, file.name.lastIndexOf('.'))) + '.' + this.getFileType(file.name)
        };
        /* istanbul ignore next */
        if (paste$$1) {
            fileDetails.fileSource = 'paste';
        }
        fileDetails.status = fileDetails.validationMessages.minSize !== '' ? 'File size is too small' :
            fileDetails.validationMessages.maxSize !== '' ? 'File size is too large' : fileDetails.status;
        if (fileDetails.validationMessages.minSize !== '' || fileDetails.validationMessages.maxSize !== '') {
            fileDetails.statusCode = '0';
        }
        fileData.push(fileDetails);
    };
    RteUploader.prototype.wireEvents = function () {
        sf.base.EventHandler.add(this.element, 'change', this.onSelectFiles, this);
    };
    RteUploader.prototype.unWireEvents = function () {
        sf.base.EventHandler.remove(this.element, 'change', this.onSelectFiles);
    };
    RteUploader.prototype.destroy = function () {
        this.unWireEvents();
        this.removeEventListener();
    };
    return RteUploader;
}());

/**
 * PasteCleanup module called when pasting content in RichTextEditor
 */
var PasteCleanup = /** @class */ (function () {
    function PasteCleanup(parent) {
        this.containsHtml = false;
        this.isNotFromHtml = false;
        this.inlineNode = ['a', 'abbr', 'acronym', 'audio', 'b', 'bdi', 'bdo', 'big', 'br', 'button',
            'canvas', 'cite', 'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'font', 'i', 'iframe', 'img', 'input',
            'ins', 'kbd', 'label', 'map', 'mark', 'meter', 'noscript', 'object', 'output', 'picture', 'progress',
            'q', 'ruby', 's', 'samp', 'script', 'select', 'slot', 'small', 'span', 'strong', 'sub', 'sup', 'svg',
            'template', 'textarea', 'time', 'u', 'tt', 'var', 'video', 'wbr'];
        this.blockNode = ['div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
            'address', 'blockquote', 'button', 'center', 'dd', 'dir', 'dl', 'dt', 'fieldset',
            'frameset', 'hr', 'iframe', 'isindex', 'li', 'map', 'menu', 'noframes', 'noscript',
            'object', 'ol', 'pre', 'td', 'tr', 'th', 'tbody', 'tfoot', 'thead', 'table', 'ul',
            'header', 'article', 'nav', 'footer', 'section', 'aside', 'main', 'figure', 'figcaption'];
        this.parent = parent;
        this.addEventListener();
    }
    PasteCleanup.prototype.addEventListener = function () {
        this.nodeSelectionObj = new NodeSelection();
        this.parent.observer.on(success, this.success, this);
        this.parent.observer.on(failure, this.failure, this);
        this.parent.observer.on(selected, this.selected, this);
        this.parent.observer.on(uploading, this.uploading, this);
        this.parent.observer.on(pasteClean, this.pasteClean, this);
        this.parent.observer.on(removing, this.cancelingAndRemoving, this);
        this.parent.observer.on(canceling, this.cancelingAndRemoving, this);
        this.parent.observer.on(beforePasteUpload, this.beforeImageUpload, this);
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(afterPasteCleanUp, this.pasteUpdatedValue, this);
    };
    PasteCleanup.prototype.destroy = function () {
        this.removeEventListener();
    };
    PasteCleanup.prototype.removeEventListener = function () {
        this.parent.observer.off(success, this.success);
        this.parent.observer.off(failure, this.failure);
        this.parent.observer.off(selected, this.selected);
        this.parent.observer.off(uploading, this.uploading);
        this.parent.observer.off(pasteClean, this.pasteClean);
        this.parent.observer.off(removing, this.cancelingAndRemoving);
        this.parent.observer.off(canceling, this.cancelingAndRemoving);
        this.parent.observer.off(beforePasteUpload, this.beforeImageUpload);
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(afterPasteCleanUp, this.pasteUpdatedValue);
    };
    PasteCleanup.prototype.pasteClean = function (e) {
        var _this = this;
        var args = {
            requestType: 'Paste',
            editorMode: this.parent.editorMode,
            event: e
        };
        var value = null;
        var imageproperties;
        if (e.args && !sf.base.isNullOrUndefined(e.args.clipboardData)) {
            value = e.args.clipboardData.getData('text/html');
        }
        if (this.parent.beforePasteCleanupEnabled) {
            this.parent.dotNetRef.invokeMethodAsync('BeforePasteCleanUp', { value: value });
        }
        if (e.args && value !== null && this.parent.editorMode === 'HTML') {
            if (value.length === 0) {
                var htmlRegex = new RegExp(/<\/[a-z][\s\S]*>/i);
                value = e.args.clipboardData.getData('text/plain');
                this.isNotFromHtml = value !== '' ? true : false;
                value = value.replace(/</g, '&lt;');
                value = value.replace(/>/g, '&gt;');
                this.containsHtml = htmlRegex.test(value);
                var file = e && e.args.clipboardData &&
                    e.args.clipboardData.items.length > 0 ?
                    e.args.clipboardData.items[0].getAsFile() : null;
                this.parent.observer.notify(paste, {
                    file: file,
                    args: e.args,
                    text: value,
                    callBack: function (b) {
                        imageproperties = b;
                        if (typeof (imageproperties) === 'object') {
                            _this.parent.formatter.editorManager.execCommand('Images', 'Image', e.args, _this.imageFormatting.bind(_this, args), 'pasteCleanup', imageproperties, 'pasteCleanupModule');
                        }
                        else {
                            value = imageproperties;
                        }
                    }
                });
                if (!htmlRegex.test(value)) {
                    var divElement = sf.base.createElement('div');
                    divElement.innerHTML = this.splitBreakLine(value);
                    value = divElement.innerHTML;
                }
            }
            else if (value.length > 0) {
                this.parent.formatter.editorManager.observer.notify(MS_WORD_CLEANUP, {
                    args: e.args,
                    text: e.text,
                    allowedStylePropertiesArray: this.parent.pasteCleanupSettings.allowedStyleProps,
                    callBack: function (a) {
                        value = a;
                    }
                });
            }
            var currentDocument = document;
            var range = this.nodeSelectionObj.getRange(currentDocument);
            this.saveSelection = this.nodeSelectionObj.save(range, currentDocument);
            this.pasteArgs = args;
            e.args.preventDefault();
            if (!this.parent.afterPasteCleanupEnabled) {
                this.pasteUpdatedValue(value);
            }
            else {
                this.parent.dotNetRef.invokeMethodAsync('AfterPasteCleanUp', { value: value });
            }
        }
    };
    PasteCleanup.prototype.pasteUpdatedValue = function (args) {
        var value = this.parent.afterPasteCleanupEnabled ? args.text : args;
        if (this.parent.pasteCleanupSettings.prompt) {
            var tempDivElem = sf.base.createElement('div');
            tempDivElem.innerHTML = value;
            if (tempDivElem.textContent !== '' || !sf.base.isNullOrUndefined(tempDivElem.querySelector('img')) ||
                !sf.base.isNullOrUndefined(tempDivElem.querySelector('table'))) {
                this.pasteDialog(value, this.pasteArgs);
            }
        }
        else if (this.parent.pasteCleanupSettings.plainText) {
            this.plainFormatting(value, this.pasteArgs);
        }
        else if (this.parent.pasteCleanupSettings.keepFormat) {
            this.formatting(value, false, this.pasteArgs);
        }
        else {
            this.formatting(value, true, this.pasteArgs);
        }
    };
    PasteCleanup.prototype.splitBreakLine = function (value) {
        var enterSplitText = value.split('\n');
        var contentInnerElem = '';
        for (var i = 0; i < enterSplitText.length; i++) {
            if (enterSplitText[i].trim() === '') {
                contentInnerElem += '<p><br></p>';
            }
            else {
                var contentWithSpace = this.makeSpace(enterSplitText[i]);
                contentInnerElem += '<p>' + contentWithSpace.trim() + '</p>';
            }
        }
        return contentInnerElem;
    };
    PasteCleanup.prototype.makeSpace = function (enterSplitText) {
        var contentWithSpace = '';
        var spaceBetweenContent = true;
        var spaceSplit = enterSplitText.split(' ');
        for (var j = 0; j < spaceSplit.length; j++) {
            if (spaceSplit[j].trim() === '') {
                contentWithSpace += spaceBetweenContent ? '&nbsp;' : ' ';
            }
            else {
                spaceBetweenContent = false;
                contentWithSpace += spaceSplit[j] + ' ';
            }
        }
        return contentWithSpace;
    };
    PasteCleanup.prototype.imgUploading = function (elm) {
        var allImgElm = elm.querySelectorAll('.' + CLS_PASTED_CONTENT_IMG);
        if (allImgElm.length > 0) {
            var base64Src = [];
            var imgName = [];
            var uploadImg = [];
            for (var i = 0; i < allImgElm.length; i++) {
                if (allImgElm[i].getAttribute('src').split(',')[0].indexOf('base64') >= 0) {
                    base64Src.push(allImgElm[i].getAttribute('src'));
                    imgName.push(sf.base.getUniqueID('rte_image'));
                    uploadImg.push(allImgElm[i]);
                }
            }
            var fileList = [];
            for (var i = 0; i < base64Src.length; i++) {
                fileList.push(this.base64ToFile(base64Src[i], imgName[i]));
            }
            for (var i = 0; i < fileList.length; i++) {
                this.uploadMethod(fileList[i], uploadImg[i]);
            }
            if ((sf.base.isNullOrUndefined(this.parent.insertImageSettings.saveUrl) || sf.base.isNullOrUndefined(this.parent.insertImageSettings.path)) &&
                this.parent.insertImageSettings.saveFormat === 'Blob') {
                this.getBlob(allImgElm);
            }
        }
        else if (this.parent.insertImageSettings.saveFormat === 'Blob') {
            this.getBlob(allImgElm);
        }
        var allImgElmId = elm.querySelectorAll('.' + CLS_PASTED_CONTENT_IMG);
        for (var i = 0; i < allImgElmId.length; i++) {
            allImgElmId[i].classList.remove(CLS_PASTED_CONTENT_IMG);
            if (allImgElmId[i].getAttribute('class').trim() === '') {
                allImgElm[i].removeAttribute('class');
            }
        }
    };
    PasteCleanup.prototype.getBlob = function (allImgElm) {
        for (var i = 0; i < allImgElm.length; i++) {
            if (!sf.base.isNullOrUndefined(allImgElm[i].getAttribute('src')) &&
                allImgElm[i].getAttribute('src').split(',')[0].indexOf('base64') >= 0) {
                var blopUrl = URL.createObjectURL(convertToBlob$1(allImgElm[i].getAttribute('src')));
                allImgElm[i].setAttribute('src', blopUrl);
            }
        }
    };
    PasteCleanup.prototype.uploadMethod = function (fileList, imgElem) {
        var _this = this;
        this.uploadImgElem = imgElem;
        var uploadEle = document.createElement('div');
        document.body.appendChild(uploadEle);
        uploadEle.setAttribute('display', 'none');
        this.uploadImgElem.style.opacity = '0.5';
        var popupEle = sf.base.createElement('div');
        this.parent.element.appendChild(popupEle);
        var contentEle = sf.base.createElement('input', {
            id: this.parent.element.id + '_upload', attrs: { type: 'File', name: 'UploadFiles' }
        });
        var offsetY = this.parent.iframeSettings.enable ? -50 : -90;
        this.popupObj = new sf.popups.Popup(popupEle, {
            relateTo: this.uploadImgElem,
            height: '85px',
            width: '300px',
            offsetY: offsetY,
            content: contentEle,
            viewPortElement: this.parent.element,
            position: { X: 'center', Y: 'top' },
            enableRtl: this.parent.enableRtl,
            zIndex: 10001,
            close: function (event) {
                _this.parent.isBlur = false;
                _this.popupObj.destroy();
                sf.base.detach(_this.popupObj.element);
            }
        });
        this.popupObj.element.style.display = 'none';
        sf.base.addClass([this.popupObj.element], [CLS_POPUP_OPEN, CLS_RTE_UPLOAD_POPUP]);
        var timeOut = fileList.size > 1000000 ? 300 : 100;
        setTimeout(function () { _this.refreshPopup(imgElem, _this.popupObj); }, timeOut);
        this.rawFile = undefined;
        var uploaderOptions = {
            asyncSettings: {
                saveUrl: this.parent.insertImageSettings.saveUrl
            },
            cssClass: CLS_RTE_DIALOG_UPLOAD,
            enableRtl: this.parent.enableRtl,
            allowedExtensions: this.parent.insertImageSettings.allowedTypes.toString()
        };
        this.uploadObj = new RteUploader(uploaderOptions, this.popupObj.element.childNodes[0], this.parent);
        /* eslint-disable */
        var fileData = [{
                name: fileList.name,
                rawFile: fileList,
                size: fileList.size,
                type: fileList.type,
                validationMessages: { minSize: '', maxSize: '' },
                statusCode: '1'
            }];
        this.uploadObj.createFileList(fileData);
        this.uploadObj.filesData.push(fileData[0]);
        /* eslint-enable */
        this.rawFile = fileData;
        this.uploadObj.upload(fileData);
        this.popupObj.element.getElementsByClassName(CLS_FILE_SELECT_WRAP)[0].style.display = 'none';
        sf.base.detach(this.popupObj.element.querySelector('.' + CLS_RTE_DIALOG_UPLOAD + ' .' + CLS_FILE_SELECT_WRAP));
    };
    PasteCleanup.prototype.uploading = function (e) {
        this.parent.inputElement.contentEditable = 'false';
    };
    PasteCleanup.prototype.success = function (e) {
        var _this = this;
        setTimeout(function () { _this.popupClose(_this.popupObj, _this.uploadImgElem, e); }, 900);
    };
    PasteCleanup.prototype.failure = function (e) {
        var _this = this;
        setTimeout(function () { _this.uploadFailure(_this.uploadImgElem, _this.popupObj, e); }, 900);
    };
    PasteCleanup.prototype.selected = function (e) {
        this.rawFile = e.filesData;
    };
    PasteCleanup.prototype.cancelingAndRemoving = function (e) {
        this.parent.inputElement.contentEditable = 'true';
        if (this.uploadImgElem.nextSibling.textContent === ' ') {
            sf.base.detach(this.uploadImgElem.nextSibling);
        }
        sf.base.detach(this.uploadImgElem);
        this.popupObj.close();
    };
    /* eslint-disable */
    PasteCleanup.prototype.beforeImageUpload = function (args) {
        var _this = this;
        // @ts-ignore-end
        if (!this.parent.beforeUploadImageEnabled) {
            if (sf.base.isNullOrUndefined(this.parent.insertImageSettings.saveUrl)) {
                this.popupClose(this.popupObj, this.uploadImgElem, null);
            }
            else {
                this.parent.observer.notify(beforePasteUploadCallBack, args);
            }
            return;
        }
        var beforeUploadArgs;
        beforeUploadArgs = JSON.parse(JSON.stringify(args));
        beforeUploadArgs.filesData = this.rawFile;
        return new Promise(function (resolve) {
            _this.parent.dotNetRef.invokeMethodAsync(
            // @ts-ignore-start
            beforeUpload, beforeUploadArgs).then(function (args) {
                if (args.cancel) {
                    return;
                }
                _this.uploadObj.currentRequestHeader = args.currentRequest ?
                    args.currentRequest : _this.uploadObj.currentRequestHeader;
                _this.uploadObj.customFormDatas = args.customFormData && args.customFormData.length > 0 ?
                    args.customFormData : _this.uploadObj.customFormDatas;
                if (sf.base.isNullOrUndefined(_this.parent.insertImageSettings.saveUrl)) {
                    _this.popupClose(_this.popupObj, _this.uploadImgElem, null);
                }
                else {
                    _this.parent.observer.notify(beforePasteUploadCallBack, args);
                }
                /* eslint-enable */
                // @ts-ignore-end
                resolve();
            });
        });
    };
    PasteCleanup.prototype.uploadFailure = function (imgElem, popupObj, e) {
        this.parent.inputElement.contentEditable = 'true';
        sf.base.detach(imgElem);
        if (popupObj) {
            popupObj.close();
        }
        if (this.parent.onImageUploadFailedEnabled) {
            this.parent.dotNetRef.invokeMethodAsync(pasteImageUploadFailed, e);
        }
        this.uploadObj.destroy();
        this.uploadObj = undefined;
    };
    PasteCleanup.prototype.popupClose = function (popupObj, imgElem, e) {
        var _this = this;
        this.parent.inputElement.contentEditable = 'true';
        if (!sf.base.isNullOrUndefined(this.parent.insertImageSettings.saveUrl) && this.parent.onImageUploadSuccessEnabled) {
            // @ts-ignore-start
            this.parent.dotNetRef.invokeMethodAsync(pasteImageUploadSuccess, e).then(function (args) {
                // @ts-ignore-end
                _this.pasteUploadSuccessCallback(imgElem, e, args);
            });
        }
        else {
            this.pasteUploadSuccessCallback(imgElem, e);
        }
        popupObj.close();
        imgElem.style.opacity = '1';
        this.uploadObj.destroy();
        this.uploadObj = undefined;
    };
    // @ts-ignore-start
    PasteCleanup.prototype.pasteUploadSuccessCallback = function (imgElem, e, args) {
        // @ts-ignore-end
        if (!sf.base.isNullOrUndefined(this.parent.insertImageSettings.path)) {
            if (!sf.base.isNullOrUndefined(args) && !sf.base.isNullOrUndefined(args.file) && !sf.base.isNullOrUndefined(args.file.name)) {
                var url = this.parent.insertImageSettings.path + args.file.name;
                imgElem.src = url;
                imgElem.setAttribute('alt', args.file.name);
            }
            else {
                var url = this.parent.insertImageSettings.path + e.file.name;
                imgElem.src = url;
                imgElem.setAttribute('alt', e.file.name);
            }
        }
    };
    PasteCleanup.prototype.refreshPopup = function (imageElement, popupObj) {
        var imgPosition = this.parent.iframeSettings.enable ? this.parent.element.offsetTop +
            imageElement.offsetTop : imageElement.offsetTop;
        var rtePosition = this.parent.element.offsetTop + this.parent.element.offsetHeight;
        if (imgPosition > rtePosition) {
            popupObj.relateTo = this.parent.inputElement;
            popupObj.offsetY = this.parent.iframeSettings.enable ? -30 : -65;
            popupObj.element.style.display = 'block';
        }
        else {
            if (popupObj) {
                popupObj.refreshPosition(imageElement);
                popupObj.element.style.display = 'block';
            }
        }
    };
    PasteCleanup.prototype.base64ToFile = function (base64, filename) {
        var baseStr = base64.split(',');
        var typeStr = baseStr[0].match(/:(.*?);/)[1];
        var extension = typeStr.split('/')[1];
        var decodeStr = atob(baseStr[1]);
        var strLen = decodeStr.length;
        var decodeArr = new Uint8Array(strLen);
        while (strLen--) {
            decodeArr[strLen] = decodeStr.charCodeAt(strLen);
        }
        if (sf.base.Browser.isIE || navigator.appVersion.indexOf('Edge') > -1) {
            var blob = new Blob([decodeArr], { type: extension });
            sf.base.extend(blob, { name: filename + '.' + (!sf.base.isNullOrUndefined(extension) ? extension : '') });
            return blob;
        }
        else {
            return new File([decodeArr], filename + '.' + (!sf.base.isNullOrUndefined(extension) ? extension : ''), { type: extension });
        }
    };
    PasteCleanup.prototype.imageFormatting = function (pasteArgs, imgElement) {
        var imageElement = sf.base.createElement('span');
        imageElement.appendChild(imgElement.elements[0]);
        var imageValue = imageElement.innerHTML;
        var currentDocument = document;
        var range = this.nodeSelectionObj.getRange(currentDocument);
        this.saveSelection = this.nodeSelectionObj.save(range, currentDocument);
        if (this.parent.pasteCleanupSettings.prompt) {
            this.pasteDialog(imageValue, pasteArgs);
        }
        else if (this.parent.pasteCleanupSettings.plainText) {
            this.plainFormatting(imageValue, pasteArgs);
        }
        else if (this.parent.pasteCleanupSettings.keepFormat) {
            this.formatting(imageValue, false, pasteArgs);
        }
        else {
            this.formatting(imageValue, true, pasteArgs);
        }
    };
    PasteCleanup.prototype.selectFormatting = function (option) {
        if (this.newRTEHeight !== '') {
            this.parent.element.style.height = this.preRTEHeight;
        }
        if (option === 'KeepFormat') {
            this.formatting(this.currentValue, false, this.currentArgs);
        }
        else if (option === 'CleanFormat') {
            this.formatting(this.currentValue, true, this.currentArgs);
        }
        else if (option === 'PlainTextFormat') {
            this.plainFormatting(this.currentValue, this.currentArgs);
        }
    };
    PasteCleanup.prototype.pasteDialog = function (value, args) {
        this.currentValue = value;
        this.currentArgs = args;
        this.preRTEHeight = this.parent.height.toString();
        this.newRTEHeight = '';
        if (this.parent.element.offsetHeight < 265) {
            this.newRTEHeight = (265 + 40).toString();
        }
        if (this.newRTEHeight !== '') {
            this.parent.element.style.height = this.newRTEHeight + 'px';
        }
        this.parent.openPasteDialog();
    };
    PasteCleanup.prototype.formatting = function (value, clean, args) {
        var _this = this;
        var clipBoardElem = sf.base.createElement('div', { className: 'pasteContent', styles: 'display:inline;' });
        if (this.isNotFromHtml && this.containsHtml) {
            value = this.splitBreakLine(value);
        }
        clipBoardElem.innerHTML = value;
        if (this.parent.pasteCleanupSettings.deniedTags !== null) {
            clipBoardElem = this.deniedTags(clipBoardElem);
        }
        if (clean) {
            clipBoardElem = this.deniedAttributes(clipBoardElem, clean);
        }
        else if (this.parent.pasteCleanupSettings.deniedAttrs !== null) {
            clipBoardElem = this.deniedAttributes(clipBoardElem, clean);
        }
        if (this.parent.pasteCleanupSettings.allowedStyleProps !== null) {
            clipBoardElem = this.allowedStyle(clipBoardElem);
        }
        this.saveSelection.restore();
        clipBoardElem.innerHTML = this.sanitizeHelper(clipBoardElem.innerHTML);
        var allImg = clipBoardElem.querySelectorAll('img');
        for (var i = 0; i < allImg.length; i++) {
            allImg[i].classList.add(CLS_PASTED_CONTENT_IMG);
            if (this.parent.insertImageSettings.width != 'auto')
                allImg[i].setAttribute('width', this.parent.insertImageSettings.width);
            if (this.parent.insertImageSettings.minWidth != '0')
                allImg[i].style.minWidth = this.parent.insertImageSettings.minWidth.toString();
            if (this.parent.insertImageSettings.maxWidth != null)
                allImg[i].style.maxWidth = this.parent.imageModule.getMaxWidth().toString();
            if (this.parent.insertImageSettings.height != 'auto')
                allImg[i].setAttribute('height', this.parent.insertImageSettings.height);
            if (this.parent.insertImageSettings.minHeight != '0')
                allImg[i].style.minHeight = this.parent.insertImageSettings.minHeight.toString();
            if (this.parent.insertImageSettings.maxHeight != null)
                allImg[i].style.maxHeight = this.parent.insertImageSettings.maxHeight.toString();
        }
        this.addTempClass(clipBoardElem);
        if (clipBoardElem.textContent !== '' || !sf.base.isNullOrUndefined(clipBoardElem.querySelector('img')) ||
            !sf.base.isNullOrUndefined(clipBoardElem.querySelector('table'))) {
            this.parent.formatter.editorManager.execCommand('inserthtml', 'pasteCleanup', args, function (returnArgs) {
                sf.base.extend(args, { elements: returnArgs.elements, imageElements: returnArgs.imgElem }, true);
                _this.parent.formatter.onSuccess(_this.parent, args);
            }, clipBoardElem);
            this.removeTempClass();
            this.parent.observer.notify(toolbarRefresh, {});
            this.imgUploading(this.parent.inputElement);
        }
    };
    PasteCleanup.prototype.addTempClass = function (clipBoardElem) {
        var allChild = clipBoardElem.children;
        for (var i = 0; i < allChild.length; i++) {
            allChild[i].classList.add(CLS_RTE_PASTE_CONTENT);
        }
    };
    PasteCleanup.prototype.removeTempClass = function () {
        var classElm = this.parent.inputElement.querySelectorAll('.' + CLS_RTE_PASTE_CONTENT);
        for (var i = 0; i < classElm.length; i++) {
            classElm[i].classList.remove(CLS_RTE_PASTE_CONTENT);
            if (classElm[i].getAttribute('class') === '') {
                classElm[i].removeAttribute('class');
            }
        }
    };
    PasteCleanup.prototype.sanitizeHelper = function (value) {
        value = sanitizeHelper(value, this.parent);
        return value;
    };
    PasteCleanup.prototype.plainFormatting = function (value, args) {
        var _this = this;
        var clipBoardElem = sf.base.createElement('div', { className: 'pasteContent', styles: 'display:inline;' });
        clipBoardElem.innerHTML = value;
        this.detachInlineElements(clipBoardElem);
        this.getTextContent(clipBoardElem);
        if (clipBoardElem.textContent.trim() !== '') {
            if (!sf.base.isNullOrUndefined(clipBoardElem.firstElementChild) && clipBoardElem.firstElementChild.tagName !== 'BR') {
                var firstElm = clipBoardElem.firstElementChild;
                if (!sf.base.isNullOrUndefined(clipBoardElem.firstElementChild)) {
                    var spanElm = sf.base.createElement('span');
                    for (var i = 0, j = 0; i < firstElm.childNodes.length; i++, j++) {
                        if (firstElm.childNodes[i].nodeName === '#text') {
                            spanElm.appendChild(firstElm.childNodes[i]);
                            clipBoardElem.insertBefore(spanElm, clipBoardElem.firstElementChild);
                            i--;
                        }
                        else if (firstElm.childNodes[i].nodeName !== '#text' && j === 0) {
                            for (var k = 0; k < firstElm.childNodes[i].childNodes.length; k++) {
                                spanElm.appendChild(firstElm.childNodes[i].childNodes[k]);
                                clipBoardElem.insertBefore(spanElm, clipBoardElem.firstElementChild);
                                k--;
                            }
                            i--;
                        }
                        else {
                            break;
                        }
                    }
                    if (!firstElm.hasChildNodes()) {
                        sf.base.detach(firstElm);
                    }
                }
            }
            this.removeEmptyElements(clipBoardElem);
            this.saveSelection.restore();
            clipBoardElem.innerHTML = this.sanitizeHelper(clipBoardElem.innerHTML);
            this.addTempClass(clipBoardElem);
            this.parent.formatter.editorManager.execCommand('inserthtml', 'pasteCleanup', args, function (returnArgs) {
                sf.base.extend(args, { elements: returnArgs.elements, imageElements: returnArgs.imgElem }, true);
                _this.parent.formatter.onSuccess(_this.parent, args);
            }, clipBoardElem);
            this.removeTempClass();
        }
        else {
            this.saveSelection.restore();
            sf.base.extend(args, { elements: [] }, true);
            this.parent.formatter.onSuccess(this.parent, args);
        }
    };
    PasteCleanup.prototype.getTextContent = function (clipBoardElem) {
        for (var i = 0; i < this.blockNode.length; i++) {
            var inElem = clipBoardElem.querySelectorAll(this.blockNode[i]);
            for (var j = 0; j < inElem.length; j++) {
                var parElem = void 0;
                for (var k = 0, l = 0, preNode = void 0; k < inElem[j].childNodes.length; k++, l++) {
                    if (inElem[j].childNodes[k].nodeName === 'DIV' || inElem[j].childNodes[k].nodeName === 'P' ||
                        (inElem[j].childNodes[k].nodeName === '#text' &&
                            (inElem[j].childNodes[k].nodeValue.replace(/\u00a0/g, '&nbsp;') !== '&nbsp;') &&
                            inElem[j].childNodes[k].textContent.trim() === '')) {
                        parElem = inElem[j].childNodes[k].parentElement;
                        inElem[j].childNodes[k].parentElement.parentElement.insertBefore(inElem[j].childNodes[k], inElem[j].childNodes[k].parentElement);
                        k--;
                    }
                    else {
                        parElem = inElem[j].childNodes[k].parentElement;
                        if (preNode === 'text') {
                            var previousElem = parElem.previousElementSibling;
                            previousElem.appendChild(inElem[j].childNodes[k]);
                        }
                        else {
                            var divElement = sf.base.createElement('div', { id: 'newDiv' });
                            divElement.appendChild(inElem[j].childNodes[k]);
                            parElem.parentElement.insertBefore(divElement, parElem);
                        }
                        k--;
                        preNode = 'text';
                    }
                }
                if (!sf.base.isNullOrUndefined(parElem)) {
                    sf.base.detach(parElem);
                }
            }
        }
        var allElems = clipBoardElem.querySelectorAll('*');
        for (var i = 0; i < allElems.length; i++) {
            var allAtr = allElems[i].attributes;
            for (var j = 0; j < allAtr.length; j++) {
                allElems[i].removeAttribute(allAtr[j].name);
                j--;
            }
        }
    };
    PasteCleanup.prototype.detachInlineElements = function (clipBoardElem) {
        for (var i = 0; i < this.inlineNode.length; i++) {
            var inElem = clipBoardElem.querySelectorAll(this.inlineNode[i]);
            for (var j = 0; j < inElem.length; j++) {
                var parElem = void 0;
                for (var k = 0; k < inElem[j].childNodes.length; k++) {
                    parElem = inElem[j].childNodes[k].parentElement;
                    inElem[j].childNodes[k].parentElement.parentElement.insertBefore(inElem[j].childNodes[k], inElem[j].childNodes[k].parentElement);
                    k--;
                }
                if (!sf.base.isNullOrUndefined(parElem)) {
                    sf.base.detach(parElem);
                }
            }
        }
    };
    PasteCleanup.prototype.findDetachEmptyElem = function (element) {
        var removableElement;
        if (!sf.base.isNullOrUndefined(element.parentElement)) {
            if (element.parentElement.textContent.trim() === '' &&
                element.parentElement.getAttribute('class') !== 'pasteContent') {
                removableElement = this.findDetachEmptyElem(element.parentElement);
            }
            else {
                removableElement = element;
            }
        }
        else {
            removableElement = null;
        }
        return removableElement;
    };
    PasteCleanup.prototype.removeEmptyElements = function (element) {
        var emptyElements = element.querySelectorAll(':empty');
        for (var i = 0; i < emptyElements.length; i++) {
            if (emptyElements[i].tagName !== 'BR') {
                var detachableElement = this.findDetachEmptyElem(emptyElements[i]);
                if (!sf.base.isNullOrUndefined(detachableElement)) {
                    sf.base.detach(detachableElement);
                }
            }
        }
    };
    PasteCleanup.prototype.tagGrouping = function (deniedTags) {
        var groupingTags = deniedTags.slice();
        var keys = Object.keys(pasteCleanupGroupingTags);
        var values = keys.map(function (key) { return pasteCleanupGroupingTags[key]; });
        var addTags = [];
        for (var i = 0; i < groupingTags.length; i++) {
            //The value split using '[' because to reterive the tag name from the user given format which may contain tag with attributes
            if (groupingTags[i].split('[').length > 1) {
                groupingTags[i] = groupingTags[i].split('[')[0].trim();
            }
            if (keys.indexOf(groupingTags[i]) > -1) {
                for (var j = 0; j < values[keys.indexOf(groupingTags[i])].length; j++) {
                    if (groupingTags.indexOf(values[keys.indexOf(groupingTags[i])][j]) < 0 &&
                        addTags.indexOf(values[keys.indexOf(groupingTags[i])][j]) < 0) {
                        addTags.push(values[keys.indexOf(groupingTags[i])][j]);
                    }
                }
            }
        }
        return deniedTags = deniedTags.concat(addTags);
    };
    PasteCleanup.prototype.attributesfilter = function (deniedTags) {
        for (var i = 0; i < deniedTags.length; i++) {
            if (deniedTags[i].split('[').length > 1) {
                var userAttributes = deniedTags[i].split('[')[1].split(']')[0].split(',');
                var allowedAttributeArray = [];
                var deniedAttributeArray = [];
                for (var j = 0; j < userAttributes.length; j++) {
                    userAttributes[j].indexOf('!') < 0 ? allowedAttributeArray.push(userAttributes[j].trim())
                        : deniedAttributeArray.push(userAttributes[j].split('!')[1].trim());
                }
                var allowedAttribute = allowedAttributeArray.length > 1 ?
                    (allowedAttributeArray.join('][')) : (allowedAttributeArray.join());
                var deniedAttribute = deniedAttributeArray.length > 1 ?
                    deniedAttributeArray.join('][') : (deniedAttributeArray.join());
                if (deniedAttribute.length > 0) {
                    var select$$1 = allowedAttribute !== '' ? deniedTags[i].split('[')[0] +
                        '[' + allowedAttribute + ']' : deniedTags[i].split('[')[0];
                    deniedTags[i] = select$$1 + ':not([' + deniedAttribute + '])';
                }
                else {
                    deniedTags[i] = deniedTags[i].split('[')[0] + '[' + allowedAttribute + ']';
                }
            }
        }
        return deniedTags;
    };
    PasteCleanup.prototype.deniedTags = function (clipBoardElem) {
        var deniedTags = sf.base.isNullOrUndefined(this.parent.pasteCleanupSettings.deniedTags) ? [] : this.parent.pasteCleanupSettings.deniedTags.slice();
        deniedTags = this.attributesfilter(deniedTags);
        deniedTags = this.tagGrouping(deniedTags);
        for (var i = 0; i < deniedTags.length; i++) {
            var removableElement = clipBoardElem.querySelectorAll(deniedTags[i]);
            for (var j = removableElement.length - 1; j >= 0; j--) {
                var parentElem = removableElement[j].parentNode;
                while (removableElement[j].firstChild) {
                    parentElem.insertBefore(removableElement[j].firstChild, removableElement[j]);
                }
                parentElem.removeChild(removableElement[j]);
            }
        }
        return clipBoardElem;
    };
    PasteCleanup.prototype.deniedAttributes = function (clipBoardElem, clean) {
        var deniedAttrs = sf.base.isNullOrUndefined(this.parent.pasteCleanupSettings.deniedAttrs) ? [] : this.parent.pasteCleanupSettings.deniedAttrs.slice();
        if (clean) {
            deniedAttrs.push('style');
        }
        for (var i = 0; i < deniedAttrs.length; i++) {
            var removableAttrElement = clipBoardElem.
                querySelectorAll('[' + deniedAttrs[i] + ']');
            for (var j = 0; j < removableAttrElement.length; j++) {
                removableAttrElement[j].removeAttribute(deniedAttrs[i]);
            }
        }
        return clipBoardElem;
    };
    PasteCleanup.prototype.allowedStyle = function (clipBoardElem) {
        var allowedStyleProps = sf.base.isNullOrUndefined(this.parent.pasteCleanupSettings.allowedStyleProps) ? [] : this.parent.pasteCleanupSettings.allowedStyleProps.slice();
        allowedStyleProps.push('list-style-type', 'list-style');
        var styleElement = clipBoardElem.querySelectorAll('[style]');
        for (var i = 0; i < styleElement.length; i++) {
            var allowedStyleValue = '';
            var allowedStyleValueArray = [];
            var styleValue = styleElement[i].getAttribute('style').split(';');
            for (var k = 0; k < styleValue.length; k++) {
                if (allowedStyleProps.indexOf(styleValue[k].split(':')[0].trim()) >= 0) {
                    allowedStyleValueArray.push(styleValue[k]);
                }
            }
            styleElement[i].removeAttribute('style');
            allowedStyleValue = allowedStyleValueArray.join(';').trim() === '' ?
                allowedStyleValueArray.join(';') : allowedStyleValueArray.join(';') + ';';
            if (allowedStyleValue) {
                styleElement[i].setAttribute('style', allowedStyleValue);
            }
        }
        return clipBoardElem;
    };
    return PasteCleanup;
}());

/**
 * MarkdownSelection internal module
 *
 * @hidden
 * @deprecated
 */
var MarkdownSelection = /** @class */ (function () {
    function MarkdownSelection() {
    }
    /**
     * markdown getLineNumber method
     *
     * @param {HTMLTextAreaElement} textarea - specifies the text area element
     * @param {number} point - specifies the number value
     * @returns {number} - returns the value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.getLineNumber = function (textarea, point) {
        return textarea.value.substr(0, point).split('\n').length;
    };
    /**
     * markdown getSelectedText method
     *
     * @param {HTMLTextAreaElement} textarea - specifies the text area element
     * @returns {string} - specifies the string value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.getSelectedText = function (textarea) {
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;
        return textarea.value.substring(start, end);
    };
    /**
     * markdown getAllParents method
     *
     * @param {string} value - specifies the string value
     * @returns {string[]} - returns the string value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.getAllParents = function (value) {
        return value.split('\n');
    };
    /**
     * markdown getSelectedLine method
     *
     * @param {HTMLTextAreaElement} textarea - specifies the text area element
     * @returns {string} - returns the string value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.getSelectedLine = function (textarea) {
        var lines = this.getAllParents(textarea.value);
        var index = this.getLineNumber(textarea, textarea.selectionStart);
        return lines[index - 1];
    };
    /**
     * markdown getLine method
     *
     * @param {HTMLTextAreaElement} textarea - specifies the text area element
     * @param {number} index - specifies the number value
     * @returns {string} - returns the string value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.getLine = function (textarea, index) {
        var lines = this.getAllParents(textarea.value);
        return lines[index];
    };
    /**
     * markdown getSelectedParentPoints method
     *
     * @param {HTMLTextAreaElement} textarea - specifies the text area element
     * @returns {string} - returns the string value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.getSelectedParentPoints = function (textarea) {
        var lines = this.getAllParents(textarea.value);
        var start = this.getLineNumber(textarea, textarea.selectionStart);
        var end = this.getLineNumber(textarea, textarea.selectionEnd);
        var parents = this.getSelectedText(textarea).split('\n');
        var selectedPoints = [];
        var selectedLine = lines[start - 1];
        var startLength = lines.slice(0, start - 1).join('').length;
        var firstPoint = {};
        firstPoint.line = start - 1;
        firstPoint.start = startLength + firstPoint.line;
        firstPoint.end = selectedLine !== '' ? firstPoint.start +
            selectedLine.length + 1 : firstPoint.start + selectedLine.length;
        firstPoint.text = selectedLine;
        selectedPoints.push(firstPoint);
        if (parents.length > 1) {
            for (var i = 1; i < parents.length - 1; i++) {
                var points = {};
                points.line = selectedPoints[i - 1].line + 1;
                points.start = parents[i] !== '' ? selectedPoints[i - 1].end : selectedPoints[i - 1].end;
                points.end = points.start + parents[i].length + 1;
                points.text = parents[i];
                selectedPoints.push(points);
            }
            var lastPoint = {};
            lastPoint.line = selectedPoints[selectedPoints.length - 1].line + 1;
            lastPoint.start = selectedPoints[selectedPoints.length - 1].end;
            lastPoint.end = lastPoint.start + lines[end - 1].length + 1;
            lastPoint.text = lines[end - 1];
            selectedPoints.push(lastPoint);
        }
        return selectedPoints;
    };
    /**
     * markdown setSelection method
     *
     * @param {HTMLTextAreaElement} textarea - specifies the text area element
     * @param {number} start - specifies the start vaulue
     * @param {number} end - specifies the end value
     * @returns {void}
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.setSelection = function (textarea, start, end) {
        textarea.setSelectionRange(start, end);
        textarea.focus();
    };
    /**
     * markdown save method
     *
     * @param {number} start - specifies the start vaulue
     * @param {number} end - specifies the end value
     * @returns {void}
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.save = function (start, end) {
        this.selectionStart = start;
        this.selectionEnd = end;
    };
    /**
     * markdown restore method
     *
     * @param {HTMLTextAreaElement} textArea - specifies the text area element
     * @returns {void}
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.restore = function (textArea) {
        this.setSelection(textArea, this.selectionStart, this.selectionEnd);
    };
    /**
     * markdown isStartWith method
     *
     * @param {string} line - specifies the string value
     * @param {string} command - specifies the string value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.isStartWith = function (line, command) {
        var isStart = false;
        if (line) {
            var reg = line.trim() === command.trim() ?
                new RegExp('^(' + this.replaceSpecialChar(command.trim()) + ')', 'gim') :
                new RegExp('^(' + this.replaceSpecialChar(command) + ')', 'gim');
            isStart = reg.test(line.trim());
        }
        return isStart;
    };
    /**
     * markdown replaceSpecialChar method
     *
     * @param {string} value - specifies the string value
     * @returns {string} - returns the value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.replaceSpecialChar = function (value) {
        // eslint-disable-next-line
        return value.replace(/[`~!@#$%^&*()_|+\-=?;:'",.<>\{\}\[\]\\\/]/g, '\\$&');
    };
    /**
     * markdown isClear method
     *
     * @param {string} parents - specifies the parent element
     * @param {string} regex - specifies the regex value
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.isClear = function (parents, regex) {
        var isClear = false;
        for (var i = 0; i < parents.length; i++) {
            if (new RegExp(regex, 'gim').test(parents[i].text)) {
                return true;
            }
        }
        return isClear;
    };
    /**
     * markdown getSelectedInlinePoints method
     *
     * @param {HTMLTextAreaElement} textarea - specifies the text area
     * @returns {void}
     * @hidden
     * @deprecated
     */
    MarkdownSelection.prototype.getSelectedInlinePoints = function (textarea) {
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;
        var selection = this.getSelectedText(textarea);
        return { start: start, end: end, text: selection };
    };
    return MarkdownSelection;
}());

/**
 * MarkdownToolbarStatus module for refresh the toolbar status
 */
var MarkdownToolbarStatus = /** @class */ (function () {
    function MarkdownToolbarStatus(parent) {
        this.toolbarStatus = this.prevToolbarStatus = getDefaultMDTbStatus();
        this.selection = new MarkdownSelection();
        this.parent = parent;
        this.element = this.parent.getEditPanel();
        this.addEventListener();
    }
    MarkdownToolbarStatus.prototype.addEventListener = function () {
        this.parent.observer.on(toolbarRefresh, this.onRefreshHandler, this);
        this.parent.observer.on(destroy, this.removeEventListener, this);
    };
    MarkdownToolbarStatus.prototype.removeEventListener = function () {
        this.parent.observer.off(toolbarRefresh, this.onRefreshHandler);
        this.parent.observer.off(destroy, this.removeEventListener);
    };
    MarkdownToolbarStatus.prototype.onRefreshHandler = function (args) {
        var parentsLines = this.selection.getSelectedParentPoints(this.element);
        this.toolbarStatus = {
            orderedlist: args.documentNode ? false : this.isListsApplied(parentsLines, 'OL'),
            unorderedlist: args.documentNode ? false : this.isListsApplied(parentsLines, 'UL'),
            formats: this.currentFormat(parentsLines, args.documentNode),
            bold: args.documentNode ? false : this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('Bold'),
            italic: args.documentNode ? false : this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('Italic'),
            inlinecode: args.documentNode ? false : this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('InlineCode'),
            strikethrough: args.documentNode ? false :
                this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('StrikeThrough'),
            subscript: args.documentNode ? false : this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('SubScript'),
            superscript: args.documentNode ? false : this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('SuperScript'),
            uppercase: args.documentNode ? false : this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('UpperCase')
        };
        if (this.parent.formatter.editorManager.mdSelectionFormats.isAppliedCommand('InlineCode')) {
            this.toolbarStatus.formats = 'pre';
        }
        var tbStatusString = JSON.stringify(this.toolbarStatus);
        this.parent.observer.notify(toolbarUpdated, this.toolbarStatus);
        if (JSON.stringify(this.prevToolbarStatus) !== tbStatusString) {
            this.parent.observer.notify(updateTbItemsStatus, { html: null, markdown: JSON.parse(tbStatusString) });
            this.prevToolbarStatus = JSON.parse(tbStatusString);
        }
    };
    MarkdownToolbarStatus.prototype.isListsApplied = function (lines, type) {
        var isApply = true;
        if (type === 'OL') {
            for (var i = 0; i < lines.length; i++) {
                var lineSplit = lines[i].text.trim().split(' ', 2)[0] + ' ';
                if (!/^[\d.]+[ ]+$/.test(lineSplit)) {
                    isApply = false;
                    break;
                }
            }
        }
        else {
            for (var i = 0; i < lines.length; i++) {
                if (!this.selection.isStartWith(lines[i].text, this.parent.formatter.listSyntax[type])) {
                    isApply = false;
                    break;
                }
            }
        }
        return isApply;
    };
    MarkdownToolbarStatus.prototype.currentFormat = function (lines, documentNode) {
        var format = 'p';
        var keys = Object.keys(this.parent.formatter.formatSyntax);
        var direction = this.element.selectionDirection;
        var checkLine = direction === 'backward' ? lines[0].text : lines[lines.length - 1].text;
        for (var i = 0; !documentNode && i < keys.length; i++) {
            if (keys[i] !== 'pre' && this.selection.isStartWith(checkLine, this.parent.formatter.formatSyntax[keys[i]])) {
                format = keys[i];
                break;
            }
            else if (keys[i] === 'pre') {
                if (this.codeFormat()) {
                    format = keys[i];
                    break;
                }
            }
        }
        return format;
    };
    MarkdownToolbarStatus.prototype.codeFormat = function () {
        var isFormat = false;
        var textArea = this.parent.inputElement;
        var start = textArea.selectionStart;
        var splitAt = function (index) { return function (x) { return [x.slice(0, index), x.slice(index)]; }; };
        var splitText = splitAt(start)(textArea.value);
        var cmdPre = this.parent.formatter.formatSyntax.pre;
        var selectedText = this.getSelectedText(textArea);
        if (selectedText !== '' && selectedText === selectedText.toLocaleUpperCase()) {
            return true;
        }
        else if (selectedText === '') {
            var beforeText = textArea.value.substr(splitText[0].length - 1, 1);
            var afterText = splitText[1].substr(0, 1);
            if ((beforeText !== '' && afterText !== '' && beforeText.match(/[a-z]/i)) &&
                beforeText === beforeText.toLocaleUpperCase() && afterText === afterText.toLocaleUpperCase()) {
                return true;
            }
        }
        if ((this.isCode(splitText[0], cmdPre) && this.isCode(splitText[1], cmdPre)) &&
            (splitText[0].match(this.multiCharRegx(cmdPre)).length % 2 === 1 &&
                splitText[1].match(this.multiCharRegx(cmdPre)).length % 2 === 1)) {
            isFormat = true;
        }
        return isFormat;
    };
    MarkdownToolbarStatus.prototype.getSelectedText = function (textarea) {
        return textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);
    };
    MarkdownToolbarStatus.prototype.isCode = function (text, cmd) {
        return text.search('\\' + cmd + '') !== -1;
    };
    MarkdownToolbarStatus.prototype.multiCharRegx = function (cmd) {
        return new RegExp('(\\' + cmd + ')', 'g');
    };
    return MarkdownToolbarStatus;
}());

/**
 * Constant values for Markdown Parser
 */
/**
 * List plugin events
 *
 * @hidden
 */
var LISTS_COMMAND = 'lists-commands';
/**
 * selectioncommand plugin events
 *
 * @hidden
 */
var selectionCommand = 'command-type';
/**
 * Link plugin events
 *
 * @hidden
 */
var LINK_COMMAND = 'link-commands';
/**
 * Clear plugin events
 *
 * @hidden
 */
var CLEAR_COMMAND = 'clear-commands';
/**
 * Table plugin events
 *
 * @hidden
 */
var MD_TABLE = 'insert-table';

/**
 * Lists internal component
 *
 * @hidden
 */
var MDLists = /** @class */ (function () {
    /**
     * Constructor for creating the Lists plugin
     *
     * @param {IMDFormats} options - specifies the options
     * @hidden
     */
    function MDLists(options) {
        sf.base.extend(this, this, options, true);
        this.selection = this.parent.markdownSelection;
        this.addEventListener();
    }
    MDLists.prototype.addEventListener = function () {
        this.parent.observer.on(LISTS_COMMAND, this.applyListsHandler, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.keyDownHandler, this);
        this.parent.observer.on(KEY_UP_HANDLER, this.keyUpHandler, this);
    };
    MDLists.prototype.keyDownHandler = function (event) {
        switch (event.event.which) {
            case 9:
                this.tabKey(event);
                break;
        }
        switch (event.event.action) {
            case 'ordered-list':
                this.applyListsHandler({ subCommand: 'OL', callBack: event.callBack });
                event.event.preventDefault();
                break;
            case 'unordered-list':
                this.applyListsHandler({ subCommand: 'UL', callBack: event.callBack });
                event.event.preventDefault();
                break;
        }
    };
    MDLists.prototype.keyUpHandler = function (event) {
        switch (event.event.which) {
            case 13:
                this.enterKey(event);
                break;
        }
    };
    MDLists.prototype.tabKey = function (event) {
        var textArea = this.parent.element;
        this.selection.save(textArea.selectionStart, textArea.selectionEnd);
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var parents = this.selection.getSelectedParentPoints(textArea);
        var addedLength = 0;
        var isNotFirst = this.isNotFirstLine(textArea, parents[0]);
        if (!isNotFirst && !event.event.shiftKey) {
            this.restore(textArea, start, end + addedLength, event);
            return;
        }
        var listFormat = this.olListType();
        var regex = this.getListRegex();
        this.currentAction = this.getAction(parents[0].text);
        for (var i = 0; i < parents.length; i++) {
            var prevIndex = event.event.shiftKey ? parents[i].line - 1 : parents[i].line - 1;
            var prevLine = this.selection.getLine(textArea, prevIndex);
            if (prevLine && (!event.event.shiftKey && isNotFirst || (event.event.shiftKey))) {
                var prevLineSplit = prevLine.split('. ');
                var tabSpace = '\t';
                var tabSpaceLength = event.event.shiftKey ? -tabSpace.length : tabSpace.length;
                var splitTab = parents[i].text.split('\t');
                if (event.event.shiftKey && splitTab.length === 1) {
                    break;
                }
                if (this.currentAction === 'OL' && /^\d+$/.test(prevLineSplit[0].trim()) && listFormat) {
                    event.event.preventDefault();
                    parents[i].text = event.event.shiftKey ? splitTab.splice(1, splitTab.length).join('\t') : tabSpace + parents[i].text;
                    var curTabSpace = this.getTabSpace(parents[i].text);
                    var prevTabSpace = this.getTabSpace(prevLine);
                    var splitText = parents[i].text.split('. ');
                    if (curTabSpace === prevTabSpace) {
                        this.changeTextAreaValue(splitText, this.nextOrderedListValue(prevLineSplit[0].trim()), event, textArea, parents, i, end);
                    }
                    else if (prevTabSpace < curTabSpace) {
                        this.changeTextAreaValue(splitText, '1. ', event, textArea, parents, i, end);
                    }
                    else {
                        for (; prevTabSpace.length > curTabSpace.length; null) {
                            prevIndex = prevIndex - 1;
                            prevLine = this.selection.getLine(textArea, prevIndex);
                            var prevLineSplit_1 = prevLine.trim().split('. ');
                            if (/^\d+$/.test(prevLineSplit_1[0])) {
                                prevTabSpace = this.getTabSpace(prevLine);
                                if (prevTabSpace.length <= curTabSpace.length) {
                                    this.changeTextAreaValue(splitText, this.nextOrderedListValue(prevLineSplit_1[0]), event, textArea, parents, i, end);
                                    break;
                                }
                            }
                        }
                    }
                }
                else if (this.currentAction === 'UL' && regex.test(prevLine.trim()) || !listFormat) {
                    event.event.preventDefault();
                    parents[i].text = event.event.shiftKey ? splitTab.splice(1, splitTab.length).join('\t') : tabSpace + parents[i].text;
                    textArea.value = textArea.value.substr(0, parents[i].start) + parents[i].text + '\n' +
                        textArea.value.substr(parents[i].end, textArea.value.length);
                }
                start = i === 0 ? start + tabSpaceLength : start;
                addedLength += tabSpaceLength;
                if (parents.length !== 1) {
                    for (var j = i; j < parents.length; j++) {
                        parents[j].start = j !== 0 ? parents[j].start + tabSpaceLength : parents[j].start;
                        parents[j].end = parents[j].end + tabSpaceLength;
                    }
                }
            }
        }
        this.restore(textArea, start, end + addedLength, event);
    };
    MDLists.prototype.changeTextAreaValue = function (splitText, prefixValue, event, 
    // eslint-disable-next-line
    textArea, parents, k, end) {
        var prefix = prefixValue;
        splitText.splice(0, 1);
        var textAreaLength = this.selection.getAllParents(textArea.value).length;
        var changedList = '';
        var curTabSpace = this.getTabSpace(parents[k].text);
        // eslint-disable-next-line
        var prefixNumber = parseInt(prefix.split('.')[0], null);
        var nestedTabSpace = this.getTabSpace(parents[k].text);
        var nestedlistorder = true;
        var nestedListStart = true;
        var curTabSpaceLength;
        var nextPrefixValue = -1;
        var traversIncreased = true;
        var nextLineLength = 0;
        var lineBreak = '';
        changedList = (this.selection.getLine(textArea, parents[0].line + 1) !== '') ?
            '' : changedList + textArea.value.substr(parents[0].end, textArea.value.length);
        for (var i = 1; i < textAreaLength &&
            !sf.base.isNullOrUndefined(this.selection.getLine(textArea, parents[0].line + i))
            && this.selection.getLine(textArea, parents[0].line + i) !== ''; i++) {
            var nextLine = this.selection.getLine(textArea, parents[0].line + i);
            var nextTabSpace = this.getTabSpace(nextLine);
            var nextLineSplit = nextLine.split('. ');
            if (nextLineSplit.length === 1) {
                changedList += textArea.value.substr(parents[0].end + nextLineLength, textArea.value.length);
                break;
            }
            else {
                nextLineLength += nextLine.length;
                var shiftTabTargetList = false;
                curTabSpaceLength = event.event.shiftKey ? curTabSpace.length + 1 : curTabSpace.length - 1;
                if (nextTabSpace.length > nestedTabSpace.length) {
                    traversIncreased = false;
                }
                if (curTabSpace.length !== nextTabSpace.length && nextTabSpace.length < nestedTabSpace.length) {
                    nestedListStart = true;
                    nestedlistorder = false;
                    shiftTabTargetList = event.event.shiftKey &&
                        curTabSpace.length === nextTabSpace.length ? (nestedListStart = false, true) : false;
                }
                else if (traversIncreased && event.event.shiftKey &&
                    curTabSpace.length === nextTabSpace.length && nextTabSpace.length === nestedTabSpace.length) {
                    nestedListStart = false;
                    shiftTabTargetList = true;
                }
                lineBreak = changedList === '' ? '' : '\n';
                if (curTabSpaceLength === nextTabSpace.length && nestedListStart) {
                    var nextPrefix = event.event.shiftKey ?
                        (nextPrefixValue++, this.nextOrderedListValue(nextPrefixValue.toString()))
                        : this.previousOrderedListValue(nextLineSplit[0]);
                    nextLineSplit.splice(0, 1);
                    changedList = changedList + lineBreak + nextTabSpace + nextPrefix + nextLineSplit.join('. ');
                }
                else if (curTabSpace.length === nextTabSpace.length && nestedlistorder || shiftTabTargetList) {
                    var nextPrefix = this.nextOrderedListValue(prefixNumber.toString());
                    prefixNumber++;
                    nextLineSplit.splice(0, 1);
                    changedList = changedList + lineBreak + nextTabSpace + nextPrefix + nextLineSplit.join('. ');
                }
                else {
                    changedList = changedList + lineBreak + nextLine;
                    nestedListStart = false;
                }
                nestedTabSpace = this.getTabSpace(nextLine);
            }
        }
        parents[k].text = this.getTabSpace(parents[k].text) + prefix + splitText.join('. ') + '\n';
        textArea.value = textArea.value.substr(0, parents[k].start) + parents[k].text + changedList;
    };
    MDLists.prototype.getTabSpace = function (line) {
        var split = line.split('\t');
        var tabs = '';
        for (var i = 0; i < split.length; i++) {
            if (split[i] === '') {
                tabs += '\t';
            }
            else {
                break;
            }
        }
        return tabs;
    };
    MDLists.prototype.isNotFirstLine = function (textArea, points) {
        var currentLine = points.text;
        var prevIndex = points.line - 1;
        var prevLine = this.selection.getLine(textArea, prevIndex);
        var regex = this.getListRegex();
        var isNotFirst = false;
        var regexFirstCondition;
        if (prevLine) {
            this.currentAction = this.getAction(prevLine);
            var prevLineSplit = prevLine.split('. ');
            regexFirstCondition = this.currentAction === 'OL' ? /^\d+$/.test(prevLineSplit[0].trim()) : regex.test(prevLine.trim());
        }
        if (prevLine && regexFirstCondition) {
            var curTabSpace = this.getTabSpace(currentLine);
            var prevTabSpace = this.getTabSpace(prevLine);
            isNotFirst = curTabSpace === prevTabSpace ? true : isNotFirst;
            for (; prevTabSpace.length > curTabSpace.length; null) {
                prevIndex = prevIndex - 1;
                prevLine = this.selection.getLine(textArea, prevIndex);
                var prevLineSplit = prevLine.trim().split('. ');
                var regexSecondCondition = this.currentAction === 'OL' ?
                    /^\d+$/.test(prevLineSplit[0]) : regex.test(prevLine.trim());
                if (regexSecondCondition) {
                    prevTabSpace = this.getTabSpace(prevLine);
                    if (prevTabSpace.length <= curTabSpace.length) {
                        isNotFirst = true;
                        break;
                    }
                }
            }
        }
        return isNotFirst;
    };
    MDLists.prototype.getAction = function (line) {
        var ol = line.split('. ')[0];
        // eslint-disable-next-line
        var currentState = /^\d+$/.test(ol.trim());
        var ul = line.trim().split(new RegExp('^(' + this.selection.replaceSpecialChar(this.syntax.UL).trim() + ')'))[1];
        return (currentState ? 'OL' : ul ? 'UL' : 'NOTLIST');
    };
    MDLists.prototype.nextOrderedListValue = function (previousLine) {
        // eslint-disable-next-line
        var currentValue = parseInt(previousLine, null);
        var nextValue = currentValue + 1;
        return nextValue.toString() + '. ';
    };
    MDLists.prototype.previousOrderedListValue = function (previousLine) {
        // eslint-disable-next-line
        var currentValue = parseInt(previousLine, null);
        var nextValue = currentValue - 1;
        return nextValue.toString() + '. ';
    };
    MDLists.prototype.enterKey = function (event) {
        var textArea = this.parent.element;
        this.selection.save(textArea.selectionStart, textArea.selectionEnd);
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var parents = this.selection.getSelectedParentPoints(textArea);
        var prevLine = this.selection.getLine(textArea, parents[0].line - 1);
        var listFormat = this.olListType();
        var regex = this.getListRegex();
        var prevLineSplit = [];
        if (!sf.base.isNullOrUndefined(prevLine)) {
            prevLineSplit = prevLine.split('. ');
            this.currentAction = this.getAction(prevLine);
        }
        var addedLength = 0;
        if (this.currentAction === 'OL' && prevLineSplit.length > 1 && /^\d+$/.test(prevLineSplit[0].trim()) && listFormat
            && prevLineSplit[1] !== '') {
            var tabSpace = this.getTabSpace(prevLine);
            this.currentAction = this.getAction(prevLine);
            var prefix = this.nextOrderedListValue(prevLineSplit[0]);
            parents[0].text = tabSpace + prefix + parents[0].text;
            var textAreaLength = this.selection.getAllParents(textArea.value).length;
            var changedList = '\n';
            var curTabSpace = this.getTabSpace(prevLine);
            var nestedTabSpace = this.getTabSpace(parents[0].text);
            var nestedListOrder = true;
            for (var i = 1; i < textAreaLength &&
                textArea.value.substr(parents[0].end, textArea.value.length) !== ''; i++) {
                var nextLine = this.selection.getLine(textArea, parents[0].line + i);
                if (sf.base.isNullOrUndefined(nextLine)) {
                    changedList = changedList + '';
                }
                else {
                    var nextLineSplit = nextLine.split('. ');
                    var nextTabSpace = this.getTabSpace(nextLine);
                    if (nextTabSpace.length < nestedTabSpace.length) {
                        nestedListOrder = false;
                    }
                    if (nextLineSplit.length > 1 && /^\d+$/.test(nextLineSplit[0].trim()) &&
                        curTabSpace.length === nextTabSpace.length && nestedListOrder) {
                        var nextPrefix = this.nextOrderedListValue(nextLineSplit[0]);
                        nextLineSplit.splice(0, 1);
                        changedList = changedList + nextTabSpace + nextPrefix + nextLineSplit.join('. ') + '\n';
                    }
                    else {
                        changedList = changedList + nextLine + '\n';
                        nestedTabSpace = this.getTabSpace(nextLine);
                    }
                }
            }
            textArea.value = textArea.value.substr(0, parents[0].start) + curTabSpace +
                prefix + this.selection.getLine(textArea, parents[0].line) + changedList;
            start = start + prefix.length + tabSpace.length;
            addedLength += prefix.length + tabSpace.length;
        }
        else if (this.currentAction === 'UL' && (prevLine && regex.test(prevLine.trim())) &&
            prevLine.trim().replace(regex, '') !== '' || this.currentAction === 'OL' && !listFormat) {
            var tabSpace = this.getTabSpace(prevLine);
            var prefix = this.syntax[this.currentAction];
            parents[0].text = tabSpace + prefix + parents[0].text +
                (parents[0].text.trim().length > 0 ? '\n' : '');
            textArea.value = textArea.value.substr(0, parents[0].start) + parents[0].text +
                textArea.value.substr(parents[0].end, textArea.value.length);
            start = start + prefix.length + tabSpace.length;
            addedLength += prefix.length + tabSpace.length;
        }
        this.restore(textArea, start, end + addedLength, event);
    };
    MDLists.prototype.olListType = function () {
        var olSyntaxList = this.syntax.OL.split('.,');
        var listType = olSyntaxList.length === 1 ? null :
            // eslint-disable-next-line
            parseInt(olSyntaxList[2].trim(), null) - parseInt(olSyntaxList[0].trim(), null);
        if (listType) {
            return 1;
        }
        else {
            return 0;
        }
    };
    MDLists.prototype.applyListsHandler = function (e) {
        var textArea = this.parent.element;
        this.selection.save(textArea.selectionStart, textArea.selectionEnd);
        this.currentAction = e.subCommand;
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var addedLength = 0;
        var startLength = 0;
        var endLength = 0;
        var parents = this.selection.getSelectedParentPoints(textArea);
        var prefix = '';
        var listFormat = this.olListType();
        var regex;
        var perfixObj = {};
        for (var i = 0; i < parents.length; i++) {
            if (listFormat) {
                regex = this.currentAction === 'OL' ? i + listFormat + '. ' : this.syntax[this.currentAction];
            }
            else {
                regex = this.currentAction === 'OL' ? this.syntax.OL : this.syntax[this.currentAction];
            }
            if (!this.selection.isStartWith(parents[i].text, regex)) {
                if (parents[i].text === '' && i === 0) {
                    this.selection.save(start, end);
                    if (parents.length !== 1) {
                        for (var j = i; j < parents.length; j++) {
                            parents[j].start = j !== 0 ? 1 + parents[j].start : parents[j].start;
                            parents[j].end = 1 + parents[j].end;
                        }
                    }
                }
                var preLineTabSpaceLength = !sf.base.isNullOrUndefined(parents[i - 1]) ?
                    this.getTabSpace(parents[i - 1].text).length : 0;
                var replace = this.appliedLine(parents[i].text, regex, perfixObj, preLineTabSpaceLength);
                prefix = replace.line ? prefix : regex;
                parents[i].text = replace.line ? replace.line : prefix + parents[i].text;
                replace.space = replace.space ? replace.space : 0;
                textArea.value = textArea.value.substr(0, parents[i].start + endLength) + parents[i].text + '\n' +
                    textArea.value.substr(parents[i].end, textArea.value.length);
                start = i === 0 ? (start + prefix.length + replace.space) > 0 ?
                    start + prefix.length + replace.space : 0 : start;
                addedLength += prefix.length + replace.space;
                if (parents.length !== 1) {
                    for (var j = i; j < parents.length; j++) {
                        parents[j].start = j !== 0 ? prefix.length +
                            parents[j].start + replace.space : parents[j].start;
                        parents[j].end = prefix.length + parents[j].end + replace.space;
                    }
                }
                this.restore(textArea, start, end + addedLength, null);
            }
            else {
                parents[i].text = parents[i].text.replace(regex, '');
                textArea.value = textArea.value.substr(0, parents[i].start + endLength) + parents[i].text + '\n' +
                    textArea.value.substr(parents[i].end + endLength, textArea.value.length);
                endLength -= regex.length;
                startLength = regex.length;
                this.restore(textArea, start - startLength, end + endLength, null);
            }
        }
        this.restore(textArea, null, null, e);
    };
    MDLists.prototype.appliedLine = function (line, prefixPattern, perfixObj, preTabSpaceLength) {
        var points = {};
        var regex = new RegExp('^[' + this.syntax.UL.trim() + ']');
        var lineSplit = line.split('. ');
        var currentPrefix = lineSplit[0] + '. ';
        var isExist = regex.test(line.trim()) || line.trim() === this.syntax.OL.trim()
            || line.trim() === this.syntax.UL.trim() || /^\d+$/.test(lineSplit[0].trim());
        var listFormat = this.olListType();
        var curTabSpaceLength = this.getTabSpace(line).length;
        if (this.currentAction === 'OL' && listFormat) {
            perfixObj[curTabSpaceLength.toString()] = !sf.base.isNullOrUndefined(perfixObj[curTabSpaceLength.toString()]) ?
                perfixObj[curTabSpaceLength.toString()].valueOf() + 1 : 1;
            prefixPattern = perfixObj[curTabSpaceLength.toString()].valueOf().toString() + '. ';
            if (!sf.base.isNullOrUndefined(preTabSpaceLength) && preTabSpaceLength > curTabSpaceLength) {
                perfixObj[preTabSpaceLength.toString()] = 0;
            }
        }
        if (isExist) {
            var replace = void 0;
            var pattern = void 0;
            // eslint-disable-next-line
            if (regex.test(line.trim())) {
                pattern = this.syntax.UL;
                replace = prefixPattern;
                points.space = prefixPattern.trim().length - this.syntax.UL.trim().length;
            }
            else if (/^\d+$/.test(lineSplit[0].trim()) && listFormat) {
                pattern = lineSplit[0].trim() + '. ';
                replace = prefixPattern;
                points.space = this.syntax.UL.trim().length - currentPrefix.trim().length;
            }
            else if (/^\d+$/.test(lineSplit[0].trim())) {
                pattern = lineSplit[0].trim() + '. ';
                replace = this.syntax.UL;
                points.space = this.syntax.UL.trim().length - currentPrefix.trim().length;
            }
            points.line = line.replace(pattern, replace);
        }
        return points;
    };
    MDLists.prototype.restore = function (textArea, start, end, event) {
        if (!sf.base.isNullOrUndefined(start) && !sf.base.isNullOrUndefined(start)) {
            this.selection.save(start, end);
        }
        if (!sf.base.isNullOrUndefined(event)) {
            this.selection.restore(textArea);
        }
        if (event && event.callBack) {
            event.callBack({
                requestType: this.currentAction,
                selectedText: this.selection.getSelectedText(textArea),
                editorMode: 'Markdown',
                event: event.event
            });
        }
    };
    MDLists.prototype.getListRegex = function () {
        var regex = '';
        var configKey = Object.keys(this.syntax);
        for (var j = 0; j < configKey.length; j++) {
            var syntax = this.selection.replaceSpecialChar(this.syntax[configKey[j]]);
            regex += regex === '' ? '^(' + syntax + ')|^(' + syntax.trim() + ')' :
                '|^(' + syntax + ')|^(' + syntax.trim() + ')';
        }
        return new RegExp(regex);
    };
    return MDLists;
}());

/**
 * MDFormats internal plugin
 *
 * @hidden
 * @deprecated
 */
var MDFormats = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {IMDFormats} options - specifies the formats
     * @hidden
     * @deprecated
     */
    function MDFormats(options) {
        sf.base.extend(this, this, options, true);
        this.selection = this.parent.markdownSelection;
        this.addEventListener();
    }
    MDFormats.prototype.addEventListener = function () {
        this.parent.observer.on(FORMAT_TYPE, this.applyFormats, this);
    };
    MDFormats.prototype.applyFormats = function (e) {
        e.subCommand = e.subCommand.toLowerCase();
        var textArea = this.parent.element;
        this.selection.save(textArea.selectionStart, textArea.selectionEnd);
        var parents = this.selection.getSelectedParentPoints(textArea);
        if (this.isAppliedFormat(parents) === e.subCommand) {
            if (e.subCommand === 'pre') {
                if (parents.length > 1) {
                    this.applyCodeBlock(textArea, e, parents);
                }
                else {
                    return;
                }
            }
            this.cleanFormat(textArea);
            this.restore(textArea, textArea.selectionStart, textArea.selectionEnd, e);
            return;
        }
        if (e.subCommand === 'p') {
            this.cleanFormat(textArea);
            this.restore(textArea, textArea.selectionStart, textArea.selectionEnd, e);
            return;
        }
        else {
            if ((e.subCommand === 'pre' && parents.length !== 1) || e.subCommand !== 'pre') {
                this.cleanFormat(textArea, e.subCommand);
            }
        }
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var addedLength = 0;
        parents = this.selection.getSelectedParentPoints(textArea);
        if (e.subCommand === 'pre') {
            if (parents.length > 1) {
                this.applyCodeBlock(textArea, e, parents);
            }
            else {
                sf.base.extend(e, e, { subCommand: 'InlineCode' }, true);
                this.parent.observer.notify(selectionCommand, e);
            }
            return;
        }
        for (var i = 0; i < parents.length; i++) {
            if (parents[i].text !== '' && !this.selection.isStartWith(parents[i].text, '\\' + this.syntax[e.subCommand])) {
                parents[i].text = this.syntax[e.subCommand] + parents[i].text;
                textArea.value = textArea.value.substr(0, parents[i].start) + parents[i].text + '\n' +
                    textArea.value.substr(parents[i].end, textArea.value.length);
                start = i === 0 ? start + this.syntax[e.subCommand].length : start;
                addedLength += this.syntax[e.subCommand].length;
                if (parents.length !== 1) {
                    for (var j = i; j < parents.length; j++) {
                        parents[j].start = j !== 0 ?
                            this.syntax[e.subCommand].length + parents[j].start : parents[j].start;
                        parents[j].end = this.syntax[e.subCommand].length + parents[j].end;
                    }
                }
            }
            else if (parents[i].text === '' && i === 0) {
                this.selection.save(start, end);
                if (this.selection.getSelectedText(textArea).length === 0) {
                    parents[i].text = this.syntax[e.subCommand];
                    textArea.value = textArea.value.substr(0, parents[i].start) + this.syntax[e.subCommand] +
                        textArea.value.substr(parents[i].end, textArea.value.length);
                    start = i === 0 ? start + this.syntax[e.subCommand].length : start;
                    addedLength += this.syntax[e.subCommand].length;
                }
                if (parents.length !== 1) {
                    for (var j = i; j < parents.length; j++) {
                        parents[j].start = j !== 0 ? 1 + parents[j].start : parents[j].start;
                        parents[j].end = 1 + parents[j].end;
                    }
                }
            }
        }
        this.restore(textArea, start, end + addedLength, e);
    };
    MDFormats.prototype.clearRegex = function () {
        var regex = '';
        var configKey = Object.keys(this.syntax);
        for (var j = 0; j < configKey.length && configKey[j] !== 'pre' && configKey[j] !== 'p'; j++) {
            regex += regex === '' ? '^(' + this.selection.replaceSpecialChar(this.syntax[configKey[j]].trim()) + ')' :
                '|^(' + this.selection.replaceSpecialChar(this.syntax[configKey[j]].trim()) + ')';
        }
        return regex;
    };
    MDFormats.prototype.cleanFormat = function (textArea, command) {
        var parents = this.selection.getSelectedParentPoints(textArea);
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var removeLength = 0;
        if (this.selection.isClear(parents, this.clearRegex())) {
            for (var i = 0; i < parents.length; i++) {
                var configKey = Object.keys(this.syntax);
                for (var j = 0; parents[i].text !== '' && j < configKey.length; j++) {
                    var removeText = this.syntax[configKey[j]];
                    if (configKey[j] === command) {
                        continue;
                    }
                    var regex = new RegExp('^(' + this.selection.replaceSpecialChar(removeText) + ')', 'gim');
                    if (regex.test(parents[i].text)) {
                        parents[i].text = parents[i].text.replace(regex, '');
                        textArea.value = textArea.value.substr(0, parents[i].start) + parents[i].text + '\n' +
                            textArea.value.substr(parents[i].end, textArea.value.length);
                        start = i === 0 ? (start - (removeText.length)) > 0 ? start - (removeText.length) : 0 : start;
                        removeLength += removeText.length;
                        if (parents.length !== 1) {
                            for (var k = 0; k < parents.length; k++) {
                                parents[k].start = k !== 0 ?
                                    parents[k].start - removeText.length : parents[k].start;
                                parents[k].end = parents[k].end - removeText.length;
                            }
                        }
                        break;
                    }
                }
                if (parents[i].text === '' && i === 0) {
                    this.selection.save(start, end);
                    if (parents.length !== 1) {
                        for (var j = i; j < parents.length; j++) {
                            parents[j].start = j !== 0 ? 1 + parents[j].start : parents[j].start;
                            parents[j].end = 1 + parents[j].end;
                        }
                    }
                }
            }
            this.restore(textArea, start, end - removeLength);
        }
    };
    MDFormats.prototype.applyCodeBlock = function (textArea, event, parents) {
        var command = event.subCommand;
        var start = parents[0].start;
        var end = parents[parents.length - 1].end;
        var parentLines = this.selection.getAllParents(textArea.value);
        var firstPrevText = parentLines[parents[0].line - 1];
        var lastNextText = parentLines[(parents.length + 1) + 1];
        // eslint-disable-next-line
        if (!this.selection.isStartWith(firstPrevText, this.syntax.pre.split('\n')[0]) &&
            !this.selection.isStartWith(lastNextText, this.syntax.pre.split('\n')[0])) {
            var lines = textArea.value.substring(start, end).split('\n');
            var lastLine = lines[lines.length - 1] === '' ? '' : '\n';
            textArea.value = textArea.value.substr(0, start) + this.syntax[command] + textArea.value.substring(start, end) +
                lastLine + this.syntax[command] +
                textArea.value.substr(end, textArea.value.length);
            start = this.selection.selectionStart + this.syntax[command].length;
            end = this.selection.selectionEnd + this.syntax[command].length - 1;
        }
        else {
            var cmd = this.syntax[command];
            var selection = this.parent.markdownSelection.getSelectedInlinePoints(textArea);
            var startNo = textArea.value.substr(0, textArea.selectionStart).lastIndexOf(cmd);
            var endNo = textArea.value.substr(textArea.selectionEnd, textArea.selectionEnd).indexOf(cmd);
            endNo = endNo + selection.end;
            var repStartText = this.replaceAt(textArea.value.substr(0, selection.start), cmd, '', startNo, selection.start);
            var repEndText = this.replaceAt(textArea.value.substr(selection.end, textArea.value.length), cmd, '', 0, endNo);
            textArea.value = repStartText + selection.text + repEndText;
            start = this.selection.selectionStart - cmd.length;
            end = this.selection.selectionEnd - cmd.length;
        }
        this.restore(textArea, start, end, event);
    };
    MDFormats.prototype.replaceAt = function (input, search, replace, start, end) {
        return input.slice(0, start)
            + input.slice(start, end).replace(search, replace)
            + input.slice(end);
    };
    MDFormats.prototype.restore = function (textArea, start, end, event) {
        this.selection.save(start, end);
        this.selection.restore(textArea);
        if (event && event.callBack) {
            event.callBack({
                requestType: event.subCommand,
                selectedText: this.selection.getSelectedText(textArea),
                editorMode: 'Markdown',
                event: event.event
            });
        }
    };
    MDFormats.prototype.isAppliedFormat = function (lines, documentNode) {
        var format = 'p';
        // eslint-disable-next-line
        var configKey = Object.keys(this.syntax);
        var keys = Object.keys(this.syntax);
        var direction = this.parent.element.selectionDirection;
        var checkLine = direction === 'backward' ? lines[0].text : lines[lines.length - 1].text;
        for (var i = 0; !documentNode && i < keys.length; i++) {
            if (keys[i] !== 'pre' && this.selection.isStartWith(checkLine, this.syntax[keys[i]])) {
                format = keys[i];
                break;
            }
            else if (keys[i] === 'pre') {
                var parentLines = this.selection.getAllParents(this.parent.element.value);
                var firstPrevText = parentLines[lines[0].line - 1];
                var lastNextText = parentLines[lines.length + 1];
                if (this.selection.isStartWith(firstPrevText, this.syntax[keys[i]].split('\n')[0]) &&
                    this.selection.isStartWith(lastNextText, this.syntax[keys[i]].split('\n')[0])) {
                    format = keys[i];
                    break;
                }
            }
        }
        return format;
    };
    return MDFormats;
}());

/**
 * SelectionCommands internal component
 *
 * @hidden
 * @deprecated
 */
var MDSelectionFormats = /** @class */ (function () {
    function MDSelectionFormats(parent) {
        sf.base.extend(this, this, parent, true);
        this.selection = this.parent.markdownSelection;
        this.addEventListener();
    }
    MDSelectionFormats.prototype.addEventListener = function () {
        this.parent.observer.on(selectionCommand, this.applyCommands, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.keyDownHandler, this);
    };
    MDSelectionFormats.prototype.keyDownHandler = function (e) {
        switch (e.event.action) {
            case 'bold':
                this.applyCommands({ subCommand: 'Bold', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'italic':
                this.applyCommands({ subCommand: 'Italic', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'strikethrough':
                this.applyCommands({ subCommand: 'StrikeThrough', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'uppercase':
                this.applyCommands({ subCommand: 'UpperCase', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'lowercase':
                this.applyCommands({ subCommand: 'LowerCase', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'superscript':
                this.applyCommands({ subCommand: 'SuperScript', callBack: e.callBack });
                e.event.preventDefault();
                break;
            case 'subscript':
                this.applyCommands({ subCommand: 'SubScript', callBack: e.callBack });
                e.event.preventDefault();
                break;
        }
    };
    MDSelectionFormats.prototype.isBold = function (text, cmd) {
        return text.search('\\' + cmd + '\\' + cmd + '') !== -1;
    };
    MDSelectionFormats.prototype.isItalic = function (text, cmd) {
        return text.search('\\' + cmd) !== -1;
    };
    MDSelectionFormats.prototype.isMatch = function (text, cmd) {
        var matchText = [''];
        switch (cmd) {
            case this.syntax.Italic:
                matchText = text.match(this.singleCharRegx(cmd));
                break;
            case this.syntax.InlineCode:
                matchText = text.match(this.singleCharRegx(cmd));
                break;
            case this.syntax.StrikeThrough:
                matchText = text.match(this.singleCharRegx(cmd));
                break;
        }
        return matchText;
    };
    MDSelectionFormats.prototype.multiCharRegx = function (cmd) {
        return new RegExp('(\\' + cmd + '\\' + cmd + ')', 'g');
    };
    MDSelectionFormats.prototype.singleCharRegx = function (cmd) {
        return new RegExp('(\\' + cmd + ')', 'g');
    };
    MDSelectionFormats.prototype.isAppliedCommand = function (cmd) {
        // eslint-disable-next-line
        var isFormat = false;
        var textArea = this.parent.element;
        var start = textArea.selectionStart;
        var splitAt = function (index) { return function (x) { return [x.slice(0, index), x.slice(index)]; }; };
        var splitText = splitAt(start)(textArea.value);
        var cmdB = this.syntax.Bold.substr(0, 1);
        var cmdI = this.syntax.Italic;
        var selectedText = this.parent.markdownSelection.getSelectedText(textArea);
        if (selectedText !== '' && selectedText === selectedText.toLocaleUpperCase() && cmd === 'UpperCase') {
            return true;
        }
        else if (selectedText === '') {
            var beforeText = textArea.value.substr(splitText[0].length - 1, 1);
            var afterText = splitText[1].substr(0, 1);
            if ((beforeText !== '' && afterText !== '' && beforeText.match(/[a-z]/i)) &&
                beforeText === beforeText.toLocaleUpperCase() && afterText === afterText.toLocaleUpperCase() && cmd === 'UpperCase') {
                return true;
            }
        }
        if (!(this.isBold(splitText[0], cmdB)) && !(this.isItalic(splitText[0], cmdI)) && !(this.isBold(splitText[1], cmdB)) &&
            !(this.isItalic(splitText[1], cmdI))) {
            if ((!sf.base.isNullOrUndefined(this.isMatch(splitText[0], this.syntax.StrikeThrough)) &&
                !sf.base.isNullOrUndefined(this.isMatch(splitText[1], this.syntax.StrikeThrough))) &&
                (this.isMatch(splitText[0], this.syntax.StrikeThrough).length % 2 === 1 &&
                    this.isMatch(splitText[1], this.syntax.StrikeThrough).length % 2 === 1) && cmd === 'StrikeThrough') {
                isFormat = true;
            }
            if ((!sf.base.isNullOrUndefined(this.isMatch(splitText[0], this.syntax.InlineCode)) &&
                !sf.base.isNullOrUndefined(this.isMatch(splitText[1], this.syntax.InlineCode))) &&
                (this.isMatch(splitText[0], this.syntax.InlineCode).length % 2 === 1 &&
                    this.isMatch(splitText[1], this.syntax.InlineCode).length % 2 === 1) && cmd === 'InlineCode') {
                isFormat = true;
            }
            /* eslint-disable */
            if ((!sf.base.isNullOrUndefined(splitText[0].match(/\<sub>/g)) && !sf.base.isNullOrUndefined(splitText[1].match(/\<\/sub>/g))) &&
                (splitText[0].match(/\<sub>/g).length % 2 === 1 &&
                    splitText[1].match(/\<\/sub>/g).length % 2 === 1) && cmd === 'SubScript') {
                isFormat = true;
            }
            if ((!sf.base.isNullOrUndefined(splitText[0].match(/\<sup>/g)) && !sf.base.isNullOrUndefined(splitText[1].match(/\<\/sup>/g))) &&
                (splitText[0].match(/\<sup>/g).length % 2 === 1 && splitText[1].match(/\<\/sup>/g).length % 2 === 1) &&
                cmd === 'SuperScript') {
                isFormat = true;
            }
            /* eslint-enable */
        }
        if ((this.isBold(splitText[0], cmdB) && this.isBold(splitText[1], cmdB)) &&
            (splitText[0].match(this.multiCharRegx(cmdB)).length % 2 === 1 &&
                splitText[1].match(this.multiCharRegx(cmdB)).length % 2 === 1) && cmd === 'Bold') {
            isFormat = true;
        }
        splitText[0] = this.isBold(splitText[0], cmdB) ? splitText[0].replace(this.multiCharRegx(cmdB), '$%@') : splitText[0];
        splitText[1] = this.isBold(splitText[1], cmdB) ? splitText[1].replace(this.multiCharRegx(cmdB), '$%@') : splitText[1];
        if ((!sf.base.isNullOrUndefined(this.isMatch(splitText[0], this.syntax.Italic)) &&
            !sf.base.isNullOrUndefined(this.isMatch(splitText[1], this.syntax.Italic))) &&
            (this.isMatch(splitText[0], this.syntax.Italic).length % 2 === 1 &&
                this.isMatch(splitText[1], this.syntax.Italic).length % 2 === 1) && cmd === 'Italic') {
            isFormat = true;
        }
        if ((!sf.base.isNullOrUndefined(this.isMatch(splitText[0], this.syntax.StrikeThrough)) &&
            !sf.base.isNullOrUndefined(this.isMatch(splitText[1], this.syntax.StrikeThrough))) &&
            (this.isMatch(splitText[0], this.syntax.StrikeThrough).length % 2 === 1 &&
                this.isMatch(splitText[1], this.syntax.StrikeThrough).length % 2 === 1) && cmd === 'StrikeThrough') {
            isFormat = true;
        }
        if ((!sf.base.isNullOrUndefined(this.isMatch(splitText[0], this.syntax.InlineCode)) &&
            !sf.base.isNullOrUndefined(this.isMatch(splitText[1], this.syntax.InlineCode))) &&
            (this.isMatch(splitText[0], this.syntax.InlineCode).length % 2 === 1 &&
                this.isMatch(splitText[1], this.syntax.InlineCode).length % 2 === 1) && cmd === 'InlineCode') {
            isFormat = true;
        }
        /* eslint-disable */
        if ((!sf.base.isNullOrUndefined(splitText[0].match(/\<sub>/g)) && !sf.base.isNullOrUndefined(splitText[1].match(/\<\/sub>/g))) &&
            (splitText[0].match(/\<sub>/g).length % 2 === 1 && splitText[1].match(/\<\/sub>/g).length % 2 === 1) && cmd === 'SubScript') {
            isFormat = true;
        }
        if ((!sf.base.isNullOrUndefined(splitText[0].match(/\<sup>/g)) && !sf.base.isNullOrUndefined(splitText[1].match(/\<\/sup>/g))) &&
            (splitText[0].match(/\<sup>/g).length % 2 === 1 && splitText[1].match(/\<\/sup>/g).length % 2 === 1) && cmd === 'SuperScript') {
            isFormat = true;
            /* eslint-enable */
        }
        return isFormat;
    };
    MDSelectionFormats.prototype.applyCommands = function (e) {
        this.currentAction = e.subCommand;
        var textArea = this.parent.element;
        this.selection.save(textArea.selectionStart, textArea.selectionEnd);
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var addedLength = 0;
        var selection = this.parent.markdownSelection.getSelectedInlinePoints(textArea);
        if (this.isAppliedCommand(e.subCommand) && selection.text !== '') {
            var startCmd = this.syntax[e.subCommand];
            var endCmd = e.subCommand === 'SubScript' ? '</sub>' :
                e.subCommand === 'SuperScript' ? '</sup>' : this.syntax[e.subCommand];
            var startLength = (e.subCommand === 'UpperCase' || e.subCommand === 'LowerCase') ? 0 : startCmd.length;
            var startNo = textArea.value.substr(0, selection.start).lastIndexOf(startCmd);
            var endNo = textArea.value.substr(selection.end, textArea.value.length).indexOf(endCmd);
            endNo = endNo + selection.end;
            var repStartText = this.replaceAt(textArea.value.substr(0, selection.start), startCmd, '', startNo, selection.start);
            var repEndText = this.replaceAt(textArea.value.substr(selection.end, textArea.value.length), endCmd, '', 0, endNo);
            textArea.value = repStartText + selection.text + repEndText;
            this.restore(textArea, start - startLength, end - startLength, e);
            return;
        }
        if (selection.text !== '' && !this.isApplied(selection, e.subCommand)) {
            addedLength = (e.subCommand === 'UpperCase' || e.subCommand === 'LowerCase') ? 0 :
                this.syntax[e.subCommand].length;
            var repStart = textArea.value.substr(selection.start - this.syntax[e.subCommand].length, this.syntax[e.subCommand].length);
            var repEnd = void 0;
            if ((repStart === e.subCommand) || ((selection.start - this.syntax[e.subCommand].length ===
                textArea.value.indexOf(this.syntax[e.subCommand])) && (selection.end === textArea.value.lastIndexOf(this.syntax[e.subCommand]) || selection.end === textArea.value.lastIndexOf('</' + this.syntax[e.subCommand].substring(1, 5))))) {
                if (e.subCommand === 'SubScript' || e.subCommand === 'SuperScript') {
                    repEnd = textArea.value.substr(selection.end, this.syntax[e.subCommand].length + 1);
                }
                else {
                    repEnd = textArea.value.substr(selection.end, this.syntax[e.subCommand].length);
                }
                var repStartText = this.replaceAt(textArea.value.substr(0, selection.start), repStart, '', selection.start - this.syntax[e.subCommand].length, selection.start);
                var repEndText = this.replaceAt(textArea.value.substr(selection.end, textArea.value.length), repEnd, '', 0, repEnd.length);
                textArea.value = repStartText + selection.text + repEndText;
                this.restore(textArea, start - addedLength, end - addedLength, e);
            }
            else {
                if (e.subCommand === 'SubScript' || e.subCommand === 'SuperScript') {
                    selection.text = this.syntax[e.subCommand] + selection.text
                        + '</' + this.syntax[e.subCommand].substring(1, 5);
                }
                else if (e.subCommand === 'UpperCase' || e.subCommand === 'LowerCase') {
                    selection.text = (e.subCommand === 'UpperCase') ? selection.text.toUpperCase()
                        : selection.text.toLowerCase();
                }
                else {
                    selection.text = this.syntax[e.subCommand] + selection.text + this.syntax[e.subCommand];
                }
                textArea.value = textArea.value.substr(0, selection.start) + selection.text +
                    textArea.value.substr(selection.end, textArea.value.length);
                this.restore(textArea, start + addedLength, end + addedLength, e);
            }
        }
        else if (e.subCommand !== 'UpperCase' && e.subCommand !== 'LowerCase') {
            if (e.subCommand === 'SubScript' || e.subCommand === 'SuperScript') {
                selection.text = this.textReplace(selection.text, e.subCommand);
                selection.text = this.syntax[e.subCommand] + selection.text
                    + '</' + this.syntax[e.subCommand].substring(1, 5);
            }
            else {
                selection.text = this.textReplace(selection.text, e.subCommand);
                selection.text = this.syntax[e.subCommand] + selection.text + this.syntax[e.subCommand];
            }
            textArea.value = textArea.value.substr(0, selection.start)
                + selection.text + textArea.value.substr(selection.end, textArea.value.length);
            addedLength = this.syntax[e.subCommand].length;
            if (selection.start === selection.end) {
                this.restore(textArea, start + addedLength, end + addedLength, e);
            }
            else {
                this.restore(textArea, start + addedLength, end - addedLength, e);
            }
        }
        else {
            this.restore(textArea, start, end, e);
        }
        this.parent.undoRedoManager.saveData();
    };
    MDSelectionFormats.prototype.replaceAt = function (input, search, replace, start, end) {
        return input.slice(0, start)
            + input.slice(start, end).replace(search, replace)
            + input.slice(end);
    };
    MDSelectionFormats.prototype.restore = function (textArea, start, end, event) {
        this.selection.save(start, end);
        this.selection.restore(textArea);
        if (event && event.callBack) {
            event.callBack({
                requestType: this.currentAction,
                selectedText: this.selection.getSelectedText(textArea),
                editorMode: 'Markdown',
                event: event.event
            });
        }
    };
    MDSelectionFormats.prototype.textReplace = function (text, command) {
        var regx = this.singleCharRegx(this.syntax[command]);
        switch (command) {
            case 'Bold':
                regx = this.multiCharRegx(this.syntax[command].substr(0, 1));
                text = text.replace(regx, '');
                break;
            case 'Italic':
                if (!this.isBold(text, this.syntax[command].substr(0, 1))) {
                    text = text.replace(regx, '');
                }
                else {
                    var regxB = this.multiCharRegx(this.syntax[command].substr(0, 1));
                    var repText = text;
                    repText = repText.replace(regxB, '$%@').replace(regx, '');
                    var regxTemp = new RegExp('\\$%@', 'g');
                    text = repText.replace(regxTemp, this.syntax[command].substr(0, 1) + this.syntax[command].substr(0, 1));
                }
                break;
            case 'StrikeThrough':
                text = text.replace(regx, '');
                break;
            case 'InlineCode':
                text = text.replace(regx, '');
                break;
            case 'SubScript':
                text = text.replace(/<sub>/g, '').replace(/<\/sub>/g, '');
                break;
            case 'SuperScript':
                text = text.replace(/<sup>/g, '').replace(/<\/sup>/g, '');
                break;
        }
        return text;
    };
    MDSelectionFormats.prototype.isApplied = function (line, command) {
        var regx = this.singleCharRegx(this.syntax[command]);
        switch (command) {
            case 'SubScript':
            case 'SuperScript':
                regx = this.singleCharRegx(this.syntax[command]);
                return regx.test(line.text);
            case 'Bold':
            case 'StrikeThrough':
                regx = this.multiCharRegx(this.syntax[command].substr(0, 1));
                return regx.test(line.text);
            case 'UpperCase':
            case 'LowerCase':
                regx = new RegExp('^[' + this.syntax[command] + ']*$', 'g');
                return regx.test(line.text);
            case 'Italic': {
                var regTest = void 0;
                var regxB = this.multiCharRegx(this.syntax[command].substr(0, 1));
                if (regxB.test(line.text)) {
                    var repText = line.text;
                    repText = repText.replace(regxB, '$%#');
                    regTest = regx.test(repText);
                }
                else {
                    regTest = regx.test(line.text);
                }
                return regTest;
            }
            case 'InlineCode':
                return regx.test(line.text);
        }
    };
    return MDSelectionFormats;
}());

/**
 * `Undo` module is used to handle undo actions.
 */
var UndoRedoCommands = /** @class */ (function () {
    function UndoRedoCommands(parent, options) {
        this.undoRedoStack = [];
        this.parent = parent;
        this.undoRedoSteps = !sf.base.isNullOrUndefined(options) ? options.undoRedoSteps : 30;
        this.undoRedoTimer = !sf.base.isNullOrUndefined(options) ? options.undoRedoTimer : 300;
        this.selection = this.parent.markdownSelection;
        this.addEventListener();
    }
    UndoRedoCommands.prototype.addEventListener = function () {
        var debounceListener = sf.base.debounce(this.keyUp, this.undoRedoTimer);
        this.parent.observer.on(KEY_UP_HANDLER, debounceListener, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.keyDown, this);
        this.parent.observer.on(ACTION, this.onAction, this);
        this.parent.observer.on(MODEL_CHANGED_PLUGIN, this.onPropertyChanged, this);
    };
    UndoRedoCommands.prototype.onPropertyChanged = function (props) {
        for (var _i = 0, _a = Object.keys(props.newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'undoRedoSteps':
                    this.undoRedoSteps = props.newProp.undoRedoSteps;
                    break;
                case 'undoRedoTimer':
                    this.undoRedoTimer = props.newProp.undoRedoTimer;
                    break;
            }
        }
    };
    UndoRedoCommands.prototype.removeEventListener = function () {
        var debounceListener = sf.base.debounce(this.keyUp, 300);
        this.parent.observer.off(KEY_UP_HANDLER, debounceListener);
        this.parent.observer.off(KEY_DOWN_HANDLER, this.keyDown);
        this.parent.observer.off(ACTION, this.onAction);
        this.parent.observer.off(MODEL_CHANGED_PLUGIN, this.onPropertyChanged);
    };
    /**
     * Destroys the ToolBar.
     *
     * @function destroy
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoCommands.prototype.destroy = function () {
        this.removeEventListener();
    };
    /**
     * onAction method
     *
     * @param {IMarkdownSubCommands} e - specifies the sub commands
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoCommands.prototype.onAction = function (e) {
        if (e.subCommand === 'Undo') {
            this.undo(e);
        }
        else {
            this.redo(e);
        }
    };
    UndoRedoCommands.prototype.keyDown = function (e) {
        var event = e.event;
        // eslint-disable-next-line
        var proxy = this;
        switch (event.action) {
            case 'undo':
                event.preventDefault();
                proxy.undo(e);
                break;
            case 'redo':
                event.preventDefault();
                proxy.redo(e);
                break;
        }
    };
    UndoRedoCommands.prototype.keyUp = function (e) {
        if (e.event.keyCode !== 17 && !e.event.ctrlKey) {
            this.saveData(e);
        }
    };
    /**
     * MD collection stored string format.
     *
     * @param {KeyboardEvent} e - specifies the key board event
     * @function saveData
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoCommands.prototype.saveData = function (e) {
        var textArea = this.parent.element;
        this.selection.save(textArea.selectionStart, textArea.selectionEnd);
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var textValue = this.parent.element.value;
        var changEle = { text: textValue, start: start, end: end };
        if (this.undoRedoStack.length >= this.steps) {
            this.undoRedoStack = this.undoRedoStack.slice(0, this.steps + 1);
        }
        if (this.undoRedoStack.length > 1 && (this.undoRedoStack[this.undoRedoStack.length - 1].start === start) &&
            (this.undoRedoStack[this.undoRedoStack.length - 1].end === end)) {
            return;
        }
        this.undoRedoStack.push(changEle);
        this.steps = this.undoRedoStack.length - 1;
        if (this.steps > this.undoRedoSteps) {
            this.undoRedoStack.shift();
            this.steps--;
        }
        if (e && e.callBack) {
            e.callBack();
        }
    };
    /**
     * Undo the editable text.
     *
     * @param {IMarkdownSubCommands} e - specifies the sub commands
     * @function undo
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoCommands.prototype.undo = function (e) {
        if (this.steps > 0) {
            this.currentAction = 'Undo';
            var start = this.undoRedoStack[this.steps - 1].start;
            var end = this.undoRedoStack[this.steps - 1].end;
            var removedContent = this.undoRedoStack[this.steps - 1].text;
            this.parent.element.value = removedContent;
            this.parent.element.focus();
            this.steps--;
            this.restore(this.parent.element, start, end, e);
        }
    };
    /**
     * Redo the editable text.
     *
     * @param {IMarkdownSubCommands} e - specifies the sub commands
     * @function redo
     * @returns {void}
     * @hidden
     * @deprecated
     */
    UndoRedoCommands.prototype.redo = function (e) {
        if (this.undoRedoStack[this.steps + 1] != null) {
            this.currentAction = 'Redo';
            var start = this.undoRedoStack[this.steps + 1].start;
            var end = this.undoRedoStack[this.steps + 1].end;
            this.parent.element.value = this.undoRedoStack[this.steps + 1].text;
            this.parent.element.focus();
            this.steps++;
            this.restore(this.parent.element, start, end, e);
        }
    };
    UndoRedoCommands.prototype.restore = function (textArea, start, end, event) {
        this.selection.save(start, end);
        this.selection.restore(textArea);
        if (event && event.callBack) {
            event.callBack({
                requestType: this.currentAction,
                selectedText: this.selection.getSelectedText(textArea),
                editorMode: 'Markdown',
                event: event.event
            });
        }
    };
    /**
     * getUndoStatus method
     *
     * @returns {boolean} - returns the boolean value
     * @hidden
     * @deprecated
     */
    UndoRedoCommands.prototype.getUndoStatus = function () {
        var status = { undo: false, redo: false };
        if (this.steps > 0) {
            status.undo = true;
        }
        if (this.undoRedoStack[this.steps + 1] != null) {
            status.redo = true;
        }
        return status;
    };
    return UndoRedoCommands;
}());

/**
 * Link internal component
 *
 * @hidden
 * @deprecated
 */
var MDLink = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {MarkdownParser} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function MDLink(parent) {
        this.parent = parent;
        this.selection = this.parent.markdownSelection;
        this.addEventListener();
    }
    MDLink.prototype.addEventListener = function () {
        this.parent.observer.on(LINK_COMMAND, this.createLink, this);
    };
    MDLink.prototype.createLink = function (e) {
        var textArea = this.parent.element;
        textArea.focus();
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var text = (e.subCommand === 'Image') ? this.selection.getSelectedText(textArea) : e.item.text;
        var startOffset = (e.subCommand === 'Image') ? (start + 2) : (start + 1);
        var endOffset = (e.subCommand === 'Image') ? (end + 2) : (end + 1);
        text = (e.subCommand === 'Image') ? '![' + text + '](' + e.item.url + ')' : '[' + text + '](' + e.item.url + ')';
        textArea.value = textArea.value.substr(0, start)
            + text + textArea.value.substr(end, textArea.value.length);
        this.parent.markdownSelection.setSelection(textArea, startOffset, endOffset);
        this.restore(textArea, startOffset, endOffset, e);
    };
    MDLink.prototype.restore = function (textArea, start, end, event) {
        this.selection.save(start, end);
        this.selection.restore(textArea);
        if (event && event.callBack) {
            event.callBack({
                requestType: event.subCommand,
                selectedText: this.selection.getSelectedText(textArea),
                editorMode: 'Markdown',
                event: event.event
            });
        }
    };
    return MDLink;
}());

/**
 * Link internal component
 *
 * @hidden
 * @deprecated
 */
var MDTable = /** @class */ (function () {
    /**
     * Constructor for creating the Formats plugin
     *
     * @param {IMDTable} options - specifies the options
     * @hidden
     * @deprecated
     */
    function MDTable(options) {
        sf.base.extend(this, this, options, true);
        this.selection = this.parent.markdownSelection;
        this.addEventListener();
    }
    MDTable.prototype.addEventListener = function () {
        this.parent.observer.on(MD_TABLE, this.createTable, this);
        this.parent.observer.on(KEY_DOWN_HANDLER, this.onKeyDown, this);
    };
    MDTable.prototype.removeEventListener = function () {
        this.parent.observer.off(MD_TABLE, this.createTable);
        this.parent.observer.off(KEY_DOWN_HANDLER, this.onKeyDown);
    };
    /**
     * markdown destroy method
     *
     * @returns {void}
     * @hidden
     * @deprecated
     */
    MDTable.prototype.destroy = function () {
        this.removeEventListener();
    };
    MDTable.prototype.onKeyDown = function (e) {
        if (e.event.action === 'insert-table') {
            e.item = e.value;
            this.createTable(e);
        }
    };
    MDTable.prototype.createTable = function (e) {
        this.element = this.parent.element;
        var start = this.element.selectionStart;
        var end = this.element.selectionEnd;
        var textAreaInitial = this.element.value;
        this.locale = e;
        this.selection.save(start, end);
        this.restore(this.element.selectionStart, this.element.selectionEnd, null);
        this.insertTable(start, end, textAreaInitial, e);
    };
    MDTable.prototype.getTable = function () {
        var table = '';
        table += this.textNonEmpty();
        table += this.tableHeader(this.locale);
        table += this.tableCell(this.locale);
        return table;
    };
    MDTable.prototype.tableHeader = function (e) {
        var text = '';
        for (var i = 1; i <= 2; i++) {
            text += '|';
            for (var j = 1; j <= 2; j++) {
                if (i === 1) {
                    text += e.item.headingText + ' ' + j + '|';
                }
                else {
                    text += '---------|';
                }
            }
            text += this.insertLine();
        }
        return text;
    };
    MDTable.prototype.tableCell = function (e) {
        var text = '';
        for (var i = 1; i <= 2; i++) {
            text += '|';
            for (var j = 1; j <= 2; j++) {
                text += e.item.colText + ' ' + this.convertToLetters(i) + j + '|';
            }
            text += this.insertLine();
        }
        text += this.insertLine();
        return text;
    };
    MDTable.prototype.insertLine = function () {
        var dummyElement = document.createElement('div');
        dummyElement.innerHTML = '\n';
        return dummyElement.textContent;
    };
    MDTable.prototype.insertTable = function (start, end, textAreaInitial, e) {
        var parentText = this.selection.getSelectedParentPoints(this.element);
        var lastLineSplit = parentText[parentText.length - 1].text.split(' ', 2);
        var syntaxArr = this.getFormatTag();
        // eslint-disable-next-line
        if (lastLineSplit.length < 2) {
            this.element.value = this.updateValue(this.getTable());
            this.makeSelection(textAreaInitial, start, end);
        }
        else {
            if (this.ensureFormatApply(parentText[parentText.length - 1].text)) {
                this.checkValid(start, end, this.getTable(), textAreaInitial, e, lastLineSplit, parentText, syntaxArr);
            }
            else {
                this.element.value = this.updateValue(this.getTable());
                this.makeSelection(textAreaInitial, start, end);
            }
        }
        this.restore(this.element.selectionStart, this.element.selectionEnd, e);
    };
    MDTable.prototype.makeSelection = function (textAreaInitial, start, end) {
        end = start + (textAreaInitial.length > 0 ? 12 : 10); //end is added 12 or 10 because to make the table heading selected
        start += textAreaInitial.length > 0 ? 3 : 1; // Start is added 3 or 1 because new lines are added when inserting table
        this.selection.setSelection(this.element, start, end);
    };
    MDTable.prototype.getFormatTag = function () {
        var syntaxFormatKey = Object.keys(this.syntaxTag.Formats);
        var syntaxListKey = Object.keys(this.syntaxTag.List);
        var syntaxArr = [];
        for (var i = 0; i < syntaxFormatKey.length; i++) {
            syntaxArr.push(this.syntaxTag.Formats[syntaxFormatKey[i]]);
        }
        for (var j = 0; j < syntaxListKey.length; j++) {
            syntaxArr.push(this.syntaxTag.List[syntaxListKey[j]]);
        }
        return syntaxArr;
    };
    MDTable.prototype.ensureFormatApply = function (line) {
        var formatTags = this.getFormatTag();
        var formatSplitZero = line.trim().split(' ', 2)[0] + ' ';
        for (var i = 0; i < formatTags.length; i++) {
            if (formatSplitZero === formatTags[i] || /^[\d.]+[ ]+$/.test(formatSplitZero)) {
                return true;
            }
        }
        return false;
    };
    MDTable.prototype.ensureStartValid = function (firstLine, parentText) {
        var firstLineSplit = parentText[0].text.split(' ', 2);
        for (var i = firstLine + 1; i <= firstLine + firstLineSplit[0].length + 1; i++) {
            if (this.element.selectionStart === i || this.element.selectionEnd === i) {
                return false;
            }
        }
        return true;
    };
    MDTable.prototype.ensureEndValid = function (lastLine, formatSplitLength) {
        for (var i = lastLine + 1; i <= lastLine + formatSplitLength + 1; i++) {
            if (this.element.selectionEnd === i) {
                return false;
            }
        }
        return true;
    };
    MDTable.prototype.updateValueWithFormat = function (formatSplit, text) {
        var textApplyFormat = this.element.value.substring(this.element.selectionEnd, this.element.value.length);
        text += textApplyFormat.replace(textApplyFormat, (formatSplit[0] + ' ' + textApplyFormat));
        return this.element.value.substr(0, this.element.selectionStart) + text;
    };
    MDTable.prototype.updateValue = function (text) {
        return this.element.value.substr(0, this.element.selectionStart) + text +
            this.element.value.substr(this.element.selectionEnd, this.element.value.length);
    };
    MDTable.prototype.checkValid = function (start, end, text, textAreaInitial, 
    // eslint-disable-next-line
    e, formatSplit, parentText, syntaxArr) {
        if (this.ensureStartValid(parentText[0].start, parentText) &&
            this.ensureEndValid(parentText[parentText.length - 1].start, formatSplit[0].length)) {
            if (start === parentText[0].start) {
                if (start !== end && end !== (parentText[parentText.length - 1].end - 1)) {
                    this.element.value = this.updateValueWithFormat(formatSplit, text);
                }
                else {
                    this.element.value = this.updateValue(text);
                }
            }
            else if (end === parentText[parentText.length - 1].end - 1) {
                this.element.value = this.updateValue(text);
            }
            else {
                this.element.value = this.updateValueWithFormat(formatSplit, text);
            }
            this.makeSelection(textAreaInitial, start, end);
        }
    };
    MDTable.prototype.convertToLetters = function (rowNumber) {
        var baseChar = ('A').charCodeAt(0);
        var letters = '';
        do {
            rowNumber -= 1;
            letters = String.fromCharCode(baseChar + (rowNumber % 26)) + letters;
            rowNumber = (rowNumber / 26) >> 0;
        } while (rowNumber > 0);
        return letters;
    };
    MDTable.prototype.textNonEmpty = function () {
        var emptyText = '';
        if (this.isCursorBased() || this.isSelectionBased()) {
            if (this.element.value.length > 0) {
                emptyText += this.insertLine();
                emptyText += this.insertLine(); // to append two new line when textarea having content.
            }
        }
        return emptyText;
    };
    MDTable.prototype.isCursorBased = function () {
        return this.element.selectionStart === this.element.selectionEnd;
    };
    MDTable.prototype.isSelectionBased = function () {
        return this.element.selectionStart !== this.element.selectionEnd;
    };
    MDTable.prototype.restore = function (start, end, event) {
        this.selection.save(start, end);
        this.selection.restore(this.element);
        if (event && event.callBack) {
            event.callBack({
                requestType: event.subCommand,
                selectedText: this.selection.getSelectedText(this.element),
                editorMode: 'Markdown',
                event: event.event
            });
        }
    };
    return MDTable;
}());

/**
 * Link internal component
 *
 * @hidden
 * @deprecated
 */
var ClearFormat$1 = /** @class */ (function () {
    /**
     * Constructor for creating the clear format plugin
     *
     * @param {MarkdownParser} parent - specifies the parent element
     * @hidden
     * @deprecated
     */
    function ClearFormat(parent) {
        this.parent = parent;
        this.selection = this.parent.markdownSelection;
        this.addEventListener();
    }
    ClearFormat.prototype.addEventListener = function () {
        this.parent.observer.on(CLEAR_COMMAND, this.clear, this);
    };
    ClearFormat.prototype.replaceRegex = function (data) {
        /* eslint-disable */
        return data.replace(/\*/ig, '\\*').replace(/\&/ig, '\\&')
            .replace(/\-/ig, '\\-').replace(/\^/ig, '\\^')
            .replace(/\$/ig, '\\$').replace(/\./ig, '\\.')
            .replace(/\|/ig, '\\|').replace(/\?/ig, '\\?')
            .replace(/\+/ig, '\\+').replace(/\-/ig, '\\-')
            .replace(/\&/ig, '\\&');
        /* eslint-enable */
    };
    ClearFormat.prototype.clearSelectionTags = function (text) {
        var data = this.parent.selectionTags;
        var keys = Object.keys(data);
        for (var num = 0; num < keys.length; num++) {
            var key = keys[num];
            // eslint-disable-next-line
            if (data.hasOwnProperty(key) && data[key] !== '') {
                var expString = this.replaceRegex(data[key]);
                var regExp = void 0;
                var startExp = data[key].length;
                var endExp = (data[key] === '<sup>' || data[key] === '<sub>') ? data[key].length + 1 : data[key].length;
                if (data[key] === '<sup>') {
                    // eslint-disable-next-line
                    regExp = new RegExp('<sup>(.*?)<\/sup>', 'ig');
                }
                else if (data[key] === '<sub>') {
                    // eslint-disable-next-line
                    regExp = new RegExp('<sub>(.*?)<\/sub>', 'ig');
                }
                else {
                    regExp = new RegExp(expString + '(.*?)' + expString, 'ig');
                }
                var val = text.match(regExp);
                for (var index = 0; val && index < val.length && val[index] !== ''; index++) {
                    text = text.replace(val[index], val[index].substr(startExp, val[index].length - endExp - startExp));
                }
            }
        }
        return text;
    };
    ClearFormat.prototype.clearFormatTags = function (text) {
        var lines = text.split('\n');
        return this.clearFormatLines(lines);
    };
    ClearFormat.prototype.clearFormatLines = function (lines) {
        var tags = [this.parent.formatTags, this.parent.listTags];
        var str = '';
        for (var len = 0; len < lines.length; len++) {
            for (var num = 0; num < tags.length; num++) {
                var data = tags[num];
                var keys = Object.keys(data);
                for (var index = 0; index < keys.length; index++) {
                    var key = keys[index];
                    // eslint-disable-next-line
                    if (data.hasOwnProperty(key) && data[key] !== '') {
                        if (lines[len].indexOf(data[key]) === 0) {
                            lines[len] = lines[len].replace(data[key], '');
                            lines[len] = this.clearFormatLines([lines[len]]);
                        }
                    }
                }
            }
            str = str + lines[len] + ((len !== lines.length - 1) ? '\n' : '');
        }
        return str;
    };
    ClearFormat.prototype.clear = function (e) {
        var textArea = this.parent.element;
        textArea.focus();
        var start = textArea.selectionStart;
        var end = textArea.selectionEnd;
        var text = this.selection.getSelectedText(textArea);
        text = this.clearSelectionTags(text);
        text = this.clearFormatTags(text);
        textArea.value = textArea.value.substr(0, start)
            + text + textArea.value.substr(end, textArea.value.length);
        this.parent.markdownSelection.setSelection(textArea, start, start + text.length);
        this.restore(textArea, start, start + text.length, e);
    };
    ClearFormat.prototype.restore = function (textArea, start, end, event) {
        this.selection.save(start, end);
        this.selection.restore(textArea);
        if (event && event.callBack) {
            event.callBack({
                requestType: event.subCommand,
                selectedText: this.selection.getSelectedText(textArea),
                editorMode: 'Markdown',
                event: event.event
            });
        }
    };
    return ClearFormat;
}());

/**
 * MarkdownParser internal component
 *
 * @hidden
 * @deprecated
 */
var MarkdownParser = /** @class */ (function () {
    /**
     * Constructor for creating the component
     *
     * @param {IMarkdownParserModel} options - specifies the options
     * @hidden
     * @deprecated
     */
    function MarkdownParser(options) {
        this.initialize();
        sf.base.extend(this, this, options, true);
        this.observer = new sf.base.Observer(this);
        this.markdownSelection = new MarkdownSelection();
        this.listObj = new MDLists({ parent: this, syntax: this.listTags });
        this.formatObj = new MDFormats({ parent: this, syntax: this.formatTags });
        this.undoRedoManager = new UndoRedoCommands(this, options.options);
        this.mdSelectionFormats = new MDSelectionFormats({ parent: this, syntax: this.selectionTags });
        this.linkObj = new MDLink(this);
        this.tableObj = new MDTable({ parent: this, syntaxTag: ({ Formats: this.formatTags, List: this.listTags }) });
        this.clearObj = new ClearFormat$1(this);
        this.wireEvents();
    }
    MarkdownParser.prototype.initialize = function () {
        this.formatTags = markdownFormatTags;
        this.listTags = markdownListsTags;
        this.selectionTags = markdownSelectionTags;
    };
    MarkdownParser.prototype.wireEvents = function () {
        this.observer.on(KEY_DOWN, this.editorKeyDown, this);
        this.observer.on(KEY_UP, this.editorKeyUp, this);
        this.observer.on(MODEL_CHANGED, this.onPropertyChanged, this);
    };
    MarkdownParser.prototype.onPropertyChanged = function (props) {
        this.observer.notify(MODEL_CHANGED_PLUGIN, props);
    };
    MarkdownParser.prototype.editorKeyDown = function (e) {
        this.observer.notify(KEY_DOWN_HANDLER, e);
    };
    MarkdownParser.prototype.editorKeyUp = function (e) {
        this.observer.notify(KEY_UP_HANDLER, e);
    };
    /* eslint-disable */
    /**
     * markdown execCommand method
     *
     * @param {MarkdownExecCommand} command - specifies the command
     * @param {T} - specifies the value
     * @param {Event} event - specifies the event
     * @param {Function} callBack - specifies the call back function
     * @param {string} text - specifies the string value
     * @param {T} exeValue - specifies the value
     * @returns {void}
     * @hidden
     * @deprecated
     */
    /* eslint-enable */
    MarkdownParser.prototype.execCommand = function (command, value, event, callBack, text, exeValue) {
        switch (command.toLocaleLowerCase()) {
            case 'lists':
                this.observer.notify(LISTS_COMMAND, { subCommand: value, event: event, callBack: callBack });
                break;
            case 'formats':
                this.observer.notify(FORMAT_TYPE, { subCommand: value, event: event, callBack: callBack });
                break;
            case 'actions':
                this.observer.notify(ACTION, { subCommand: value, event: event, callBack: callBack });
                break;
            case 'style':
            case 'effects':
            case 'casing':
                this.observer.notify(selectionCommand, { subCommand: value, event: event, callBack: callBack });
                break;
            case 'links':
            case 'images':
                this.observer.notify(LINK_COMMAND, { subCommand: value, event: event, callBack: callBack, item: exeValue });
                break;
            case 'table':
                switch (value.toString().toLocaleLowerCase()) {
                    case 'createtable':
                        this.observer.notify(MD_TABLE, { subCommand: value, item: exeValue, event: event, callBack: callBack });
                        break;
                }
                break;
            case 'clear':
                this.observer.notify(CLEAR_COMMAND, { subCommand: value, event: event, callBack: callBack });
                break;
        }
    };
    return MarkdownParser;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Markdown adapter
 */
var MarkdownFormatter = /** @class */ (function (_super) {
    __extends$1(MarkdownFormatter, _super);
    function MarkdownFormatter(options) {
        var _this = _super.call(this) || this;
        _this.initialize();
        sf.base.extend(_this, _this, options, true);
        if (options && _this.element) {
            _this.updateFormatter(_this.element, document, options.options);
        }
        return _this;
    }
    MarkdownFormatter.prototype.initialize = function () {
        this.keyConfig = markdownKeyConfig;
        this.formatSyntax = markdownFormatTags;
        this.listSyntax = markdownListsTags;
        this.selectionSyntax = markdownSelectionTags;
    };
    MarkdownFormatter.prototype.updateFormatter = function (editElement, doc, options) {
        if (editElement) {
            this.editorManager = new MarkdownParser({
                element: editElement,
                formatTags: this.formatSyntax,
                listTags: this.listSyntax,
                selectionTags: this.selectionSyntax,
                options: options
            });
        }
    };
    return MarkdownFormatter;
}(Formatter));

/**
 * `MarkdownEditor` module is used to markdown editor
 */
var MarkdownEditor = /** @class */ (function () {
    function MarkdownEditor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    MarkdownEditor.prototype.addEventListener = function () {
        this.saveSelection = new MarkdownSelection();
        this.parent.observer.on(initialEnd, this.render, this);
        this.parent.observer.on(markdownToolbarClick, this.onToolbarClick, this);
        this.parent.observer.on(destroy, this.destroy, this);
        this.parent.observer.on(selectAll$1, this.selectAll, this);
        this.parent.observer.on(getSelectedHtml, this.getSelectedHtml, this);
        this.parent.observer.on(selectionSave, this.onSelectionSave, this);
        this.parent.observer.on(selectionRestore, this.onSelectionRestore, this);
        this.parent.observer.on(readOnlyMode, this.updateReadOnly, this);
    };
    MarkdownEditor.prototype.updateReadOnly = function () {
        if (this.parent.readonly) {
            this.parent.getEditPanel().setAttribute('readonly', 'readonly');
            sf.base.addClass([this.parent.element], CLS_RTE_READONLY);
        }
        else {
            this.parent.getEditPanel().removeAttribute('readonly');
            sf.base.removeClass([this.parent.element], CLS_RTE_READONLY);
        }
    };
    MarkdownEditor.prototype.onSelectionSave = function () {
        var textArea = this.parent.getEditPanel();
        this.saveSelection.save(textArea.selectionStart, textArea.selectionEnd);
    };
    MarkdownEditor.prototype.onSelectionRestore = function (e) {
        this.parent.getEditPanel().focus();
        var textArea = this.parent.getEditPanel();
        this.saveSelection.restore(textArea);
    };
    MarkdownEditor.prototype.onToolbarClick = function (args) {
        var text;
        var startOffset;
        var endOffset;
        var item = args.item;
        var textArea = this.parent.getEditPanel();
        textArea.focus();
        startOffset = textArea.selectionStart;
        endOffset = textArea.selectionEnd;
        text = textArea.value.substring(startOffset, endOffset);
        switch (item.subCommand) {
            case 'Maximize':
                this.parent.observer.notify(enableFullScreen, { args: args });
                break;
            case 'Minimize':
                this.parent.observer.notify(disableFullScreen, { args: args });
                break;
            case 'CreateLink':
                this.parent.observer.notify(insertLink, { member: 'link', args: args, text: text, module: 'Markdown' });
                break;
            case 'Image':
                this.parent.observer.notify(insertImage, { member: 'image', args: args, text: text, module: 'Markdown' });
                break;
            case 'CreateTable':
                var tableConstant = {
                    'headingText': this.parent.localeData.headingText,
                    'colText': this.parent.localeData.colText
                };
                this.parent.formatter.process(this.parent, args, args.originalEvent, tableConstant);
                break;
            default:
                this.parent.formatter.process(this.parent, args, args.originalEvent, null);
                break;
        }
    };
    MarkdownEditor.prototype.removeEventListener = function () {
        this.parent.observer.off(initialEnd, this.render);
        this.parent.observer.off(destroy, this.destroy);
        this.parent.observer.off(markdownToolbarClick, this.onToolbarClick);
        this.parent.observer.off(selectAll$1, this.selectAll);
        this.parent.observer.off(getSelectedHtml, this.getSelectedHtml);
        this.parent.observer.off(selectionSave, this.onSelectionSave);
        this.parent.observer.off(selectionRestore, this.onSelectionRestore);
        this.parent.observer.off(readOnlyMode, this.updateReadOnly);
    };
    MarkdownEditor.prototype.render = function () {
        var editElement = this.parent.getEditPanel();
        var option = { undoRedoSteps: this.parent.undoRedoSteps, undoRedoTimer: this.parent.undoRedoTimer };
        if (sf.base.isNullOrUndefined(this.parent.adapter)) {
            this.parent.formatter = new MarkdownFormatter({
                element: editElement,
                options: option
            });
        }
        else {
            this.parent.formatter = new MarkdownFormatter(sf.base.extend({}, this.parent.adapter, {
                element: editElement,
                options: option
            }));
        }
        if (this.parent.toolbarSettings.enable) {
            this.toolbarUpdate = new MarkdownToolbarStatus(this.parent);
        }
        this.parent.observer.notify(bindOnEnd, {});
    };
    MarkdownEditor.prototype.selectAll = function () {
        this.parent.formatter.editorManager.markdownSelection.setSelection(this.parent.getEditPanel(), 0, this.parent.getEditPanel().value.length);
    };
    MarkdownEditor.prototype.getSelectedHtml = function (e) {
        e.callBack(this.parent.formatter.editorManager.markdownSelection.getSelectedText(this.parent.getEditPanel()));
    };
    MarkdownEditor.prototype.destroy = function () {
        this.removeEventListener();
    };
    return MarkdownEditor;
}());

/**
 * `ExecCommandCallBack` module is used to run the editor manager command
 */
var ExecCommandCallBack = /** @class */ (function () {
    function ExecCommandCallBack(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    ExecCommandCallBack.prototype.addEventListener = function () {
        this.parent.observer.on(execCommandCallBack, this.commandCallBack, this);
        this.parent.observer.on(destroy, this.removeEventListener, this);
    };
    ExecCommandCallBack.prototype.commandCallBack = function (args) {
        if (args.requestType !== 'Undo' && args.requestType !== 'Redo') {
            this.parent.formatter.saveData();
        }
        this.parent.observer.notify(toolbarRefresh, { args: args });
        this.parent.observer.notify(count, {});
    };
    ExecCommandCallBack.prototype.removeEventListener = function () {
        this.parent.observer.off(execCommandCallBack, this.commandCallBack);
        this.parent.observer.off(destroy, this.removeEventListener);
    };
    return ExecCommandCallBack;
}());

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * RichTextEditor base
 */
var SfRichTextEditor = /** @class */ (function () {
    //#endregion
    function SfRichTextEditor(element, options, dotnetRef) {
        this.undoRedoSteps = 30;
        this.undoRedoTimer = 300;
        this.floatingToolbarOffset = 0;
        this.enableHtmlEncode = false;
        this.defaultResetValue = null;
        this.isInitial = false;
        this.blurEnabled = false;
        this.focusEnabled = false;
        this.undoRedoStatus = false;
        this.createdEnabled = false;
        this.isIframeRteElement = true;
        this.actionBeginEnabled = false;
        this.imageDeleteEnabled = false;
        this.onResizeStopEnabled = false;
        this.quickTbClosedEnabled = false;
        this.quickTbOpenedEnabled = false;
        this.onQuickTbOpenEnabled = false;
        this.onResizeStartEnabled = false;
        this.actionCompleteEnabled = false;
        this.beforeUploadImageEnabled = false;
        this.onImageUploadFailedEnabled = false;
        this.onImageUploadSuccessEnabled = false;
        this.beforePasteCleanupEnabled = false;
        this.afterPasteCleanupEnabled = false;
        this.inlineCloseItems = ['CreateLink', 'Image', 'CreateTable', 'Maximize', 'Minimize'];
        if (sf.base.isNullOrUndefined(element)) {
            return;
        }
        this.element = element;
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
        this.updateContext(options);
        this.observer = new sf.base.Observer(this);
        this.dotNetRef.invokeMethodAsync('UpdateDeviceData', { isDevice: sf.base.Browser.isDevice, isIDevice: isIDevice() });
        this.initModules();
    }
    //#region Internal methods
    SfRichTextEditor.prototype.updateContext = function (rteObj) {
        sf.base.extend(this, this, rteObj);
    };
    SfRichTextEditor.prototype.initModules = function () {
        if (this.editorMode === 'HTML') {
            this.htmlEditorModule = new HtmlEditor(this);
            this.pasteCleanupModule = new PasteCleanup(this);
        }
        else {
            this.markdownEditorModule = new MarkdownEditor(this);
        }
        if (this.toolbarSettings.enable) {
            this.isUndoRedoStatus();
            this.toolbarModule = new Toolbar(this);
        }
        this.fullScreenModule = new FullScreen(this);
        this.viewSourceModule = new ViewSource(this);
        this.countModule = new Count(this);
        this.resizeModule = new Resize(this);
        this.linkModule = new Link(this);
        this.imageModule = new Image(this);
        this.tableModule = new Table(this);
        this.quickToolbarModule = new QuickToolbar(this);
    };
    SfRichTextEditor.prototype.initialize = function () {
        this.isInitial = true;
        this.onBlurHandler = this.blurHandler.bind(this);
        this.onFocusHandler = this.focusHandler.bind(this);
        this.onResizeHandler = this.resizeHandler.bind(this);
        var execCommandCallBack$$1 = new ExecCommandCallBack(this);
        this.id = this.element.id;
        this.clickPoints = { clientX: 0, clientY: 0 };
        this.updateContentElements();
        this.inputElement = this.getEditPanel();
        this.valueContainer = this.element.querySelector('textarea');
        if (this.readonly) {
            this.setReadOnly(true);
        }
        this.setHeight(this.height);
        this.setWidth(this.width);
        // setStyleAttribute(this.element, { 'width': formatUnit(this.width) });
        this.setContentHeight();
        if (this.iframeSettings && this.iframeSettings.enable) {
            this.setIframeSettings();
        }
        if (sf.base.isNullOrUndefined(this.value) || this.value === '') {
            this.value = this.element.querySelector('.e-rte-value-wrapper').innerHTML.replace(/<!--!-->/gi, '').trim();
        }
        this.setPanelValue(this.value);
        this.observer.notify(initialEnd, {});
        if (this.enableXhtml) {
            this.value = this.getXhtml();
        }
        if (this.value !== null) {
            this.defaultResetValue = this.value;
        }
        this.wireEvents();
        if (this.createdEnabled) {
            this.dotNetRef.invokeMethodAsync('CreatedEvent');
        }
    };
    SfRichTextEditor.prototype.isUndoRedoStatus = function () {
        for (var i = 0; i < this.toolbarSettings.items.length; i++) {
            if (!sf.base.isNullOrUndefined(this.toolbarSettings.items[i]) && (this.toolbarSettings.items[i].subCommand === 'Undo'
                || this.toolbarSettings.items[i].subCommand === 'Redo')) {
                this.undoRedoStatus = true;
                break;
            }
        }
    };
    SfRichTextEditor.prototype.setPanelValue = function (value, isReset) {
        value = this.serializeValue(value);
        if (this.editorMode === 'HTML' && this.enableXhtml) {
            this.inputElement.innerHTML = value;
            this.observer.notify(xhtmlValidation, {});
            value = this.inputElement.innerHTML;
        }
        if (this.editorMode === 'HTML' && !isReset) {
            this.value = getEditValue(sf.base.isNullOrUndefined(value) ? '' : value, this);
        }
        this.updatePanelValue();
        if (this.value !== this.cloneValue) {
            if (this.enableXhtml) {
                this.valueContainer.value = this.getXhtmlString(this.valueContainer.value);
            }
            dispatchEvent(this.valueContainer, 'change');
            if (!this.isInitial) {
                this.dotNetRef.invokeMethodAsync('UpdateValue', this.value);
            }
            else {
                this.isInitial = false;
            }
            this.cloneValue = this.value;
        }
        this.setPlaceHolder();
    };
    SfRichTextEditor.prototype.updateContentElements = function () {
        if ((this.editorMode === 'HTML' && (sf.base.isNullOrUndefined(this.iframeSettings) || !this.iframeSettings.enable)) || this.editorMode === 'Markdown') {
            this.contentPanel = this.element.querySelector('.e-rte-content');
        }
        else if (this.editorMode === 'HTML' && (this.iframeSettings && this.iframeSettings.enable)) {
            this.contentPanel = this.element.querySelector('iframe');
            this.updateIframeHtmlContents();
        }
    };
    SfRichTextEditor.prototype.updateIframeHtmlContents = function () {
        var iFrameBodyContent = '<body spellcheck="false" autocorrect="off" contenteditable="true"></body></html>';
        var iFrameContent = IFRAME_HEADER + iFrameBodyContent;
        var iframe = this.contentPanel;
        iframe.srcdoc = iFrameContent;
        iframe.contentDocument.body.id = this.id + '_rte-edit-view';
        iframe.contentDocument.body.setAttribute('aria-owns', this.id);
        iframe.contentDocument.open();
        iFrameContent = this.setThemeColor(iFrameContent, { color: '#333' });
        iframe.contentDocument.write(iFrameContent);
        iframe.contentDocument.close();
        if (this.enableRtl) {
            iframe.contentDocument.body.setAttribute('class', 'e-rtl');
        }
    };
    SfRichTextEditor.prototype.setThemeColor = function (content, styles) {
        var fontColor = getComputedStyle(this.element, '.e-richtexteditor').getPropertyValue('color');
        return content.replace(styles.color, fontColor);
    };
    SfRichTextEditor.prototype.refresh = function (e) {
        if (e === void 0) { e = { requestType: 'refresh' }; }
        this.observer.notify(e.requestType + "-begin", e);
    };
    SfRichTextEditor.prototype.setWidth = function (width) {
        if (width !== 'auto') {
            sf.base.setStyleAttribute(this.element, { 'width': sf.base.formatUnit(this.width) });
        }
        else {
            this.element.style.width = 'auto';
        }
    };
    SfRichTextEditor.prototype.setHeight = function (height) {
        if (height !== 'auto') {
            this.element.style.height = sf.base.formatUnit(height);
        }
        else {
            this.element.style.height = 'auto';
        }
        if (this.toolbarSettings.type === 'Expand' && (typeof (this.height) === 'string' &&
            this.height.indexOf('px') > -1 || typeof (this.height) === 'number')) {
            this.element.classList.add(CLS_RTE_FIXED_TB_EXPAND);
        }
        else {
            this.element.classList.remove(CLS_RTE_FIXED_TB_EXPAND);
        }
    };
    SfRichTextEditor.prototype.openPasteDialog = function () {
        this.dotNetRef.invokeMethodAsync('PasteDialog');
    };
    SfRichTextEditor.prototype.setContentHeight = function (target, isExpand) {
        var heightValue = '';
        var topValue = 0;
        var rteHeightPercent = '';
        var heightPercent = typeof (this.height) === 'string' && this.height.indexOf('%') > -1;
        var sourceCodeEle = this.element.querySelector('.e-rte-content .e-rte-srctextarea');
        var cntEle = (!sf.base.isNullOrUndefined(sourceCodeEle) &&
            sourceCodeEle.parentElement.style.display === 'block') ? sourceCodeEle.parentElement : this.getPanel();
        var rteHeight = this.element.offsetHeight;
        if (rteHeight === 0 && this.height !== 'auto' && !this.getToolbar()) {
            rteHeight = parseInt(this.height, 10);
            if (heightPercent) {
                rteHeightPercent = this.height;
            }
        }
        var tbHeight = this.getToolbar() ? this.toolbarModule.getToolbarHeight() : 0;
        var rzHandle = this.element.querySelector('.' + CLS_RTE_RES_HANDLE);
        var rzHeight = this.enableResize ? (!sf.base.isNullOrUndefined(rzHandle) ? (rzHandle.offsetHeight + 8) : 0) : 0;
        var expandPopHeight = this.getToolbar() ? this.toolbarModule.getExpandTBarPopHeight() : 0;
        if (this.toolbarSettings.type === 'Expand' && isExpand && target !== 'preview') {
            heightValue = (this.height === 'auto' && rzHeight === 0 && !this.element.classList.contains('e-rte-full-screen')) ?
                'auto' : rteHeight - (tbHeight + expandPopHeight + rzHeight) + 'px';
            topValue = (!this.toolbarSettings.enableFloating) ? expandPopHeight : 0;
        }
        else {
            if (this.height === 'auto' && !(this.element.classList.contains('e-rte-full-screen')) && !this.isResizeInitialized) {
                heightValue = 'auto';
            }
            else {
                heightValue = heightPercent && rteHeightPercent ? rteHeightPercent : (this.element.classList.contains('e-rte-full-screen') ?
                    window.innerHeight : rteHeight) - (tbHeight + expandPopHeight + rzHeight) + 'px';
            }
        }
        if (target !== 'windowResize') {
            sf.base.setStyleAttribute(cntEle, { height: heightValue, marginTop: topValue + 'px' });
        }
        if (this.iframeSettings.enable && target === 'sourceCode') {
            var codeElement = sf.base.select('.' + CLS_RTE_CONTENT, this.element);
            sf.base.setStyleAttribute(codeElement, { height: heightValue, marginTop: topValue + 'px' });
        }
        if (this.toolbarSettings.enableFloating && this.getToolbar() && !this.inlineMode.enable) {
            var isExpandOpened = !sf.base.isNullOrUndefined(this.element.querySelector('.e-rte-toolbar .e-hor-nav.e-nav-active'));
            var tbContainerHeight = (isExpandOpened ? (tbHeight + expandPopHeight) : tbHeight) + 'px';
            sf.base.setStyleAttribute(this.getToolbar().parentElement, { height: tbContainerHeight });
        }
        if (rzHeight === 0) {
            this.autoResize();
        }
    };
    SfRichTextEditor.prototype.getXhtml = function () {
        var currentValue = this.value;
        if (this.enableXhtml) {
            currentValue = this.htmlEditorModule.xhtmlValidation.selfEncloseValidation(currentValue);
        }
        return currentValue;
    };
    SfRichTextEditor.prototype.getXhtmlString = function (value) {
        var currentValue = value;
        if (this.enableXhtml) {
            currentValue = this.htmlEditorModule.xhtmlValidation.selfEncloseValidation(currentValue);
        }
        return currentValue;
    };
    SfRichTextEditor.prototype.getPanel = function () {
        return this.contentPanel;
    };
    SfRichTextEditor.prototype.saveSelection = function () {
        this.formatter.editorManager.nodeSelection.save(this.getRange(), this.getDocument());
    };
    SfRichTextEditor.prototype.restoreSelection = function () {
        this.formatter.editorManager.nodeSelection.restore();
    };
    SfRichTextEditor.prototype.getEditPanel = function () {
        var editNode;
        if (this.iframeSettings && this.iframeSettings.enable) {
            if (!sf.base.isNullOrUndefined(this.contentPanel.contentDocument)) {
                editNode = this.contentPanel.contentDocument.body;
            }
            else {
                editNode = this.inputElement;
            }
        }
        else {
            editNode = this.element.querySelector('.e-rte-content .e-content');
        }
        return editNode;
    };
    SfRichTextEditor.prototype.getText = function () {
        return this.getEditPanel().innerText;
    };
    SfRichTextEditor.prototype.getDocument = function () {
        return this.getEditPanel().ownerDocument;
    };
    SfRichTextEditor.prototype.getRange = function () {
        return this.formatter.editorManager.nodeSelection.getRange(this.getDocument());
    };
    SfRichTextEditor.prototype.updateValueContainer = function (val) {
        if (this.enableXhtml && !sf.base.isNullOrUndefined(val)) {
            val = this.getXhtmlString(val);
        }
        this.valueContainer.value = val;
        dispatchEvent(this.valueContainer, 'change');
    };
    SfRichTextEditor.prototype.getInputInnerHtml = function () {
        return this.inputElement.innerHTML.replace(/<!--!-->/gi, '');
    };
    SfRichTextEditor.prototype.refreshUI = function () {
        this.refresh();
    };
    SfRichTextEditor.prototype.getUpdatedValue = function () {
        var value;
        if (!sf.base.isNullOrUndefined(this.tableModule)) {
            this.tableModule.removeResizeEle();
        }
        var getTextArea = this.element.querySelector('.e-rte-srctextarea');
        if (this.editorMode === 'HTML') {
            var inputContent = this.getInputInnerHtml();
            value = (inputContent === '<p><br></p>') ? null : this.enableHtmlEncode ?
                this.encode(decode(inputContent)) : inputContent;
            if (getTextArea && getTextArea.style.display === 'block') {
                value = getTextArea.value;
            }
        }
        else {
            value = this.inputElement.value === '' ? null :
                this.inputElement.value;
        }
        return value;
    };
    SfRichTextEditor.prototype.countCalculate = function () {
        this.countModule.renderCount();
    };
    SfRichTextEditor.prototype.updateEnable = function () {
        if (this.enabled) {
            sf.base.removeClass([this.element], CLS_DISABLED);
            this.element.setAttribute('aria-disabled', 'false');
            if (!sf.base.isNullOrUndefined(this.htmlAttributes.tabindex)) {
                this.inputElement.setAttribute('tabindex', this.htmlAttributes.tabindex);
            }
            else {
                this.inputElement.setAttribute('tabindex', '0');
            }
        }
        else {
            if (this.getToolbar()) {
                sf.base.removeClass(this.getToolbar().querySelectorAll('.' + CLS_ACTIVE), CLS_ACTIVE);
                sf.base.removeClass([this.getToolbar()], [CLS_TB_FLOAT, CLS_TB_ABS_FLOAT]);
            }
            sf.base.addClass([this.element], CLS_DISABLED);
            this.element.tabIndex = -1;
            this.element.setAttribute('aria-disabled', 'true');
            this.inputElement.setAttribute('tabindex', '-1');
        }
    };
    SfRichTextEditor.prototype.setEnable = function () {
        this.updateEnable();
        (this.enabled) ? this.wireEvents() : this.unWireEvents();
    };
    SfRichTextEditor.prototype.executeCommand = function (commandName, value, option) {
        value = this.htmlPurifier(commandName, value);
        if (this.editorMode === 'HTML') {
            var range = this.getRange();
            if (this.iframeSettings.enable) {
                this.formatter.editorManager.nodeSelection.Clear(this.element.ownerDocument);
            }
            var toFocus = (this.iframeSettings.enable &&
                range.startContainer === this.inputElement) ? true : !this.inputElement.contains(range.startContainer);
            if (toFocus) {
                this.focusIn();
            }
        }
        var tool = executeGroup[commandName];
        if (option && option.undo) {
            if (option.undo && this.formatter.getUndoRedoStack().length === 0) {
                this.formatter.saveData();
            }
        }
        this.formatter.editorManager.execCommand(tool.command, tool.subCommand ? tool.subCommand : (value ? value : tool.value), null, null, (value ? value : tool.value), (value ? value : tool.value));
        if (option && option.undo) {
            this.formatter.saveData();
            this.formatter.enableUndo(this);
        }
        this.setPlaceHolder();
        this.observer.notify(contentChanged, {});
        this.value = this.inputElement.innerHTML;
        this.dotNetRef.invokeMethodAsync('UpdateValue', this.value);
    };
    SfRichTextEditor.prototype.htmlPurifier = function (command, value) {
        if (this.editorMode === 'HTML') {
            switch (command) {
                case 'insertTable':
                    if (sf.base.isNullOrUndefined(value.width)) {
                        value.width = {
                            minWidth: this.tableSettings.minWidth,
                            maxWidth: this.tableSettings.maxWidth, width: this.tableSettings.width
                        };
                    }
                    value.selection = this.formatter.editorManager.nodeSelection.save(this.getRange(), this.getDocument());
                    break;
                case 'insertImage':
                    var temp = sf.base.createElement('img', {
                        attrs: {
                            src: value.url
                        }
                    });
                    var imageValue = temp.outerHTML;
                    var url = (imageValue !== '' && (sf.base.createElement('div', {
                        innerHTML: imageValue
                    }).firstElementChild).getAttribute('src')) || null;
                    url = !sf.base.isNullOrUndefined(url) ? url : '';
                    value.url = url;
                    if (sf.base.isNullOrUndefined(value.width)) {
                        value.width = {
                            minWidth: this.insertImageSettings.minWidth,
                            maxWidth: this.insertImageSettings.maxWidth, width: this.insertImageSettings.width
                        };
                    }
                    if (sf.base.isNullOrUndefined(value.height)) {
                        value.height = {
                            minHeight: this.insertImageSettings.minHeight,
                            maxHeight: this.insertImageSettings.maxHeight, height: this.insertImageSettings.height
                        };
                    }
                    value.selection = this.formatter.editorManager.nodeSelection.save(this.getRange(), this.getDocument());
                    break;
                case 'createLink':
                    var tempNode = sf.base.createElement('a', {
                        attrs: {
                            href: value.url
                        }
                    });
                    var linkValue = tempNode.outerHTML;
                    var href = (linkValue !== '' && (sf.base.createElement('div', {
                        innerHTML: linkValue
                    }).firstElementChild).getAttribute('href')) || null;
                    href = !sf.base.isNullOrUndefined(href) ? href : '';
                    value.url = href;
                    value.selection = this.formatter.editorManager.nodeSelection.save(this.getRange(), this.getDocument());
                    break;
            }
        }
        return value;
    };
    SfRichTextEditor.prototype.serializeValue = function (value) {
        if (this.editorMode === 'HTML' && !sf.base.isNullOrUndefined(value)) {
            if (this.enableHtmlEncode) {
                value = this.htmlEditorModule.sanitizeHelper(decode(value));
                value = this.encode(value);
            }
            else {
                value = this.htmlEditorModule.sanitizeHelper(value);
            }
        }
        return value;
    };
    SfRichTextEditor.prototype.selectAll = function () {
        this.observer.notify(selectAll$1, {});
    };
    SfRichTextEditor.prototype.selectRange = function (range) {
        this.observer.notify(selectRange, { range: range });
    };
    SfRichTextEditor.prototype.showFullScreen = function () {
        this.fullScreenModule.showFullScreen();
    };
    SfRichTextEditor.prototype.sanitizeHtml = function (value) {
        return this.serializeValue(value);
    };
    SfRichTextEditor.prototype.updateValue = function (value) {
        if (sf.base.isNullOrUndefined(value)) {
            var inputVal = this.inputElement.innerHTML;
            //this.setProperties({ value: isEditableValueEmpty(inputVal) ? null : inputVal });
        }
        else {
            //this.setProperties({ value: value });
        }
    };
    SfRichTextEditor.prototype.clipboardAction = function (action, event) {
        switch (action.toLowerCase()) {
            case 'cut':
                this.onCut();
                this.formatter.onSuccess(this, {
                    requestType: 'Cut',
                    editorMode: this.editorMode,
                    event: event
                });
                break;
            case 'copy':
                this.onCopy();
                this.formatter.onSuccess(this, {
                    requestType: 'Copy',
                    editorMode: this.editorMode,
                    event: event
                });
                break;
            case 'paste':
                this.onPaste(event);
                break;
        }
    };
    SfRichTextEditor.prototype.getContent = function () {
        if (this.iframeSettings.enable) {
            return this.inputElement;
        }
        else {
            return this.getPanel();
        }
    };
    SfRichTextEditor.prototype.getSelectedHtml = function () {
        var range;
        var containerElm = sf.base.createElement('div');
        var selection = this.getDocument().getSelection();
        if (selection.rangeCount > 0) {
            range = selection.getRangeAt(0);
            var selectedHtml = range.cloneContents();
            containerElm.appendChild(selectedHtml);
        }
        return containerElm.innerHTML;
    };
    SfRichTextEditor.prototype.getSelection = function () {
        var str = '';
        this.observer.notify(getSelectedHtml, {
            callBack: function (txt) {
                str = txt;
            }
        });
        return str;
    };
    SfRichTextEditor.prototype.showInlineToolbar = function () {
        if (this.inlineMode.enable) {
            var currentRange = this.getRange();
            var targetElm = currentRange.endContainer.nodeName === '#text' ?
                currentRange.endContainer.parentElement : currentRange.endContainer;
            var x = currentRange.getClientRects()[0].left;
            var y = currentRange.getClientRects()[0].top;
            this.quickToolbarModule.showInlineQTBar(x, y, targetElm);
        }
    };
    SfRichTextEditor.prototype.hideInlineToolbar = function () {
        this.quickToolbarModule.hideInlineQTBar();
    };
    SfRichTextEditor.prototype.updateValueData = function () {
        if (this.enableHtmlEncode) {
            this.setPanelValue(this.encode(decode(this.inputElement.innerHTML)));
        }
        else {
            var value = /<[a-z][\s\S]*>/i.test(this.inputElement.innerHTML) ? this.inputElement.innerHTML :
                decode(this.inputElement.innerHTML);
            this.setPanelValue(value);
        }
    };
    SfRichTextEditor.prototype.removeSheets = function (srcList) {
        var i;
        for (i = 0; i < srcList.length; i++) {
            sf.base.detach(srcList[i]);
        }
    };
    SfRichTextEditor.prototype.updateReadOnly = function () {
        this.observer.notify(readOnlyMode, { editPanel: this.inputElement, mode: this.readonly });
    };
    SfRichTextEditor.prototype.setReadOnly = function (initial) {
        this.updateReadOnly();
        if (!initial) {
            if (this.readonly && this.enabled) {
                this.unBindEvents();
            }
            else if (this.enabled) {
                this.bindEvents();
            }
        }
    };
    SfRichTextEditor.prototype.setIframeSettings = function () {
        if (this.iframeSettings.resources) {
            var styleSrc = this.iframeSettings.resources.styles;
            var scriptSrc = this.iframeSettings.resources.scripts;
            if (this.iframeSettings.resources.styles.length > 0) {
                this.InjectSheet(false, styleSrc);
            }
            if (this.iframeSettings.resources.scripts.length > 0) {
                this.InjectSheet(true, scriptSrc);
            }
        }
        if (this.iframeSettings.attributes) {
            setAttributes(this.iframeSettings.attributes, this, true, false);
        }
    };
    SfRichTextEditor.prototype.InjectSheet = function (scriptSheet, srcList) {
        try {
            if (srcList && srcList.length > 0) {
                var iFrame = this.getDocument();
                var target = iFrame.querySelector('head');
                for (var i = 0; i < srcList.length; i++) {
                    if (scriptSheet) {
                        var scriptEle = this.createScriptElement();
                        scriptEle.src = srcList[i];
                        target.appendChild(scriptEle);
                    }
                    else {
                        var styleEle = this.createStyleElement();
                        styleEle.href = srcList[i];
                        target.appendChild(styleEle);
                    }
                }
            }
        }
        catch (e) {
            return;
        }
    };
    SfRichTextEditor.prototype.createScriptElement = function () {
        var scriptEle = sf.base.createElement('script', {
            className: CLS_SCRIPT_SHEET
        });
        scriptEle.type = 'text/javascript';
        return scriptEle;
    };
    SfRichTextEditor.prototype.createStyleElement = function () {
        var styleEle = sf.base.createElement('link', {
            className: CLS_STYLE_SHEET
        });
        styleEle.rel = 'stylesheet';
        return styleEle;
    };
    SfRichTextEditor.prototype.setValue = function () {
        var innerHtml = !sf.base.isNullOrUndefined(this.element.innerHTML) && this.element.innerHTML.replace(/<(\/?|\!?)(!--!--)>/g, '').trim();
        if (innerHtml !== '') {
            if (this.element.tagName === 'TEXTAREA') {
                // this.setProperties({ value: decode(innerHtml) });
            }
            else {
                //  this.setProperties({ value: innerHtml });
            }
        }
    };
    SfRichTextEditor.prototype.updateResizeFlag = function () {
        this.isResizeInitialized = true;
    };
    SfRichTextEditor.prototype.getHtml = function () {
        return this.serializeValue(this.getEditPanel().innerHTML);
    };
    SfRichTextEditor.prototype.showSourceCode = function () {
        if (this.readonly) {
            return;
        }
        this.observer.notify(sourceCode, {});
    };
    SfRichTextEditor.prototype.getCharCount = function () {
        var htmlText = this.editorMode === 'Markdown' ? this.getEditPanel().value.trim() :
            this.getEditPanel().textContent.trim();
        var htmlLength;
        if (this.editorMode !== 'Markdown' && htmlText.indexOf('\u200B') !== -1) {
            htmlLength = htmlText.replace(/\u200B/g, '').length;
        }
        else {
            htmlLength = htmlText.length;
        }
        return htmlLength;
    };
    SfRichTextEditor.prototype.focusOut = function () {
        if (this.enabled) {
            this.inputElement.blur();
            this.blurHandler({});
        }
    };
    // public getBaseToolbarObject(): BaseToolbar {
    //     let tbObj: BaseToolbar;
    //     if (this.inlineMode.enable && (!Browser.isDevice || isIDevice())) {
    //         tbObj = this.quickToolbarModule && this.quickToolbarModule.getInlineBaseToolbar();
    //     } else {
    //         tbObj = this.toolbarModule && this.toolbarModule.getBaseToolbar();
    //     }
    //     return tbObj;
    // }
    SfRichTextEditor.prototype.getToolbar = function () {
        return this.toolbarSettings.enable ? this.element.querySelector('#' + this.id + '_toolbar') : null;
    };
    SfRichTextEditor.prototype.getToolbarElement = function () {
        return this.toolbarSettings.enable ? this.element.querySelector('#' + this.id + '_toolbar') : null;
    };
    SfRichTextEditor.prototype.updateIntervalValue = function () {
        clearTimeout(this.idleInterval);
        this.idleInterval = setTimeout(this.updateValueOnIdle.bind(this), 0);
    };
    SfRichTextEditor.prototype.updateValueOnIdle = function () {
        if (!sf.base.isNullOrUndefined(this.tableModule) && !sf.base.isNullOrUndefined(this.inputElement.querySelector('.e-table-box.e-rbox-select'))) {
            return;
        }
        this.value = this.getUpdatedValue();
        this.updateValueContainer(this.value);
        this.invokeChangeEvent();
    };
    SfRichTextEditor.prototype.invokeChangeEvent = function () {
        if (this.enableXhtml && !sf.base.isNullOrUndefined(this.value)) {
            this.value = this.getXhtml();
        }
        if (this.value !== this.cloneValue) {
            if (this.enablePersistence) {
                window.localStorage.setItem(this.id, this.value);
            }
            this.dotNetRef.invokeMethodAsync('ChangeEvent');
            this.cloneValue = this.value;
        }
    };
    SfRichTextEditor.prototype.preventImgResize = function (e) {
        if (e.target.nodeName.toLocaleLowerCase() === 'img') {
            e.preventDefault();
        }
    };
    SfRichTextEditor.prototype.defaultResize = function (e, isDefault) {
        if (sf.base.Browser.info.name === 'msie') {
            if (isDefault) {
                this.getEditPanel().removeEventListener('mscontrolselect', this.preventImgResize);
            }
            else {
                this.getEditPanel().addEventListener('mscontrolselect', this.preventImgResize);
            }
        }
        else if (sf.base.Browser.info.name === 'mozilla') {
            var value = isDefault ? 'true' : 'false';
            this.getDocument().execCommand('enableObjectResizing', isDefault, value);
            this.getDocument().execCommand('enableInlineTableEditing', isDefault, value);
        }
    };
    SfRichTextEditor.prototype.encode = function (value) {
        var divNode = document.createElement('div');
        divNode.innerText = value.trim();
        return divNode.innerHTML.replace(/<br\s*[\/]?>/gi, '\n');
    };
    SfRichTextEditor.prototype.print = function () {
        var _this = this;
        var printWind;
        var printArgs = {
            requestType: 'print',
            cancel: false
        };
        // @ts-ignore-start
        this.dotNetRef.invokeMethodAsync('ActionBeginEvent', printArgs).then(function (printingArgs) {
            // @ts-ignore-end
            printWind = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth);
            if (sf.base.Browser.info.name === 'msie') {
                printWind.resizeTo(screen.availWidth, screen.availHeight);
            }
            printWind = sf.base.print(_this.inputElement, printWind);
            if (!printingArgs.cancel) {
                var actionArgs = {
                    requestType: 'print'
                };
                _this.dotNetRef.invokeMethodAsync('ActionCompleteEvent', actionArgs);
            }
        });
    };
    SfRichTextEditor.prototype.autoResize = function () {
        var _this = this;
        if (this.height === 'auto') {
            if (this.editorMode === 'Markdown') {
                setTimeout(function () { _this.setAutoHeight(_this.inputElement); }, 0);
            }
            else if (this.iframeSettings.enable) {
                var iframeElement_1 = this.element.querySelector('#' + this.element.id + '_rte-view');
                setTimeout(function () { _this.setAutoHeight(iframeElement_1); }, 100);
                this.inputElement.style.overflow = 'hidden';
            }
        }
        else {
            this.inputElement.style.overflow = null;
        }
    };
    SfRichTextEditor.prototype.setAutoHeight = function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.style.height = '';
            element.style.height = this.inputElement.scrollHeight + 'px';
            element.style.overflow = 'hidden';
        }
    };
    SfRichTextEditor.prototype.restrict = function (e) {
        if (this.maxLength >= 0) {
            var element = this.editorMode === 'Markdown' ? this.getText() :
                e.currentTarget.textContent.trim();
            var array = [8, 16, 17, 37, 38, 39, 40, 46, 65];
            var arrayKey = void 0;
            for (var i = 0; i <= array.length - 1; i++) {
                if (e.which === array[i]) {
                    if (e.ctrlKey && e.which === 65) {
                        return;
                    }
                    else if (e.which !== 65) {
                        arrayKey = array[i];
                        return;
                    }
                }
            }
            if ((element.length >= this.maxLength && this.maxLength !== -1) && e.which !== arrayKey) {
                e.preventDefault();
            }
        }
    };
    SfRichTextEditor.prototype.setPlaceHolder = function () {
        if (this.inputElement && this.placeholder && this.iframeSettings.enable !== true) {
            if (this.editorMode !== 'Markdown') {
                if (!this.placeHolderContainer) {
                    this.placeHolderContainer = this.element.querySelector('.e-rte-placeholder');
                }
                this.placeHolderContainer.innerHTML = this.placeholder;
                if (this.inputElement.textContent.length === 0 &&
                    !sf.base.isNullOrUndefined(this.inputElement.firstChild) && this.inputElement.firstChild.nodeName === 'P' &&
                    !sf.base.isNullOrUndefined(this.inputElement.firstChild.firstChild) && this.inputElement.firstChild.firstChild.nodeName === 'BR') {
                    this.placeHolderContainer.style.display = 'block';
                }
                else {
                    this.placeHolderContainer.style.display = 'none';
                }
            }
            else {
                this.inputElement.setAttribute('placeholder', this.placeholder);
            }
        }
    };
    SfRichTextEditor.prototype.updatePanelValue = function () {
        var value = this.value;
        value = (this.enableHtmlEncode && this.value) ? decode(value) : value;
        var getTextArea = this.element.querySelector('.e-rte-srctextarea');
        if (value) {
            if (getTextArea && getTextArea.style.display === 'block') {
                getTextArea.value = this.value;
            }
            if (this.valueContainer) {
                this.valueContainer.value = (this.enableHtmlEncode) ? this.value : value;
            }
            if (this.editorMode === 'HTML' && this.inputElement && this.inputElement.innerHTML.trim() !== value.trim()) {
                this.inputElement.innerHTML = value;
            }
            else if (this.editorMode === 'Markdown' && this.inputElement
                && this.inputElement.value.trim() !== value.trim()) {
                this.inputElement.value = value;
            }
        }
        else {
            if (getTextArea && getTextArea.style.display === 'block') {
                getTextArea.value = '';
            }
            if (this.editorMode === 'HTML') {
                this.inputElement.innerHTML = '<p><br/></p>';
            }
            else {
                this.inputElement.value = '';
            }
            if (this.valueContainer) {
                this.valueContainer.value = '';
            }
        }
        if (this.showCharCount) {
            this.countModule.refresh();
        }
    };
    SfRichTextEditor.prototype.contentChanged = function () {
        if (this.autoSaveOnIdle) {
            if (!sf.base.isNullOrUndefined(this.saveInterval)) {
                clearTimeout(this.timeInterval);
                this.timeInterval = setTimeout(this.updateIntervalValue.bind(this), this.saveInterval);
            }
        }
    };
    SfRichTextEditor.prototype.notifyMouseUp = function (e) {
        var touch = (e.touches ? e.changedTouches[0] : e);
        this.observer.notify(mouseUp, {
            member: 'mouseUp', args: e,
            touchData: {
                prevClientX: this.clickPoints.clientX, prevClientY: this.clickPoints.clientY,
                clientX: touch.clientX, clientY: touch.clientY
            }
        });
        if (this.inputElement && ((this.editorMode === 'HTML' && this.inputElement.textContent.length !== 0) ||
            (this.editorMode === 'Markdown' && this.inputElement.value.length !== 0))) {
            this.observer.notify(toolbarRefresh, { args: e });
        }
        this.triggerEditArea(e);
    };
    SfRichTextEditor.prototype.triggerEditArea = function (e) {
        if (!isIDevice()) {
            this.observer.notify(editAreaClick, { member: 'editAreaClick', args: e });
        }
        else {
            var touch = (e.touches ? e.changedTouches[0] : e);
            if (this.clickPoints.clientX === touch.clientX && this.clickPoints.clientY === touch.clientY) {
                this.observer.notify(editAreaClick, { member: 'editAreaClick', args: e });
            }
        }
    };
    SfRichTextEditor.prototype.updateStatus = function (e) {
        if (!sf.base.isNullOrUndefined(e.html) || !sf.base.isNullOrUndefined(e.markdown)) {
            var status_1 = this.formatter.editorManager.undoRedoManager.getUndoStatus();
            this.dotNetRef.invokeMethodAsync(updatedToolbarStatusEvent, {
                undo: status_1.undo,
                redo: status_1.redo,
                html: e.html,
                markdown: e.markdown
            });
        }
    };
    //#endregion
    //#region Interop interaction methods
    SfRichTextEditor.prototype.onListDropDownButtonClick = function (args) {
        if (sf.base.isNullOrUndefined(args)) {
            return;
        }
        args.item.subCommand = args.item.subCommand === "BulletFormatList" ? "UL" : "OL";
        if (this.inlineCloseItems.indexOf(args.item.subCommand) > -1) {
            this.quickToolbarModule.hideInlineQTBar();
        }
        if (this.editorMode === 'HTML') {
            this.observer.notify(htmlToolbarClick, args);
        }
    };
    
    SfRichTextEditor.prototype.toolbarItemClick = function (args, id, targetType) {
        if (sf.base.isNullOrUndefined(args)) {
            return;
        }
        var target;
        if (targetType === 'Root' && !this.inlineMode.enable) {
            target = sf.base.select('#' + id, this.element);
        }
        else {
            target = sf.base.select('#' + id, document.body);
        }
        args.originalEvent = __assign({}, args.originalEvent, { target: target });
        if (this.inlineCloseItems.indexOf(args.item.subCommand) > -1) {
            this.quickToolbarModule.hideInlineQTBar();
        }
        if (this.editorMode === 'HTML') {
            this.observer.notify(htmlToolbarClick, args);
        }
        else {
            this.observer.notify(markdownToolbarClick, args);
        }
    };
    SfRichTextEditor.prototype.toolbarClick = function (id) {
        var trg = sf.base.select('#' + id + ' .e-hor-nav', this.element);
        if (trg && this.toolbarSettings.type === 'Expand' && !sf.base.isNullOrUndefined(trg)) {
            if (!trg.classList.contains('e-nav-active')) {
                sf.base.removeClass([this.getToolbar()], [CLS_EXPAND_OPEN]);
                this.setContentHeight('toolbar', false);
            }
            else {
                sf.base.addClass([this.getToolbar()], [CLS_EXPAND_OPEN]);
                this.setContentHeight('toolbar', true);
            }
        }
        else if (sf.base.Browser.isDevice || this.inlineMode.enable) {
            //this.isToolbar = true;
        }
        if (sf.base.isNullOrUndefined(trg) && this.toolbarSettings.type === 'Expand') {
            sf.base.removeClass([this.getToolbar()], [CLS_EXPAND_OPEN]);
        }
    };
    SfRichTextEditor.prototype.hideTableQuickToolbar = function () {
        this.quickToolbarModule.hideTableQTBar();
    };
    SfRichTextEditor.prototype.dropDownBeforeOpen = function (args) {
        this.observer.notify(selectionSave, args);
        this.observer.notify(beforeDropDownOpen, args);
    };
    SfRichTextEditor.prototype.dropDownClose = function (args) {
        this.observer.notify(selectionRestore, args);
    };
    SfRichTextEditor.prototype.dropDownSelect = function (e) {
        e.name = 'dropDownSelect';
        if (!(document.body.contains(document.body.querySelector('.e-rte-quick-toolbar'))
            && e.item && (e.item.command === 'Images' || e.item.command === 'Display' || e.item.command === 'Table'))) {
            this.observer.notify(selectionRestore, {});
            var value = null;
            // let value: string = e.item.controlParent && this.quickToolbarModule && this.quickToolbarModule.tableQTBar
            //     && this.quickToolbarModule.tableQTBar.element.contains(e.item.controlParent.element) ? 'Table' : null;
            if (e.item.command === 'Lists') {
                var listItem = { listStyle: e.item.value, listImage: e.item.listImage, type: e.item.subCommand };
                this.formatter.process(this, e, e.originalEvent, listItem);
            }
            else {
                this.formatter.process(this, e, e.originalEvent, value);
            }
            this.observer.notify(selectionSave, {});
        }
        this.observer.notify(dropDownSelect, e);
    };
    SfRichTextEditor.prototype.colorDropDownBeforeOpen = function () {
        this.observer.notify(selectionSave, {});
    };
    SfRichTextEditor.prototype.colorIconSelected = function (args, value, container) {
        this.observer.notify(selectionSave, {});
        this.observer.notify(selectionRestore, {});
        args.value = sf.base.isNullOrUndefined(value) ? args.value : value;
        var range = this.formatter.editorManager.nodeSelection.getRange(this.getDocument());
        var parentNode = range.startContainer.parentNode;
        if ((range.startContainer.nodeName === 'TD' || range.startContainer.nodeName === 'TH' ||
            (sf.base.closest(range.startContainer.parentNode, 'td,th')) || (this.iframeSettings.enable &&
            !hasClass(parentNode.ownerDocument.querySelector('body'), 'e-lib'))) && range.collapsed &&
            args.subCommand === 'BackgroundColor' && container === 'quick') {
            this.observer.notify(tableColorPickerChanged, { item: args, name: 'colorPickerChanged' });
        }
        else {
            this.observer.notify(selectionRestore, {});
            this.formatter.process(this, { item: args, name: 'colorPickerChanged' }, undefined, null);
            this.observer.notify(selectionSave, {});
        }
    };
    SfRichTextEditor.prototype.colorChanged = function (args, value, container) {
        this.observer.notify(selectionRestore, {});
        args.value = sf.base.isNullOrUndefined(value) ? args.value : value;
        var range = this.formatter.editorManager.nodeSelection.getRange(this.getDocument());
        if ((range.startContainer.nodeName === 'TD' || range.startContainer.nodeName === 'TH' ||
            sf.base.closest(range.startContainer.parentNode, 'td,th')) && range.collapsed && args.subCommand === 'BackgroundColor'
            && container === 'quick') {
            this.observer.notify(tableColorPickerChanged, { item: args, name: 'colorPickerChanged' });
        }
        else {
            this.observer.notify(selectionRestore, {});
            this.formatter.process(this, { item: args, name: 'colorPickerChanged' }, undefined, null);
            this.observer.notify(selectionSave, {});
        }
    };
    SfRichTextEditor.prototype.cancelLinkDialog = function () {
        this.isBlur = false;
        this.linkModule.cancelDialog();
    };
    SfRichTextEditor.prototype.cancelImageDialog = function () {
        this.isBlur = false;
    };
    SfRichTextEditor.prototype.linkDialogClosed = function () {
        this.isBlur = false;
        this.linkModule.linkDialogClosed();
    };
    SfRichTextEditor.prototype.dialogClosed = function (type) {
        this.isBlur = false;
        if (type === 'restore') {
            this.observer.notify(selectionRestore, {});
        }
    };
    SfRichTextEditor.prototype.insertLink = function (args) {
        this.linkModule.insertLink(args);
    };
    SfRichTextEditor.prototype.imageRemoving = function () {
        this.imageModule.removing();
    };
    SfRichTextEditor.prototype.uploadSuccess = function (url, altText) {
        this.imageModule.imageUploadSuccess(url, altText);
    };
    SfRichTextEditor.prototype.imageSelected = function () {
        this.imageModule.imageSelected();
    };
    SfRichTextEditor.prototype.imageUploadComplete = function (base64Str, altText) {
        this.imageModule.imageUploadComplete(base64Str, altText);
    };
    SfRichTextEditor.prototype.imageUploadChange = function (url, isStream) {
        this.imageModule.imageUploadChange(url, isStream);
    };
    SfRichTextEditor.prototype.dropUploadChange = function (url, isStream) {
        this.imageModule.dropUploadChange(url, isStream);
    };
    SfRichTextEditor.prototype.insertImage = function () {
        this.imageModule.insertImageUrl();
    };
    SfRichTextEditor.prototype.imageDialogOpened = function () {
        this.imageModule.dialogOpened();
    };
    SfRichTextEditor.prototype.imageDialogClosed = function () {
        this.isBlur = false;
        this.imageModule.dialogClosed();
    };
    SfRichTextEditor.prototype.insertTable = function (row, column) {
        this.tableModule.customTable(row, column);
    };
    SfRichTextEditor.prototype.applyTableProperties = function (model) {
        this.tableModule.applyTableProperties(model);
    };
    SfRichTextEditor.prototype.createTablePopupOpened = function () {
        this.tableModule.createTablePopupOpened();
    };
    SfRichTextEditor.prototype.pasteContent = function (pasteOption) {
        this.pasteCleanupModule.selectFormatting(pasteOption);
    };
    SfRichTextEditor.prototype.updatePasteContent = function (value) {
        this.observer.notify(afterPasteCleanUp, { text: value });
    };
    SfRichTextEditor.prototype.imageDropInitialized = function (isStream) {
        this.imageModule.imageDropInitialized(isStream);
    };
    SfRichTextEditor.prototype.preventEditable = function () {
        this.inputElement.contentEditable = 'false';
    };
    SfRichTextEditor.prototype.enableEditable = function () {
        this.inputElement.contentEditable = 'true';
    };
    SfRichTextEditor.prototype.removeDroppedImage = function () {
        this.imageModule.removeDroppedImage();
    };
    SfRichTextEditor.prototype.dropUploadSuccess = function (url, altText) {
        this.imageModule.dropUploadSuccess(url, altText);
    };
    SfRichTextEditor.prototype.focusIn = function () {
        if (this.enabled) {
            this.inputElement.focus();
            this.focusHandler({});
        }
    };
    SfRichTextEditor.prototype.insertAlt = function (altText) {
        this.imageModule.insertAlt(altText);
    };
    SfRichTextEditor.prototype.insertSize = function (width, height) {
        this.imageModule.insertSize(width, height);
    };
    SfRichTextEditor.prototype.insertImageLink = function (url, target) {
        this.imageModule.insertLink(url, target);
    };
    SfRichTextEditor.prototype.showLinkDialog = function () {
        this.linkModule.showDialog(true);
    };
    SfRichTextEditor.prototype.showImageDialog = function () {
        this.imageModule.showDialog(true);
    };
    SfRichTextEditor.prototype.showTableDialog = function () {
        this.tableModule.showDialog(true);
    };
    SfRichTextEditor.prototype.destroy = function () {
        this.unWireEvents();
    };
    //#endregion
    //#region Event binding and unbinding function
    SfRichTextEditor.prototype.wireEvents = function () {
        this.element.addEventListener('focusin', this.onFocusHandler, true);
        this.element.addEventListener('focusout', this.onBlurHandler, true);
        this.observer.on(contentChanged, this.contentChanged, this);
        this.observer.on(modelChanged, this.refresh, this);
        this.observer.on(resizeInitialized, this.updateResizeFlag, this);
        this.observer.on(updateTbItemsStatus, this.updateStatus, this);
        if (this.readonly && this.enabled) {
            return;
        }
        this.bindEvents();
    };
    SfRichTextEditor.prototype.bindEvents = function () {
        this.keyboardModule = new KeyboardEvents$1(this.inputElement, {
            keyAction: this.keyDown.bind(this), keyConfigs: __assign({}, this.formatter.keyConfig, this.keyConfig), eventName: 'keydown'
        });
        var formElement = sf.base.closest(this.valueContainer, 'form');
        if (formElement) {
            sf.base.EventHandler.add(formElement, 'reset', this.resetHandler, this);
        }
        sf.base.EventHandler.add(this.inputElement, 'keyup', this.keyUp, this);
        sf.base.EventHandler.add(this.inputElement, 'paste', this.onPaste, this);
        sf.base.EventHandler.add(this.inputElement, sf.base.Browser.touchEndEvent, sf.base.debounce(this.mouseUp, 30), this);
        sf.base.EventHandler.add(this.inputElement, sf.base.Browser.touchStartEvent, this.mouseDownHandler, this);
        this.wireContextEvent();
        this.formatter.editorManager.observer.on('keydown-handler', this.editorKeyDown, this);
        this.element.ownerDocument.defaultView.addEventListener('resize', this.onResizeHandler, true);
        if (this.iframeSettings.enable) {
            sf.base.EventHandler.add(this.inputElement, 'focusin', this.focusHandler, this);
            sf.base.EventHandler.add(this.inputElement, 'focusout', this.blurHandler, this);
            sf.base.EventHandler.add(this.inputElement.ownerDocument, 'scroll', this.contentScrollHandler, this);
            sf.base.EventHandler.add(this.inputElement.ownerDocument, sf.base.Browser.touchStartEvent, this.onIframeMouseDown, this);
        }
        this.wireScrollElementsEvents();
    };
    SfRichTextEditor.prototype.wireContextEvent = function () {
        if (this.quickToolbarSettings.showOnRightClick) {
            sf.base.EventHandler.add(this.inputElement, 'contextmenu', this.contextHandler, this);
            if (sf.base.Browser.isDevice) {
                this.touchModule = new sf.base.Touch(this.inputElement, { tapHold: this.touchHandler.bind(this), tapHoldThreshold: 500 });
            }
        }
    };
    SfRichTextEditor.prototype.wireScrollElementsEvents = function () {
        this.scrollParentElements = sf.popups.getScrollableParent(this.element);
        for (var _i = 0, _a = this.scrollParentElements; _i < _a.length; _i++) {
            var element = _a[_i];
            sf.base.EventHandler.add(element, 'scroll', this.scrollHandler, this);
        }
        if (!this.iframeSettings.enable) {
            sf.base.EventHandler.add(this.getPanel(), 'scroll', this.contentScrollHandler, this);
        }
    };
    SfRichTextEditor.prototype.unWireEvents = function () {
        this.element.removeEventListener('focusin', this.onFocusHandler, true);
        this.element.removeEventListener('focusout', this.onBlurHandler, true);
        this.observer.off(contentChanged, this.contentChanged);
        this.observer.off(resizeInitialized, this.updateResizeFlag);
        this.observer.off(updateTbItemsStatus, this.updateStatus);
        this.unBindEvents();
    };
    SfRichTextEditor.prototype.unBindEvents = function () {
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
        var formElement = sf.base.closest(this.valueContainer, 'form');
        if (formElement) {
            sf.base.EventHandler.remove(formElement, 'reset', this.resetHandler);
        }
        sf.base.EventHandler.remove(this.inputElement, 'keyup', this.keyUp);
        sf.base.EventHandler.remove(this.inputElement, 'paste', this.onPaste);
        sf.base.EventHandler.remove(this.inputElement, sf.base.Browser.touchEndEvent, sf.base.debounce(this.mouseUp, 30));
        sf.base.EventHandler.remove(this.inputElement, sf.base.Browser.touchStartEvent, this.mouseDownHandler);
        this.unWireContextEvent();
        if (this.formatter) {
            this.formatter.editorManager.observer.off('keydown-handler', this.editorKeyDown);
        }
        this.element.ownerDocument.defaultView.removeEventListener('resize', this.onResizeHandler, true);
        if (this.iframeSettings.enable) {
            sf.base.EventHandler.remove(this.inputElement, 'focusin', this.focusHandler);
            sf.base.EventHandler.remove(this.inputElement, 'focusout', this.blurHandler);
            sf.base.EventHandler.remove(this.inputElement.ownerDocument, 'scroll', this.contentScrollHandler);
            sf.base.EventHandler.remove(this.inputElement.ownerDocument, sf.base.Browser.touchStartEvent, this.onIframeMouseDown);
        }
        this.unWireScrollElementsEvents();
    };
    SfRichTextEditor.prototype.unWireContextEvent = function () {
        sf.base.EventHandler.remove(this.inputElement, 'contextmenu', this.contextHandler);
        if (sf.base.Browser.isDevice && this.touchModule) {
            this.touchModule.destroy();
        }
    };
    SfRichTextEditor.prototype.unWireScrollElementsEvents = function () {
        this.scrollParentElements = sf.popups.getScrollableParent(this.element);
        for (var _i = 0, _a = this.scrollParentElements; _i < _a.length; _i++) {
            var element = _a[_i];
            sf.base.EventHandler.remove(element, 'scroll', this.scrollHandler);
        }
        if (!this.iframeSettings.enable) {
            sf.base.EventHandler.remove(this.getPanel(), 'scroll', this.contentScrollHandler);
        }
    };
    //#endregion
    //#region Event handler methods
    SfRichTextEditor.prototype.focusHandler = function (e) {
        if ((!this.isRTE || this.isFocusOut)) {
            this.isRTE = this.isFocusOut ? false : true;
            this.isFocusOut = false;
            sf.base.addClass([this.element], [CLS_FOCUS]);
            if (this.editorMode === 'HTML') {
                this.cloneValue = (this.inputElement.innerHTML === '<p><br></p>') ? null : this.enableHtmlEncode ?
                    this.encode(decode(this.inputElement.innerHTML)) : this.inputElement.innerHTML;
            }
            else {
                this.cloneValue = this.inputElement.value === '' ? null :
                    this.inputElement.value;
            }
            var active = document.activeElement;
            if (active === this.element || active === this.getToolbarElement() || active === this.getEditPanel()
                || ((this.iframeSettings.enable && active === this.getPanel()) &&
                    e.target && !e.target.classList.contains('e-img-inner')
                    && (e.target && e.target.parentElement
                        && !e.target.parentElement.classList.contains('e-img-wrap')))
                || sf.base.closest(active, '.e-rte-toolbar') === this.getToolbarElement()) {
                this.getEditPanel().focus();
                if (!sf.base.isNullOrUndefined(this.getToolbarElement())) {
                    this.getToolbarElement().setAttribute('tabindex', '-1');
                    var items = this.getToolbarElement().querySelectorAll('[tabindex="0"]');
                    for (var i = 0; i < items.length; i++) {
                        items[i].setAttribute('tabindex', '-1');
                    }
                }
            }
            this.defaultResize(e, false);
            var args = { isInteracted: Object.keys(e).length === 0 ? false : true };
            if (this.focusEnabled) {
                this.dotNetRef.invokeMethodAsync('FocusEvent', args);
            }
            if (!sf.base.isNullOrUndefined(this.saveInterval) && this.saveInterval > 0 && !this.autoSaveOnIdle) {
                this.timeInterval = setInterval(this.updateValueOnIdle.bind(this), this.saveInterval);
            }
            sf.base.EventHandler.add(document, 'mousedown', this.onDocumentClick, this);
        }
        if (!sf.base.isNullOrUndefined(this.getToolbarElement())) {
            var toolbarItem = this.getToolbarElement().querySelectorAll('input,select,button,a,[tabindex]');
            for (var i = 0; i < toolbarItem.length; i++) {
                if ((!toolbarItem[i].classList.contains('e-rte-dropdown-btn') &&
                    !toolbarItem[i].classList.contains('e-insert-table-btn')) &&
                    (!toolbarItem[i].hasAttribute('tabindex') ||
                        toolbarItem[i].getAttribute('tabindex') !== '-1')) {
                    toolbarItem[i].setAttribute('tabindex', '-1');
                }
            }
        }
    };
    SfRichTextEditor.prototype.blurHandler = function (e) {
        var trg = e.relatedTarget;
        if (trg) {
            var rteElement = sf.base.closest(trg, '.' + CLS_RTE);
            if (rteElement && rteElement === this.element) {
                this.isBlur = false;
                if (trg === this.getToolbarElement()) {
                    trg.setAttribute('tabindex', '-1');
                }
            }
            else if (sf.base.closest(trg, '[aria-owns="' + this.element.id + '"]') || !sf.base.isNullOrUndefined(sf.base.closest(trg, '.' + CLS_RTE_ELEMENTS))) {
                this.isBlur = false;
            }
            else {
                this.isBlur = true;
                trg = null;
            }
        }
        else if (!this.isIframeRteElement) {
            this.isBlur = true;
            this.isIframeRteElement = true;
        }
        if (this.isBlur && sf.base.isNullOrUndefined(trg)) {
            sf.base.removeClass([this.element], [CLS_FOCUS]);
            this.observer.notify(focusChange, {});
            this.value = this.getUpdatedValue();
            this.updateValueContainer(this.value);
            this.observer.notify(toolbarRefresh, { args: e, documentNode: document });
            this.invokeChangeEvent();
            this.isFocusOut = true;
            this.isBlur = false;
            if (this.enableXhtml) {
                this.valueContainer.value = this.getXhtmlString(this.valueContainer.value);
            }
            dispatchEvent(this.valueContainer, 'focusout');
            this.defaultResize(e, true);
            var args = { isInteracted: Object.keys(e).length === 0 ? false : true };
            if (this.blurEnabled) {
                this.dotNetRef.invokeMethodAsync('BlurEvent', args);
            }
            if (!sf.base.isNullOrUndefined(this.timeInterval)) {
                clearInterval(this.timeInterval);
                this.timeInterval = null;
            }
            sf.base.EventHandler.remove(document, 'mousedown', this.onDocumentClick);
        }
        else {
            this.isRTE = true;
        }
    };
    SfRichTextEditor.prototype.resizeHandler = function () {
        var isExpand = false;
        if (!document.body.contains(this.element)) {
            return;
        }
        if (this.toolbarSettings.enable && !this.inlineMode.enable) {
            this.dotNetRef.invokeMethodAsync('RefreshToolbarOverflow');
            var tbElement = this.element.querySelector('.e-rte-toolbar');
            isExpand = tbElement && tbElement.classList.contains(CLS_EXPAND_OPEN);
        }
        this.setContentHeight('windowResize', isExpand);
        this.observer.notify(windowResize, null);
    };
    SfRichTextEditor.prototype.touchHandler = function (e) {
        this.notifyMouseUp(e.originalEvent);
        this.triggerEditArea(e.originalEvent);
    };
    SfRichTextEditor.prototype.resetHandler = function () {
        var defaultValue = this.valueContainer.defaultValue.trim().replace(/<!--!-->/gi, '');
        this.value = (defaultValue === '' ? null : this.defaultResetValue);
        this.setPanelValue(this.value, true);
    };
    SfRichTextEditor.prototype.contextHandler = function (e) {
        var closestElem = sf.base.closest(e.target, 'a, table, img');
        if (this.inlineMode.onSelection === false || (!sf.base.isNullOrUndefined(closestElem) && this.inputElement.contains(closestElem)
            && (closestElem.tagName === 'IMG' || closestElem.tagName === 'TABLE' || closestElem.tagName === 'A'))) {
            e.preventDefault();
        }
    };
    SfRichTextEditor.prototype.scrollHandler = function (e) {
        this.observer.notify(scroll, { args: e });
    };
    SfRichTextEditor.prototype.contentScrollHandler = function (e) {
        this.observer.notify(contentscroll, { args: e });
    };
    SfRichTextEditor.prototype.mouseUp = function (e) {
        if (this.quickToolbarSettings.showOnRightClick && sf.base.Browser.isDevice) {
            var target = e.target;
            var closestTable = sf.base.closest(target, 'table');
            if (target && target.nodeName === 'A' || target.nodeName === 'IMG' || (target.nodeName === 'TD' || target.nodeName === 'TH' ||
                target.nodeName === 'TABLE' || (closestTable && this.getEditPanel().contains(closestTable)))) {
                return;
            }
        }
        this.notifyMouseUp(e);
    };
    SfRichTextEditor.prototype.mouseDownHandler = function (e) {
        var touch = (e.touches ? e.changedTouches[0] : e);
        sf.base.addClass([this.element], [CLS_FOCUS]);
        this.defaultResize(e, false);
        this.observer.notify(mouseDown, { args: e });
        this.clickPoints = { clientX: touch.clientX, clientY: touch.clientY };
    };
    SfRichTextEditor.prototype.onIframeMouseDown = function (e) {
        this.isBlur = false;
        this.observer.notify(iframeMouseDown, e);
    };
    SfRichTextEditor.prototype.keyDown = function (e) {
        this.observer.notify(keyDown, { member: 'keydown', args: e });
        this.restrict(e);
        if (this.iframeSettings.enable && !this.enableTabKey && (e.which === 9 && e.code === 'Tab')
            && e.target.nodeName === 'BODY') {
            this.isIframeRteElement = false;
        }
        if (this.editorMode === 'HTML' && ((e.which === 8 && e.code === 'Backspace') || (e.which === 46 && e.code === 'Delete'))) {
            var range = this.getRange();
            var startNode = range.startContainer.nodeName === '#text' ? range.startContainer.parentElement :
                range.startContainer;
            if (sf.base.closest(startNode, 'pre') &&
                (e.which === 8 && range.startContainer.textContent.charCodeAt(range.startOffset - 1) === 8203) ||
                (e.which === 46 && range.startContainer.textContent.charCodeAt(range.startOffset) === 8203)) {
                var regEx = new RegExp(String.fromCharCode(8203), 'g');
                var pointer = e.which === 8 ? range.startOffset - 1 : range.startOffset;
                range.startContainer.textContent = range.startContainer.textContent.replace(regEx, '');
                this.formatter.editorManager.nodeSelection.setCursorPoint(this.getDocument(), range.startContainer, pointer);
            }
            else if ((e.code === 'Backspace' && e.which === 8) &&
                range.startContainer.textContent.charCodeAt(0) === 8203 && range.collapsed) {
                var parentEle = range.startContainer.parentElement;
                var index = void 0;
                var i = void 0;
                for (i = 0; i < parentEle.childNodes.length; i++) {
                    if (parentEle.childNodes[i] === range.startContainer) {
                        index = i;
                    }
                }
                var bool = true;
                var removeNodeArray = [];
                for (i = index; i >= 0; i--) {
                    if (parentEle.childNodes[i].nodeType === 3 && parentEle.childNodes[i].textContent.charCodeAt(0) === 8203 && bool) {
                        removeNodeArray.push(i);
                    }
                    else {
                        bool = false;
                    }
                }
                if (removeNodeArray.length > 0) {
                    for (i = removeNodeArray.length - 1; i > 0; i--) {
                        parentEle.childNodes[removeNodeArray[i]].textContent = '';
                    }
                }
                this.formatter.editorManager.nodeSelection.setCursorPoint(this.getDocument(), range.startContainer, range.startOffset);
            }
        }
        if (this.formatter.getUndoRedoStack().length === 0) {
            this.formatter.saveData();
        }
        if (e.action !== 'insert-link' &&
            (e.action && e.action !== 'paste' && e.action !== 'space'
                || e.which === 9 || (e.code === 'Backspace' && e.which === 8))) {
            this.formatter.process(this, null, e);
            switch (e.action) {
                case 'toolbar-focus':
                    if (this.toolbarSettings.enable) {
                        var selector = '.e-toolbar-item[aria-disabled="false"][title] [tabindex]';
                        this.getToolbar().querySelector(selector).focus();
                    }
                    break;
                case 'escape':
                    this.getEditPanel().focus();
                    break;
            }
        }
        if (!sf.base.isNullOrUndefined(this.placeholder)) {
            if ((!sf.base.isNullOrUndefined(this.placeHolderContainer)) && (this.inputElement.textContent.length !== 1)) {
                this.placeHolderContainer.style.display = 'none';
            }
            else {
                this.setPlaceHolder();
            }
        }
        this.autoResize();
    };
    SfRichTextEditor.prototype.editorKeyDown = function (e) {
        switch (e.event.action) {
            case 'copy':
                this.onCopy();
                break;
            case 'cut':
                this.onCut();
                break;
        }
        if (e.callBack && (e.event.action === 'copy' || e.event.action === 'cut' || e.event.action === 'delete')) {
            e.callBack({
                requestType: e.event.action,
                editorMode: 'HTML',
                event: e.event
            });
        }
    };
    SfRichTextEditor.prototype.keyUp = function (e) {
        if (this.editorMode === 'HTML') {
            switch (e.which) {
                case 46:
                case 8:
                    var childNodes = this.getEditPanel().childNodes;
                    if ((childNodes.length === 0) ||
                        (childNodes.length === 1 && ((childNodes[0].tagName === 'BR') ||
                            (childNodes[0].tagName === 'P' &&
                                (childNodes[0].childNodes.length === 0 || childNodes[0].textContent === ''))))) {
                        var node = this.getEditPanel();
                        node.innerHTML = '<p><br/></p>';
                        this.formatter.editorManager.nodeSelection.setCursorPoint(this.getDocument(), node.childNodes[0], 0);
                    }
                    break;
            }
        }
        this.observer.notify(keyUp, { member: 'keyup', args: e });
        if (e.code === 'KeyX' && e.which === 88 && e.keyCode === 88 && e.ctrlKey && (this.inputElement.innerHTML === '' ||
            this.inputElement.innerHTML === '<br>')) {
            this.inputElement.innerHTML = getEditValue('<p><br></p>', this);
        }
        var allowedKeys = e.which === 32 || e.which === 13 || e.which === 8 || e.which === 46;
        if (((e.key !== 'shift' && !e.ctrlKey) && e.key && e.key.length === 1 || allowedKeys) || (this.editorMode === 'Markdown'
            && ((e.key !== 'shift' && !e.ctrlKey) && e.key && e.key.length === 1 || allowedKeys)) && !this.inlineMode.enable) {
            this.formatter.onKeyHandler(this, e);
        }
        if (this.inputElement && this.inputElement.textContent.length !== 0
            || this.element.querySelectorAll('.e-toolbar-item.e-active').length > 0) {
            this.observer.notify(toolbarRefresh, { args: e });
        }
        if (!sf.base.isNullOrUndefined(this.placeholder)) {
            if (!(e.key === 'Enter' && e.keyCode === 13) && this.inputElement.innerHTML === '<p><br></p>') {
                this.setPlaceHolder();
            }
        }
    };
    SfRichTextEditor.prototype.onCut = function () {
        this.getDocument().execCommand('cut', false, null);
    };
    SfRichTextEditor.prototype.onCopy = function () {
        this.getDocument().execCommand('copy', false, null);
    };
    SfRichTextEditor.prototype.onPaste = function (e) {
        if (!sf.base.isNullOrUndefined(sf.base.select('.e-rte-img-dialog', this.element))) {
            return;
        }
        var currentLength = this.getText().length;
        var selectionLength = this.getSelection().length;
        var pastedContentLength = (sf.base.isNullOrUndefined(e) || sf.base.isNullOrUndefined(e.clipboardData))
            ? 0 : e.clipboardData.getData('text/plain').length;
        var totalLength = (currentLength - selectionLength) + pastedContentLength;
        if (this.editorMode === 'Markdown') {
            if (!(this.maxLength === -1 || totalLength < this.maxLength)) {
                e.preventDefault();
            }
            return;
        }
        if (this.inputElement.contentEditable === 'true' &&
            (this.maxLength === -1 || totalLength < this.maxLength)) {
            this.observer.notify(pasteClean, { args: e });
        }
        else {
            e.preventDefault();
        }
    };
    SfRichTextEditor.prototype.onDocumentClick = function (e) {
        var target = e.target;
        var rteElement = sf.base.closest(target, '.' + CLS_RTE);
        if (!this.element.contains(e.target) && document !== e.target && rteElement !== this.element &&
            !sf.base.closest(target, '[aria-owns="' + this.element.id + '"]')) {
            this.isBlur = true;
            this.isRTE = false;
        }
        this.observer.notify(docClick, { args: e });
    };
    SfRichTextEditor.prototype.propertyChangeHandler = function (newProps) {
        var oldProps = {};
        for (var _i = 0, _a = Object.keys(newProps); _i < _a.length; _i++) {
            var prop = _a[_i];
            /* eslint-disable */
            oldProps[prop] = this[prop];
            /* eslint-enable */
        }
        var oldValue = this.value;
        this.updateContext(newProps);
        for (var _b = 0, _c = Object.keys(newProps); _b < _c.length; _b++) {
            var prop = _c[_b];
            switch (prop) {
                case 'enableXhtml':
                case 'enableHtmlSanitizer':
                case 'value':
                    if (prop === 'value' && oldValue === this.value) {
                        break;
                    }
                    this.setPanelValue(this.value);
                    if (this.enableXhtml) {
                        this.value = this.getXhtml();
                    }
                    break;
                case 'height':
                    this.setHeight(this.height);
                    this.setContentHeight();
                    this.autoResize();
                    break;
                case 'width':
                    this.setWidth(this.width);
                    if (this.toolbarSettings.enable) {
                        this.dotNetRef.invokeMethodAsync('RefreshToolbarOverflow');
                        //this.toolbarModule.refreshToolbarOverflow();
                        this.resizeHandler();
                    }
                    break;
                case 'readonly':
                    this.setReadOnly(false);
                    break;
                case 'enabled':
                    this.setEnable();
                    break;
                case 'placeholder':
                    this.placeholder = this.placeholder;
                    this.setPlaceHolder();
                    break;
                case 'showCharCount':
                    if (this.showCharCount && this.countModule) {
                        this.countModule.renderCount();
                    }
                    else if (this.showCharCount === false && this.countModule) {
                        this.countModule.destroy();
                    }
                    break;
                case 'maxLength':
                    if (this.showCharCount) {
                        this.countModule.refresh();
                    }
                    break;
                case 'enableHtmlEncode':
                    this.updateValueData();
                    this.updatePanelValue();
                    this.setPlaceHolder();
                    if (this.showCharCount) {
                        this.countModule.refresh();
                    }
                    break;
                case 'undoRedoSteps':
                case 'undoRedoTimer':
                    this.formatter.editorManager.observer.notify('model_changed', { newProp: newProps });
                    break;
                case 'adapter':
                    var editElement = this.getEditPanel();
                    var option = { undoRedoSteps: this.undoRedoSteps, undoRedoTimer: this.undoRedoTimer };
                    if (this.editorMode === 'Markdown') {
                        this.formatter = new MarkdownFormatter(sf.base.extend({}, this.adapter, {
                            element: editElement,
                            options: option
                        }));
                    }
                    break;
                case 'iframeSettings':
                    var frameSetting = oldProps[prop];
                    if (frameSetting.resources) {
                        var iframe = this.getDocument();
                        var header = iframe.querySelector('head');
                        var files = void 0;
                        if (frameSetting.resources.scripts) {
                            files = header.querySelectorAll('.' + CLS_SCRIPT_SHEET);
                            this.removeSheets(files);
                        }
                        if (frameSetting.resources.styles) {
                            files = header.querySelectorAll('.' + CLS_STYLE_SHEET);
                            this.removeSheets(files);
                        }
                    }
                    this.setIframeSettings();
                    break;
                case 'quickToolbarSettings':
                    this.quickToolbarSettings.showOnRightClick ? this.wireContextEvent() : this.unWireContextEvent();
                    break;
                default:
                    //this.observer.notify('model-changed', { newProp: newProp, oldProp: oldProp });
                    break;
            }
        }
    };
    return SfRichTextEditor;
}());

/**
 * Interop handler
 */
// eslint-disable-next-line
var RichTextEditor = {
    initialize: function (element, options, dotnetRef) {
        if (element) {
            new SfRichTextEditor(element, options, dotnetRef);
            element.blazor__instance.initialize();
        }
    },
    updateProperties: function (element, options) {
        if (element) {
            element.blazor__instance.updateContext(options);
        }
    },
    setPanelValue: function (element, value) {
        if (element) {
            element.blazor__instance.setPanelValue(value);
        }
    },
    toolbarItemClick: function (element, args, id, targetType) {
        if (element) {
            element.blazor__instance.toolbarItemClick(args, id, targetType);
        }
    },
    toolbarClick: function (element, id) {
        if (element) {
            element.blazor__instance.toolbarClick(id);
        }
    },
    listDropDownButtonClick: function (element, args) {
        if (element) {
            element.blazor__instance.onListDropDownButtonClick(args);
        }
    },
    dropDownBeforeOpen: function (element, args) {
        if (element) {
            element.blazor__instance.dropDownBeforeOpen(args);
        }
    },
    dropDownClose: function (element, args) {
        if (element) {
            element.blazor__instance.dropDownClose(args);
        }
    },
    dropDownButtonItemSelect: function (element, args) {
        if (element) {
            element.blazor__instance.dropDownSelect(args);
        }
    },
    colorDropDownBeforeOpen: function (element) {
        if (element) {
            element.blazor__instance.colorDropDownBeforeOpen();
        }
    },
    colorIconSelected: function (element, args, value, container) {
        if (element) {
            element.blazor__instance.colorIconSelected(args, value, container);
        }
    },
    colorPickerChanged: function (element, args, value, container) {
        if (element) {
            element.blazor__instance.colorChanged(args, value, container);
        }
    },
    cancelLinkDialog: function (element) {
        if (element) {
            element.blazor__instance.cancelLinkDialog();
        }
    },
    cancelImageDialog: function (element) {
        if (element) {
            element.blazor__instance.cancelImageDialog();
        }
    },
    linkDialogClosed: function (element) {
        if (element) {
            element.blazor__instance.linkDialogClosed();
        }
    },
    dialogClosed: function (element, type) {
        if (element) {
            element.blazor__instance.dialogClosed(type);
        }
    },
    insertLink: function (element, args) {
        if (element) {
            element.blazor__instance.insertLink(args);
        }
    },
    countCalculate: function (element) {
        if (element) {
            element.blazor__instance.countCalculate();
        }
    },
    imageRemoving: function (element) {
        if (element) {
            element.blazor__instance.imageRemoving();
        }
    },
    uploadSuccess: function (element, url, altText) {
        if (element) {
            element.blazor__instance.uploadSuccess(url, altText);
        }
    },
    imageSelected: function (element) {
        if (element) {
            element.blazor__instance.imageSelected();
        }
    },
    imageUploadComplete: function (element, base64Str, altText) {
        if (element) {
            element.blazor__instance.imageUploadComplete(base64Str, altText);
        }
    },
    imageUploadChange: function (element, url, isStream) {
        if (element) {
            element.blazor__instance.imageUploadChange(url, isStream);
        }
    },
    dropUploadChange: function (element, url, isStream) {
        if (element) {
            element.blazor__instance.dropUploadChange(url, isStream);
        }
    },
    insertImage: function (element) {
        if (element) {
            element.blazor__instance.insertImage();
        }
    },
    imageDialogOpened: function (element) {
        if (element) {
            element.blazor__instance.imageDialogOpened();
        }
    },
    imageDialogClosed: function (element) {
        if (element) {
            element.blazor__instance.imageDialogClosed();
        }
    },
    propertyChangeHandler: function (element, option) {
        if (element) {
            element.blazor__instance.propertyChangeHandler(option);
        }
    },
    insertTable: function (element, row, column) {
        if (element) {
            element.blazor__instance.insertTable(row, column);
        }
    },
    applyTableProperties: function (element, model) {
        if (element) {
            element.blazor__instance.applyTableProperties(model);
        }
    },
    createTablePopupOpened: function (element) {
        if (element) {
            element.blazor__instance.createTablePopupOpened();
        }
    },
    pasteContent: function (element, pasteOption) {
        if (element) {
            element.blazor__instance.pasteContent(pasteOption);
        }
    },
    updatePasteContent: function (element, value) {
        if (element) {
            element.blazor__instance.updatePasteContent(value);
        }
    },
    imageDropInitialized: function (element, isStream) {
        if (element) {
            element.blazor__instance.imageDropInitialized(isStream);
        }
    },
    preventEditable: function (element) {
        if (element) {
            element.blazor__instance.preventEditable();
        }
    },
    enableEditable: function (element) {
        if (element) {
            element.blazor__instance.enableEditable();
        }
    },
    removeDroppedImage: function (element) {
        if (element) {
            element.blazor__instance.removeDroppedImage();
        }
    },
    dropUploadSuccess: function (element, url, altText) {
        if (element) {
            element.blazor__instance.dropUploadSuccess(url, altText);
        }
    },
    executeCommand: function (element, commandName, value, option) {
        if (element) {
            element.blazor__instance.executeCommand(commandName, value, option);
        }
    },
    getCharCount: function (element) {
        return element && element.blazor__instance.getCharCount();
    },
    focusIn: function (element) {
        return element && element.blazor__instance.focusIn();
    },
    focusOut: function (element) {
        return element && element.blazor__instance.focusOut();
    },
    getContent: function (element) {
        return element && element.blazor__instance.getContent();
    },
    getHtml: function (element) {
        return element && element.blazor__instance.getHtml();
    },
    getSelectedHtml: function (element) {
        return element && element.blazor__instance.getSelectedHtml();
    },
    getSelection: function (element) {
        return element && element.blazor__instance.getSelection();
    },
    getText: function (element) {
        return element && element.blazor__instance.getText();
    },
    print: function (element) {
        return element && element.blazor__instance.print();
    },
    refreshUI: function (element) {
        return element && element.blazor__instance.refreshUI();
    },
    sanitizeHtml: function (element, value) {
        return element && element.blazor__instance.sanitizeHtml(value);
    },
    selectAll: function (element) {
        return element && element.blazor__instance.selectAll();
    },
    selectRange: function (element, range) {
        return element && element.blazor__instance.selectRange(range);
    },
    showFullScreen: function (element) {
        return element && element.blazor__instance.showFullScreen();
    },
    showSourceCode: function (element) {
        return element && element.blazor__instance.showSourceCode();
    },
    insertAlt: function (element, altText) {
        return element && element.blazor__instance.insertAlt(altText);
    },
    insertSize: function (element, width, height) {
        return element && element.blazor__instance.insertSize(width, height);
    },
    insertImageLink: function (element, url, target) {
        return element && element.blazor__instance.insertImageLink(url, target);
    },
    updateContentHeight: function (element) {
        return element && element.blazor__instance.setContentHeight();
    },
    saveSelection: function (element) {
        if (element) {
            element.blazor__instance.saveSelection();
        }
    },
    restoreSelection: function (element) {
        if (element) {
            element.blazor__instance.restoreSelection();
        }
    },
    getXhtml: function (element) {
        return element.blazor__instance.getXhtml();
    },
    showLinkDialog: function (element) {
        if (element) {
            element.blazor__instance.showLinkDialog();
        }
    },
    showImageDialog: function (element) {
        if (element) {
            element.blazor__instance.showImageDialog();
        }
    },
    showTableDialog: function (element) {
        if (element) {
            element.blazor__instance.showTableDialog();
        }
    },
    destroy: function (element) {
        if (element) {
            element.blazor__instance.destroy();
        }
    }
};

return RichTextEditor;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-spinner.js":
/*!*************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-spinner.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Spinner = (function () {
'use strict';

var SfSpinner = /** @class */ (function () {
    function SfSpinner(element) {
        this.element = element;
        this.element.blazor__instance = this;
    }
    SfSpinner.prototype.initialize = function (element) {
        var theme = window.getComputedStyle(element, ':after').getPropertyValue('content');
        return theme.replace(/['"]+/g, '');
    };
    return SfSpinner;
}());
// eslint-disable-next-line
var Spinner = {
    initialize: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            new SfSpinner(element);
            return (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) ?
                element.blazor__instance.initialize(element) : null;
        }
        else {
            return null;
        }
    }
};

return Spinner;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-splitter.js":
/*!**************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-splitter.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Splitter = (function () {
'use strict';

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/* class variables */
var ROOT = 'e-splitter';
var HORIZONTAL_PANE = 'e-splitter-horizontal';
var PANE = 'e-pane';
var SPLIT_BAR = 'e-split-bar';
var SPLIT_H_BAR = 'e-split-bar-horizontal';
var SPLIT_V_BAR = 'e-split-bar-vertical';
var STATIC_PANE = 'e-static-pane';
var RESIZE_BAR = 'e-resize-handler';
var RESIZABLE_BAR = 'e-resizable-split-bar';
var SPLIT_BAR_HOVER = 'e-split-bar-hover';
var SPLIT_BAR_ACTIVE = 'e-split-bar-active';
var HIDE_HANDLER = 'e-hide-handler';
var COLLAPSIBLE = 'e-collapsible';
var NAVIGATE_ARROW = 'e-navigate-arrow';
var ARROW_RIGHT = 'e-arrow-right';
var ARROW_LEFT = 'e-arrow-left';
var ARROW_UP = 'e-arrow-up';
var ARROW_DOWN = 'e-arrow-down';
var HIDE_ICON = 'e-icon-hidden';
var EXPAND_PANE = 'e-expanded';
var COLLAPSE_PANE = 'e-collapsed';
var PANE_HIDDEN = 'e-pane-hidden';
var RESIZABLE_PANE = 'e-resizable';
var LAST_BAR = 'e-last-bar';
/* common variables */
var MSIE = 'msie';
var IE = 'e-ie';
var HORIZONTAL = 'Horizontal';
var VERTICAL = 'Vertical';
var PX = 'px';
var ZERO_PX = '0px';
var IFRAME = 'iframe';
var SEPARATOR = 'separator';
var CHROME = 'chrome';
var ARIA_EXPANDED = 'aria-expanded';
var PREVIOUS = 'previous';
var CURRENT = 'current';
var FLEX_ONE = '1';
var FLEX_ZERO = '0';
var FLEX_EMPTY = '';
var ORDER_NO = 2; //TO find panes and seprator position.
var MIN = 'min';
var MAX = 'max';
var AUTO = 'auto';
var STRING = 'string';
var NONE = 'none';
var BAR_SIZE_DEFAULT = 1;
var RADIX = 10;
var PERCENT = 100;
var TRUE = 'true';
var FALSE = 'false';
/* event names */
var TOUCHSTART_CLICK = 'touchstart click';
var TOUCHSTART = 'touchstart';
var POINTERDOWN = 'pointerdown';
var MOUSEDOWN = 'mousedown';
var KEYDOWN = 'keydown';
var FOCUS = 'focus';
var BLUR = 'blur';
var MOUSEMOVE = 'mousemove';
var MOUSEUP = 'mouseup';
var POINTERMOVE = 'pointermove';
var POINTERUP = 'pointerup';
var TOUCHMOVE = 'touchmove';
var TOUCHEND = 'touchend';
var MOUSEENTER = 'mouseenter';
var MOUSELEAVE = 'mouseleave';
var MOUSEOUT = 'mouseout';
var MOUSEOVER = 'mouseover';
var MOUSE = 'mouse';
var TOUCH = 'touch';
var RESIZE = 'resize';
var SPLIT_TOUCH = 'e-splitter-touch';
/* Server side event variables */
var CREATED_EVENT = 'CreatedEvent';
var RESIZING_EVENT = 'ResizingEvent';
var RESIZE_START_EVENT = 'ResizeStartEvent';
var ONCOLLAPSED_EVENT = 'OnCollapseEvent';
var COLLAPSED_EVENT = 'CollapsedEvent';
var RESIZESTOP_EVENT = 'ResizeStopEvent';
var ONEXPAND_EVENT = 'OnExpandEvent';
var EXPANDED_EVENT = 'ExpandedEvent';
var UPDATE_COLLAPSED = 'UpdateCollapsed';
var UPDATE_SETTINGS = 'UpdateSettings';
/* keycode values */
var KEY_LEFT_ARROW = 37;
var KEY_UP_ARROW = 38;
var KEY_RIGHT_ARROW = 39;
var KEY_DOWN_ARROW = 40;
var SfSplitter = /** @class */ (function () {
    function SfSplitter(element, options, dotnetRef) {
        this.allPanes = [];
        this.allBars = [];
        this.previousCoordinates = {};
        this.currentCoordinates = {};
        this.updatePrePaneInPercentage = false;
        this.updateNextPaneInPercentage = false;
        this.panesDimensions = [];
        this.border = 0;
        this.isToggleInvoke = false;
        this.createdEnabled = false;
        this.resizingEnabled = false;
        this.expandedEnabled = false;
        this.onExpandEnabled = false;
        this.collapsedEnabled = false;
        this.onCollapseEnabled = false;
        this.onResizeStopEnabled = false;
        this.onResizeStartEnabled = false;
        this.iconsDelay = 300;
        this.collapseFlag = false;
        this.expandFlag = true;
        this.enablePersistence = false;
        this.element = element;
        this.dotNetRef = dotnetRef;
        this.updateContext(options);
        if (!sf.base.isNullOrUndefined(element)) {
            this.element.blazor__instance = this;
        }
    }
    SfSplitter.prototype.updateContext = function (splitObj) {
        sf.base.extend(this, this, splitObj);
    };
    SfSplitter.prototype.initialize = function () {
        this.id = this.element.id;
        this.addSeparator();
        this.collapseFlag = true;
        this.isCollapsed();
        this.collapseFlag = false;
        this.updateClass();
        sf.base.EventHandler.add(document, TOUCHSTART_CLICK, this.onDocumentClick, this);
        if (document.body.contains(this.element) && this.createdEnabled) {
            this.dotNetRef.invokeMethodAsync(CREATED_EVENT, null);
        }
        sf.base.EventHandler.add(this.element, KEYDOWN, this.onMove, this);
        window.addEventListener(RESIZE, this.reportWindowSize.bind(this), true);
        if (sf.base.Browser.isDevice) {
            sf.base.addClass([this.element], SPLIT_TOUCH);
        }
        if (this.enableReversePanes) {
            this.setReversePane();
        }
    };
    SfSplitter.prototype.setReversePane = function () {
        this.allPanes = this.allPanes.reverse();
        this.allBars = this.allBars.reverse();
        sf.base.addClass([this.allBars[this.allBars.length - 1]], LAST_BAR);
        sf.base.removeClass([this.allBars[0]], LAST_BAR);
    };
    SfSplitter.prototype.onDocumentClick = function (e) {
        if (!e.target.classList.contains(SPLIT_BAR) && !sf.base.isNullOrUndefined(this.currentSeparator)) {
            sf.base.removeClass([this.currentSeparator], [SPLIT_BAR_HOVER, SPLIT_BAR_ACTIVE]);
        }
    };
    SfSplitter.prototype.updateClass = function () {
        if (sf.base.Browser.info.name === MSIE) {
            sf.base.addClass([this.element], IE);
            var allBar = this.element.querySelectorAll('.' + ROOT + ' .' + RESIZE_BAR);
            for (var i = 0; i < allBar.length; i++) {
                var separatorSize = sf.base.isNullOrUndefined(this.separatorSize) ? 1 : this.separatorSize;
                sf.base.setStyleAttribute(allBar[i], { 'padding-left': separatorSize / ORDER_NO + PX,
                    'padding-right': separatorSize / ORDER_NO + PX });
            }
        }
    };
    SfSplitter.prototype.reportWindowSize = function () {
        var _this = this;
        var paneCount = this.allPanes.length;
        for (var i = 0; i < paneCount; i++) {
            if (sf.base.isNullOrUndefined(this.paneSettings[i].size)) {
                this.allPanes[i].classList.remove(STATIC_PANE);
            }
            if (paneCount - 1 === i) {
                var staticPaneCount = this.element.querySelectorAll('.' + STATIC_PANE).length;
                if (staticPaneCount === paneCount) {
                    sf.base.removeClass([this.allPanes[i]], STATIC_PANE);
                }
            }
        }
        setTimeout(function () { _this.updateSplitterSize(true); }, 200);
    };
    SfSplitter.prototype.onMove = function (event) {
        if (this.allPanes.length > 1 && this.element.children.length > 1) {
            this.getPaneDetails();
            this.getPaneDimensions();
            var index = this.getSeparatorIndex(this.currentSeparator);
            var isPrevpaneCollapsed = this.previousPane.classList.contains(COLLAPSE_PANE);
            var isPrevpaneExpanded = this.previousPane.classList.contains(EXPAND_PANE);
            var isNextpaneCollapsed = this.nextPane.classList.contains(COLLAPSE_PANE);
            if (((this.orientation !== HORIZONTAL && event.keyCode === KEY_UP_ARROW)
                || (this.orientation === HORIZONTAL && event.keyCode === KEY_RIGHT_ARROW)
                || (this.orientation === HORIZONTAL && event.keyCode === KEY_LEFT_ARROW)
                || (this.orientation !== HORIZONTAL && event.keyCode === KEY_DOWN_ARROW))
                && (!isPrevpaneExpanded && !isNextpaneCollapsed && !isPrevpaneCollapsed
                    || (isPrevpaneExpanded) && !isNextpaneCollapsed)
                && document.activeElement.classList.contains(SPLIT_BAR)
                && (this.paneSettings[index].resizable && this.paneSettings[index + 1].resizable)) {
                event.preventDefault();
                this.checkPaneSize(event);
                if (this.resizingEnabled) {
                    this.dotNetRef.invokeMethodAsync(RESIZING_EVENT, {
                        event: this.getKeyBoardEvtArgs(event),
                        index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()],
                        separator: this.getDomObject(SEPARATOR, this.currentSeparator),
                        paneSize: [this.prePaneDimenson, this.nextPaneDimension]
                    });
                }
            }
            else if (event.keyCode === 13 && this.paneSettings[index].collapsible &&
                document.activeElement.classList.contains(SPLIT_BAR) && this.currentSeparator.classList.contains(SPLIT_BAR_ACTIVE)) {
                if (!this.previousPane.classList.contains(COLLAPSE_PANE)) {
                    this.collapse(index);
                    sf.base.addClass([this.currentSeparator], SPLIT_BAR_ACTIVE);
                }
                else {
                    this.expand(index);
                    sf.base.addClass([this.currentSeparator], SPLIT_BAR_ACTIVE);
                }
            }
        }
    };
    
    SfSplitter.prototype.addSeparator = function () {
        var _this = this;
        var separator;
        this.allBars = [];
        this.allPanes = [];
        for (var j = 0; j < this.element.children.length; j++) {
            if (this.element.children[j].classList.contains(PANE)) {
                this.allPanes.push(this.element.children[j]);
            }
            if (this.element.children[j].classList.contains(SPLIT_BAR)) {
                this.allBars.push(this.element.children[j]);
            }
        }
        var childCount = this.allPanes.length;
        for (var i = 0; i < childCount; i++) {
            if (i < childCount - 1) {
                separator = this.allBars[i];
                this.updateIconClass();
                if (!sf.base.isNullOrUndefined(separator)) {
                    this.currentSeparator = separator;
                    this.addMouseActions(separator);
                    sf.base.EventHandler.add(this.currentSeparator, TOUCHSTART_CLICK, this.clickHandler, this);
                    separator.addEventListener(FOCUS, function () {
                        if (document.activeElement.classList.contains(SPLIT_BAR)) {
                            _this.currentSeparator = document.activeElement;
                            sf.base.addClass([_this.currentSeparator], SPLIT_BAR_ACTIVE);
                        }
                    });
                    separator.addEventListener(BLUR, function () {
                        sf.base.removeClass([_this.currentSeparator], SPLIT_BAR_ACTIVE);
                    });
                }
                if (!sf.base.isNullOrUndefined(separator)) {
                    if (this.isResizable()) {
                        sf.base.EventHandler.add(separator, MOUSEDOWN, this.onMouseDown, this);
                        var eventName = (sf.base.Browser.info.name === MSIE) ? POINTERDOWN : TOUCHSTART;
                        sf.base.EventHandler.add(separator, eventName, this.onMouseDown, this);
                        sf.base.addClass([separator], RESIZABLE_BAR);
                        this.updateResizablePanes(i);
                    }
                    else {
                        sf.base.addClass([sf.base.select('.' + RESIZE_BAR, separator)], HIDE_HANDLER);
                    }
                }
            }
            else {
                if (separator) {
                    sf.base.addClass([separator], LAST_BAR);
                }
                if (childCount > 1) {
                    this.updateResizablePanes(i);
                }
            }
        }
    };
    SfSplitter.prototype.updateSeparator = function () {
        for (var i = 0; i < this.allBars.length; i++) {
            var separator = this.allBars[i];
            sf.base.EventHandler.remove(separator, TOUCHSTART_CLICK, this.clickHandler);
        }
        this.addSeparator();
    };
    SfSplitter.prototype.updateResizablePanes = function (index) {
        this.getPaneDetails();
        this.isResizable() ? sf.base.addClass([this.allPanes[index]], RESIZABLE_PANE) : sf.base.addClass([this.allPanes[index]], RESIZABLE_PANE);
    };
    SfSplitter.prototype.getPaneDetails = function () {
        var prevPane = null;
        var nextPane = null;
        this.order = parseInt(this.currentSeparator.style.order, RADIX);
        if (this.allPanes.length > 1) {
            prevPane = this.getPrevPane(this.order);
            nextPane = this.getNextPane(this.order);
        }
        if (prevPane && nextPane) {
            this.previousPane = prevPane;
            this.nextPane = nextPane;
            this.prevPaneIndex = this.getPreviousPaneIndex();
            this.nextPaneIndex = this.getNextPaneIndex();
        }
    };
    SfSplitter.prototype.getOrderIndex = function (order, type) {
        var index;
        var panes = type === 'pane' ? this.allPanes : this.allBars;
        for (var i = 0; i < panes.length; i++) {
            if (parseInt(panes[i].style.order) === order) {
                index = i;
            }
        }
        return index;
    };
    SfSplitter.prototype.getPrevPane = function (order) {
        return this.enableReversePanes ? this.getOrderPane(order + 1) : this.getOrderPane(order - 1);
    };
    SfSplitter.prototype.getNextPane = function (order) {
        return this.enableReversePanes ? this.getOrderPane(order - 1) : this.getOrderPane(order + 1);
    };
    SfSplitter.prototype.getOrderPane = function (order) {
        var pane;
        for (var i = 0; i < this.element.children.length; i++) {
            if (parseInt(this.element.children[i].style.order) === order) {
                pane = this.element.children[i];
            }
        }
        return pane;
    };
    SfSplitter.prototype.getPreviousPaneIndex = function () {
        var separatorIndex = this.enableReversePanes ? parseInt(this.currentSeparator.style.order, 10) + 1 :
            parseInt(this.currentSeparator.style.order, 10) - 1;
        return this.getOrderIndex(separatorIndex, 'pane');
    };
    SfSplitter.prototype.getNextPaneIndex = function () {
        var separatorIndex = this.enableReversePanes ? parseInt(this.currentSeparator.style.order, 10) - 1 :
            parseInt(this.currentSeparator.style.order, 10) + 1;
        return this.getOrderIndex(separatorIndex, 'pane');
    };
    SfSplitter.prototype.onMouseDown = function (e) {
        e.preventDefault();
        var target = e.target;
        this.splitterDetails(e);
        if (target.classList.contains(NAVIGATE_ARROW)) {
            return;
        }
        this.updateCurrentSeparator(target);
        sf.base.addClass([this.currentSeparator], SPLIT_BAR_ACTIVE);
        this.updateCursorPosition(e, PREVIOUS);
        this.getPaneDetails();
        var iframeElements = this.element.querySelectorAll(IFRAME);
        for (var i = 0; i < iframeElements.length; i++) {
            iframeElements[i].style.pointerEvents = NONE;
        }
        if (this.onResizeStartEnabled) {
            this.dotNetRef.invokeMethodAsync(RESIZE_START_EVENT, {
                event: this.getMouseEvtArgs(e),
                index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()],
                separator: this.getDomObject(SEPARATOR, this.currentSeparator),
                cancel: false
            });
        }
        else {
            this.resizeEvent(e);
        }
    };
    SfSplitter.prototype.getMouseEvtArgs = function (e) {
        return {
            button: e.button,
            buttons: e.buttons,
            clientX: e.clientX,
            clientY: e.clientY,
            detail: e.detail,
            screenX: e.screenX,
            screenY: e.screenY,
            ctrlKey: e.ctrlKey,
            metaKey: e.metaKey,
            shiftKey: e.shiftKey,
            altKey: e.altKey,
            type: e.type
        };
    };
    
    SfSplitter.prototype.getKeyBoardEvtArgs = function (e) {
        return {
            key: e.key,
            code: e.code,
            location: e.location,
            repeat: e.repeat,
            ctrlKey: e.ctrlKey,
            metaKey: e.metaKey,
            shiftKey: e.shiftKey,
            altKey: e.altKey,
            type: e.type
        };
    };
    
    SfSplitter.prototype.getDomObject = function (value, element) {
        if (element != null) {
            // tslint:disable-next-line
            return window.sfBlazor.getDomObject(value, element);
        }
        else {
            return null;
        }
    };
    SfSplitter.prototype.resizeEvent = function (e) {
        this.wireResizeEvents();
        this.checkPaneSize(e);
    };
    SfSplitter.prototype.checkPaneSize = function (e) {
        var prePaneSize;
        var nextPaneSize;
        var splitBarSize = sf.base.isNullOrUndefined(this.separatorSize) ? BAR_SIZE_DEFAULT : this.separatorSize;
        prePaneSize = this.orientation === HORIZONTAL ? this.previousPane.offsetWidth : this.previousPane.offsetHeight;
        nextPaneSize = this.orientation === HORIZONTAL ? this.nextPane.offsetWidth : this.nextPane.offsetHeight;
        if ((this.previousPane.style.flexBasis.indexOf('%') > 0 || this.nextPane.style.flexBasis.indexOf('%') > 0)) {
            var previousFlexBasis = this.updatePaneFlexBasis(this.previousPane);
            var nextFlexBasis = this.updatePaneFlexBasis(this.nextPane);
            this.totalPercent = previousFlexBasis + nextFlexBasis;
            this.totalWidth = this.convertPercentageToPixel(this.totalPercent + '%');
            if (e.type === KEYDOWN && (!sf.base.isNullOrUndefined(e.keyCode))) {
                if ((e.keyCode === KEY_RIGHT_ARROW ||
                    (e.keyCode === KEY_DOWN_ARROW)) && nextPaneSize > 0 &&
                    (this.getMinInPixel(this.paneSettings[this.nextPaneIndex].min) <
                        this.convertPercentageToPixel((nextFlexBasis - 1) + '%'))) {
                    this.previousPane.style.flexBasis = (previousFlexBasis + 1) + '%';
                    this.nextPane.style.flexBasis = (nextFlexBasis - 1) + '%';
                }
                else if ((e.keyCode === KEY_LEFT_ARROW ||
                    (e.keyCode === KEY_UP_ARROW)) && prePaneSize > 0 &&
                    (this.getMinInPixel(this.paneSettings[this.prevPaneIndex].min) <
                        this.convertPercentageToPixel((previousFlexBasis - 1) + '%'))) {
                    this.previousPane.style.flexBasis = (previousFlexBasis - 1) + '%';
                    this.nextPane.style.flexBasis = (nextFlexBasis + 1) + '%';
                }
            }
        }
        else {
            this.totalWidth = (this.orientation === HORIZONTAL) ? this.previousPane.offsetWidth + this.nextPane.offsetWidth :
                this.previousPane.offsetHeight + this.nextPane.offsetHeight;
            if (e.type === KEYDOWN && (!sf.base.isNullOrUndefined(e.keyCode))) {
                if ((e.keyCode === KEY_RIGHT_ARROW ||
                    (e.keyCode === KEY_DOWN_ARROW)) && nextPaneSize > 0 &&
                    (this.getMinInPixel(this.paneSettings[this.nextPaneIndex].min) < (nextPaneSize + splitBarSize))) {
                    this.addStaticPaneClass();
                    this.previousPane.style.flexBasis = (prePaneSize + splitBarSize) + PX;
                    this.nextPane.style.flexBasis = (nextPaneSize < splitBarSize) ? ZERO_PX :
                        (nextPaneSize - splitBarSize) + PX;
                }
                else if ((e.keyCode === KEY_LEFT_ARROW ||
                    (e.keyCode === KEY_UP_ARROW)) && prePaneSize > 0 &&
                    (this.getMinInPixel(this.paneSettings[this.prevPaneIndex].min) < (prePaneSize - splitBarSize))) {
                    this.addStaticPaneClass();
                    this.previousPane.style.flexBasis = (prePaneSize < splitBarSize) ? ZERO_PX :
                        (prePaneSize - splitBarSize) + PX;
                    this.nextPane.style.flexBasis = (nextPaneSize + splitBarSize) + PX;
                }
            }
        }
    };
    SfSplitter.prototype.getMinInPixel = function (minValue) {
        var min;
        if (sf.base.isNullOrUndefined(minValue)) {
            return 0;
        }
        var paneMinRange = this.convertPixelToNumber(minValue.toString());
        if (minValue.indexOf('%') > 0) {
            paneMinRange = this.convertPercentageToPixel(minValue);
        }
        min = this.convertPixelToNumber((paneMinRange).toString());
        return min;
    };
    SfSplitter.prototype.addStaticPaneClass = function () {
        if (!this.previousPane.classList.contains(STATIC_PANE)) {
            sf.base.addClass([this.previousPane], STATIC_PANE);
        }
        if (!this.nextPane.classList.contains(STATIC_PANE)) {
            sf.base.addClass([this.nextPane], STATIC_PANE);
        }
    };
    SfSplitter.prototype.convertPercentageToPixel = function (value, targetElement) {
        var percentage = value.toString();
        var convertedValue;
        if (percentage.indexOf('%') > -1) {
            convertedValue = parseFloat(percentage.slice(0, percentage.indexOf('%')));
            var offsetValue = void 0;
            if (!sf.base.isNullOrUndefined(targetElement)) {
                offsetValue = this.panesDimensions[this.allPanes.indexOf(targetElement)];
            }
            else {
                offsetValue = (this.orientation === HORIZONTAL) ? this.element.offsetWidth : this.element.offsetHeight;
            }
            convertedValue = Math.ceil(offsetValue * (convertedValue / PERCENT));
        }
        else {
            convertedValue = parseInt(percentage, RADIX);
        }
        return convertedValue;
    };
    SfSplitter.prototype.updatePaneFlexBasis = function (pane) {
        var previous;
        if (pane.style.flexBasis.indexOf('%') > 0) {
            previous = parseFloat(pane.style.flexBasis.slice(0, pane.style.flexBasis.indexOf('%')));
        }
        else {
            if (pane.style.flexBasis !== '') {
                previous = this.convertPixelToPercentage(this.convertPixelToNumber(pane.style.flexBasis));
            }
            else {
                var offset = (this.orientation === HORIZONTAL) ? (pane.offsetWidth) : (pane.offsetHeight);
                previous = this.convertPixelToPercentage(offset);
            }
        }
        return previous;
    };
    SfSplitter.prototype.convertPixelToPercentage = function (value) {
        var offsetValue = (this.orientation === HORIZONTAL) ? this.element.offsetWidth : this.element.offsetHeight;
        return (value / offsetValue) * PERCENT;
    };
    SfSplitter.prototype.convertPixelToNumber = function (value) {
        return value.indexOf('p') > -1 ? parseFloat(value.slice(0, value.indexOf('p'))) : parseFloat(value);
    };
    SfSplitter.prototype.updateCurrentSeparator = function (target) {
        this.currentSeparator = target.classList.contains(SPLIT_BAR) ? target : target.parentElement;
    };
    SfSplitter.prototype.wireResizeEvents = function () {
        sf.base.EventHandler.add(document, MOUSEMOVE, this.onMouseMove, this);
        sf.base.EventHandler.add(document, MOUSEUP, this.onMouseUp, this);
        var touchMoveEvent = (sf.base.Browser.info.name === MSIE) ? POINTERMOVE : TOUCHMOVE;
        var touchEndEvent = (sf.base.Browser.info.name === MSIE) ? POINTERUP : TOUCHEND;
        sf.base.EventHandler.add(document, touchMoveEvent, this.onMouseMove, this);
        sf.base.EventHandler.add(document, touchEndEvent, this.onMouseUp, this);
    };
    SfSplitter.prototype.unwireResizeEvents = function () {
        var touchMoveEvent = (sf.base.Browser.info.name === MSIE) ? POINTERMOVE : TOUCHMOVE;
        var touchEndEvent = (sf.base.Browser.info.name === MSIE) ? POINTERUP : TOUCHEND;
        sf.base.EventHandler.remove(document, MOUSEMOVE, this.onMouseMove);
        sf.base.EventHandler.remove(document, MOUSEUP, this.onMouseUp);
        sf.base.EventHandler.remove(document, touchMoveEvent, this.onMouseMove);
        sf.base.EventHandler.remove(document, touchEndEvent, this.onMouseUp);
        window.removeEventListener(RESIZE, this.reportWindowSize.bind(this));
    };
    SfSplitter.prototype.onMouseMove = function (e) {
        if (!this.isCursorMoved(e)) {
            return;
        }
        this.getPaneDetails();
        this.getPaneDimensions();
        if (this.resizingEnabled) {
            this.dotNetRef.invokeMethodAsync(RESIZING_EVENT, {
                event: this.getMouseEvtArgs(e),
                index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()],
                separator: this.getDomObject(SEPARATOR, this.currentSeparator),
                paneSize: [this.prePaneDimenson, this.nextPaneDimension]
            });
        }
        var left = this.validateDraggedPosition(this.getSeparatorPosition(e), this.prePaneDimenson, this.nextPaneDimension);
        var separatorNewPosition;
        this.getBorder();
        if (this.orientation === HORIZONTAL) {
            separatorNewPosition = (this.element.getBoundingClientRect().left + left) -
                this.currentSeparator.getBoundingClientRect().left + this.border;
        }
        else {
            separatorNewPosition = (this.element.getBoundingClientRect().top + left) -
                this.currentSeparator.getBoundingClientRect().top + this.border;
        }
        this.nextPaneHeightWidth =
            (typeof (this.nextPaneHeightWidth) === STRING && this.nextPaneHeightWidth.indexOf('p') > -1) ?
                this.convertPixelToNumber(this.nextPaneHeightWidth) : parseInt(this.nextPaneHeightWidth, RADIX);
        this.prevPaneCurrentWidth = separatorNewPosition + this.convertPixelToNumber(this.previousPaneHeightWidth);
        this.nextPaneCurrentWidth = this.nextPaneHeightWidth - separatorNewPosition;
        this.validateMinMaxValues();
        if (this.nextPaneCurrentWidth < 0) {
            this.nextPaneCurrentWidth = 0;
        }
        /* istanbul ignore next */
        if (this.prevPaneCurrentWidth < 0) {
            this.prevPaneCurrentWidth = 0;
        }
        if ((this.nextPaneCurrentWidth + this.prevPaneCurrentWidth) > this.totalWidth) {
            if (this.nextPaneCurrentWidth < this.prevPaneCurrentWidth) {
                this.prevPaneCurrentWidth = this.prevPaneCurrentWidth - ((this.nextPaneCurrentWidth + this.prevPaneCurrentWidth)
                    - this.totalWidth);
            }
            else {
                this.nextPaneCurrentWidth = this.nextPaneCurrentWidth - ((this.nextPaneCurrentWidth + this.prevPaneCurrentWidth)
                    - this.totalWidth);
            }
        }
        /* istanbul ignore next */
        if ((this.nextPaneCurrentWidth + this.prevPaneCurrentWidth) < this.totalWidth) {
            var difference = this.totalWidth - ((this.nextPaneCurrentWidth + this.prevPaneCurrentWidth));
            this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + difference;
        }
        this.calculateCurrentDimensions();
        this.addStaticPaneClass();
        this.previousPane.style.flexBasis = this.prevPaneCurrentWidth;
        this.nextPane.style.flexBasis = this.nextPaneCurrentWidth;
        if (!(this.allPanes.length > ORDER_NO)) {
            this.updateSplitterSize();
        }
    };
    SfSplitter.prototype.updateSplitterSize = function (iswindowResize) {
        var totalWidth = 0;
        var flexPaneIndexes = [];
        var flexCount = 0;
        var children = this.element.children;
        for (var i = 0; i < children.length; i++) {
            totalWidth += this.orientation === HORIZONTAL ? children[i].offsetWidth :
                children[i].offsetHeight;
        }
        for (var j = 0; j < this.allBars.length; j++) {
            var cssStyles = getComputedStyle(this.allBars[j]);
            totalWidth += this.orientation === HORIZONTAL ? parseInt(cssStyles.marginLeft, RADIX) +
                parseInt(cssStyles.marginLeft, RADIX) : parseInt(cssStyles.marginTop, RADIX) +
                parseInt(cssStyles.marginBottom, RADIX);
        }
        var diff = this.orientation === HORIZONTAL ? this.element.offsetWidth -
            ((this.border * ORDER_NO) + totalWidth) :
            this.element.offsetHeight - ((this.border * ORDER_NO) + totalWidth);
        for (var i = 0; i < this.allPanes.length; i++) {
            if (!this.paneSettings[i].size && !(this.allPanes[i].innerText === '')) {
                flexPaneIndexes[flexCount] = i;
                flexCount++;
            }
        }
        var avgDiffWidth = diff / flexPaneIndexes.length;
        for (var j = 0; j < flexPaneIndexes.length; j++) {
            this.allPanes[flexPaneIndexes[j]].style.flexBasis = this.orientation === HORIZONTAL ?
                (this.allPanes[flexPaneIndexes[j]].offsetWidth + avgDiffWidth) + PX :
                (this.allPanes[flexPaneIndexes[j]].offsetHeight + avgDiffWidth) + PX;
        }
        if (this.allPanes.length === 2 && iswindowResize) {
            var paneCount = this.allPanes.length;
            var minValue = void 0;
            var paneMinRange = void 0;
            var paneIndex = 0;
            var updatePane = void 0;
            var flexPane = void 0;
            for (var i = 0; i < paneCount; i++) {
                if (!sf.base.isNullOrUndefined(this.paneSettings[i].min)) {
                    paneMinRange = this.convertPixelToNumber((this.paneSettings[i].min).toString());
                    if (this.paneSettings[i].min.indexOf('%') > 0) {
                        paneMinRange = this.convertPercentageToPixel(this.paneSettings[i].min);
                    }
                    minValue = this.convertPixelToNumber((paneMinRange).toString());
                    if (this.allPanes[i].offsetWidth < minValue) {
                        if (i === paneIndex) {
                            updatePane = this.allPanes[i];
                            flexPane = this.allPanes[i + 1];
                        }
                        else {
                            updatePane = this.allPanes[i];
                            flexPane = this.allPanes[i - 1];
                        }
                        var sizeDiff = minValue - this.allPanes[i].offsetWidth;
                        var isPercent = updatePane.style.flexBasis.indexOf('%') > -1;
                        updatePane.style.flexBasis = isPercent ? this.convertPixelToPercentage(updatePane.offsetWidth + sizeDiff) + '%'
                            : (updatePane.offsetWidth + sizeDiff) + 'px';
                        flexPane.style.flexBasis = flexPane.style.flexBasis.indexOf('%') > -1 ?
                            this.convertPixelToPercentage(flexPane.offsetWidth - sizeDiff) + '%' : (flexPane.offsetWidth - sizeDiff) + 'px';
                    }
                }
            }
        }
    };
    SfSplitter.prototype.calcDragPosition = function (rectValue, offsetValue) {
        var separatorPosition;
        var separator;
        separatorPosition = this.orientation === HORIZONTAL ? (this.currentCoordinates.x - rectValue) :
            (this.currentCoordinates.y - rectValue);
        separator = separatorPosition / offsetValue;
        separator = (separator > 1) ? 1 : (separator < 0) ? 0 : separator;
        return separator * offsetValue;
    };
    SfSplitter.prototype.getSeparatorPosition = function (e) {
        this.updateCursorPosition(e, CURRENT);
        var rectBound = (this.orientation === HORIZONTAL) ? this.element.getBoundingClientRect().left :
            this.element.getBoundingClientRect().top + window.scrollY;
        var offSet = (this.orientation === HORIZONTAL) ? this.element.offsetWidth : this.element.offsetHeight;
        return this.calcDragPosition(rectBound, offSet);
    };
    SfSplitter.prototype.getBorder = function () {
        var border = this.orientation === HORIZONTAL ? ((this.element.offsetWidth - this.element.clientWidth) / ORDER_NO) :
            (this.element.offsetHeight - this.element.clientHeight) / ORDER_NO;
        this.border = sf.base.Browser.info.name !== CHROME ? 0 : border;
    };
    SfSplitter.prototype.validateMinMaxValues = function () {
        this.prevPaneCurrentWidth = this.validateMinRange(this.prevPaneIndex, this.prevPaneCurrentWidth, this.previousPane);
        this.nextPaneCurrentWidth = this.validateMinRange(this.nextPaneIndex, this.nextPaneCurrentWidth, this.nextPane);
        this.prevPaneCurrentWidth = this.validateMaxRange(this.prevPaneIndex, this.prevPaneCurrentWidth, this.previousPane);
        this.nextPaneCurrentWidth = this.validateMaxRange(this.nextPaneIndex, this.nextPaneCurrentWidth, this.nextPane);
    };
    SfSplitter.prototype.validateMinRange = function (paneIndex, paneCurrentWidth, pane) {
        var paneMinRange = null;
        var paneMinDimensions;
        var difference = 0;
        var validatedVal;
        if (!sf.base.isNullOrUndefined(this.paneSettings[paneIndex]) && !sf.base.isNullOrUndefined(this.paneSettings[paneIndex].min)) {
            paneMinRange = this.paneSettings[paneIndex].min.toString();
        }
        if (!sf.base.isNullOrUndefined(paneMinRange)) {
            if (paneMinRange.indexOf('%') > 0) {
                paneMinRange = this.convertPercentageToPixel(paneMinRange).toString();
            }
            paneMinDimensions = this.convertPixelToNumber(paneMinRange);
            if (paneCurrentWidth < paneMinDimensions) {
                difference = (paneCurrentWidth - paneMinDimensions) <= 0 ? 0 :
                    (paneCurrentWidth - paneMinDimensions);
                this.totalWidth = this.totalWidth - difference;
                this.totalPercent = this.convertPixelToPercentage(this.totalWidth);
                validatedVal = paneMinDimensions;
            }
        }
        return sf.base.isNullOrUndefined(validatedVal) ? paneCurrentWidth : validatedVal;
    };
    SfSplitter.prototype.validateMaxRange = function (paneIndex, paneCurrentWidth, pane) {
        var paneMaxRange = null;
        var paneMaxDimensions;
        var validatedVal;
        if (!sf.base.isNullOrUndefined(this.paneSettings[paneIndex]) && !sf.base.isNullOrUndefined(this.paneSettings[paneIndex].max)) {
            paneMaxRange = this.paneSettings[paneIndex].max.toString();
        }
        if (!sf.base.isNullOrUndefined(paneMaxRange)) {
            if (paneMaxRange.indexOf('%') > 0) {
                paneMaxRange = this.convertPercentageToPixel(paneMaxRange).toString();
            }
            paneMaxDimensions = this.convertPixelToNumber(paneMaxRange);
            if (paneCurrentWidth > paneMaxDimensions) {
                this.totalWidth = this.totalWidth - (paneCurrentWidth - paneMaxDimensions);
                this.totalPercent = this.convertPixelToPercentage(this.totalWidth);
                validatedVal = paneMaxDimensions;
            }
        }
        return sf.base.isNullOrUndefined(validatedVal) ? paneCurrentWidth : validatedVal;
    };
    SfSplitter.prototype.calculateCurrentDimensions = function () {
        if (this.updatePrePaneInPercentage || this.updateNextPaneInPercentage) {
            this.prevPaneCurrentWidth = Math.round(Number(Math.round(this.convertPixelToPercentage(this.prevPaneCurrentWidth)
                * RADIX) / RADIX));
            this.nextPaneCurrentWidth = Math.round(Number(Math.round(this.convertPixelToPercentage(this.nextPaneCurrentWidth)
                * RADIX) / RADIX));
            if (this.prevPaneCurrentWidth === 0) {
                this.nextPaneCurrentWidth = this.totalPercent;
            }
            if (this.nextPaneCurrentWidth === 0) {
                this.prevPaneCurrentWidth = this.totalPercent;
            }
            if (this.prevPaneCurrentWidth + this.nextPaneCurrentWidth !== this.totalPercent) {
                this.equatePaneWidths();
            }
            else {
                this.prevPaneCurrentWidth = this.prevPaneCurrentWidth + '%';
                this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + '%';
            }
            this.prevPaneCurrentWidth = (this.updatePrePaneInPercentage) ? this.prevPaneCurrentWidth :
                this.convertPercentageToPixel(this.prevPaneCurrentWidth) + 'px';
            this.nextPaneCurrentWidth = (this.updateNextPaneInPercentage) ? this.nextPaneCurrentWidth :
                this.convertPercentageToPixel(this.nextPaneCurrentWidth) + 'px';
            this.updatePrePaneInPercentage = false;
            this.updateNextPaneInPercentage = false;
        }
        else {
            this.prevPaneCurrentWidth = this.prevPaneCurrentWidth + 'px';
            this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + 'px';
        }
    };
    SfSplitter.prototype.equatePaneWidths = function () {
        var difference;
        if ((this.prevPaneCurrentWidth + this.nextPaneCurrentWidth) > this.totalPercent) {
            difference = (this.prevPaneCurrentWidth + this.nextPaneCurrentWidth) - this.totalPercent;
            this.prevPaneCurrentWidth = this.prevPaneCurrentWidth - (difference / ORDER_NO) + '%';
            this.nextPaneCurrentWidth = this.nextPaneCurrentWidth - (difference / ORDER_NO) + '%';
        }
        if ((this.prevPaneCurrentWidth + this.nextPaneCurrentWidth) < this.totalPercent) {
            difference = this.totalPercent - (this.prevPaneCurrentWidth + this.nextPaneCurrentWidth);
            this.prevPaneCurrentWidth = this.prevPaneCurrentWidth + (difference / ORDER_NO) + '%';
            this.nextPaneCurrentWidth = this.nextPaneCurrentWidth + (difference / ORDER_NO) + '%';
        }
    };
    SfSplitter.prototype.validateDraggedPosition = function (draggedPos, prevPaneHeightWidth, nextPaneHeightWidth) {
        var separatorTopLeft = (this.orientation === HORIZONTAL) ? this.currentSeparator.offsetLeft :
            this.currentSeparator.offsetTop;
        var prePaneRange = separatorTopLeft - prevPaneHeightWidth;
        var nextPaneRange = nextPaneHeightWidth + separatorTopLeft;
        var pane1MinSize = this.getMinMax(this.prevPaneIndex, MIN);
        var pane2MinSize = this.getMinMax(this.nextPaneIndex, MIN);
        var pane1MaxSize = this.getMinMax(this.prevPaneIndex, MAX);
        var pane2MaxSize = this.getMinMax(this.nextPaneIndex, MAX);
        var validatedSize = draggedPos;
        if (draggedPos > nextPaneRange - pane2MinSize) {
            validatedSize = nextPaneRange - pane2MinSize;
        }
        else if (draggedPos < prePaneRange + pane1MinSize) {
            validatedSize = prePaneRange + pane1MinSize;
        }
        if (!sf.base.isNullOrUndefined(pane1MaxSize)) {
            if (draggedPos > prePaneRange + pane1MaxSize) {
                validatedSize = prePaneRange + pane1MaxSize;
            }
        }
        else if (!sf.base.isNullOrUndefined(pane2MaxSize)) {
            if (draggedPos < nextPaneRange - pane2MaxSize) {
                validatedSize = nextPaneRange - pane2MaxSize;
            }
        }
        return validatedSize;
    };
    SfSplitter.prototype.getMinMax = function (paneIndex, selection) {
        var defaultVal = selection === MIN ? 0 : null;
        // tslint:disable-next-line
        var paneValue = null;
        if (selection === MIN) {
            if (!sf.base.isNullOrUndefined(this.paneSettings[paneIndex]) &&
                !sf.base.isNullOrUndefined(this.paneSettings[paneIndex].min)) {
                paneValue = this.paneSettings[paneIndex].min;
            }
        }
        else {
            if (!sf.base.isNullOrUndefined(this.paneSettings[paneIndex]) &&
                !sf.base.isNullOrUndefined(this.paneSettings[paneIndex].max)) {
                paneValue = this.paneSettings[paneIndex].max;
            }
        }
        if (this.paneSettings.length > 0 && !sf.base.isNullOrUndefined(this.paneSettings[paneIndex]) &&
            !sf.base.isNullOrUndefined(paneValue)) {
            if (paneValue.indexOf('%') > 0) {
                paneValue = this.convertPercentageToPixel(paneValue).toString();
            }
            return this.convertPixelToNumber(paneValue);
        }
        else {
            return defaultVal;
        }
    };
    SfSplitter.prototype.isValidSize = function (paneIndex) {
        var isValid;
        if (!sf.base.isNullOrUndefined(this.paneSettings[paneIndex]) &&
            !sf.base.isNullOrUndefined(this.paneSettings[paneIndex].size) &&
            this.paneSettings[paneIndex].size.indexOf('%') > -1) {
            isValid = true;
        }
        return isValid;
    };
    SfSplitter.prototype.getPaneDimensions = function () {
        this.previousPaneHeightWidth = (this.previousPane.style.flexBasis === '') ? this.getPaneHeight(this.previousPane) :
            this.previousPane.style.flexBasis;
        this.nextPaneHeightWidth = (this.nextPane.style.flexBasis === '') ? this.getPaneHeight(this.nextPane) :
            this.nextPane.style.flexBasis;
        if (this.isValidSize(this.prevPaneIndex)) {
            this.previousPaneHeightWidth = this.convertPercentageToPixel(this.previousPaneHeightWidth).toString();
            this.updatePrePaneInPercentage = true;
        }
        if (this.isValidSize(this.nextPaneIndex)) {
            this.nextPaneHeightWidth = this.convertPercentageToPixel(this.nextPaneHeightWidth).toString();
            this.updateNextPaneInPercentage = true;
        }
        this.prePaneDimenson = this.convertPixelToNumber(this.previousPaneHeightWidth.toString());
        this.nextPaneDimension = this.convertPixelToNumber(this.nextPaneHeightWidth.toString());
    };
    SfSplitter.prototype.getPaneHeight = function (pane) {
        return ((this.orientation === HORIZONTAL) ? pane.offsetWidth.toString() :
            pane.offsetHeight.toString());
    };
    SfSplitter.prototype.isCursorMoved = function (e) {
        var cursorMoved = true;
        if (this.getEventType(e.type) === MOUSE || (!sf.base.isNullOrUndefined(e.pointerType)) &&
            this.getEventType(e.pointerType) === MOUSE) {
            cursorMoved = this.checkCoordinates(e.pageX, e.pageY);
        }
        else {
            cursorMoved = (sf.base.Browser.info.name !== MSIE) ?
                this.checkCoordinates(e.touches[0].pageX, e.touches[0].pageY) :
                this.checkCoordinates(e.pageX, e.pageY);
        }
        return cursorMoved;
    };
    SfSplitter.prototype.checkCoordinates = function (pageX, pageY) {
        var coordinatesChanged = true;
        if ((pageX === this.previousCoordinates.x || pageY === this.previousCoordinates.y)) {
            coordinatesChanged = false;
        }
        return coordinatesChanged;
    };
    SfSplitter.prototype.onMouseUp = function (e) {
        sf.base.removeClass([this.currentSeparator], SPLIT_BAR_ACTIVE);
        this.unwireResizeEvents();
        for (var i = 0; i < this.element.querySelectorAll(IFRAME).length; i++) {
            this.element.querySelectorAll(IFRAME)[i].style.pointerEvents = AUTO;
        }
        this.getPaneDimensions();
        this.updatePersistData();
        if (this.onResizeStopEnabled) {
            this.dotNetRef.invokeMethodAsync(RESIZESTOP_EVENT, {
                event: this.getMouseEvtArgs(e),
                index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()],
                separator: this.getDomObject(SEPARATOR, this.currentSeparator),
                paneSize: [this.prePaneDimenson, this.nextPaneDimension]
            });
        }
    };
    SfSplitter.prototype.isMouseEvent = function (e) {
        var isMouse;
        if (this.getEventType(e.type) === MOUSE || (!sf.base.isNullOrUndefined(e.pointerType) &&
            this.getEventType(e.pointerType) === MOUSE)) {
            isMouse = true;
        }
        return isMouse;
    };
    SfSplitter.prototype.getEventType = function (e) {
        return (e.indexOf(MOUSE) > -1) ? MOUSE : TOUCH;
    };
    SfSplitter.prototype.updateCursorPosition = function (e, type) {
        if (this.isMouseEvent(e)) {
            this.changeCoordinates({ x: e.pageX, y: e.pageY }, type);
        }
        else {
            var eventType = sf.base.Browser.info.name !== MSIE ? e.touches[0] : e;
            this.changeCoordinates({ x: eventType.pageX, y: eventType.pageY }, type);
        }
    };
    SfSplitter.prototype.changeCoordinates = function (coordinates, type) {
        type === PREVIOUS ? this.previousCoordinates = coordinates : this.currentCoordinates = coordinates;
    };
    SfSplitter.prototype.isResizable = function () {
        var resizable;
        var nextPaneIndex = this.getNextPaneIndex();
        var prevPaneIndex = this.getPreviousPaneIndex();
        if ((!sf.base.isNullOrUndefined(this.paneSettings[prevPaneIndex]) &&
            this.paneSettings[prevPaneIndex].resizable &&
            !sf.base.isNullOrUndefined(this.paneSettings[nextPaneIndex]) &&
            this.paneSettings[nextPaneIndex].resizable) ||
            sf.base.isNullOrUndefined(this.paneSettings[nextPaneIndex])) {
            resizable = true;
        }
        return resizable;
    };
    SfSplitter.prototype.clickHandler = function (e) {
        if (!e.target.classList.contains(NAVIGATE_ARROW)) {
            var hoverBars = sf.base.selectAll('.' + ROOT + ' > .' + SPLIT_BAR + '.' + SPLIT_BAR_HOVER);
            if (hoverBars.length > 0) {
                sf.base.removeClass(hoverBars, SPLIT_BAR_HOVER);
            }
            sf.base.addClass([e.target], SPLIT_BAR_HOVER);
        }
        this.updateIconClass();
        var icon = e.target;
        if (icon.classList.contains(ARROW_LEFT) || icon.classList.contains(ARROW_UP)) {
            this.collapseAction(e);
        }
        if (icon.classList.contains(ARROW_RIGHT) || icon.classList.contains(ARROW_DOWN)) {
            this.expandAction(e);
        }
        var totalWidth = 0;
        var children = this.element.children;
        for (var i = 0; i < children.length; i++) {
            totalWidth += this.orientation === HORIZONTAL ? children[i].offsetWidth :
                children[i].offsetHeight;
        }
        if (totalWidth > this.element.offsetWidth) {
            this.updateSplitterSize();
        }
    };
    SfSplitter.prototype.collapseAction = function (e) {
        this.splitterDetails(e);
        if (this.collapseFlag) {
            this.collapsePane(e);
        }
        else {
            var args = { cancel: false, event: e, index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()] };
            if (this.onCollapseEnabled) {
                this.dotNetRef.invokeMethodAsync(ONCOLLAPSED_EVENT, -1, args);
            }
            else {
                if (!sf.base.isNullOrUndefined(e)) {
                    this.onCollapseEvent(args);
                }
                else {
                    this.collapseMethodEvent(-1, args);
                }
            }
        }
    };
    SfSplitter.prototype.onCollapseEvent = function (e) {
        var iconClass = this.orientation === HORIZONTAL ? ARROW_LEFT : ARROW_UP;
        var targetEle = this.allBars[e.index[0]].querySelector('.' + iconClass);
        var event = {
            target: targetEle
        };
        this.collapsePane(event);
        if (this.collapsedEnabled) {
            this.dotNetRef.invokeMethodAsync(COLLAPSED_EVENT, {
                event: this.getMouseEvtArgs(e),
                index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()]
            });
        }
    };
    SfSplitter.prototype.collapsePane = function (e) {
        var collapseCount = this.element.querySelectorAll('.' + COLLAPSE_PANE).length;
        var nextPaneSibling = this.nextPane.nextElementSibling;
        var flexStatus = (this.previousPane.classList.contains(STATIC_PANE) &&
            !this.previousPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE) &&
            nextPaneSibling.classList.contains(PANE) &&
            !nextPaneSibling.classList.contains(STATIC_PANE) &&
            !nextPaneSibling.classList.contains(COLLAPSE_PANE) &&
            !(collapseCount === this.allPanes.length - 2))
            || (this.nextPane.classList.contains(COLLAPSE_PANE) && !this.previousPane.classList.contains(STATIC_PANE)
                && this.nextPane.classList.contains(STATIC_PANE));
        var collapseClass = [COLLAPSE_PANE, PANE_HIDDEN];
        if (this.nextPane.classList.contains(COLLAPSE_PANE)) {
            sf.base.removeClass([this.previousPane], EXPAND_PANE);
            sf.base.removeClass([this.nextPane], collapseClass);
            if (!this.collapseFlag) {
                this.updatePaneSettings(this.nextPaneIndex, false);
            }
        }
        else {
            sf.base.removeClass([this.previousPane], EXPAND_PANE);
            sf.base.removeClass([this.nextPane], collapseClass);
            sf.base.addClass([this.nextPane], EXPAND_PANE);
            sf.base.addClass([this.previousPane], collapseClass);
            if (!this.collapseFlag) {
                this.updatePaneSettings(this.prevPaneIndex, true);
            }
        }
        this.updateIconsOnCollapse(e);
        this.previousPane.setAttribute(ARIA_EXPANDED, FALSE);
        this.nextPane.setAttribute(ARIA_EXPANDED, TRUE);
        this.updateFlexGrow(this.checkStaticPanes());
        if (flexStatus) {
            sf.base.removeClass([this.nextPane], EXPAND_PANE);
            this.nextPane.style.flexGrow = '';
        }
    };
    SfSplitter.prototype.updateIconsOnCollapse = function (e) {
        this.splitterProperty();
        if (this.previousPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE)) {
            sf.base.addClass([e.target], HIDE_ICON);
            if (this.paneSettings[this.prevPaneIndex].collapsible) {
                sf.base.removeClass([sf.base.select('.' + this.arrow, this.currentSeparator)], HIDE_ICON);
            }
            this.resizableModel(this.currentBarIndex, false);
            if (this.previousPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE) &&
                !this.paneSettings[this.prevPaneIndex].collapsible) {
                this.hideTargetBarIcon(this.prevBar, this.rightArrow);
            }
            if (this.previousPane.previousElementSibling && !this.previousPane.previousElementSibling.classList.contains(COLLAPSE_PANE)) {
                if (this.previousPane.classList.contains(COLLAPSE_PANE) && this.paneSettings[this.prevPaneIndex].collapsible) {
                    this.showTargetBarIcon(this.prevBar, this.leftArrow);
                }
                else if (!this.paneSettings[this.prevPaneIndex].collapsible) {
                    this.hideTargetBarIcon(this.prevBar, this.leftArrow);
                }
            }
            if (!sf.base.isNullOrUndefined(this.prevBar)) {
                this.resizableModel(this.currentBarIndex - 1, false);
                this.hideTargetBarIcon(this.prevBar, this.arrow);
            }
            if (!this.paneSettings[this.prevPaneIndex].collapsible) {
                this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);
            }
        }
        else if (!this.splitInstance.prevPaneCollapsed && !this.splitInstance.nextPaneExpanded) {
            if (this.paneSettings[this.currentBarIndex].resizable) {
                this.resizableModel(this.currentBarIndex, true);
            }
            if (!this.splitInstance.nextPaneNextEle.classList.contains(COLLAPSE_PANE) &&
                this.paneSettings[this.currentBarIndex + 1].resizable) {
                this.resizableModel(this.currentBarIndex + 1, true);
            }
            if (!this.paneSettings[this.currentBarIndex].collapsible) {
                sf.base.addClass([e.target], HIDE_ICON);
            }
            if (this.previousPane && this.prevPaneIndex === 0 && (this.paneSettings[this.prevPaneIndex].collapsible)) {
                this.showTargetBarIcon(this.currentSeparator, this.leftArrow);
            }
            if (this.nextPane && this.nextPaneIndex === this.allPanes.length - 1 && (this.paneSettings[this.nextPaneIndex].collapsible)) {
                this.showTargetBarIcon(this.allBars[(this.nextPaneIndex - 1)], this.rightArrow);
            }
            if (!(this.previousPane.classList.contains(COLLAPSE_PANE)) && this.paneSettings[this.nextPaneIndex].collapsible) {
                this.showTargetBarIcon(this.currentSeparator, this.rightArrow);
            }
            if (!sf.base.isNullOrUndefined(this.nextBar)) {
                if (this.nextPane.nextElementSibling && (this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE) &&
                    this.paneSettings[this.nextPaneIndex + 1].collapsible) ||
                    (!this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE) &&
                        this.paneSettings[this.nextPaneIndex].collapsible)) {
                    this.showTargetBarIcon(this.nextBar, this.leftArrow);
                }
                else if (!this.paneSettings[this.splitInstance.nextPaneIndex + 1].collapsible &&
                    this.paneSettings[this.currentBarIndex]) {
                    this.hideTargetBarIcon(this.nextBar, this.arrow);
                }
            }
            if (!(this.nextPaneIndex === this.allPanes.length - 1) && this.nextPane.nextElementSibling &&
                !this.nextPane.classList.contains(COLLAPSE_PANE) && !this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE)
                && !this.paneSettings[this.nextPaneIndex + 1].collapsible) {
                this.hideTargetBarIcon(this.nextBar, this.rightArrow);
            }
        }
    };
    SfSplitter.prototype.expandAction = function (e) {
        this.splitterDetails(e);
        if (this.expandFlag) {
            if (this.onExpandEnabled) {
                this.dotNetRef.invokeMethodAsync(ONEXPAND_EVENT, {
                    cancel: false,
                    event: this.getMouseEvtArgs(e),
                    index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()]
                });
            }
            else {
                this.onExpandEvent({ event: e, index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()] });
            }
        }
        else {
            this.expandPane(e);
        }
    };
    SfSplitter.prototype.onExpandEvent = function (e) {
        var iconClass = this.orientation === HORIZONTAL ? ARROW_RIGHT : ARROW_DOWN;
        var targetEle = this.allBars[e.index[0]].querySelector('.' + iconClass);
        var event = { target: targetEle };
        this.expandPane(event);
        if (this.expandedEnabled) {
            this.dotNetRef.invokeMethodAsync(EXPANDED_EVENT, {
                event: this.getMouseEvtArgs(e.event),
                index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()]
            });
        }
    };
    SfSplitter.prototype.getSeparatorIndex = function (target) {
        var separator = this.orientation === HORIZONTAL ? SPLIT_H_BAR : SPLIT_V_BAR;
        if (this.allBars.length < 1) {
            this.allBars = sf.base.selectAll('.' + separator, this.element);
        }
        var array = [].slice.call(this.allBars);
        array = this.enableReversePanes ? array.reverse() : array;
        return array.indexOf(target);
    };
    SfSplitter.prototype.updateBars = function (index) {
        this.prevBar = this.allBars[(index - 1)];
        this.nextBar = this.allBars[(index + 1)];
    };
    SfSplitter.prototype.splitterDetails = function (e) {
        if (this.element.classList.contains(HORIZONTAL_PANE)) {
            this.orientation = HORIZONTAL;
            this.arrow = e.target.classList.contains(ARROW_LEFT) ? ARROW_RIGHT : ARROW_LEFT;
        }
        else {
            this.orientation = VERTICAL;
            this.arrow = e.target.classList.contains(ARROW_UP) ? ARROW_DOWN : ARROW_UP;
        }
        this.updateCurrentSeparator(e.target);
        this.currentBarIndex = this.getOrderIndex(parseInt(this.currentSeparator.style.order), 'splitbar'), this.updateBars(this.currentBarIndex);
        this.getPaneDetails();
    };
    SfSplitter.prototype.currentIndex = function (target) {
        this.currentBarIndex = this.getOrderIndex(parseInt(target.parentElement.style.order), 'splitbar');
    };
    SfSplitter.prototype.expandPane = function (e) {
        var collapseCount = this.element.querySelectorAll('.' + COLLAPSE_PANE).length;
        var flexStatus = (!this.previousPane.classList.contains(COLLAPSE_PANE) &&
            this.previousPane.classList.contains(STATIC_PANE) && !this.nextPane.classList.contains(COLLAPSE_PANE) &&
            !this.nextPane.classList.contains(EXPAND_PANE) && this.nextPane.nextElementSibling.classList.contains(PANE) &&
            !this.nextPane.nextElementSibling.classList.contains(STATIC_PANE) && !(collapseCount === this.allPanes.length - ORDER_NO));
        var collapseClass = [COLLAPSE_PANE, PANE_HIDDEN];
        if (!this.previousPane.classList.contains(COLLAPSE_PANE)) {
            sf.base.removeClass([this.nextPane], EXPAND_PANE);
            sf.base.removeClass([this.previousPane], collapseClass);
            sf.base.addClass([this.previousPane], EXPAND_PANE);
            sf.base.addClass([this.nextPane], collapseClass);
            if (this.expandFlag) {
                this.updatePaneSettings(this.nextPaneIndex, true);
            }
        }
        else {
            sf.base.removeClass([this.previousPane], collapseClass);
            sf.base.removeClass([this.nextPane], EXPAND_PANE);
            if (this.expandFlag) {
                this.updatePaneSettings(this.prevPaneIndex, false);
            }
        }
        this.updateIconsOnExpand(e);
        this.previousPane.setAttribute(ARIA_EXPANDED, TRUE);
        this.nextPane.setAttribute(ARIA_EXPANDED, FALSE);
        this.updateFlexGrow(this.checkStaticPanes());
        if (flexStatus) {
            sf.base.removeClass([this.previousPane], EXPAND_PANE);
            this.previousPane.style.flexGrow = '';
        }
    };
    SfSplitter.prototype.checkStaticPanes = function () {
        var staticPane = true;
        for (var i = 0; i < this.allPanes.length; i++) {
            if (!this.allPanes[i].classList.contains(COLLAPSE_PANE) && staticPane) {
                staticPane = this.allPanes[i].classList.contains(STATIC_PANE) ? true : false;
            }
        }
        return staticPane;
    };
    SfSplitter.prototype.splitterProperty = function () {
        this.splitInstance = {
            currentBarIndex: this.currentBarIndex,
            nextPaneCollapsible: this.nextPane.classList.contains(COLLAPSIBLE),
            prevPaneCollapsible: this.previousPane.classList.contains(COLLAPSIBLE),
            prevPaneExpanded: this.previousPane.classList.contains(EXPAND_PANE),
            nextPaneExpanded: this.nextPane.classList.contains(EXPAND_PANE),
            nextPaneCollapsed: this.nextPane.classList.contains(COLLAPSE_PANE),
            prevPaneCollapsed: this.previousPane.classList.contains(COLLAPSE_PANE),
            nextPaneIndex: this.getNextPaneIndex(),
            prevPaneIndex: this.getPreviousPaneIndex(),
            nextPaneNextEle: this.nextPane.nextElementSibling,
            prevPanePreEle: this.previousPane.previousElementSibling,
        };
    };
    SfSplitter.prototype.updateIconsOnExpand = function (e) {
        this.splitterProperty();
        sf.base.addClass([e.target], HIDE_ICON);
        if (!this.splitInstance.prevPaneExpanded && !this.splitInstance.nextPaneCollapsed) {
            if (this.paneSettings[this.prevPaneIndex].collapsible) {
                sf.base.removeClass([sf.base.select('.' + this.arrow, this.currentSeparator)], HIDE_ICON);
            }
            if (this.paneSettings[this.nextPaneIndex].collapsible) {
                sf.base.removeClass([e.target], HIDE_ICON);
            }
            if (this.paneSettings[this.currentBarIndex].resizable) {
                this.resizableModel(this.currentBarIndex, true);
            }
            if (!sf.base.isNullOrUndefined(this.prevBar) &&
                !this.splitInstance.prevPanePreEle.classList.contains(COLLAPSE_PANE)) {
                if (this.paneSettings[this.currentBarIndex - 1].resizable) {
                    this.resizableModel(this.currentBarIndex - 1, true);
                }
                if (this.paneSettings[this.prevPaneIndex].collapsible) {
                    this.showTargetBarIcon(this.prevBar, this.rightArrow);
                }
                if (!this.paneSettings[this.currentBarIndex - 1].collapsible) {
                    this.hideTargetBarIcon(this.prevBar, this.arrow);
                    if (this.paneSettings[this.currentBarIndex].collapsible &&
                        !this.paneSettings[this.currentBarIndex + 1].collapsible) {
                        this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);
                    }
                }
                else if (this.paneSettings[this.currentBarIndex].collapsible &&
                    !this.paneSettings[this.currentBarIndex + 1].collapsible) {
                    this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);
                }
            }
            else {
                if (this.previousPane.previousElementSibling && this.paneSettings[this.prevPaneIndex].collapsible &&
                    (this.previousPane.previousElementSibling.classList.contains(COLLAPSE_PANE) &&
                        this.paneSettings[this.prevPaneIndex - 1].collapsible)) {
                    this.showTargetBarIcon(this.prevBar, this.rightArrow);
                }
                if (!this.paneSettings[this.currentBarIndex + 1].collapsible) {
                    this.hideTargetBarIcon(this.currentSeparator, this.rightArrow);
                }
            }
        }
        else if (this.splitInstance.prevPaneExpanded && this.splitInstance.nextPaneCollapsed) {
            this.resizableModel(this.currentBarIndex, false);
            this.resizableModel(this.currentBarIndex + 1, false);
            if (this.paneSettings[this.nextPaneIndex].collapsible) {
                sf.base.removeClass([sf.base.select('.' + this.arrow, this.currentSeparator)], HIDE_ICON);
            }
            if (!sf.base.isNullOrUndefined(this.nextBar)) {
                this.hideTargetBarIcon(this.nextBar, this.arrow);
            }
            if (this.nextPane && this.nextPaneIndex === this.allPanes.length - 1 && (!this.paneSettings[this.nextPaneIndex].collapsible &&
                this.splitInstance.nextPaneCollapsed)) {
                this.hideTargetBarIcon(this.currentSeparator, this.arrow);
            }
            if (!(this.nextPaneIndex === this.allPanes.length - 1) && this.nextPane.nextElementSibling &&
                this.nextPane.classList.contains(COLLAPSE_PANE) &&
                !this.nextPane.nextElementSibling.classList.contains(COLLAPSE_PANE)
                && this.paneSettings[this.nextPaneIndex].collapsible) {
                this.showTargetBarIcon(this.nextBar, this.rightArrow);
            }
        }
    };
    SfSplitter.prototype.showResizer = function (target) {
        if (!sf.base.isNullOrUndefined(this.previousPane) && this.previousPane.classList.contains(RESIZABLE_PANE) &&
            !sf.base.isNullOrUndefined(this.nextPane) && this.nextPane.classList.contains(RESIZABLE_PANE)) {
            sf.base.removeClass([sf.base.select('.' + RESIZE_BAR, target)], HIDE_HANDLER);
        }
    };
    SfSplitter.prototype.resizableModel = function (index, newVal) {
        var paneIndex;
        var i = index;
        paneIndex = (index === (this.allBars.length)) ? (index - 1) : index;
        sf.base.EventHandler.remove(this.allBars[paneIndex], MOUSEDOWN, this.onMouseDown);
        if (newVal) {
            sf.base.EventHandler.add(this.allBars[paneIndex], MOUSEDOWN, this.onMouseDown, this);
            if (this.isResizable()) {
                this.showResizer(this.allBars[paneIndex]);
                sf.base.removeClass([sf.base.select('.' + RESIZE_BAR, this.allBars[paneIndex])], HIDE_HANDLER);
                sf.base.addClass([this.allBars[paneIndex]], RESIZABLE_BAR);
                (index === (this.allBars.length)) ? sf.base.addClass([this.allPanes[index]], RESIZABLE_PANE) :
                    sf.base.addClass([this.allPanes[paneIndex]], RESIZABLE_PANE);
                this.updateResizablePanes(i);
            }
        }
        else {
            this.updateResizablePanes(i);
            sf.base.addClass([sf.base.select('.' + RESIZE_BAR, this.allBars[paneIndex])], HIDE_HANDLER);
            sf.base.removeClass([this.allBars[paneIndex]], RESIZABLE_BAR);
            if (index === this.allBars.length) {
                sf.base.removeClass([this.allPanes[index]], RESIZABLE_PANE);
            }
            else {
                sf.base.removeClass([this.allPanes[paneIndex]], RESIZABLE_PANE);
            }
        }
    };
    SfSplitter.prototype.hideTargetBarIcon = function (targetBar, targetArrow) {
        sf.base.addClass([sf.base.select('.' + targetArrow, targetBar)], HIDE_ICON);
    };
    SfSplitter.prototype.showTargetBarIcon = function (targetBar, targetArrow) {
        sf.base.removeClass([sf.base.select('.' + targetArrow, targetBar)], HIDE_ICON);
    };
    SfSplitter.prototype.updateFlexGrow = function (status) {
        var panes = this.allPanes;
        for (var i = 0; i < panes.length; i++) {
            panes[i].style.flexGrow = panes[i].classList.contains(EXPAND_PANE) ?
                FLEX_ONE : panes[i].classList.contains(COLLAPSE_PANE) ? FLEX_ZERO : FLEX_EMPTY;
            if (status && !this.nextPane.classList.contains(COLLAPSE_PANE)) {
                this.nextPane.style.flexGrow = FLEX_ONE;
            }
        }
    };
    SfSplitter.prototype.updatePaneSettings = function (index, collapsed) {
        if (this.isToggleInvoke) {
            return;
        }
        this.paneSettings[index].collapsed = collapsed;
        this.updatePersistData();
        this.dotNetRef.invokeMethodAsync(UPDATE_COLLAPSED, index, collapsed);
    };
    SfSplitter.prototype.addMouseActions = function (separator) {
        var _this = this;
        var sTout;
        var hoverTimeOut;
        separator.addEventListener(MOUSEENTER, function () {
            /* istanbul ignore next */
            sTout = setTimeout(function () { sf.base.addClass([separator], [SPLIT_BAR_HOVER]); }, _this.iconsDelay);
        });
        separator.addEventListener(MOUSELEAVE, function () {
            clearTimeout(sTout);
            sf.base.removeClass([separator], [SPLIT_BAR_HOVER]);
        });
        separator.addEventListener(MOUSEOUT, function () {
            clearTimeout(hoverTimeOut);
        });
        separator.addEventListener(MOUSEOVER, function () {
            /* istanbul ignore next */
            hoverTimeOut = setTimeout(function () { sf.base.addClass([separator], [SPLIT_BAR_HOVER]); }, _this.iconsDelay);
        });
    };
    SfSplitter.prototype.updateIconClass = function () {
        if (this.orientation === HORIZONTAL) {
            this.leftArrow = ARROW_LEFT;
            this.rightArrow = ARROW_RIGHT;
        }
        else {
            this.leftArrow = ARROW_UP;
            this.rightArrow = ARROW_DOWN;
        }
    };
    SfSplitter.prototype.isCollapsed = function (index) {
        if (!sf.base.isNullOrUndefined(index) && this.paneSettings[index].collapsed && (this.allPanes.length > 0 &&
            !sf.base.isNullOrUndefined(this.allPanes[index]) && this.allPanes[index].classList.contains(COLLAPSE_PANE))) {
            return;
        }
        this.expandFlag = false;
        if (!sf.base.isNullOrUndefined(index)) {
            this.collapseFlag = true;
            var targetEle = void 0;
            var lastBarIndex = (index === this.allBars.length);
            var barIndex = lastBarIndex ? index - 1 : index;
            if (!lastBarIndex && this.allPanes[index + 1].classList.contains(COLLAPSE_PANE) && index !== 0) {
                targetEle = this.collapseArrow(barIndex - 1, this.targetArrows().lastBarArrow);
            }
            else {
                targetEle = (lastBarIndex) ? this.collapseArrow(barIndex, this.targetArrows().lastBarArrow) :
                    this.collapseArrow(barIndex, this.targetArrows().collapseArrow);
            }
            var event_1 = { target: targetEle };
            this.splitterDetails(event_1);
            var args = { cancel: false, index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()] };
            if (this.onCollapseEnabled) {
                this.dotNetRef.invokeMethodAsync(ONCOLLAPSED_EVENT, index, args);
            }
            else {
                this.collapseMethodEvent(index, args);
            }
        }
        else {
            for (var m = 0; m < this.allPanes.length; m++) {
                if (!sf.base.isNullOrUndefined(this.paneSettings[m]) && this.paneSettings[m].collapsed) {
                    this.updateIsCollapsed(m, this.targetArrows().collapseArrow, this.targetArrows().lastBarArrow);
                }
            }
            for (var m = this.allPanes.length - 1; m >= 0; m--) {
                if (!sf.base.isNullOrUndefined(this.paneSettings[m]) && this.paneSettings[m].collapsed &&
                    !this.allPanes[m].classList.contains(COLLAPSE_PANE)) {
                    var collapseArrow = this.orientation === HORIZONTAL ? ARROW_RIGHT : ARROW_DOWN;
                    if (m !== 0) {
                        var targetEle = this.collapseArrow(m - 1, collapseArrow);
                        targetEle.click();
                    }
                    if (!this.nextPane.classList.contains(COLLAPSE_PANE)) {
                        var targetEle = this.collapseArrow(m - 1, collapseArrow);
                        targetEle.click();
                    }
                }
            }
        }
        this.expandFlag = true;
    };
    SfSplitter.prototype.collapseMethodEvent = function (index, e) {
        this.expandFlag = false;
        var collapsedindex = [];
        collapsedindex[0] = index;
        var j = 1;
        for (var i = 0; i < this.allPanes.length; i++) {
            if (this.allPanes[i].classList.contains(COLLAPSE_PANE)) {
                collapsedindex[j] = i;
                j++;
            }
        }
        collapsedindex = collapsedindex.sort();
        this.updateIsCollapsed(index, this.targetArrows().collapseArrow, this.targetArrows().lastBarArrow);
        for (var i = 0; i < collapsedindex.length; i++) {
            if (!this.allPanes[collapsedindex[i]].classList.contains(COLLAPSE_PANE)) {
                this.updateIsCollapsed(collapsedindex[i], this.targetArrows().collapseArrow, this.targetArrows().lastBarArrow);
            }
        }
        for (var i = collapsedindex.length; i > 0; i--) {
            if (!this.allPanes[collapsedindex[i - 1]].classList.contains(COLLAPSE_PANE)) {
                var targetArrow = this.targetArrows();
                this.updateIsCollapsed(collapsedindex[i - 1], targetArrow.collapseArrow, targetArrow.lastBarArrow);
            }
        }
        if (this.collapsedEnabled) {
            this.dotNetRef.invokeMethodAsync(COLLAPSED_EVENT, {
                event: this.getMouseEvtArgs(e),
                index: [this.getPreviousPaneIndex(), this.getNextPaneIndex()],
            });
        }
        this.collapseFlag = false;
        this.expandFlag = true;
    };
    SfSplitter.prototype.toggle = function (expandIndices, collapseIndices) {
        this.isToggleInvoke = true;
        for (var i = 0; i < this.paneSettings.length; i++) {
            if (expandIndices.indexOf(i) > -1 && this.paneSettings[i].collapsed) {
                this.collapsedOnchange(i);
                this.paneSettings[i].collapsed = false;
            }
        }
        for (var i = 0; i < this.paneSettings.length; i++) {
            if (collapseIndices.indexOf(i) > -1 && !this.paneSettings[i].collapsed) {
                this.isCollapsed(i);
                this.paneSettings[i].collapsed = true;
            }
        }
        this.isToggleInvoke = false;
        this.updatePersistData();
        this.dotNetRef.invokeMethodAsync(UPDATE_SETTINGS, this.paneSettings);
    };
    SfSplitter.prototype.expand = function (index) {
        this.collapsedOnchange(index);
        this.updatePaneSettings(index, false);
    };
    SfSplitter.prototype.collapse = function (index) {
        this.isCollapsed(index);
        this.updatePaneSettings(index, true);
    };
    SfSplitter.prototype.collapsedOnchange = function (index) {
        if (!sf.base.isNullOrUndefined(this.paneSettings[index]) && !sf.base.isNullOrUndefined(this.paneSettings[index].collapsed)
            && this.allPanes[index].classList.contains(COLLAPSE_PANE)) {
            this.updateIsCollapsed(index, this.targetArrows().lastBarArrow, this.targetArrows().collapseArrow);
        }
    };
    SfSplitter.prototype.collapsibleModelUpdate = function (index) {
        var arrow2;
        var arrow1;
        var paneIndex;
        paneIndex = index === (this.allBars.length) ? (index - 1) : index;
        arrow2 = (this.orientation === HORIZONTAL) ? this.checkArrow(paneIndex, ARROW_LEFT) : this.checkArrow(paneIndex, ARROW_UP);
        arrow1 = (this.orientation === HORIZONTAL) ? this.checkArrow(paneIndex, ARROW_RIGHT) : this.checkArrow(paneIndex, ARROW_DOWN);
        this.paneCollapsible(this.allPanes[index], index);
        this.updateCollapseIcons(paneIndex, arrow1, arrow2);
    };
    SfSplitter.prototype.updateCollapseIcons = function (index, arrow1, arrow2) {
        if (!sf.base.isNullOrUndefined(this.paneSettings[index])) {
            if (!sf.base.isNullOrUndefined(this.paneSettings[index].collapsible)) {
                this.paneSettings[index].collapsible ? sf.base.removeClass([arrow2], [HIDE_ICON]) : sf.base.addClass([arrow2], [HIDE_ICON]);
                if (!sf.base.isNullOrUndefined(this.paneSettings[index + 1])) {
                    this.paneSettings[index + 1].collapsible ? sf.base.removeClass([arrow1], [HIDE_ICON]) : sf.base.addClass([arrow1], [HIDE_ICON]);
                }
            }
        }
    };
    SfSplitter.prototype.checkArrow = function (paneIndex, targetArrow) {
        return (this.allBars[paneIndex].querySelector('.' + NAVIGATE_ARROW + '.' + targetArrow));
    };
    SfSplitter.prototype.paneCollapsible = function (pane, index) {
        this.paneSettings[index].collapsible ? sf.base.addClass([pane], COLLAPSIBLE) : sf.base.removeClass([pane], COLLAPSIBLE);
    };
    SfSplitter.prototype.propertyChanged = function (splitObj, changedArgs) {
        var oldPaneSettings = __assign({}, this.paneSettings);
        sf.base.extend(this, this, splitObj);
        this.updateClass();
        if (changedArgs) {
            for (var i = 0; i <= Object.keys(changedArgs).length; i++) {
                var key = parseInt(Object.keys(changedArgs)[i], RADIX);
                if (Object(changedArgs)[key]) {
                    for (var j = 0; j < Object(changedArgs)[key].length; j++) {
                        switch (Object(changedArgs)[key][j]) {
                            case 'Visible':
                            case 'Resizable':
                                this.resizableModel(key, this.paneSettings[key].resizable);
                                break;
                            case 'Collapsible':
                                this.collapsibleModelUpdate(key);
                                break;
                            case 'Collapsed':
                                if (oldPaneSettings[key].collapsed !== splitObj.paneSettings[key].collapsed) {
                                    this.paneSettings[key].collapsed ? this.isCollapsed(key) : this.collapsedOnchange(key);
                                }
                                break;
                            case 'Size':
                                if (this.paneSettings[key].size !== '' && !sf.base.isNullOrUndefined(this.paneSettings[key].size)) {
                                    this.updatePaneSize(this.paneSettings[key].size, key);
                                }
                                break;
                        }
                    }
                }
            }
        }
    };
    SfSplitter.prototype.updatePaneSize = function (newValSize, index) {
        this.allPanes[index].style.flexBasis = newValSize;
        var flexPaneIndexes = [];
        var staticPaneWidth;
        var flexCount = 0;
        for (var i = 0; i < this.allPanes.length; i++) {
            if (!this.paneSettings[i].size && !(this.allPanes[i].innerText === '')) {
                flexPaneIndexes[flexCount] = i;
                flexCount++;
            }
            else if (this.paneSettings[i].size) {
                staticPaneWidth = this.orientation === 'Horizontal' ? this.allPanes[index].offsetWidth : this.allPanes[index].offsetHeight;
            }
        }
        staticPaneWidth = this.orientation === 'Horizontal' ? (this.allBars[0].offsetWidth * this.allBars.length) + staticPaneWidth :
            (this.allBars[0].offsetHeight * this.allBars.length) + staticPaneWidth;
        var flexPaneWidth = (this.orientation === 'Horizontal' ? this.element.offsetWidth : this.element.offsetHeight)
            - staticPaneWidth - (this.border * 2);
        var avgDiffWidth = flexPaneWidth / flexPaneIndexes.length;
        for (var j = 0; j < flexPaneIndexes.length; j++) {
            this.allPanes[flexPaneIndexes[j]].style.flexBasis = avgDiffWidth + 'px';
        }
        this.allPanes[index].classList.add(STATIC_PANE);
    };
    SfSplitter.prototype.targetArrows = function () {
        this.splitterProperty();
        return {
            collapseArrow: (this.orientation === HORIZONTAL) ? ARROW_LEFT : ARROW_UP,
            lastBarArrow: (this.orientation === VERTICAL) ? ARROW_DOWN : ARROW_RIGHT
        };
    };
    SfSplitter.prototype.collapseArrow = function (barIndex, arrow) {
        return sf.base.selectAll('.' + arrow, this.allBars[barIndex])[0];
    };
    SfSplitter.prototype.updateIsCollapsed = function (index, collapseArrow, lastBarArrow) {
        if (!sf.base.isNullOrUndefined(index)) {
            var targetEle = void 0;
            var lastBarIndex = (index === this.allBars.length);
            var barIndex = lastBarIndex ? index - 1 : index;
            if (!lastBarIndex && this.allPanes[index + 1].classList.contains(COLLAPSE_PANE) && index !== 0) {
                targetEle = this.collapseArrow(barIndex - 1, lastBarArrow);
            }
            else {
                targetEle = (lastBarIndex) ? this.collapseArrow(barIndex, lastBarArrow) : this.collapseArrow(barIndex, collapseArrow);
            }
            targetEle.click();
        }
    };
    SfSplitter.prototype.updatePersistData = function () {
        var paneConfigs = [];
        var panes = this.element.querySelectorAll(".e-pane");
        for (var i = 0; i < this.paneSettings.length; i++) {
            paneConfigs.push(JSON.parse(JSON.stringify(this.paneSettings[i])));
            delete paneConfigs[i].collapsible;
            delete paneConfigs[i].content;
            delete paneConfigs[i].cssClass;
            delete paneConfigs[i].resizable;
            paneConfigs[i].size = panes[i].style.flexBasis;
        }
        if (this.enablePersistence) {
            window.localStorage.setItem(this.id, JSON.stringify(paneConfigs));
        }
    };
    SfSplitter.prototype.destroy = function () {
        sf.base.EventHandler.remove(document, TOUCHSTART_CLICK, this.onDocumentClick);
        this.updatePersistData();
        while (this.element.attributes.length > 0) {
            this.element.removeAttribute(this.element.attributes[0].name);
        }
        var splitNodes = this.element.children;
        for (var i = splitNodes.length - 1; i >= 0; i--) {
            sf.base.detach(splitNodes[i]);
        }
    };
    return SfSplitter;
}());
// tslint:disable-next-line
var Splitter = {
    initialize: function (element, options, dotnetRef) {
        if (!sf.base.isNullOrUndefined(element)) {
            new SfSplitter(element, options, dotnetRef);
            element.blazor__instance.initialize();
        }
    },
    collapse: function (element, index) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.collapse(index);
        }
    },
    expand: function (element, index) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.expand(index);
        }
    },
    toggle: function (element, expandIndices, collapseIndices) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.toggle(expandIndices, collapseIndices);
        }
    },
    resizeEvent: function (element, e) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.resizeEvent(e);
        }
    },
    onCollapseEvent: function (element, event) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.onCollapseEvent(event);
        }
    },
    collapseMethodEvent: function (element, event, index) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.collapseMethodEvent(index, event);
        }
    },
    onExpandEvent: function (element, event) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.onExpandEvent(event);
        }
    },
    destroy: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.destroy();
        }
    },
    setReversePane: function (element) {
        if (!sf.base.isNullOrUndefined(element)) {
            element.blazor__instance.setReversePane();
        }
    },
    updateSeparator: function (splitObj) {
        if (!sf.base.isNullOrUndefined(splitObj.element)) {
            splitObj.element.blazor__instance.updateSeparator();
        }
    },
    propertyChanged: function (splitObj, changedArgs) {
        if (!sf.base.isNullOrUndefined(splitObj.element)) {
            splitObj.element.blazor__instance.propertyChanged(splitObj, changedArgs);
        }
    }
};

return Splitter;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-svg-export.js":
/*!****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-svg-export.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfExport = {
    exportToImage: async function (type, fileName, elementId, allowDownload) {
        var returnValue = await window.sfExport.imageExport(type, fileName, elementId, allowDownload);
        if (returnValue instanceof Promise) {
            await returnValue.then(async function (data) {
                return data;
            });
        } else {
            return returnValue;
        }
    },
    validateExport: async function (returnValue) {
        if (returnValue instanceof Promise) {
            await returnValue.then(async function (data) {
                return data;
            });
        }
    },
    imageExport: async function (type, fileName, elementId, allowDownload) {
        return new Promise(function (resolve, reject) {
        var element = document.getElementById(elementId);
        var svgData = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element.outerHTML + '</svg>';
        var url = window.URL.createObjectURL(new Blob(type === 'SVG' ? [svgData] : [(new XMLSerializer()).serializeToString(element)], { type: 'image/svg+xml' }));
        if (type === 'SVG') {
            if (allowDownload) {
                window.sfExport.triggerDownload(type, fileName, url);
            }
            resolve(null);
        } else {
            var canvasElement = document.createElement('canvas');
            canvasElement.height = element.clientHeight;
            canvasElement.width = element.clientWidth;
            var context = canvasElement.getContext('2d');
            var image = new Image();
            image.onload = function () {
                context.drawImage(image, 0, 0);
                window.URL.revokeObjectURL(url);
                if (allowDownload) {
                    window.sfExport.triggerDownload(type, fileName, canvasElement.toDataURL('image/png').replace('image/png', 'image/octet-stream'));
                    resolve(null);
                } else {
                    var base64String = (type === 'JPEG') ? canvasElement.toDataURL('image/jpeg') : (type === 'PNG') ? canvasElement.toDataURL('image/png') : '';
                    resolve(base64String);
                }
            };
            image.src = url;
        }
    });
    },
    triggerDownload : function(type, fileName, url)  {
        var anchorElement = document.createElement('a');
        anchorElement.download = fileName + '.' + type.toLocaleLowerCase();
        anchorElement.href = url;
        anchorElement.click();
    },
    downloadPdf: function (base64String, fileName) {
        var sliceSize = 512;
        var byteCharacters = atob(base64String);
        var byteArrays = [];
        for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            var slice = byteCharacters.slice(offset, offset + sliceSize);
            var byteNumbers = new Array(slice.length);
            for (var i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            var byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        var blob = new Blob(byteArrays, { type: 'application/pdf' });
        var Url = URL || webkitURL;
        var blobUrl = Url.createObjectURL(blob);
        sfExport.triggerDownload("PDF", fileName, blobUrl);
    },
    print: function (printElement) {
        var printWindow;
        printWindow = window.open('', 'print', 'height=' + window.outerHeight + ',width=' + window.outerWidth + ',tabbar=no');
        printWindow.moveTo(0, 0);
        printWindow.resizeTo(screen.availWidth, screen.availHeight);
        var div = document.createElement('div');
        div.appendChild(printElement.cloneNode(true));
        printWindow.document.write('<!DOCTYPE html> <html><head> </head><body>' + div.innerHTML +
            '<script> (function() { window.ready = true; })(); </script>' + '</body></html>');
        printWindow.document.close();
        printWindow.focus();
        var interval = setInterval(function () {
            if (printWindow.ready) {
                printWindow.print();
                printWindow.close();
                clearInterval(interval);
            }
        }, 500);
    }
};

/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-tab.js":
/*!*********************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-tab.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Tab = (function () {
'use strict';

/* eslint-disable @typescript-eslint/no-explicit-any */
var CLS_TAB = 'e-tab';
var CLS_HEADER = 'e-tab-header';
var CLS_BLA_TEM = 'blazor-template';
var CLS_CONTENT = 'e-content';
var CLS_NEST = 'e-nested';
var CLS_ITEM = 'e-item';
var CLS_RTL = 'e-rtl';
var CLS_ACTIVE = 'e-active';
var CLS_DISABLE = 'e-disable';
var CLS_HIDDEN = 'e-hidden';
var CLS_FOCUS = 'e-focused';
var CLS_INDICATOR = 'e-indicator';
var CLS_WRAP = 'e-tab-wrap';
var CLS_TB_ITEMS = 'e-toolbar-items';
var CLS_TB_ITEM = 'e-toolbar-item';
var CLS_TB_POP = 'e-toolbar-pop';
var CLS_TB_POPUP = 'e-toolbar-popup';
var CLS_POPUP_OPEN = 'e-popup-open';
var CLS_POPUP_CLOSE = 'e-popup-close';
var CLS_PROGRESS = 'e-progress';
var CLS_IGNORE = 'e-ignore';
var CLS_OVERLAY = 'e-overlay';
var CLS_HSCRCNT = 'e-hscroll-content';
var CLS_VSCRCNT = 'e-vscroll-content';
var CLS_VTAB = 'e-vertical-tab';
var CLS_HBOTTOM = 'e-horizontal-bottom';
var CLS_VERTICAL_ICON = 'e-vertical-icon';
var CLS_VLEFT = 'e-vertical-left';
var CLS_VRIGHT = 'e-vertical-right';
var SPACEBAR = 32;
var END = 35;
var SfTab = /** @class */ (function () {
    function SfTab(element, options, dotnetRef) {
        this.show = {};
        this.hide = {};
        this.draggableItems = [{}];
        this.resizeContext = this.refreshActElePosition.bind(this);
        this.keyConfigs = {
            tab: 'tab',
            home: 'home',
            end: 'end',
            enter: 'enter',
            space: 'space',
            delete: 'delete',
            moveLeft: 'leftarrow',
            moveRight: 'rightarrow',
            moveUp: 'uparrow',
            moveDown: 'downarrow'
        };
        this.element = element;
        // eslint-disable-next-line camelcase
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
        this.options = options;
    }
    SfTab.prototype.render = function () {
        var nested = sf.base.closest(this.element, '.' + CLS_CONTENT);
        this.prevIndex = 0;
        this.isPopup = false;
        this.initRender = true;
        this.isSwipeed = false;
        if (!sf.base.isNullOrUndefined(nested)) {
            nested.parentElement.classList.add(CLS_NEST);
        }
        var name = sf.base.Browser.info.name;
        var css = (name === 'msie') ? 'e-ie' : (name === 'edge') ? 'e-edge' : (name === 'safari') ? 'e-safari' : '';
        sf.base.setStyleAttribute(this.element, { 'width': sf.base.formatUnit(this.options.width), 'height': sf.base.formatUnit(this.options.height) });
        sf.base.attributes(this.element, { 'aria-disabled': 'false', 'aria-activedescendant': '' });
        this.setCssClass(this.element, css, true);
        this.updatePopAnimationConfig();
        this.tabId = this.element.id.length > 0 ? ('-' + this.element.id) : sf.base.getRandomId();
        this.wireEvents();
        this.initRender = false;
    };
    SfTab.prototype.serverItemsChanged = function () {
        this.enableAnimation = false;
        this.setActive(this.options.selectedItem);
        if (this.options.loadOn !== 'Dynamic' && !sf.base.isNullOrUndefined(this.cntEle)) {
            var itemCollection = [].slice.call(this.cntEle.children);
            var content_1 = CLS_CONTENT + this.tabId + '_' + this.options.selectedItem;
            itemCollection.forEach(function (item) {
                if (item.classList.contains(CLS_ACTIVE) && item.id !== content_1) {
                    item.classList.remove(CLS_ACTIVE);
                }
                if (item.id === content_1) {
                    item.classList.add(CLS_ACTIVE);
                }
            });
            this.prevIndex = this.options.selectedItem;
            this.triggerAnimation(CLS_ITEM + this.tabId + '_' + this.options.selectedItem, false);
        }
        this.enableAnimation = true;
    };
    SfTab.prototype.headerReady = function () {
        this.initRender = true;
        this.hdrEle = this.getTabHeader();
        this.setOrientation(this.options.headerPlacement, this.hdrEle);
        this.tbItems = sf.base.select('.' + CLS_HEADER + ' .' + CLS_TB_ITEMS, this.element);
        if (!sf.base.isNullOrUndefined(this.tbItems)) {
            sf.base.rippleEffect(this.tbItems, { selector: '.e-tab-wrap' });
        }
        if (sf.base.selectAll('.' + CLS_TB_ITEM, this.element).length > 0) {
            this.bdrLine = sf.base.select('.' + CLS_INDICATOR + '.' + CLS_IGNORE, this.element);
            var scrollCnt = sf.base.select('.' + this.scrCntClass, this.tbItems);
            if (!sf.base.isNullOrUndefined(scrollCnt)) {
                scrollCnt.insertBefore(this.bdrLine, scrollCnt.firstElementChild);
            }
            else {
                this.tbItems.insertBefore(this.bdrLine, this.tbItems.firstElementChild);
            }
            this.select(this.options.selectedItem);
        }
        this.cntEle = sf.base.select('.' + CLS_TAB + ' > .' + CLS_CONTENT, this.element);
        if (!sf.base.isNullOrUndefined(this.cntEle)) {
            this.touchModule = new sf.base.Touch(this.cntEle, { swipe: this.swipeHandler.bind(this) });
            if (this.options.height !== 'auto' && !this.isVertical()) {
                this.cntEle.style.height = 'calc(100% - ' + this.hdrEle.offsetHeight + 'px)';
            }
        }
        if (this.options.loadOn === 'Demand') {
            var id = this.setActiveContent();
            this.triggerAnimation(id, false);
        }
        this.initRender = false;
    };
    SfTab.prototype.setActiveContent = function () {
        var id = CLS_ITEM + this.tabId + '_' + this.options.selectedItem;
        var item = this.getTrgContent(this.cntEle, this.extIndex(id));
        if (!sf.base.isNullOrUndefined(item)) {
            item.classList.add(CLS_ACTIVE);
        }
        return id;
    };
    SfTab.prototype.removeActiveClass = function () {
        var tabHeader = this.getTabHeader();
        if (tabHeader) {
            var tabItems = sf.base.selectAll('.' + CLS_TB_ITEM + '.' + CLS_ACTIVE, tabHeader);
            sf.base.removeClass(tabItems, CLS_ACTIVE);
        }
    };
    SfTab.prototype.checkPopupOverflow = function (ele) {
        this.tbPop = sf.base.select('.' + CLS_TB_POP, this.element);
        var popIcon = sf.base.select('.e-hor-nav', this.element);
        var tbrItems = sf.base.select('.' + CLS_TB_ITEMS, this.element);
        var lastChild = tbrItems.lastChild;
        if ((!this.isVertical() && ((this.options.enableRtl && ((popIcon.offsetLeft + popIcon.offsetWidth) > tbrItems.offsetLeft))
            || (!this.options.enableRtl && popIcon.offsetLeft < tbrItems.offsetWidth))) ||
            (this.isVertical() && (popIcon.offsetTop < lastChild.offsetTop + lastChild.offsetHeight))) {
            ele.classList.add(CLS_TB_POPUP);
            this.tbPop.insertBefore(ele, sf.base.selectAll('.' + CLS_TB_POPUP, this.tbPop)[0]);
        }
        return true;
    };
    SfTab.prototype.popupHandler = function (target) {
        var ripEle = target.querySelector('.e-ripple-element');
        if (!sf.base.isNullOrUndefined(ripEle)) {
            ripEle.outerHTML = '';
            target.querySelector('.' + CLS_WRAP).classList.remove('e-ripple');
        }
        this.tbItem = sf.base.selectAll('.' + CLS_TB_ITEMS + ' .' + CLS_TB_ITEM, this.hdrEle);
        var lastChild = this.tbItem[this.tbItem.length - 1];
        if (this.tbItem.length !== 0) {
            target.classList.remove(CLS_TB_POPUP);
            target.removeAttribute('style');
            this.tbItems.appendChild(target);
            if (this.checkPopupOverflow(lastChild)) {
                var prevEle = this.tbItems.lastChild.previousElementSibling;
                this.checkPopupOverflow(prevEle);
            }
            this.isPopup = true;
        }
        return sf.base.selectAll('.' + CLS_TB_ITEM, this.tbItems).length - 1;
    };
    SfTab.prototype.previousContentAnimation = function (prev, current) {
        var animation;
        if (this.isPopup || prev <= current) {
            if (this.options.animation.previous.effect === 'SlideLeftIn') {
                animation = {
                    name: 'SlideLeftOut',
                    duration: this.options.animation.previous.duration, timingFunction: this.options.animation.previous.easing
                };
            }
            else {
                animation = null;
            }
        }
        else {
            if (this.options.animation.next.effect === 'SlideRightIn') {
                animation = {
                    name: 'SlideRightOut',
                    duration: this.options.animation.next.duration, timingFunction: this.options.animation.next.easing
                };
            }
            else {
                animation = null;
            }
        }
        return animation;
    };
    SfTab.prototype.triggerPreviousAnimation = function (oldCnt, prevIndex) {
        var animateObj = this.previousContentAnimation(prevIndex, this.options.selectedItem);
        if (!sf.base.isNullOrUndefined(animateObj)) {
            animateObj.begin = function () {
                sf.base.setStyleAttribute(oldCnt, { 'position': 'absolute' });
                sf.base.addClass([oldCnt], [CLS_PROGRESS, 'e-view']);
            };
            animateObj.end = function () {
                oldCnt.style.display = 'none';
                sf.base.removeClass([oldCnt], [CLS_ACTIVE, CLS_PROGRESS, 'e-view']);
                sf.base.setStyleAttribute(oldCnt, { 'display': '', 'position': '' });
                if (oldCnt.childNodes.length === 0) {
                    sf.base.detach(oldCnt);
                }
            };
            new sf.base.Animation(animateObj).animate(oldCnt);
        }
        else {
            oldCnt.classList.remove(CLS_ACTIVE);
        }
    };
    SfTab.prototype.triggerAnimation = function (id, value) {
        var _this = this;
        var prevIndex = this.prevIndex;
        var oldCnt;
        var newCnt;
        if (this.options.loadOn !== 'Dynamic') {
            var itemCollection = [].slice.call(this.element.querySelector('.' + CLS_CONTENT).children);
            itemCollection.forEach(function (item) {
                if (item.id === _this.prevActiveEle) {
                    oldCnt = item;
                }
            });
            var prevEle = this.tbItem[prevIndex];
            newCnt = this.getTrgContent(this.cntEle, this.extIndex(id));
            if (sf.base.isNullOrUndefined(oldCnt) && !sf.base.isNullOrUndefined(prevEle)) {
                var idNo = this.extIndex(prevEle.id);
                oldCnt = this.getTrgContent(this.cntEle, idNo);
            }
        }
        else {
            newCnt = this.cntEle.firstElementChild;
        }
        if (!sf.base.isNullOrUndefined(newCnt)) {
            this.prevActiveEle = newCnt.id;
        }
        if (this.initRender || value === false || this.options.animation === {} || sf.base.isNullOrUndefined(this.options.animation)) {
            if (oldCnt && oldCnt !== newCnt) {
                oldCnt.classList.remove(CLS_ACTIVE);
            }
            return;
        }
        var cnt = sf.base.select('.' + CLS_CONTENT, this.element);
        var animateObj;
        if (this.prevIndex > this.options.selectedItem && !this.isPopup) {
            var openEff = this.options.animation.previous.effect;
            animateObj = {
                name: ((openEff === 'None') ? '' : ((openEff !== 'SlideLeftIn') ? openEff : 'SlideLeftIn')),
                duration: this.options.animation.previous.duration,
                timingFunction: this.options.animation.previous.easing
            };
        }
        else if (this.isPopup || this.prevIndex < this.options.selectedItem || this.prevIndex === this.options.selectedItem) {
            var clsEff = this.options.animation.next.effect;
            animateObj = {
                name: ((clsEff === 'None') ? '' : ((clsEff !== 'SlideRightIn') ? clsEff : 'SlideRightIn')),
                duration: this.options.animation.next.duration,
                timingFunction: this.options.animation.next.easing
            };
        }
        animateObj.progress = function () {
            cnt.classList.add(CLS_PROGRESS);
            _this.setActiveBorder();
        };
        animateObj.end = function () {
            cnt.classList.remove(CLS_PROGRESS);
            newCnt.classList.add(CLS_ACTIVE);
        };
        if (!this.initRender && !sf.base.isNullOrUndefined(oldCnt)) {
            this.triggerPreviousAnimation(oldCnt, prevIndex);
        }
        this.isPopup = false;
        if (animateObj.name === '') {
            newCnt.classList.add(CLS_ACTIVE);
        }
        else {
            new sf.base.Animation(animateObj).animate(newCnt);
        }
    };
    SfTab.prototype.keyPressed = function (trg) {
        var trgParent = sf.base.closest(trg, '.' + CLS_HEADER + ' .' + CLS_TB_ITEM);
        var trgIndex = this.getEleIndex(trgParent);
        if (!sf.base.isNullOrUndefined(this.popEle) && trg.classList.contains('e-hor-nav')) {
            if (this.popEle.classList.contains(CLS_POPUP_OPEN)) {
                this.popObj.hide(this.hide);
            }
            else {
                this.popObj.show(this.show);
            }
        }
        else if (trg.classList.contains('e-scroll-nav')) {
            trg.click();
        }
        else {
            if (!sf.base.isNullOrUndefined(trgParent) && trgParent.classList.contains(CLS_ACTIVE) === false) {
                this.select(trgIndex);
                if (!sf.base.isNullOrUndefined(this.popEle)) {
                    this.popObj.hide(this.hide);
                }
            }
        }
    };
    SfTab.prototype.getTabHeader = function () {
        var headers = [].slice.call(this.element.children).filter(function (e) { return e.classList.contains(CLS_HEADER); });
        if (headers.length > 0) {
            return headers[0];
        }
        else {
            // eslint-disable-next-line max-len
            var wrap = [].slice.call(this.element.children).filter(function (e) { return !e.classList.contains(CLS_BLA_TEM); })[0];
            if (!wrap) {
                return undefined;
            }
            return [].slice.call(wrap.children).filter(function (e) { return e.classList.contains(CLS_HEADER); })[0];
        }
    };
    SfTab.prototype.getEleIndex = function (item) {
        return Array.prototype.indexOf.call(sf.base.selectAll('.' + CLS_TB_ITEM, this.getTabHeader()), item);
    };
    SfTab.prototype.extIndex = function (id) {
        return id.replace(CLS_ITEM + this.tabId + '_', '');
    };
    SfTab.prototype.getTrgContent = function (cntEle, no) {
        var ele;
        if (this.element.classList.contains(CLS_NEST)) {
            ele = sf.base.select('.' + CLS_NEST + '> .' + CLS_CONTENT + ' > #' + CLS_CONTENT + this.tabId + '_' + no, this.element);
        }
        else {
            ele = this.findEle(cntEle.children, CLS_CONTENT + this.tabId + '_' + no);
        }
        return ele;
    };
    SfTab.prototype.findEle = function (items, key) {
        var ele;
        for (var i = 0; i < items.length; i++) {
            if (items[i].id === key) {
                ele = items[i];
                break;
            }
        }
        return ele;
    };
    SfTab.prototype.isVertical = function () {
        var isVertical = (this.options.headerPlacement === 'Left' || this.options.headerPlacement === 'Right') ? true : false;
        this.scrCntClass = (isVertical) ? CLS_VSCRCNT : CLS_HSCRCNT;
        return isVertical;
    };
    SfTab.prototype.updatePopAnimationConfig = function () {
        this.show = { name: (this.isVertical() ? 'FadeIn' : 'SlideDown'), duration: 100 };
        this.hide = { name: (this.isVertical() ? 'FadeOut' : 'SlideUp'), duration: 100 };
    };
    SfTab.prototype.focusItem = function () {
        var curActItem = sf.base.select(' #' + CLS_ITEM + this.tabId + '_' + this.options.selectedItem, this.hdrEle);
        if (!sf.base.isNullOrUndefined(curActItem)) {
            curActItem.firstElementChild.focus();
        }
    };
    SfTab.prototype.serverChangeOrientation = function (newProp, tbarEle, isVertical, isChange) {
        this.setOrientation(newProp, this.hdrEle);
        sf.base.removeClass([this.element], [CLS_VTAB, CLS_VLEFT, CLS_VRIGHT]);
        if (isChange) {
            this.changeToolbarOrientation(tbarEle, isVertical);
        }
        if (this.isVertical()) {
            var tbPos = (this.options.headerPlacement === 'Left') ? CLS_VLEFT : CLS_VRIGHT;
            if (!this.element.classList.contains(CLS_NEST)) {
                sf.base.addClass([this.element], [CLS_VTAB, tbPos]);
            }
            else {
                sf.base.addClass([this.hdrEle], [CLS_VTAB, tbPos]);
            }
        }
        this.setActiveBorder();
        this.focusItem();
    };
    SfTab.prototype.changeToolbarOrientation = function (toolbarEle, isVertical) {
        if (!sf.base.isNullOrUndefined(toolbarEle) && !sf.base.isNullOrUndefined(toolbarEle.blazor__instance)) {
            toolbarEle.blazor__instance.options.width = (isVertical ? 'auto' : '100%');
            toolbarEle.blazor__instance.options.height = (isVertical ? '100%' : 'auto');
            toolbarEle.blazor__instance.options.isVertical = isVertical;
            toolbarEle.blazor__instance.changeOrientation();
        }
        this.updatePopAnimationConfig();
    };
    SfTab.prototype.setOrientation = function (place, ele) {
        var headerPos = Array.prototype.indexOf.call(this.element.children, ele);
        var contentPos = Array.prototype.indexOf.call(this.element.children, this.element.querySelector('.' + CLS_CONTENT));
        if (place === 'Bottom' && (contentPos > headerPos)) {
            this.element.appendChild(ele);
        }
        else {
            sf.base.removeClass([ele], [CLS_HBOTTOM]);
            this.element.insertBefore(ele, sf.base.select('.' + CLS_CONTENT, this.element));
        }
    };
    SfTab.prototype.setCssClass = function (ele, cls, val) {
        if (cls === '') {
            return;
        }
        if (val) {
            sf.base.addClass([ele], cls.split(' '));
        }
        else {
            sf.base.removeClass([ele], cls.split(' '));
        }
    };
    SfTab.prototype.setActiveBorder = function () {
        var trgHdrEle = this.getTabHeader();
        var trg = sf.base.select('.' + CLS_TB_ITEM + '.' + CLS_ACTIVE, trgHdrEle);
        if (trg === null) {
            return;
        }
        if (trg.classList.contains(CLS_TB_POPUP)) {
            this.popupHandler(trg);
        }
        var root = sf.base.closest(trg, '.' + CLS_TAB);
        if (this.element !== root) {
            return;
        }
        this.tbItems = sf.base.select('.' + CLS_TB_ITEMS, trgHdrEle);
        var bar = sf.base.select('.' + CLS_INDICATOR, trgHdrEle);
        var scrollCnt = sf.base.select('.' + CLS_TB_ITEMS + ' .' + this.scrCntClass, trgHdrEle);
        if (this.isVertical()) {
            sf.base.setStyleAttribute(bar, { 'left': '', 'right': '' });
            var tbHeight = (sf.base.isNullOrUndefined(scrollCnt)) ? this.tbItems.offsetHeight : scrollCnt.offsetHeight;
            if (tbHeight !== 0) {
                sf.base.setStyleAttribute(bar, { 'top': trg.offsetTop + 'px', 'height': trg.offsetHeight + 'px' });
            }
            else {
                sf.base.setStyleAttribute(bar, { 'top': 0, 'height': 0 });
            }
        }
        else {
            sf.base.setStyleAttribute(bar, { 'top': '', 'height': '' });
            var tbWidth = (sf.base.isNullOrUndefined(scrollCnt)) ? this.tbItems.offsetWidth : scrollCnt.offsetWidth;
            if (tbWidth !== 0) {
                sf.base.setStyleAttribute(bar, { 'left': trg.offsetLeft + 'px', 'right': tbWidth - (trg.offsetLeft + trg.offsetWidth) + 'px' });
            }
            else {
                sf.base.setStyleAttribute(bar, { 'left': 'auto', 'right': 'auto' });
            }
        }
        if (!sf.base.isNullOrUndefined(this.bdrLine)) {
            this.bdrLine.classList.remove(CLS_HIDDEN);
        }
    };
    SfTab.prototype.setActive = function (value) {
        this.tbItem = sf.base.selectAll('.' + CLS_TB_ITEM, this.getTabHeader());
        if (sf.base.isNullOrUndefined(this.hdrEle)) {
            this.hdrEle = this.getTabHeader();
        }
        var trg = this.hdrEle.querySelector('.' + CLS_TB_ITEM + '[data-index="' + value + '"]');
        if (!trg || value < 0 || isNaN(value) || this.tbItem.length === 0) {
            return;
        }
        this.options.selectedItem = value;
        if (trg.classList.contains(CLS_ACTIVE)) {
            this.setActiveBorder();
            return;
        }
        var prev = this.tbItem[this.prevIndex];
        if (!sf.base.isNullOrUndefined(prev)) {
            prev.removeAttribute('aria-controls');
        }
        sf.base.attributes(trg, { 'aria-controls': CLS_CONTENT + this.tabId + '_' + value });
        var id = trg.id;
        this.removeActiveClass();
        trg.classList.add(CLS_ACTIVE);
        trg.setAttribute('aria-selected', 'true');
        var no = Number(this.extIndex(id));
        if (sf.base.isNullOrUndefined(this.prevActiveEle)) {
            this.prevActiveEle = CLS_CONTENT + this.tabId + '_' + no;
        }
        sf.base.attributes(this.element, { 'aria-activedescendant': id });
        if (this.options.loadOn === 'Init') {
            this.cntEle = sf.base.select('.' + CLS_TAB + ' > .' + CLS_CONTENT, this.element);
            var item = this.getTrgContent(this.cntEle, this.extIndex(id));
            if (!sf.base.isNullOrUndefined(item)) {
                item.classList.add(CLS_ACTIVE);
            }
            this.triggerAnimation(id, this.enableAnimation);
        }
        this.setActiveBorder();
        this.refreshItemVisibility(trg);
        if (!this.initRender) {
            trg.firstElementChild.focus();
        }
    };
    SfTab.prototype.contentReady = function () {
        var id = this.setActiveContent();
        this.triggerAnimation(id, this.enableAnimation);
    };
    SfTab.prototype.setRTL = function (value) {
        this.setCssClass(this.element, CLS_RTL, value);
        this.refreshActiveBorder();
    };
    SfTab.prototype.refreshActiveBorder = function () {
        if (!sf.base.isNullOrUndefined(this.bdrLine)) {
            this.bdrLine.classList.add(CLS_HIDDEN);
        }
        this.setActiveBorder();
    };
    SfTab.prototype.setDragAndDrop = function (isDragAndDrop) {
        if (isDragAndDrop) {
            this.bindDraggable();
        }
        else {
            if (this.draggableItems) {
                this.draggableItems.forEach(function (item) {
                    if (item && Object.keys(item).length !== 0) {
                        item.destroy();
                    }
                });
            }
        }
    };
    SfTab.prototype.showPopup = function (config) {
        var tbPop = sf.base.select('.e-popup.e-toolbar-pop', this.hdrEle);
        if (tbPop && tbPop.classList.contains('e-popup-close')) {
            var tbPopObj = (tbPop && tbPop.ej2_instances[0]);
            tbPopObj.position.X = (this.options.headerPlacement === 'Left') ? 'left' : 'right';
            tbPopObj.dataBind();
            tbPopObj.show(config);
        }
    };
    SfTab.prototype.initializeDrag = function (target) {
        var _this = this;
        this.options.dragArea = !sf.base.isNullOrUndefined(this.options.dragArea) ? this.options.dragArea : '#' + this.element.id + ' ' + ('.' + CLS_HEADER);
        var dragObj = new sf.base.Draggable(target, {
            dragArea: this.options.dragArea,
            dragTarget: '.' + CLS_TB_ITEM,
            clone: true,
            helper: this.helper.bind(this),
            dragStart: this.itemDragStart.bind(this),
            drag: function (e) {
                var dragIndex = _this.getEleIndex(_this.dragItem);
                var dropIndex;
                if (!sf.base.isNullOrUndefined(e.target.closest('.' + CLS_TAB)) && !e.target.closest('.' + CLS_TAB).isEqualNode(_this.element) && _this.options.dragArea !== '.' + CLS_HEADER) {
                    return;
                }
                if (!(e.target.closest(_this.options.dragArea)) && _this.options.overflowMode !== 'Popup') {
                    document.body.style.cursor = 'not-allowed';
                    sf.base.addClass([_this.cloneElement], CLS_HIDDEN);
                    if (_this.dragItem.classList.contains(CLS_HIDDEN)) {
                        sf.base.removeClass([_this.dragItem], CLS_HIDDEN);
                    }
                    _this.dragItem.querySelector('.' + CLS_WRAP).style.visibility = 'visible';
                }
                else {
                    document.body.style.cursor = '';
                    _this.dragItem.querySelector('.' + CLS_WRAP).style.visibility = 'hidden';
                    if (_this.cloneElement.classList.contains(CLS_HIDDEN)) {
                        sf.base.removeClass([_this.cloneElement], CLS_HIDDEN);
                    }
                }
                if (_this.options.overflowMode === 'Scrollable' && !sf.base.isNullOrUndefined(_this.element.querySelector('.e-hscroll'))) {
                    var scrollRightNavEle = _this.element.querySelector('.e-scroll-right-nav');
                    var scrollLeftNavEle = _this.element.querySelector('.e-scroll-left-nav');
                    var hscrollBar = _this.element.querySelector('.e-hscroll-bar');
                    if (!sf.base.isNullOrUndefined(scrollRightNavEle) && Math.abs((scrollRightNavEle.offsetWidth / 2) +
                        scrollRightNavEle.offsetLeft) > _this.cloneElement.offsetLeft + _this.cloneElement.offsetWidth) {
                        hscrollBar.scrollLeft -= 10;
                    }
                    if (!sf.base.isNullOrUndefined(scrollLeftNavEle) && Math.abs((scrollLeftNavEle.offsetLeft + scrollLeftNavEle.offsetWidth) -
                        _this.cloneElement.offsetLeft) > (scrollLeftNavEle.offsetWidth / 2)) {
                        hscrollBar.scrollLeft += 10;
                    }
                }
                _this.cloneElement.style.pointerEvents = 'none';
                var x = _this.cloneElement.getBoundingClientRect().left;
                var y = _this.cloneElement.getBoundingClientRect().top;
                var ele = document.elementFromPoint(x, y);
                var dropItem = sf.base.closest(ele, '.' + CLS_TB_ITEM);
                var scrollContentWidth = 0;
                if (_this.options.overflowMode === 'Scrollable' && !sf.base.isNullOrUndefined(_this.element.querySelector('.e-hscroll'))) {
                    scrollContentWidth = _this.element.querySelector('.e-hscroll-content').offsetWidth;
                }
                if (dropItem != null && !dropItem.isSameNode(_this.dragItem) &&
                    dropItem.closest('.' + CLS_TAB).isSameNode(_this.dragItem.closest('.' + CLS_TAB))) {
                    dropIndex = _this.getEleIndex(dropItem);
                    if (dropIndex < dragIndex &&
                        (Math.abs((dropItem.offsetLeft + dropItem.offsetWidth) -
                            _this.cloneElement.offsetLeft) > (dropItem.offsetWidth / 2))) {
                        _this.dragAction(dropItem, dragIndex, dropIndex);
                    }
                    if (dropIndex > dragIndex &&
                        (Math.abs(dropItem.offsetWidth / 2) + dropItem.offsetLeft -
                            scrollContentWidth) < _this.cloneElement.offsetLeft + _this.cloneElement.offsetWidth) {
                        _this.dragAction(dropItem, dragIndex, dropIndex);
                    }
                }
                _this.droppedIndex = _this.getEleIndex(_this.dragItem);
            },
            dragStop: this.itemDragStop.bind(this)
        });
        this.draggableItems.push(dragObj);
    };
    SfTab.prototype.helper = function (e) {
        if (e.element) {
            this.cloneElement = (e.element.cloneNode(true));
            sf.base.addClass([this.cloneElement], ['e-tab-clone-element', CLS_TAB]);
            sf.base.removeClass([this.cloneElement.querySelector('.' + CLS_WRAP)], 'e-ripple');
            if (!sf.base.isNullOrUndefined(this.cloneElement.querySelector('.e-ripple-element'))) {
                sf.base.remove(this.cloneElement.querySelector('.e-ripple-element'));
            }
            document.body.appendChild(this.cloneElement);
        }
        return this.cloneElement;
    };
    SfTab.prototype.itemDragStart = function (e) {
        var _this = this;
        this.dragItem = e.element;
        this.dragStartIndex = this.getEleIndex(this.dragItem);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var toolbarEle = this.element.querySelector('.e-toolbar');
        this.dotNetRef.invokeMethodAsync('OnDragStart', this.dragStartIndex).then(function (isCancel) {
            if (isCancel) {
                sf.base.detach(_this.cloneElement);
            }
            else {
                _this.removeActiveClass();
                sf.base.addClass([_this.tbItems.querySelector('.' + CLS_INDICATOR)], CLS_HIDDEN);
                _this.dragItem.querySelector('.' + CLS_WRAP).style.visibility = 'hidden';
                e.bindEvents(sf.base.getElement(e.dragElement));
            }
        });
    };
    SfTab.prototype.dragAction = function (dropItem, dragsIndex, dropIndex) {
        if (this.options.overflowMode === 'MultiRow') {
            dropItem.parentNode.insertBefore(this.dragItem, dropItem.nextElementSibling);
        }
        if (dragsIndex > dropIndex) {
            if (!(this.dragItem.parentElement).isSameNode(dropItem.parentElement)) {
                if (this.options.overflowMode === 'Extended') {
                    if (dropItem.isSameNode(dropItem.parentElement.lastChild)) {
                        var popupContainer = this.dragItem.parentNode;
                        dropItem.parentNode.insertBefore(this.dragItem, dropItem);
                        popupContainer.insertBefore(dropItem.parentElement.lastChild, popupContainer.childNodes[0]);
                    }
                    else {
                        this.dragItem.parentNode.insertBefore((dropItem.parentElement.lastChild), this.dragItem.parentElement.childNodes[0]);
                        dropItem.parentNode.insertBefore(this.dragItem, dropItem);
                    }
                }
                else {
                    var lastEle = (dropItem.parentElement).lastChild;
                    if (dropItem.isSameNode(lastEle)) {
                        var popupContainer = this.dragItem.parentNode;
                        dropItem.parentNode.insertBefore(this.dragItem, dropItem);
                        popupContainer.insertBefore(lastEle, popupContainer.childNodes[0]);
                    }
                    else {
                        this.dragItem.parentNode.insertBefore((dropItem.parentElement).lastChild, this.dragItem.parentElement.childNodes[0]);
                        dropItem.parentNode.insertBefore(this.dragItem, dropItem);
                    }
                }
            }
            else {
                this.dragItem.parentNode.insertBefore(this.dragItem, dropItem);
            }
        }
        if (dragsIndex < dropIndex) {
            if (!(this.dragItem.parentElement).isSameNode(dropItem.parentElement)) {
                if (this.options.overflowMode === 'Extended') {
                    this.dragItem.parentElement.appendChild(dropItem.parentElement.firstElementChild);
                    dropItem.parentNode.insertBefore(this.dragItem, dropItem.nextSibling);
                }
                else {
                    this.dragItem.parentNode.insertBefore((dropItem.parentElement).lastChild, this.dragItem.parentElement.childNodes[0]);
                    dropItem.parentNode.insertBefore(this.dragItem, dropItem);
                }
            }
            else {
                this.dragItem.parentNode.insertBefore(dropItem, this.dragItem);
            }
        }
    };
    SfTab.prototype.itemDragStop = function (e) {
        sf.base.detach(this.cloneElement);
        var toolbarEle = this.element.querySelector('.e-toolbar');
        this.dragItem.querySelector('.' + CLS_WRAP).style.visibility = 'visible';
        sf.base.addClass([toolbarEle], 'e-drag-action');
        document.body.style.cursor = '';
        // tslint:disable-next-line:no-any
        var left = this.getXYValue(e.event, 'X');
        var top = this.getXYValue(e.event, 'Y');
        this.dotNetRef.invokeMethodAsync('Dragged', this.droppedIndex, this.dragStartIndex, left, top);
    };
    SfTab.prototype.getXYValue = function (e, direction) {
        var touchList = e.changedTouches;
        var value;
        if (direction === 'X') {
            value = touchList ? touchList[0].clientX : e.clientX;
        }
        else {
            value = touchList ? touchList[0].clientY : e.clientY;
        }
        return Math.ceil(value);
    };
    SfTab.prototype.bindDraggable = function () {
        var _this = this;
        if (this.options.allowDragAndDrop) {
            var items = this.element.querySelectorAll('.' + CLS_TB_ITEM);
            items.forEach(function (element) {
                if (sf.base.isNullOrUndefined(_this.options.dragArea)) {
                    _this.options.dragArea = '#' + _this.element.id + ' ' + ('.' + CLS_HEADER);
                }
                if (!element.classList.contains('e-draggable')) {
                    _this.initializeDrag(element);
                }
            });
        }
    };
    SfTab.prototype.wireEvents = function () {
        this.bindDraggable();
        window.addEventListener('resize', this.resizeContext);
        sf.base.EventHandler.add(this.element, 'keydown', this.spaceKeyDown, this);
        if (!sf.base.isNullOrUndefined(this.cntEle)) {
            this.touchModule = new sf.base.Touch(this.cntEle, { swipe: this.swipeHandler.bind(this) });
        }
        this.keyModule = new sf.base.KeyboardEvents(this.element, { keyAction: this.keyHandler.bind(this), keyConfigs: this.keyConfigs });
        this.tabKeyModule = new sf.base.KeyboardEvents(this.element, {
            keyAction: this.keyHandler.bind(this),
            keyConfigs: { openPopup: 'shift+f10', tab: 'tab', shiftTab: 'shift+tab' },
            eventName: 'keydown'
        });
    };
    SfTab.prototype.unWireEvents = function () {
        this.keyModule.destroy();
        this.tabKeyModule.destroy();
        if (!sf.base.isNullOrUndefined(this.cntEle)) {
            this.touchModule.destroy();
        }
        window.removeEventListener('resize', this.resizeContext);
        sf.base.EventHandler.remove(this.element, 'keydown', this.spaceKeyDown);
        sf.base.removeClass([this.element], [CLS_RTL, CLS_FOCUS]);
    };
    SfTab.prototype.swipeHandler = function (e) {
        if (e.velocity < 3 && sf.base.isNullOrUndefined(e.originalEvent.changedTouches)) {
            return;
        }
        if (e.originalEvent) {
            e.originalEvent.stopPropagation();
        }
        this.isSwipeed = true;
        if (e.swipeDirection === 'Right' && this.options.selectedItem !== 0) {
            for (var k = this.options.selectedItem - 1; k >= 0; k--) {
                if (!this.tbItem[k].classList.contains(CLS_HIDDEN) && !this.tbItem[k].classList.contains(CLS_DISABLE)) {
                    this.select(k);
                    break;
                }
            }
        }
        else if (e.swipeDirection === 'Left' && (this.options.selectedItem !== sf.base.selectAll('.' + CLS_TB_ITEM, this.element).length - 1)) {
            for (var i = this.options.selectedItem + 1; i < this.tbItem.length; i++) {
                if (!this.tbItem[i].classList.contains(CLS_HIDDEN) && !this.tbItem[i].classList.contains(CLS_DISABLE)) {
                    this.select(i);
                    break;
                }
            }
        }
        this.isSwipeed = false;
    };
    SfTab.prototype.spaceKeyDown = function (e) {
        if ((e.keyCode === SPACEBAR && e.which === SPACEBAR) || (e.keyCode === END && e.which === END)) {
            var clstHead = sf.base.closest(e.target, '.' + CLS_HEADER);
            if (!sf.base.isNullOrUndefined(clstHead)) {
                e.preventDefault();
            }
        }
    };
    SfTab.prototype.keyHandler = function (e) {
        if (this.element.classList.contains(CLS_DISABLE)) {
            return;
        }
        this.element.classList.add(CLS_FOCUS);
        var trg = e.target;
        var tabHeader = this.getTabHeader();
        var actEle = sf.base.select('.' + CLS_ACTIVE, tabHeader);
        this.popEle = sf.base.select('.' + CLS_TB_POP, tabHeader);
        if (!sf.base.isNullOrUndefined(this.popEle)) {
            this.popObj = this.popEle.ej2_instances[0];
        }
        var item;
        var trgParent;
        switch (e.action) {
            case 'space':
            case 'enter':
                if (trg.parentElement.classList.contains(CLS_DISABLE)) {
                    return;
                }
                if (e.action === 'enter' && trg.classList.contains('e-hor-nav')) {
                    this.showPopup(this.show);
                    break;
                }
                this.keyPressed(trg);
                break;
            case 'tab':
            case 'shiftTab':
                if (trg.classList.contains(CLS_WRAP)
                    && sf.base.closest(trg, '.' + CLS_TB_ITEM).classList.contains(CLS_ACTIVE) === false) {
                    trg.setAttribute('tabindex', '-1');
                }
                if (this.popObj && sf.base.isVisible(this.popObj.element)) {
                    this.popObj.hide(this.hide);
                }
                actEle.children.item(0).setAttribute('tabindex', '0');
                break;
            case 'moveLeft':
            case 'moveRight':
                item = sf.base.closest(document.activeElement, '.' + CLS_TB_ITEM);
                if (!sf.base.isNullOrUndefined(item)) {
                    this.refreshItemVisibility(item);
                }
                break;
            case 'openPopup':
                e.preventDefault();
                if (!sf.base.isNullOrUndefined(this.popEle) && this.popEle.classList.contains(CLS_POPUP_CLOSE)) {
                    this.popObj.show(this.show);
                }
                break;
            case 'delete':
                trgParent = sf.base.closest(trg, '.' + CLS_TB_ITEM);
                if (this.options.showCloseButton === true && !sf.base.isNullOrUndefined(trgParent)) {
                    if (this.getEleIndex(trgParent) === -1) {
                        return;
                    }
                    var nxtSib = trgParent.nextSibling;
                    if (!sf.base.isNullOrUndefined(nxtSib) && nxtSib.classList.contains(CLS_TB_ITEM)) {
                        nxtSib.firstElementChild.focus();
                    }
                    this.dotNetRef.invokeMethodAsync('RemoveTab', parseInt(trgParent.getAttribute('data-index'), 10));
                }
                this.setActiveBorder();
                break;
        }
    };
    SfTab.prototype.refreshActElePosition = function () {
        var activeEle = sf.base.select('.' + CLS_TB_ITEM + '.' + CLS_TB_POPUP + '.' + CLS_ACTIVE, this.element);
        if (!sf.base.isNullOrUndefined(activeEle)) {
            this.select(this.getEleIndex(activeEle));
        }
        this.refreshActiveBorder();
    };
    SfTab.prototype.refreshItemVisibility = function (target) {
        var scrCnt = sf.base.select('.' + this.scrCntClass, this.tbItems);
        if (!this.isVertical() && !sf.base.isNullOrUndefined(scrCnt)) {
            var scrBar = sf.base.select('.e-hscroll-bar', this.tbItems);
            var scrStart = scrBar.scrollLeft;
            var scrEnd = scrStart + scrBar.offsetWidth;
            var eleStart = target.offsetLeft;
            var eleWidth = target.offsetWidth;
            var eleEnd = target.offsetLeft + target.offsetWidth;
            if ((scrStart < eleStart) && (scrEnd < eleEnd)) {
                var eleViewRange = scrEnd - eleStart;
                scrBar.scrollLeft = scrStart + (eleWidth - eleViewRange);
            }
            else {
                if ((scrStart > eleStart) && (scrEnd > eleEnd)) {
                    var eleViewRange = eleEnd - scrStart;
                    scrBar.scrollLeft = scrStart - (eleWidth - eleViewRange);
                }
            }
        }
        else {
            return;
        }
    };
    SfTab.prototype.enableTab = function (index, value) {
        var tbItems = sf.base.selectAll('.' + CLS_TB_ITEM, this.element)[index];
        if (sf.base.isNullOrUndefined(tbItems)) {
            return;
        }
        if (value === true) {
            tbItems.classList.remove(CLS_DISABLE, CLS_OVERLAY);
            tbItems.firstElementChild.setAttribute('tabindex', '-1');
        }
        else {
            tbItems.classList.add(CLS_DISABLE, CLS_OVERLAY);
            tbItems.firstElementChild.removeAttribute('tabindex');
            if (tbItems.classList.contains(CLS_ACTIVE)) {
                this.select(index + 1);
            }
        }
        tbItems.setAttribute('aria-disabled', (value === true) ? 'false' : 'true');
    };
    SfTab.prototype.hideTab = function (index, value) {
        if (value === void 0) { value = true; }
        var items;
        var item = sf.base.selectAll('.' + CLS_TB_ITEM, this.element)[index];
        if (sf.base.isNullOrUndefined(item)) {
            return;
        }
        this.bdrLine.classList.add(CLS_HIDDEN);
        if (value) {
            item.classList.add(CLS_HIDDEN);
            items = sf.base.selectAll('.' + CLS_TB_ITEM + ':not(.' + CLS_HIDDEN + ')', this.tbItems);
            if (items.length !== 0 && item.classList.contains(CLS_ACTIVE)) {
                if (index !== 0) {
                    for (var i = index - 1; i >= 0; i--) {
                        if (!this.tbItem[i].classList.contains(CLS_HIDDEN)) {
                            this.select(i);
                            break;
                        }
                        else if (i === 0) {
                            for (var k = index + 1; k < this.tbItem.length; k++) {
                                if (!this.tbItem[k].classList.contains(CLS_HIDDEN)) {
                                    this.select(k);
                                    break;
                                }
                            }
                        }
                    }
                }
                else {
                    for (var k = index + 1; k < this.tbItem.length; k++) {
                        if (!this.tbItem[k].classList.contains(CLS_HIDDEN)) {
                            this.select(k);
                            break;
                        }
                    }
                }
            }
            else if (items.length === 0) {
                this.element.classList.add(CLS_HIDDEN);
            }
        }
        else {
            this.element.classList.remove(CLS_HIDDEN);
            items = sf.base.selectAll('.' + CLS_TB_ITEM + ':not(.' + CLS_HIDDEN + ')', this.tbItems);
            item.classList.remove(CLS_HIDDEN);
            if (items.length === 0) {
                this.select(index);
            }
        }
        this.setActiveBorder();
        item.setAttribute('aria-hidden', '' + value);
    };
    SfTab.prototype.select = function (args) {
        var tabHeader = this.getTabHeader();
        this.tbItems = sf.base.select('.' + CLS_TB_ITEMS, tabHeader);
        this.tbItem = sf.base.selectAll('.' + CLS_TB_ITEM, tabHeader);
        this.prevItem = this.tbItem[this.prevIndex];
        var value;
        var selectedItem = this.options.selectedItem;
        if (sf.base.isNullOrUndefined(selectedItem) || (selectedItem < 0) || (this.tbItem.length <= selectedItem) || isNaN(selectedItem)) {
            this.options.selectedItem = 0;
        }
        var trg = this.tbItem[args];
        if (!sf.base.isNullOrUndefined(this.prevItem) && !this.prevItem.classList.contains(CLS_DISABLE)) {
            this.prevItem.children.item(0).setAttribute('tabindex', '-1');
        }
        if (!this.initRender) {
            if (trg) {
                value = parseInt(trg.getAttribute('data-index'), 10);
            }
            var eventArg = {
                previousItem: null,
                previousIndex: this.prevIndex,
                selectedItem: null,
                selectedIndex: this.options.selectedItem,
                selectedContent: null,
                selectingItem: null,
                selectingIndex: value,
                selectingContent: null,
                isSwiped: this.isSwipeed,
                cancel: false
            };
            this.dotNetRef.invokeMethodAsync('SelectingEvent', eventArg, value);
        }
        else {
            this.selectingContent(args);
        }
    };
    SfTab.prototype.setPersistence = function (elementId, selectedItem) {
        if (this.options.enablePersistence) {
            window.localStorage.setItem(elementId, selectedItem);
        }
    };
    SfTab.prototype.selectingContent = function (args) {
        this.tbItem = sf.base.selectAll('.' + CLS_TB_ITEM, this.hdrEle);
        if (this.tbItem.length > args && args >= 0 && !isNaN(args)) {
            this.prevIndex = this.options.selectedItem;
            var item = this.hdrEle.querySelector('.' + CLS_TB_ITEM + '[data-index="' + args + '"]');
            if (item && item.classList.contains(CLS_TB_POPUP)) {
                this.popupHandler(item);
            }
            this.setActive(args);
        }
        else {
            this.setActive(0);
        }
    };
    SfTab.prototype.disable = function (value) {
        this.setCssClass(this.element, CLS_DISABLE, value);
        this.element.setAttribute('aria-disabled', '' + value);
    };
    SfTab.prototype.headerItemsUpdate = function (args) {
        var tabHeader = this.getTabHeader();
        this.tbItems = sf.base.select('.' + CLS_TB_ITEMS, tabHeader);
        this.tbItem = sf.base.selectAll('.' + CLS_TB_ITEM, tabHeader);
        this.prevItem = this.tbItem[this.prevIndex];
        if (!sf.base.isNullOrUndefined(this.prevItem) && !this.prevItem.classList.contains(CLS_DISABLE)) {
            this.prevItem.children.item(0).setAttribute('tabindex', '-1');
        }
        this.selectingContent(args);
    };
    SfTab.prototype.destroy = function () {
        var _this = this;
        this.unWireEvents();
        ['aria-disabled', 'aria-activedescendant', 'tabindex'].forEach(function (val) {
            _this.element.removeAttribute(val);
        });
    };
    SfTab.prototype.getContentElement = function (index) {
        return sf.base.select('.' + CLS_CONTENT + ' #' + CLS_CONTENT + this.tabId + '_' + index, this.element);
    };
    return SfTab;
}());
// tslint:disable
var Tab = {
    // eslint-disable-next-line max-len
    initialize: function (element, options, dotnetRef, isLoaded, isCreatedEvent) {
        if (element) {
            var instance = new SfTab(element, options, dotnetRef);
            instance.render();
            if (isLoaded) {
                instance.headerReady();
                if (!isCreatedEvent) {
                    instance.dotNetRef.invokeMethodAsync('CreatedEvent', null);
                }
            }
        }
    },
    headerReady: function (element, isCreatedEvent) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.headerReady();
            if (!isCreatedEvent) {
                element.blazor__instance.dotNetRef.invokeMethodAsync('CreatedEvent', null);
            }
        }
    },
    contentReady: function (element, selectingIndex, isPopup) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.classList.remove(CLS_FOCUS);
            element.blazor__instance.isPopup = isPopup;
            element.blazor__instance.headerItemsUpdate(selectingIndex);
            element.blazor__instance.setPersistence('tab' + element.id, selectingIndex.toString());
            if (element.blazor__instance.options.loadOn !== 'Init') {
                element.blazor__instance.contentReady();
            }
        }
    },
    selectingContent: function (element, selectingIndex) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.selectingContent(selectingIndex);
            element.blazor__instance.setPersistence('tab' + element.id, selectingIndex.toString());
            if (element.blazor__instance.options.loadOn !== 'Init') {
                element.blazor__instance.contentReady();
            }
        }
    },
    // eslint-disable-next-line max-len
    serverItemsChanged: function (element, selectedItem, animation, isVerticalIcon) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.selectedItem = selectedItem;
            element.blazor__instance.options.animation = animation;
            if (!sf.base.isNullOrUndefined(element.querySelector('.e-toolbar'))) {
                sf.base.removeClass([element.querySelector('.e-toolbar')], 'e-drag-action');
                sf.base.removeClass([element.querySelector('.' + CLS_INDICATOR)], CLS_HIDDEN);
            }
            if (isVerticalIcon) {
                sf.base.addClass([element], CLS_VERTICAL_ICON);
            }
            else {
                sf.base.removeClass([element], CLS_VERTICAL_ICON);
            }
            element.blazor__instance.serverItemsChanged();
            if (element.blazor__instance.options.allowDragAndDrop) {
                element.blazor__instance.bindDraggable();
            }
        }
    },
    enableTab: function (element, index, value) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.enableTab(index, value);
        }
    },
    hideTab: function (element, index, value) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.hideTab(index, value);
        }
    },
    select: function (element, index) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.select(index);
        }
    },
    disable: function (element, value) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.disable(value);
        }
    },
    setCssClass: function (element, cssClass) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            if (element.blazor__instance.options.cssClass !== '') {
                element.blazor__instance.setCssClass(element, element.blazor__instance.options.cssClass, false);
            }
            element.blazor__instance.setCssClass(element, cssClass, true);
            element.blazor__instance.options.cssClass = cssClass;
        }
    },
    showCloseButton: function (element, showCloseButton) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.showCloseButton = showCloseButton;
            element.blazor__instance.refreshActElePosition();
        }
    },
    // eslint-disable-next-line max-len
    headerPlacement: function (element, headerPlacement, selectedItem, toolbarEle, toolbarCssClass, isVertical, isOrientationChange) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.headerPlacement = headerPlacement;
            element.blazor__instance.options.selectedItem = selectedItem;
            if (!sf.base.isNullOrUndefined(toolbarEle) && !sf.base.isNullOrUndefined(toolbarEle.blazor__instance)) {
                // tslint:disable-next-line:no-any
                toolbarEle.blazor__instance.setCssClass(toolbarCssClass);
            }
            element.blazor__instance.serverChangeOrientation(headerPlacement, toolbarEle, isVertical, isOrientationChange);
        }
    },
    enableRtl: function (element, enableRtl) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.enableRtl = enableRtl;
            element.blazor__instance.setRTL(enableRtl);
        }
    },
    overflowMode: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.refreshActElePosition();
        }
    },
    allowDragAndDrop: function (element, allowDragAndDrop) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.allowDragAndDrop = allowDragAndDrop;
            element.blazor__instance.setDragAndDrop(allowDragAndDrop);
        }
    },
    refresh: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.refreshActiveBorder();
        }
    },
    destroy: function (element, elementId, selectedItem) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.setPersistence(elementId, selectedItem);
            element.blazor__instance.destroy();
        }
    },
    getTabItem: function (element, index) {
        if (!sf.base.isNullOrUndefined(element)) {
            var dom = element.querySelector('.' + CLS_TB_ITEM + '[data-index="' + index + '"]');
            if (dom) {
                // tslint:disable-next-line:no-any
                return JSON.stringify(window.sfBlazor.getDomObject('tabitem', dom));
            }
        }
        return null;
    },
    getTabContent: function (element, index) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            var dom = element.blazor__instance.getContentElement(index);
            if (dom) {
                // tslint:disable-next-line:no-any
                return JSON.stringify(window.sfBlazor.getDomObject('tabcontent', dom));
            }
        }
        return null;
    }
};

return Tab;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-textbox.js":
/*!*************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-textbox.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.TextBox = (function () {
'use strict';

/**
 * Blazor texbox interop handler
 */
var BLUR = 'blur';
var MOUSE_DOWN = 'mousedown';
var MOUSE_UP = 'mouseup';
var INPUT_GROUP = 'e-input-group-icon';
var DISABLED = 'e-disabled';
var RIPPLE_BTN = 'e-input-btn-ripple';
var SfTextBox = /** @class */ (function () {
    function SfTextBox(element, dotnetRef, containerEle) {
        this.element = element;
        this.container = containerEle;
        this.element.blazor_input_instance = this;
        this.dotNetRef = dotnetRef;
        this.isDestroyed = false;
    }
    SfTextBox.prototype.initialize = function () {
        sf.base.EventHandler.add(this.element, BLUR, this.blurHandler, this);
        var buttons = this.container ? this.container.querySelectorAll('.' + INPUT_GROUP) : null;
        if (buttons && buttons.length > 0) {
            for (var index = 0; index < buttons.length; index++) {
                sf.base.EventHandler.add(buttons[index], MOUSE_DOWN, this.onMouseDownRipple, this);
                sf.base.EventHandler.add(buttons[index], MOUSE_UP, this.onMouseUpRipple, this);
            }
        }
    };
    SfTextBox.prototype.onMouseDownRipple = function (args) {
        var button = args ? args.currentTarget : null;
        if (button && !this.container.classList.contains(DISABLED) && !this.container.querySelector('input').readOnly) {
            button.classList.add(RIPPLE_BTN);
        }
    };
    SfTextBox.prototype.onMouseUpRipple = function (args) {
        var button = args ? args.currentTarget : null;
        if (button) {
            setTimeout(function () {
                button.classList.remove(RIPPLE_BTN);
            }, 500);
        }
    };
    SfTextBox.prototype.blurHandler = function () {
        if (!this.isDestroyed) {
            // tslint:disable
            this.dotNetRef.invokeMethodAsync('BlurHandler').catch(function () { });
        }
        else {
            sf.base.EventHandler.remove(this.element, BLUR, this.blurHandler);
        }
    };
    SfTextBox.prototype.destroy = function () {
        sf.base.EventHandler.remove(this.element, BLUR, this.blurHandler);
    };
    return SfTextBox;
}());
// tslint:disable
var TextBox = {
    initialize: function (element, dotnetRef, containerEle) {
        if (element) {
            new SfTextBox(element, dotnetRef, containerEle);
        }
        if (element && element.blazor_input_instance) {
            element.blazor_input_instance.initialize();
        }
    },
    focusIn: function (element) {
        element.focus();
    },
    focusOut: function (element) {
        element.blur();
    },
    destroyInput: function (element) {
        if (element && element.blazor_input_instance) {
            element.blazor_input_instance.isDestroyed = true;
            element.blazor_input_instance.destroy();
        }
    }
};

return TextBox;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-timepicker.js":
/*!****************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-timepicker.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.TimePicker = (function () {
'use strict';

var ROOT = 'e-timepicker';
var POPUPDIMENSION = '240px';
var POPUPWRAPPER = 'e-popup-wrapper';
var OVERFLOW = 'e-time-overflow';
var LISTCLASS = 'e-list-item';
var SELECTED = 'e-active';
var HOVER = 'e-hover';
var NAVIGATION = 'e-navigation';
var POPUP_CONTENT = 'e-content';
var MODEL_POPUP = 'e-timepicker-mob-popup-wrap';
var ARIA_SELECT = 'aria-selected';
var HIDE_POPUP = 'HidePopup';
var TIME_MODAL = 'e-time-modal';
var RIGHT = 'right';
var LEFT = 'left';
var TAB = 'tab';
var ENTER = 'enter';
var CLOSE_POPUP = 'ClosePopup';
var OFFSETVALUE = 4;
var OPENDURATION = 300;
var HALFPOSITION = 2;
var ANIMATIONDURATION = 50;
var DAY = new Date().getDate();
var MONTH = new Date().getMonth();
var YEAR = new Date().getFullYear();
var SfTimePicker = /** @class */ (function () {
    // tslint:disable
    function SfTimePicker(containerElement, element, dotnetRef, options) {
        this.containerElement = containerElement;
        this.element = element;
        this.options = options;
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
    }
    SfTimePicker.prototype.initialize = function () {
        this.keyConfigure = {
            enter: 'enter', escape: 'escape', end: 'end', tab: 'tab', home: 'home', down: 'downarrow',
            up: 'uparrow', left: 'leftarrow', right: 'rightarrow', open: 'alt+downarrow', close: 'alt+uparrow'
        };
        if (!sf.base.Browser.isDevice) {
            this.keyConfigure = sf.base.extend(this.keyConfigure, this.options.keyConfigs);
            new sf.base.KeyboardEvents(this.containerElement, {
                keyAction: this.inputHandler.bind(this),
                keyConfigs: this.keyConfigure,
                eventName: 'keydown'
            });
        }
    };
    // tslint:disable
    SfTimePicker.prototype.renderPopup = function (popupElement, popupHolderEle, openEventArgs, options) {
        this.options = options;
        this.popupHolder = popupHolderEle;
        this.timeCollections = [];
        this.listWrapper = popupHolderEle.querySelector('.' + POPUP_CONTENT) || sf.base.select('.' + POPUP_CONTENT);
        this.getTimeCollection();
        if (!sf.base.isNullOrUndefined(this.element.value)) {
            this.removeSelection();
            this.selectedElement = this.listWrapper.querySelector('li[data-value = "' + this.element.value + '"]');
            this.updateSelection(this.selectedElement);
        }
        this.popupCreation(popupElement, options);
        if (sf.base.Browser.isDevice) {
            this.mobilePopupWrapper = sf.base.createElement('div', { className: MODEL_POPUP });
            document.body.appendChild(this.mobilePopupWrapper);
        }
        var appendToElement = openEventArgs.appendTo === 'model' ? this.mobilePopupWrapper : document.body;
        appendToElement.appendChild(this.popupWrapper);
        this.setScrollPosition();
        this.popupObj.refreshPosition(this.element);
        var openAnimation = {
            name: 'FadeIn',
            duration: sf.base.Browser.isDevice ? 0 : OPENDURATION,
        };
        if (this.options.zIndex === 1000) {
            this.popupObj.show(new sf.base.Animation(openAnimation), this.element);
        }
        else {
            this.popupObj.show(new sf.base.Animation(openAnimation), null);
        }
        this.setOverlayIndex(this.mobilePopupWrapper, this.popupObj.element, this.modal, sf.base.Browser.isDevice);
        sf.base.EventHandler.add(document, 'mousedown touchstart', this.documentClickHandler, this);
    };
    SfTimePicker.prototype.getTimeCollection = function () {
        var liCollections = this.listWrapper.querySelectorAll('.' + LISTCLASS);
        for (var index = 0; index < liCollections.length; index++) {
            this.timeCollections.push(liCollections[index].getAttribute('data-value'));
        }
    };
    SfTimePicker.prototype.updateSelection = function (selectElement) {
        if (selectElement) {
            sf.base.addClass([selectElement], SELECTED);
            selectElement.setAttribute(ARIA_SELECT, 'true');
        }
    };
    SfTimePicker.prototype.setScrollPosition = function () {
        if (!sf.base.isNullOrUndefined(this.selectedElement)) {
            this.findScrollTop(this.selectedElement);
        }
        else if (this.popupWrapper && this.options.scrollTo && this.checkDateValue(new Date(this.options.scrollTo))) {
            this.setScrollTo();
        }
    };
    SfTimePicker.prototype.checkDateValue = function (value) {
        return (!sf.base.isNullOrUndefined(value) && value instanceof Date && !isNaN(+value)) ? value : null;
    };
    SfTimePicker.prototype.findScrollTop = function (element) {
        var listHeight = this.getPopupHeight();
        var nextEle = element.nextElementSibling;
        var height = nextEle ? nextEle.offsetTop : element.offsetTop;
        var liHeight = element.getBoundingClientRect().height;
        if ((height + element.offsetTop) > listHeight) {
            this.popupWrapper.scrollTop = nextEle ? (height - (listHeight / HALFPOSITION + liHeight / HALFPOSITION)) : height;
        }
        else {
            this.popupWrapper.scrollTop = 0;
        }
    };
    SfTimePicker.prototype.setScrollTo = function () {
        var element;
        if (!sf.base.isNullOrUndefined(this.popupWrapper)) {
            var items = this.popupWrapper.querySelectorAll('.' + LISTCLASS);
            if (items.length) {
                var initialTime = new Date(new Date().toDateString() + ' ' + this.timeCollections[0]).setMilliseconds(0);
                var scrollTime = this.getDateObject(new Date(this.options.scrollTo)).getTime();
                element = items[Math.round((scrollTime - initialTime) / (this.options.step * 60000))];
            }
        }
        else {
            this.popupWrapper.scrollTop = 0;
        }
        if (!sf.base.isNullOrUndefined(element)) {
            this.findScrollTop(element);
        }
        else {
            this.popupWrapper.scrollTop = 0;
        }
    };
    SfTimePicker.prototype.getDateObject = function (text) {
        if (!sf.base.isNullOrUndefined(text)) {
            var dateValue = text;
            var value = !sf.base.isNullOrUndefined(this.options.value);
            if (this.checkDateValue(dateValue)) {
                var date = value ? new Date(this.options.value).getDate() : DAY;
                var month = value ? new Date(this.options.value).getMonth() : MONTH;
                var year = value ? new Date(this.options.value).getFullYear() : YEAR;
                return new Date(year, month, date, dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds());
            }
        }
        return null;
    };
    SfTimePicker.prototype.getPopupHeight = function () {
        var height = parseInt(POPUPDIMENSION, 10);
        var popupHeight = this.popupWrapper.getBoundingClientRect().height;
        return popupHeight > height ? height : popupHeight;
    };
    SfTimePicker.prototype.popupCreation = function (popupElement, options) {
        var _this = this;
        this.popupWrapper = popupElement;
        this.containerStyle = this.containerElement.getBoundingClientRect();
        if (sf.base.Browser.isDevice) {
            this.modal = sf.base.createElement('div');
            this.modal.className = '' + ROOT + ' ' + TIME_MODAL;
            document.body.className += ' ' + OVERFLOW;
            this.modal.style.display = 'block';
            document.body.appendChild(this.modal);
        }
        this.popupObj = new sf.popups.Popup(this.popupWrapper, {
            width: this.setPopupWidth(this.options.width),
            relateTo: sf.base.Browser.isDevice ? document.body : this.containerElement,
            position: sf.base.Browser.isDevice ? { X: 'center', Y: 'center' } : { X: 'left', Y: 'bottom' },
            collision: sf.base.Browser.isDevice ? { X: 'fit', Y: 'fit' } : { X: 'flip', Y: 'flip' },
            offsetY: OFFSETVALUE,
            targetType: 'relative',
            enableRtl: options.enableRtl,
            zIndex: options.zIndex,
            open: function () {
                _this.popupWrapper.style.visibility = 'visible';
            }, close: function () {
                _this.popupHolder.appendChild(_this.popupWrapper);
                if (_this.popupObj) {
                    _this.popupObj.destroy();
                }
                if (!_this.isDisposed) {
                    // tslint:disable
                    _this.dotNetRef.invokeMethodAsync(CLOSE_POPUP).catch(function () { });
                }
                _this.popupObj = null;
            }, targetExitViewport: function () {
                if (!sf.base.Browser.isDevice && !_this.isDisposed) {
                    _this.dotNetRef.invokeMethodAsync(HIDE_POPUP, null);
                }
            }
        });
        if (!sf.base.Browser.isDevice) {
            this.popupObj.collision = { X: 'none', Y: 'flip' };
        }
        this.popupObj.element.style.maxHeight = POPUPDIMENSION;
    };
    SfTimePicker.prototype.closePopup = function (closeEventArgs, options) {
        this.options = options;
        sf.base.removeClass([document.body], OVERFLOW);
        this.closeEventCallback(closeEventArgs);
    };
    SfTimePicker.prototype.removeSelection = function () {
        this.removeHover(HOVER);
        if (!sf.base.isNullOrUndefined(this.popupWrapper)) {
            var items = this.popupWrapper.querySelectorAll('.' + SELECTED);
            if (items.length) {
                sf.base.removeClass(items, SELECTED);
                items[0].removeAttribute(ARIA_SELECT);
            }
        }
    };
    SfTimePicker.prototype.removeHover = function (className) {
        var hoveredItem = this.popupWrapper ?
            this.popupWrapper.querySelectorAll('.' + className) : [];
        if (hoveredItem && hoveredItem.length) {
            sf.base.removeClass(hoveredItem, className);
            if (className === NAVIGATION) {
                hoveredItem[0].removeAttribute(ARIA_SELECT);
            }
        }
    };
    SfTimePicker.prototype.setWidth = function (width) {
        if (typeof width === 'number') {
            width = sf.base.formatUnit(width);
        }
        else if (typeof width === 'string') {
            width = (width.match(/px|%|em/)) ? width : sf.base.formatUnit(width);
        }
        else {
            width = '100%';
        }
        return width;
    };
    SfTimePicker.prototype.setPopupWidth = function (width) {
        width = this.setWidth(width);
        if (width.indexOf('%') > -1) {
            var inputWidth = this.containerStyle.width * parseFloat(width) / 100;
            width = inputWidth.toString() + 'px';
        }
        return width;
    };
    SfTimePicker.prototype.closeEventCallback = function (eventArgs) {
        var preventArgs = eventArgs;
        if (this.isPopupOpen() && !preventArgs.cancel && this.popupObj) {
            var animModel = {
                name: 'FadeOut',
                duration: ANIMATIONDURATION,
                delay: 0
            };
            this.popupObj.hide(new sf.base.Animation(animModel));
        }
        if (sf.base.Browser.isDevice) {
            if (this.modal) {
                this.modal.style.display = 'none';
                this.modal.outerHTML = '';
                this.modal = null;
            }
            if (!sf.base.isNullOrUndefined(this.mobilePopupWrapper)) {
                this.mobilePopupWrapper.remove();
                this.mobilePopupWrapper = null;
            }
        }
        sf.base.EventHandler.remove(document, 'mousedown touchstart', this.documentClickHandler);
    };
    SfTimePicker.prototype.isPopupOpen = function () {
        return this.popupWrapper && this.popupWrapper.classList.contains('' + ROOT);
    };
    SfTimePicker.prototype.documentClickHandler = function (event) {
        var target = event.target;
        if ((!sf.base.isNullOrUndefined(this.popupObj) && (this.containerElement.contains(target) ||
            (this.popupObj.element && this.popupObj.element.contains(target)))) && event.type !== 'touchstart') {
            event.preventDefault();
        }
        var clearElement = this.containerElement.querySelector('.e-clear-icon');
        var timeIconElement = this.containerElement.querySelector('.e-time-icon.e-icons');
        if (!(sf.base.closest(target, '.' + POPUPWRAPPER)) && target !== this.element
            && target !== timeIconElement && target !== clearElement && target !== this.containerElement) {
            if (this.isPopupOpen() && !this.isDisposed) {
                this.dotNetRef.invokeMethodAsync(HIDE_POPUP, null);
            }
        }
    };
    SfTimePicker.prototype.setOverlayIndex = function (popupWrapper, timePopupElement, modal, isDevice) {
        if (isDevice && !sf.base.isNullOrUndefined(timePopupElement) && !sf.base.isNullOrUndefined(modal) && !sf.base.isNullOrUndefined(popupWrapper)) {
            var index = parseInt(timePopupElement.style.zIndex, 10) ? parseInt(timePopupElement.style.zIndex, 10) : 1000;
            modal.style.zIndex = (index - 1).toString();
            popupWrapper.style.zIndex = index.toString();
        }
    };
    SfTimePicker.prototype.selectInputText = function (element, isNavigation, index) {
        if (!sf.base.Browser.isDevice) {
            element.setSelectionRange(0, element.value.length);
            if (isNavigation && this.listWrapper) {
                this.selectedElement = this.listWrapper.querySelectorAll('.' + LISTCLASS)[index];
                this.setScrollPosition();
            }
        }
    };
    SfTimePicker.prototype.isDevice = function () {
        return sf.base.Browser.isDevice;
    };
    SfTimePicker.prototype.inputHandler = function (event) {
        if (event.action !== RIGHT && event.action !== LEFT && event.action !== TAB && event.action !== ENTER) {
            event.preventDefault();
        }
        if (event.action === ENTER && this.isPopupOpen()) {
            event.stopPropagation();
        }
        var eventArgs = {
            Action: event.action,
            Key: event.key,
            KeyCode: event.keyCode,
            Events: event,
            SelectDate: null,
            FocusedDate: null,
            classList: '',
            Id: null,
            TargetClassList: null
        };
        if (!this.isDisposed) {
            this.dotNetRef.invokeMethodAsync('KeyboardHandler', eventArgs);
        }
    };
    return SfTimePicker;
}());
// tslint:disable
var TimePicker = {
    initialize: function (containerElement, element, dotnetRef, options) {
        if (element) {
            new SfTimePicker(containerElement, element, dotnetRef, options);
        }
        if (element && element.blazor__instance) {
            element.blazor__instance.initialize();
        }
    },
    renderPopup: function (element, popupElement, popupHolderEle, openEventArgs, options) {
        if (element && element.blazor__instance && popupElement && popupHolderEle) {
            element.blazor__instance.renderPopup(popupElement, popupHolderEle, openEventArgs, options);
        }
    },
    closePopup: function (element, closeEventArgs, options) {
        if (element && element.blazor__instance) {
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    },
    selectInputText: function (element, isNavigation, index) {
        if (element && element.blazor__instance) {
            element.blazor__instance.selectInputText(element, isNavigation, index);
        }
    },
    focusIn: function (inputEle) {
        if (inputEle) {
            inputEle.focus();
        }
    },
    focusOut: function (inputEle) {
        if (inputEle) {
            inputEle.blur();
        }
    },
    destroy: function (element, popupElement, popupHolderEle, closeEventArgs, options) {
        if (element && element.blazor__instance && popupElement && popupElement instanceof HTMLElement && popupHolderEle) {
            element.blazor__instance.isDisposed = true;
            element.blazor__instance.closePopup(closeEventArgs, options);
        }
    }
};

return TimePicker;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-toolbar.js":
/*!*************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-toolbar.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Toolbar = (function () {
'use strict';

var CLS_TOOLBAR = 'e-toolbar';
var CLS_VERTICAL = 'e-vertical';
var CLS_ITEMS = 'e-toolbar-items';
var BZ_ITEMS = 'e-blazor-toolbar-items';
var CLS_ITEM = 'e-toolbar-item';
var CLS_RTL = 'e-rtl';
var CLS_SEPARATOR = 'e-separator';
var CLS_POPUPICON = 'e-popup-up-icon';
var CLS_POPUPDOWN = 'e-popup-down-icon';
var CLS_POPUPOPEN = 'e-popup-open';
var CLS_TEMPLATE = 'e-template';
var CLS_DISABLE = 'e-overlay';
var CLS_POPUPTEXT = 'e-toolbar-text';
var CLS_TBARTEXT = 'e-popup-text';
var CLS_TBAROVERFLOW = 'e-overflow-show';
var CLS_POPOVERFLOW = 'e-overflow-hide';
var CLS_TBARNAV = 'e-hor-nav';
var CLS_TBARSCRLNAV = 'e-scroll-nav';
var CLS_TBARRIGHT = 'e-toolbar-right';
var CLS_TBARLEFT = 'e-toolbar-left';
var CLS_TBARCENTER = 'e-toolbar-center';
var CLS_TBARPOS = 'e-tbar-pos';
var CLS_HSCROLLCNT = 'e-hscroll-content';
var CLS_VSCROLLCNT = 'e-vscroll-content';
var CLS_POPUPNAV = 'e-hor-nav';
var CLS_POPUPCLASS = 'e-toolbar-pop';
var CLS_POPUP = 'e-toolbar-popup';
var CLS_TBARBTNTEXT = 'e-tbar-btn-text';
var CLS_TBARNAVACT = 'e-nav-active';
var CLS_TBARIGNORE = 'e-ignore';
var CLS_POPPRI = 'e-popup-alone';
var CLS_HIDDEN = 'e-hidden';
var CLS_MULTIROW = 'e-toolbar-multirow';
var CLS_MULTIROWPOS = 'e-multirow-pos';
var CLS_MULTIROW_SEPARATOR = 'e-multirow-separator';
var CLS_EXTENDABLE_SEPARATOR = 'e-extended-separator';
var CLS_EXTEANDABLE_TOOLBAR = 'e-extended-toolbar';
var CLS_EXTENDABLECLASS = 'e-toolbar-extended';
var CLS_EXTENDPOPUP = 'e-expended-nav';
var CLS_EXTENDEDPOPOPEN = 'e-tbar-extended';
var CLS_ICON_CLOSE = 'e-close-icon';
var TAB = 9;
var DOWNARROW = 40;
var UPARROW = 38;
var END = 35;
var HOME = 36;
var SfToolbar = /** @class */ (function () {
    function SfToolbar(element, options, dotnetRef) {
        this.resizeContext = this.resize.bind(this);
        this.keyConfigs = {
            moveLeft: 'leftarrow',
            moveRight: 'rightarrow',
            moveUp: 'uparrow',
            moveDown: 'downarrow',
            popupOpen: 'enter',
            popupClose: 'escape',
            tab: 'tab',
            home: 'home',
            end: 'end'
        };
        this.element = element;
        if (!sf.base.isNullOrUndefined(element)) {
            // eslint-disable-next-line camelcase
            this.element.blazor__instance = this;
        }
        this.dotNetRef = dotnetRef;
        this.options = options;
    }
    SfToolbar.prototype.destroy = function () {
        this.unwireEvents();
        this.clearProperty();
        this.popObj = null;
        this.tbarAlign = null;
    };
    SfToolbar.prototype.wireEvents = function () {
        sf.base.EventHandler.add(this.element, 'click', this.clickHandler, this);
        window.addEventListener('resize', this.resizeContext);
        if (this.options.allowKeyboard) {
            this.wireKeyboardEvent();
        }
    };
    SfToolbar.prototype.wireKeyboardEvent = function () {
        this.keyModule = new sf.base.KeyboardEvents(this.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: this.keyConfigs
        });
        sf.base.EventHandler.add(this.element, 'keydown', this.docKeyDown, this);
        this.element.setAttribute('tabIndex', '0');
    };
    SfToolbar.prototype.unwireKeyboardEvent = function () {
        if (this.keyModule) {
            sf.base.EventHandler.remove(this.element, 'keydown', this.docKeyDown);
            this.keyModule.destroy();
            this.keyModule = null;
        }
    };
    SfToolbar.prototype.docKeyDown = function (e) {
        if (e.target.tagName === 'INPUT') {
            return;
        }
        var popCheck = !sf.base.isNullOrUndefined(this.popObj) && sf.base.isVisible(this.popObj.element) && this.options.overflowMode !== 'Extended';
        if (e.keyCode === TAB && e.target.classList.contains('e-hor-nav') === true && popCheck) {
            this.popObj.hide({ name: 'FadeOut', duration: 100 });
        }
        var keyCheck = (e.keyCode === DOWNARROW || e.keyCode === UPARROW || e.keyCode === END || e.keyCode === HOME);
        if (keyCheck) {
            e.preventDefault();
        }
    };
    SfToolbar.prototype.unwireEvents = function () {
        sf.base.EventHandler.remove(this.element, 'click', this.clickHandler);
        this.destroyScroll();
        this.unwireKeyboardEvent();
        window.removeEventListener('resize', this.resizeContext);
        sf.base.EventHandler.remove(document, 'scroll', this.docEvent);
        sf.base.EventHandler.remove(document, 'click', this.docEvent);
    };
    SfToolbar.prototype.clearProperty = function () {
        this.tbarEle = [];
        this.tbarAlgEle = { lefts: [], centers: [], rights: [] };
    };
    SfToolbar.prototype.docEvent = function (e) {
        var popEle = sf.base.closest(e.target, '.e-popup');
        if (this.popObj && sf.base.isVisible(this.popObj.element) && !popEle && this.options.overflowMode === 'Popup') {
            this.popObj.hide({ name: 'FadeOut', duration: 100 });
        }
    };
    SfToolbar.prototype.destroyScroll = function () {
        if (this.scrollModule) {
            if (this.tbarAlign) {
                sf.base.addClass([this.scrollModule.element], CLS_TBARPOS);
            }
            this.scrollModule.destroy();
            this.scrollModule = null;
        }
    };
    SfToolbar.prototype.destroyMode = function () {
        if (this.scrollModule) {
            sf.base.removeClass([this.scrollModule.element], CLS_RTL);
            this.destroyScroll();
        }
        sf.base.removeClass([this.element], CLS_EXTENDEDPOPOPEN);
        sf.base.removeClass([this.element], CLS_EXTEANDABLE_TOOLBAR);
        var tempEle = this.element.querySelector('.e-toolbar-multirow');
        if (tempEle) {
            sf.base.removeClass([tempEle], CLS_MULTIROW);
        }
        if (this.popObj) {
            this.popupRefresh(this.popObj.element, true);
        }
    };
    SfToolbar.prototype.elementFocus = function (ele) {
        var fChild = ele.firstElementChild;
        if (fChild) {
            fChild.focus();
            this.activeEleSwitch(ele);
        }
        else {
            ele.focus();
        }
    };
    SfToolbar.prototype.clstElement = function (tbrNavChk, trgt) {
        var clst;
        if (tbrNavChk && this.popObj && sf.base.isVisible(this.popObj.element)) {
            clst = this.popObj.element.querySelector('.' + CLS_ITEM);
        }
        else if (this.element === trgt || tbrNavChk) {
            clst = this.element.querySelector('.' + CLS_ITEM + ':not(.' + CLS_DISABLE + ' ):not(.' + CLS_SEPARATOR + ' ):not(.' + CLS_HIDDEN + ' )');
        }
        else {
            clst = sf.base.closest(trgt, '.' + CLS_ITEM);
        }
        return clst;
    };
    SfToolbar.prototype.keyHandling = function (clst, e, trgt, navChk, scrollChk) {
        var popObj = this.popObj;
        var rootEle = this.element;
        var popAnimate = { name: 'FadeOut', duration: 100 };
        var ele;
        var nodes;
        var value;
        switch (e.action) {
            case 'moveRight':
                if (this.options.isVertical) {
                    return;
                }
                if (rootEle === trgt) {
                    this.elementFocus(clst);
                }
                else if (!navChk) {
                    this.eleFocus(clst, 'next');
                }
                break;
            case 'moveLeft':
                if (this.options.isVertical) {
                    return;
                }
                if (!navChk) {
                    this.eleFocus(clst, 'previous');
                }
                break;
            case 'home':
            case 'end':
                if (clst) {
                    var popupCheck = sf.base.closest(clst, '.e-popup');
                    if (popupCheck) {
                        if (sf.base.isVisible(this.popObj.element)) {
                            nodes = [].slice.call(popupCheck.children);
                            if (e.action === 'home') {
                                ele = nodes[0];
                            }
                            else {
                                ele = nodes[nodes.length - 1];
                            }
                        }
                    }
                    else {
                        nodes = this.element.querySelectorAll('.' + CLS_ITEMS + ' .' + CLS_ITEM);
                        if (e.action === 'home') {
                            ele = nodes[0];
                        }
                        else {
                            ele = nodes[nodes.length - 1];
                        }
                    }
                    if (ele) {
                        this.elementFocus(ele);
                    }
                }
                break;
            case 'moveUp':
            case 'moveDown':
                value = e.action === 'moveUp' ? 'previous' : 'next';
                if (!this.options.isVertical) {
                    if (popObj && sf.base.closest(trgt, '.e-popup')) {
                        var popEle = popObj.element;
                        var popFrstEle = popEle.firstElementChild;
                        if ((value === 'previous' && popFrstEle === clst) || (value === 'next' && popEle.lastElementChild === clst)) {
                            return;
                        }
                        else {
                            this.eleFocus(clst, value);
                        }
                    }
                    else if (e.action === 'moveDown' && popObj && sf.base.isVisible(popObj.element)) {
                        this.elementFocus(clst);
                    }
                }
                else {
                    if (e.action === 'moveUp') {
                        this.eleFocus(clst, 'previous');
                    }
                    else {
                        this.eleFocus(clst, 'next');
                    }
                }
                break;
            case 'tab':
                if (!scrollChk && !navChk) {
                    var ele_1 = clst.firstElementChild;
                    if (rootEle === trgt) {
                        if (this.activeEle) {
                            this.activeEle.focus();
                        }
                        else {
                            this.activeEleRemove(ele_1);
                            ele_1.focus();
                        }
                        this.element.removeAttribute('tabindex');
                    }
                }
                break;
            case 'popupClose':
                if (popObj && this.options.overflowMode !== 'Extended') {
                    popObj.hide(popAnimate);
                }
                break;
            case 'popupOpen':
                if (!navChk) {
                    return;
                }
                if (popObj && !sf.base.isVisible(popObj.element)) {
                    popObj.element.style.top = rootEle.offsetHeight + 'px';
                    popObj.show({ name: 'FadeIn', duration: 100 });
                }
                else {
                    popObj.hide(popAnimate);
                }
                break;
        }
    };
    SfToolbar.prototype.keyActionHandler = function (e) {
        var trgt = e.target;
        if (trgt.tagName === 'INPUT' || trgt.tagName === 'TEXTAREA' || this.element.classList.contains(CLS_DISABLE)) {
            return;
        }
        e.preventDefault();
        var tbrNavChk = trgt.classList.contains(CLS_TBARNAV);
        var tbarScrollChk = trgt.classList.contains(CLS_TBARSCRLNAV);
        var clst = this.clstElement(tbrNavChk, trgt);
        if (clst || tbarScrollChk) {
            this.keyHandling(clst, e, trgt, tbrNavChk, tbarScrollChk);
        }
    };
    SfToolbar.prototype.eleContains = function (el) {
        return el.classList.contains(CLS_SEPARATOR) || el.classList.contains(CLS_DISABLE) || el.getAttribute('disabled') || el.classList.contains(CLS_HIDDEN) || !sf.base.isVisible(el);
    };
    SfToolbar.prototype.eleFocus = function (closest$$1, pos) {
        var sib = Object(closest$$1)[pos + 'ElementSibling'];
        if (sib) {
            var skipEle = this.eleContains(sib);
            if (skipEle) {
                this.eleFocus(sib, pos);
                return;
            }
            this.elementFocus(sib);
        }
        else if (this.tbarAlign) {
            var elem = Object(closest$$1.parentElement)[pos + 'ElementSibling'];
            if (!sf.base.isNullOrUndefined(elem) && elem.children.length === 0) {
                elem = Object(elem)[pos + 'ElementSibling'];
            }
            if (!sf.base.isNullOrUndefined(elem) && elem.children.length > 0) {
                if (pos === 'next') {
                    var el = elem.querySelector('.' + CLS_ITEM);
                    if (this.eleContains(el)) {
                        this.eleFocus(el, pos);
                    }
                    else {
                        el.firstElementChild.focus();
                        this.activeEleSwitch(el);
                    }
                }
                else {
                    var el = elem.lastElementChild;
                    if (this.eleContains(el)) {
                        this.eleFocus(el, pos);
                    }
                    else {
                        this.elementFocus(el);
                    }
                }
            }
        }
    };
    SfToolbar.prototype.clickHandler = function (e) {
        if (this.element.classList.contains('e-drag-action')) {
            return;
        }
        var trgt = e.target;
        var clsList = trgt.classList;
        var ele = this.element;
        var isPopupElement = !sf.base.isNullOrUndefined(sf.base.closest(trgt, '.' + CLS_POPUPCLASS));
        var isCloseIcon = clsList.contains(CLS_ICON_CLOSE);
        var popupNav = sf.base.closest(trgt, ('.' + CLS_TBARNAV));
        var trgParentDataIndex;
        var id;
        if (!popupNav) {
            popupNav = trgt;
        }
        if (!ele.children[0].classList.contains('e-hscroll') && !ele.children[0].classList.contains('e-vscroll')
            && (clsList.contains(CLS_TBARNAV))) {
            clsList = trgt.querySelector('.e-icons').classList;
        }
        if (clsList.contains(CLS_POPUPICON) || clsList.contains(CLS_POPUPDOWN)) {
            this.popupClickHandler(ele, popupNav, CLS_RTL);
        }
        var clst = sf.base.closest(e.target, '.' + CLS_ITEM);
        if ((sf.base.isNullOrUndefined(clst) || clst.classList.contains(CLS_DISABLE)) && !popupNav.classList.contains(CLS_TBARNAV)) {
            return;
        }
        if (!sf.base.isNullOrUndefined(clst)) {
            trgParentDataIndex = parseInt(clst.getAttribute('data-index'), 10);
            id = clst.id;
        }
        var tbItem = sf.base.selectAll('.' + CLS_ITEMS + ' .' + CLS_ITEM, this.element);
        this.dotNetRef.invokeMethodAsync('TriggerClickEvent', e, isPopupElement, isCloseIcon, trgParentDataIndex, id, tbItem.length - 1);
    };
    SfToolbar.prototype.popupClickHandler = function (ele, popupNav, CLS_RTL) {
        var popObj = this.popObj;
        if (sf.base.isVisible(popObj.element)) {
            popupNav.classList.remove(CLS_TBARNAVACT);
            popObj.hide({ name: 'FadeOut', duration: 100 });
        }
        else {
            if (ele.classList.contains(CLS_RTL) || this.options.isVerticalLeft) {
                if (ele.classList.contains(CLS_RTL)) {
                    popObj.enableRtl = true;
                }
                popObj.position = { X: 'left', Y: 'top' };
            }
            if (popObj.offsetX === 0 && (!ele.classList.contains(CLS_RTL) && !this.options.isVerticalLeft)) {
                popObj.enableRtl = false;
                popObj.position = { X: 'right', Y: 'top' };
            }
            popObj.dataBind();
            popObj.refreshPosition();
            popObj.element.style.top = this.getElementOffsetY() + 'px';
            if (this.options.overflowMode === 'Extended') {
                popObj.element.style.minHeight = '0px';
            }
            popupNav.classList.add(CLS_TBARNAVACT);
            popObj.show({ name: 'FadeIn', duration: 100 });
        }
    };
    SfToolbar.prototype.render = function () {
        this.scrollModule = null;
        this.popObj = null;
        this.isExtendedOpen = false;
        this.popupPriCount = 0;
        var width = sf.base.formatUnit(this.options.width);
        var height = sf.base.formatUnit(this.options.height);
        if (this.element) {
            if (sf.base.Browser.info.name !== 'msie' || this.options.height !== 'auto') {
                sf.base.setStyleAttribute(this.element, { 'height': height });
            }
            sf.base.setStyleAttribute(this.element, { 'width': width });
            this.element.setAttribute('aria-haspopup', 'false');
            this.renderControl();
            this.wireEvents();
        }
    };
    SfToolbar.prototype.renderControl = function () {
        this.tbarAlgEle = { lefts: [], centers: [], rights: [] };
        this.renderItems();
        this.renderLayout();
    };
    SfToolbar.prototype.renderLayout = function () {
        this.renderOverflowMode();
        if (this.tbarAlign) {
            this.itemPositioning();
        }
        if (this.popObj && this.popObj.element.childElementCount > 1 && this.checkPopupRefresh(this.element, this.popObj.element)) {
            this.popupRefresh(this.popObj.element, false);
        }
        this.separator();
    };
    SfToolbar.prototype.itemsAlign = function (items, itemEleDom, firstRender) {
        var innerItem;
        var innerPos;
        if (!this.tbarEle) {
            this.tbarEle = [];
        }
        for (var i = 0; i < items.length; i++) {
            var itemEleBlaDom = this.element.querySelector('.' + BZ_ITEMS);
            if (this.options.overflowMode === 'MultiRow' && firstRender) {
                innerItem = itemEleDom.querySelector('.' + CLS_ITEM + '[id="' + items[i].id + '"]');
            }
            else {
                innerItem = itemEleBlaDom.querySelector('.' + CLS_ITEM + '[id="' + items[i].id + '"]');
            }
            if (!innerItem) {
                continue;
            }
            if (items[i].overflow !== 'Show' && items[i].showAlwaysInPopup && !innerItem.classList.contains(CLS_SEPARATOR)) {
                this.popupPriCount++;
            }
            if (items[i].htmlAttributes) {
                this.setAttr(items[i].htmlAttributes, innerItem);
            }
            if (items[i].type === 'Button') {
                sf.base.EventHandler.remove(innerItem, 'click', this.itemClick);
                sf.base.EventHandler.add(innerItem, 'click', this.itemClick, this);
            }
            if (this.tbarEle.indexOf(innerItem) === -1) {
                this.tbarEle.push(innerItem);
            }
            if (this.options.overflowMode === 'MultiRow' && firstRender) {
                continue;
            }
            if (!this.tbarAlign) {
                this.tbarItemAlign(items[i], itemEleDom, i);
            }
            innerPos = itemEleDom.querySelector('.e-toolbar-' + items[i].align.toLowerCase());
            if (innerPos) {
                if (!(items[i].showAlwaysInPopup && items[i].overflow !== 'Show')) {
                    this.tbarAlgEle[(items[i].align + 's').toLowerCase()].push(innerItem);
                }
                innerPos.appendChild(innerItem);
            }
            else {
                itemEleDom.appendChild(innerItem);
            }
        }
    };
    SfToolbar.prototype.serverItemsRefresh = function (firstRender) {
        var ele = this.element;
        var wrapBlaEleDom = ele.querySelector('.' + BZ_ITEMS);
        var itemEleDom = ele.querySelector('.' + CLS_ITEMS);
        if ((itemEleDom && itemEleDom.children.length > 0) || wrapBlaEleDom.children.length > 0) {
            if (!itemEleDom && ele && ele.classList.contains(CLS_TOOLBAR) && ele.firstElementChild) {
                itemEleDom = sf.base.createElement('div', { className: CLS_ITEMS });
                ele.insertBefore(itemEleDom, ele.firstElementChild);
            }
            this.itemsAlign(this.options.items, itemEleDom, firstRender);
            this.renderLayout();
            this.refreshOverflow();
        }
    };
    SfToolbar.prototype.resetServerItems = function (firstRender) {
        if (this.options.overflowMode === 'MultiRow' && firstRender) {
            return;
        }
        var wrapBlaEleDom = this.element.querySelector('.' + BZ_ITEMS);
        var itemEles = [].slice.call(sf.base.selectAll('.' + CLS_ITEMS + ' .' + CLS_ITEM, this.element));
        sf.base.append(itemEles, wrapBlaEleDom);
        this.clearProperty();
    };
    SfToolbar.prototype.changeOrientation = function () {
        if (!this.options.isVertical) {
            this.element.classList.remove(CLS_VERTICAL);
            this.element.setAttribute('aria-orientation', 'horizontal');
            if (this.options.height === 'auto' || this.options.height === '100%') {
                this.element.style.height = this.options.height;
            }
        }
        else {
            this.element.classList.add(CLS_VERTICAL);
            this.element.setAttribute('aria-orientation', 'vertical');
            sf.base.setStyleAttribute(this.element, { 'height': sf.base.formatUnit(this.options.height), 'width': sf.base.formatUnit(this.options.width) });
        }
        this.destroyMode();
        this.refreshOverflow();
    };
    SfToolbar.prototype.initScroll = function (element, innerItems) {
        if (!this.scrollModule && this.checkOverflow(element, innerItems[0])) {
            if (this.tbarAlign) {
                this.element.querySelector('.' + CLS_ITEMS + ' .' + CLS_TBARCENTER).removeAttribute('style');
            }
            if (this.options.isVertical) {
                // eslint-disable-next-line max-len
                this.scrollModule = new sf.navigations.VScroll({ scrollStep: this.options.scrollStep, enableRtl: this.options.enableRtl }, innerItems[0]);
            }
            else {
                // eslint-disable-next-line max-len
                this.scrollModule = new sf.navigations.HScroll({ scrollStep: this.options.scrollStep, enableRtl: this.options.enableRtl }, innerItems[0]);
            }
            sf.base.removeClass([this.scrollModule.element], CLS_TBARPOS);
            sf.base.setStyleAttribute(this.element, { overflow: 'hidden' });
        }
    };
    SfToolbar.prototype.itemWidthCal = function (items) {
        var _this = this;
        var width = 0;
        var style;
        [].slice.call(sf.base.selectAll('.' + CLS_ITEM, items)).forEach(function (el) {
            if (sf.base.isVisible(el)) {
                style = window.getComputedStyle(el);
                width += _this.options.isVertical ? el.offsetHeight : el.offsetWidth;
                width += parseFloat(_this.options.isVertical ? style.marginTop : style.marginRight);
                width += parseFloat(_this.options.isVertical ? style.marginBottom : style.marginLeft);
            }
        });
        return width;
    };
    SfToolbar.prototype.getScrollCntEle = function (innerItem) {
        var trgClass = (this.options.isVertical) ? '.e-vscroll-content' : '.e-hscroll-content';
        return innerItem.querySelector(trgClass);
    };
    SfToolbar.prototype.checkOverflow = function (element, innerItem) {
        if (sf.base.isNullOrUndefined(element) || sf.base.isNullOrUndefined(innerItem) || !sf.base.isVisible(element)) {
            return false;
        }
        var eleWidth = this.options.isVertical ? element.offsetHeight : element.offsetWidth;
        var itemWidth = this.options.isVertical ? innerItem.offsetHeight : innerItem.offsetWidth;
        if (this.tbarAlign || this.scrollModule || (eleWidth === itemWidth)) {
            itemWidth = this.itemWidthCal(this.scrollModule ? this.getScrollCntEle(innerItem) : innerItem);
        }
        var popNav = element.querySelector('.' + CLS_TBARNAV);
        var scrollNav = element.querySelector('.' + CLS_TBARSCRLNAV);
        var navEleWidth = 0;
        if (popNav) {
            navEleWidth = this.options.isVertical ? popNav.offsetHeight : popNav.offsetWidth;
        }
        else if (scrollNav) {
            navEleWidth = this.options.isVertical ? (scrollNav.offsetHeight * (2)) : (scrollNav.offsetWidth * 2);
        }
        if (itemWidth > eleWidth - navEleWidth) {
            return true;
        }
        else {
            return false;
        }
    };
    SfToolbar.prototype.refreshOverflow = function () {
        this.resize();
    };
    SfToolbar.prototype.toolbarAlign = function (innerItems) {
        if (this.tbarAlign) {
            sf.base.addClass([innerItems], CLS_TBARPOS);
            this.itemPositioning();
        }
    };
    SfToolbar.prototype.renderOverflowMode = function () {
        var ele = this.element;
        var innerItems = ele.querySelector('.' + CLS_ITEMS);
        var priorityCheck = this.popupPriCount > 0;
        if (ele && ele.children.length > 0) {
            this.offsetWid = ele.offsetWidth;
            sf.base.removeClass([this.element], 'e-toolpop');
            if (sf.base.Browser.info.name === 'msie' && this.options.height === 'auto') {
                ele.style.height = '';
            }
            switch (this.options.overflowMode) {
                case 'Scrollable':
                    if (sf.base.isNullOrUndefined(this.scrollModule)) {
                        this.initScroll(ele, [].slice.call(ele.getElementsByClassName(CLS_ITEMS)));
                    }
                    break;
                case 'Popup':
                    sf.base.addClass([this.element], 'e-toolpop');
                    if (this.tbarAlign) {
                        this.removePositioning();
                    }
                    if (this.checkOverflow(ele, innerItems) || priorityCheck) {
                        this.setOverflowAttributes(ele);
                    }
                    this.toolbarAlign(innerItems);
                    break;
                case 'MultiRow':
                    sf.base.addClass([innerItems], CLS_MULTIROW);
                    if (this.checkOverflow(ele, innerItems) && this.tbarAlign) {
                        this.removePositioning();
                        sf.base.addClass([innerItems], CLS_MULTIROWPOS);
                    }
                    if (ele.style.overflow === 'hidden') {
                        ele.style.overflow = '';
                    }
                    if (sf.base.Browser.info.name === 'msie' || ele.style.height !== 'auto') {
                        ele.style.height = 'auto';
                    }
                    break;
                case 'Extended':
                    sf.base.addClass([this.element], CLS_EXTEANDABLE_TOOLBAR);
                    if (this.checkOverflow(ele, innerItems) || priorityCheck) {
                        if (this.tbarAlign) {
                            this.removePositioning();
                        }
                        this.setOverflowAttributes(ele);
                    }
                    this.toolbarAlign(innerItems);
            }
        }
    };
    SfToolbar.prototype.setOverflowAttributes = function (ele) {
        this.createPopupEle(ele, [].slice.call(sf.base.selectAll('.' + CLS_ITEMS + ' .' + CLS_ITEM, ele)));
        this.element.querySelector('.' + CLS_TBARNAV).setAttribute('tabIndex', '0');
        this.element.querySelector('.' + CLS_TBARNAV).setAttribute('role', 'list');
    };
    SfToolbar.prototype.separator = function () {
        var element = this.element;
        var eleItem = [].slice.call(element.querySelectorAll('.' + CLS_SEPARATOR));
        var multiVar = element.querySelector('.' + CLS_MULTIROW_SEPARATOR);
        var extendVar = element.querySelector('.' + CLS_EXTENDABLE_SEPARATOR);
        var eleInlineItem = this.options.overflowMode === 'MultiRow' ? multiVar : extendVar;
        if (eleInlineItem !== null) {
            if (this.options.overflowMode === 'MultiRow') {
                eleInlineItem.classList.remove(CLS_MULTIROW_SEPARATOR);
            }
            else if (this.options.overflowMode === 'Extended') {
                eleInlineItem.classList.remove(CLS_EXTENDABLE_SEPARATOR);
            }
        }
        for (var i = 0; i <= eleItem.length - 1; i++) {
            if (eleItem[i].offsetLeft < 30 && eleItem[i].offsetLeft !== 0) {
                if (this.options.overflowMode === 'MultiRow') {
                    eleItem[i].classList.add(CLS_MULTIROW_SEPARATOR);
                }
                else if (this.options.overflowMode === 'Extended') {
                    eleItem[i].classList.add(CLS_EXTENDABLE_SEPARATOR);
                }
            }
        }
    };
    SfToolbar.prototype.createPopupEle = function (ele, innerEle) {
        var innerNav = ele.querySelector('.' + CLS_TBARNAV);
        var vertical = this.options.isVertical;
        if (!innerNav) {
            this.createPopupIcon(ele);
        }
        innerNav = ele.querySelector('.' + CLS_TBARNAV);
        var innerNavDom = (vertical ? innerNav.offsetHeight : innerNav.offsetWidth);
        var eleWidth = ((vertical ? ele.offsetHeight : ele.offsetWidth) - (innerNavDom));
        this.element.classList.remove('e-rtl');
        sf.base.setStyleAttribute(this.element, { direction: 'initial' });
        this.checkPriority(ele, innerEle, eleWidth, true);
        if (this.options.enableRtl) {
            this.element.classList.add('e-rtl');
        }
        this.element.style.removeProperty('direction');
        this.createPopup();
    };
    SfToolbar.prototype.pushingPoppedEle = function (tbarObj, popupPri, ele, eleHeight, sepHeight) {
        var element = this.element;
        var nodes = sf.base.selectAll('.' + CLS_TBAROVERFLOW, ele);
        var nodeIndex = 0;
        var poppedEle = [].slice.call(sf.base.selectAll('.' + CLS_POPUP, element.querySelector('.' + CLS_ITEMS)));
        var nodePri = 0;
        poppedEle.forEach(function (el, index) {
            nodes = sf.base.selectAll('.' + CLS_TBAROVERFLOW, ele);
            if (el.classList.contains(CLS_TBAROVERFLOW) && nodes.length > 0) {
                if (tbarObj.tbResize && nodes.length > index) {
                    ele.insertBefore(el, nodes[index]);
                    ++nodePri;
                }
                else {
                    ele.insertBefore(el, ele.children[nodes.length]);
                    ++nodePri;
                }
            }
            else if (el.classList.contains(CLS_TBAROVERFLOW)) {
                ele.insertBefore(el, ele.firstChild);
                ++nodePri;
            }
            else if (tbarObj.tbResize && el.classList.contains(CLS_POPOVERFLOW) && ele.children.length > 0 && nodes.length === 0) {
                ele.insertBefore(el, ele.firstChild);
                ++nodePri;
            }
            else if (el.classList.contains(CLS_POPOVERFLOW)) {
                popupPri.push(el);
            }
            else if (tbarObj.tbResize) {
                ele.insertBefore(el, ele.childNodes[nodeIndex + nodePri]);
                ++nodeIndex;
            }
            else {
                ele.appendChild(el);
            }
            if (el.classList.contains(CLS_SEPARATOR)) {
                sf.base.setStyleAttribute(el, { display: '', height: sepHeight + 'px' });
            }
            else {
                sf.base.setStyleAttribute(el, { display: '', height: eleHeight + 'px' });
            }
        });
        popupPri.forEach(function (el) {
            ele.appendChild(el);
        });
        var tbarEle = sf.base.selectAll('.' + CLS_ITEM, element.querySelector('.' + CLS_ITEMS));
        for (var i = tbarEle.length - 1; i >= 0; i--) {
            var tbarElement = tbarEle[i];
            if (tbarElement.classList.contains(CLS_SEPARATOR) && this.options.overflowMode !== 'Extended') {
                sf.base.setStyleAttribute(tbarElement, { display: 'none' });
            }
            else {
                break;
            }
        }
    };
    SfToolbar.prototype.createPopup = function () {
        var element = this.element;
        var sepHeight;
        var sepItem;
        if (this.options.overflowMode === 'Extended') {
            sepItem = element.querySelector('.' + CLS_SEPARATOR + ':not(.' + CLS_POPUP + ')');
            sepHeight = (element.style.height === 'auto' || element.style.height === '') ? null : (sepItem && sepItem.offsetHeight);
        }
        // eslint-disable-next-line max-len
        var eleItem = element.querySelector('.' + CLS_ITEM + ':not(.' + CLS_SEPARATOR + '):not(.' + CLS_POPUP + '):not(.' + CLS_HIDDEN + ')');
        var eleHeight = (element.style.height === 'auto' || element.style.height === '') ? null : (eleItem && eleItem.offsetHeight);
        var ele;
        var popupPri = [];
        if (element.querySelector('#' + element.id + '_popup.' + CLS_POPUPCLASS)) {
            ele = element.querySelector('#' + element.id + '_popup.' + CLS_POPUPCLASS);
        }
        else {
            var extendEle = sf.base.createElement('div', {
                id: element.id + '_popup', className: CLS_POPUPCLASS + ' ' + CLS_EXTENDABLECLASS
            });
            var popupEle = sf.base.createElement('div', { id: element.id + '_popup', className: CLS_POPUPCLASS });
            ele = this.options.overflowMode === 'Extended' ? extendEle : popupEle;
        }
        this.pushingPoppedEle(this, popupPri, ele, eleHeight, sepHeight);
        this.popupInit(element, ele);
    };
    SfToolbar.prototype.getElementOffsetY = function () {
        return (this.options.overflowMode === 'Extended' && window.getComputedStyle(this.element).getPropertyValue('box-sizing') === 'border-box' ?
            this.element.clientHeight : this.element.offsetHeight);
    };
    SfToolbar.prototype.popupInit = function (element, ele) {
        if (!this.popObj) {
            element.appendChild(ele);
            sf.base.setStyleAttribute(this.element, { overflow: '' });
            var eleStyles = window.getComputedStyle(this.element);
            var popup = new sf.popups.Popup(null, {
                relateTo: this.element,
                offsetY: (this.options.isVertical) ? 0 : this.getElementOffsetY(),
                enableRtl: this.options.enableRtl,
                open: this.popupOpen.bind(this),
                close: this.popupClose.bind(this),
                collision: { Y: this.options.enableCollision ? 'flip' : 'none' },
                position: this.options.enableRtl ? { X: 'left', Y: 'top' } : { X: 'right', Y: 'top' }
            });
            popup.appendTo(ele);
            if (this.options.overflowMode === 'Extended') {
                popup.width = parseFloat(eleStyles.width) + ((parseFloat(eleStyles.borderRightWidth)) * 2);
                popup.offsetX = 0;
            }
            sf.base.EventHandler.add(document, 'scroll', this.docEvent.bind(this));
            sf.base.EventHandler.add(document, 'click ', this.docEvent.bind(this));
            popup.element.style.maxHeight = popup.element.offsetHeight + 'px';
            if (this.options.isVertical) {
                popup.element.style.visibility = 'hidden';
            }
            if (this.isExtendedOpen) {
                var popupNav = this.element.querySelector('.' + CLS_TBARNAV);
                popupNav.classList.add(CLS_TBARNAVACT);
                sf.base.classList(popupNav.firstElementChild, [CLS_POPUPICON], [CLS_POPUPDOWN]);
                this.element.querySelector('.' + CLS_EXTENDABLECLASS).classList.add(CLS_POPUPOPEN);
            }
            else {
                popup.hide();
            }
            this.popObj = popup;
            this.element.setAttribute('aria-haspopup', 'true');
        }
        else {
            var popupEle = this.popObj.element;
            if (this.options.overflowMode === 'Extended') {
                var eleStyle = window.getComputedStyle(this.element);
                this.popObj.width = parseFloat(eleStyle.width) + ((parseFloat(eleStyle.borderRightWidth)) * 2);
                this.popObj.offsetX = 0;
                this.popObj.dataBind();
            }
            sf.base.setStyleAttribute(popupEle, { maxHeight: '', display: 'block' });
            sf.base.setStyleAttribute(popupEle, { maxHeight: popupEle.offsetHeight + 'px', display: '' });
        }
    };
    SfToolbar.prototype.tbarPopupHandler = function (isOpen) {
        if (this.options.overflowMode === 'Extended') {
            if (isOpen) {
                sf.base.addClass([this.element], CLS_EXTENDEDPOPOPEN);
            }
            else {
                sf.base.removeClass([this.element], CLS_EXTENDEDPOPOPEN);
            }
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    SfToolbar.prototype.popupOpen = function (e) {
        var popObj = this.popObj;
        if (!this.options.isVertical) {
            popObj.offsetY = this.getElementOffsetY();
            popObj.dataBind();
        }
        var popupEle = this.popObj.element;
        var toolEle = this.popObj.element.parentElement;
        var popupNav = toolEle.querySelector('.' + CLS_TBARNAV);
        sf.base.setStyleAttribute(popObj.element, { height: 'auto', maxHeight: '' });
        popObj.element.style.maxHeight = popObj.element.offsetHeight + 'px';
        if (this.options.overflowMode === 'Extended') {
            popObj.element.style.minHeight = '';
        }
        var popupElePos = popupEle.offsetTop + popupEle.offsetHeight + sf.popups.calculatePosition(toolEle).top;
        var popIcon = popupNav.firstElementChild;
        popupNav.classList.add(CLS_TBARNAVACT);
        sf.base.classList(popIcon, [CLS_POPUPICON], [CLS_POPUPDOWN]);
        this.tbarPopupHandler(true);
        var scrollVal = sf.base.isNullOrUndefined(window.scrollY) ? 0 : window.scrollY;
        // eslint-disable-next-line max-len
        if (!this.options.isVertical && ((window.innerHeight + scrollVal) < popupElePos) && (this.element.offsetTop < popupEle.offsetHeight)) {
            var overflowHeight = (popupEle.offsetHeight - ((popupElePos - window.innerHeight - scrollVal) + 5));
            popObj.height = overflowHeight + 'px';
            for (var i = 0; i <= popupEle.childElementCount; i++) {
                var ele = popupEle.children[i];
                if (ele.offsetTop + ele.offsetHeight > overflowHeight) {
                    overflowHeight = ele.offsetTop;
                    break;
                }
            }
            sf.base.setStyleAttribute(popObj.element, { maxHeight: overflowHeight + 'px' });
        }
        else if (this.options.isVertical) {
            var tbEleData = this.element.getBoundingClientRect();
            sf.base.setStyleAttribute(popObj.element, { maxHeight: (tbEleData.top + this.element.offsetHeight) + 'px', bottom: 0, visibility: '' });
        }
        if (popObj) {
            var popupOffset = popupEle.getBoundingClientRect();
            if (popupOffset.right > document.documentElement.clientWidth && popupOffset.width > toolEle.getBoundingClientRect().width) {
                popObj.collision = { Y: 'none' };
                popObj.dataBind();
            }
            popObj.refreshPosition();
        }
    };
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    SfToolbar.prototype.popupClose = function (e) {
        var element = this.element;
        var popupNav = element.querySelector('.' + CLS_TBARNAV);
        var popIcon = popupNav.firstElementChild;
        popupNav.classList.remove(CLS_TBARNAVACT);
        sf.base.classList(popIcon, [CLS_POPUPDOWN], [CLS_POPUPICON]);
        this.tbarPopupHandler(false);
    };
    SfToolbar.prototype.checkPriority = function (ele, inEle, eleWidth, pre) {
        var popPriority = this.popupPriCount > 0;
        var len = inEle.length;
        var eleWid = eleWidth;
        var eleOffset;
        var checkoffset;
        var sepCheck = 0;
        var itemCount = 0;
        var itemPopCount = 0;
        // eslint-disable-next-line @typescript-eslint/ban-types
        var checkClass = function (ele, val) {
            var rVal = false;
            val.forEach(function (cls) {
                if (ele.classList.contains(cls)) {
                    rVal = true;
                }
            });
            return rVal;
        };
        for (var i = len - 1; i >= 0; i--) {
            var mrgn = void 0;
            var compuStyle = window.getComputedStyle(inEle[i]);
            if (this.options.isVertical) {
                mrgn = parseFloat((compuStyle).marginTop);
                mrgn += parseFloat((compuStyle).marginBottom);
            }
            else {
                mrgn = parseFloat((compuStyle).marginRight);
                mrgn += parseFloat((compuStyle).marginLeft);
            }
            var fstEleCheck = inEle[i] === this.tbarEle[0];
            if (fstEleCheck) {
                this.tbarEleMrgn = mrgn;
            }
            eleOffset = this.options.isVertical ? inEle[i].offsetHeight : inEle[i].offsetWidth;
            var eleWid_1 = fstEleCheck ? (eleOffset + mrgn) : eleOffset;
            if (checkClass(inEle[i], [CLS_POPPRI]) && popPriority) {
                inEle[i].classList.add(CLS_POPUP);
                if (this.options.isVertical) {
                    sf.base.setStyleAttribute(inEle[i], { display: 'none', minHeight: eleWid_1 + 'px' });
                }
                else {
                    sf.base.setStyleAttribute(inEle[i], { display: 'none', minWidth: eleWid_1 + 'px' });
                }
                itemPopCount++;
            }
            if (this.options.isVertical) {
                checkoffset = (inEle[i].offsetTop + inEle[i].offsetHeight + mrgn) > eleWidth;
            }
            else {
                checkoffset = (inEle[i].offsetLeft + inEle[i].offsetWidth + mrgn) > eleWidth;
            }
            if (checkoffset) {
                if (inEle[i].classList.contains(CLS_SEPARATOR)) {
                    if (this.options.overflowMode === 'Extended') {
                        if (itemCount === itemPopCount) {
                            var sepEle = inEle[i];
                            if (checkClass(sepEle, [CLS_SEPARATOR, CLS_TBARIGNORE])) {
                                inEle[i].classList.add(CLS_POPUP);
                                itemPopCount++;
                            }
                        }
                        itemCount++;
                    }
                    else if (this.options.overflowMode === 'Popup') {
                        if (sepCheck > 0 && itemCount === itemPopCount) {
                            var sepEle = inEle[i + itemCount + (sepCheck - 1)];
                            if (checkClass(sepEle, [CLS_SEPARATOR, CLS_TBARIGNORE])) {
                                sf.base.setStyleAttribute(sepEle, { display: 'none' });
                            }
                        }
                        sepCheck++;
                        itemCount = 0;
                        itemPopCount = 0;
                    }
                }
                else {
                    itemCount++;
                }
                if (inEle[i].classList.contains(CLS_TBAROVERFLOW) && pre) {
                    eleWidth -= ((this.options.isVertical ? inEle[i].offsetHeight : inEle[i].offsetWidth) + (mrgn));
                }
                else if (!checkClass(inEle[i], [CLS_SEPARATOR, CLS_TBARIGNORE])) {
                    inEle[i].classList.add(CLS_POPUP);
                    if (this.options.isVertical) {
                        sf.base.setStyleAttribute(inEle[i], { display: 'none', minHeight: eleWid_1 + 'px' });
                    }
                    else {
                        sf.base.setStyleAttribute(inEle[i], { display: 'none', minWidth: eleWid_1 + 'px' });
                    }
                    itemPopCount++;
                }
                else {
                    eleWidth -= ((this.options.isVertical ? inEle[i].offsetHeight : inEle[i].offsetWidth) + (mrgn));
                }
            }
        }
        if (pre) {
            var popedEle = sf.base.selectAll('.' + CLS_ITEM + ':not(.' + CLS_POPUP + ')', this.element);
            this.checkPriority(ele, popedEle, eleWid, false);
        }
    };
    SfToolbar.prototype.createPopupIcon = function (element) {
        var id = element.id.concat('_nav');
        var className = 'e-' + element.id.concat('_nav ' + CLS_POPUPNAV);
        className = this.options.overflowMode === 'Extended' ? className + ' ' + CLS_EXTENDPOPUP : className;
        var nav = sf.base.createElement('div', { id: id, className: className });
        if (sf.base.Browser.info.name === 'msie' || sf.base.Browser.info.name === 'edge') {
            nav.classList.add('e-ie-align');
        }
        var navItem = sf.base.createElement('div', { className: CLS_POPUPDOWN + ' e-icons' });
        nav.appendChild(navItem);
        nav.setAttribute('tabindex', '0');
        nav.setAttribute('role', 'list');
        element.appendChild(nav);
    };
    SfToolbar.prototype.tbarPriRef = function (inEle, indx, sepPri, el, des, elWid, wid, ig) {
        var ignoreCount = ig;
        var popEle = this.popObj.element;
        var query = '.' + CLS_ITEM + ':not(.' + CLS_SEPARATOR + '):not(.' + CLS_TBAROVERFLOW + ')';
        var priEleCnt = sf.base.selectAll('.' + CLS_POPUP + ':not(.' + CLS_TBAROVERFLOW + ')', popEle).length;
        // eslint-disable-next-line @typescript-eslint/ban-types
        var checkClass = function (ele, val) {
            return ele.classList.contains(val);
        };
        if (sf.base.selectAll(query, inEle).length === 0) {
            var eleSep = inEle.children[indx - (indx - sepPri) - 1];
            var ignoreCheck = (!sf.base.isNullOrUndefined(eleSep) && checkClass(eleSep, CLS_TBARIGNORE));
            if ((!sf.base.isNullOrUndefined(eleSep) && checkClass(eleSep, CLS_SEPARATOR) && !sf.base.isVisible(eleSep)) || ignoreCheck) {
                var sepDisplay = 'none';
                eleSep.style.display = 'inherit';
                var eleSepWidth = eleSep.offsetWidth + (parseFloat(window.getComputedStyle(eleSep).marginRight) * 2);
                var prevSep = eleSep.previousElementSibling;
                if ((elWid + eleSepWidth) < wid || des) {
                    inEle.insertBefore(el, inEle.children[(indx + ignoreCount) - (indx - sepPri)]);
                    if (!sf.base.isNullOrUndefined(prevSep)) {
                        prevSep.style.display = '';
                    }
                }
                else {
                    if (prevSep.classList.contains(CLS_SEPARATOR)) {
                        prevSep.style.display = sepDisplay;
                    }
                }
                eleSep.style.display = '';
            }
            else {
                inEle.insertBefore(el, inEle.children[(indx + ignoreCount) - (indx - sepPri)]);
            }
        }
        else {
            inEle.insertBefore(el, inEle.children[(indx + ignoreCount) - priEleCnt]);
        }
    };
    SfToolbar.prototype.popupRefresh = function (popupEle, destroy) {
        var _this = this;
        var ele = this.element;
        var isVer = this.options.isVertical;
        var popNav = ele.querySelector('.' + CLS_TBARNAV);
        var innerEle = ele.querySelector('.' + CLS_ITEMS);
        if (sf.base.isNullOrUndefined(popNav) || sf.base.isNullOrUndefined(innerEle)) {
            return;
        }
        innerEle.removeAttribute('style');
        popupEle.style.display = 'block';
        var dimension;
        if (isVer) {
            dimension = ele.offsetHeight - (popNav.offsetHeight + innerEle.offsetHeight);
        }
        else {
            dimension = ele.offsetWidth - (popNav.offsetWidth + innerEle.offsetWidth);
        }
        var popupEleWidth = 0;
        [].slice.call(popupEle.children).forEach(function (el) {
            popupEleWidth += _this.popupEleWidth(el);
            sf.base.setStyleAttribute(el, { 'position': '' });
        });
        if ((dimension + (isVer ? popNav.offsetHeight : popNav.offsetWidth)) > (popupEleWidth) && this.popupPriCount === 0) {
            destroy = true;
        }
        this.popupEleRefresh(dimension, popupEle, destroy);
        popupEle.style.display = '';
        if (popupEle.children.length === 0 && popNav && this.popObj) {
            sf.base.detach(popNav);
            popNav = null;
            this.popObj.destroy();
            sf.base.detach(this.popObj.element);
            this.popObj = null;
            ele.setAttribute('aria-haspopup', 'false');
        }
    };
    SfToolbar.prototype.ignoreEleFetch = function (index, innerEle) {
        var ignoreEle = [].slice.call(innerEle.querySelectorAll('.' + CLS_TBARIGNORE));
        var ignoreInx = [];
        var count = 0;
        if (ignoreEle.length > 0) {
            ignoreEle.forEach(function (ele) {
                ignoreInx.push([].slice.call(innerEle.children).indexOf(ele));
            });
        }
        else {
            return 0;
        }
        ignoreInx.forEach(function (val) {
            if (val <= index) {
                count++;
            }
        });
        return count;
    };
    SfToolbar.prototype.checkPopupRefresh = function (root, popEle) {
        popEle.style.display = 'block';
        var elWid = this.popupEleWidth(popEle.firstElementChild);
        popEle.firstElementChild.style.removeProperty('Position');
        var tbarWidth = root.offsetWidth - root.querySelector('.' + CLS_TBARNAV).offsetWidth;
        var tbarItemsWid = root.querySelector('.' + CLS_ITEMS).offsetWidth;
        popEle.style.removeProperty('display');
        if (tbarWidth > (elWid + tbarItemsWid)) {
            return true;
        }
        return false;
    };
    SfToolbar.prototype.popupEleWidth = function (el) {
        el.style.position = 'absolute';
        var elWidth = this.options.isVertical ? el.offsetHeight : el.offsetWidth;
        var btnText = el.querySelector('.' + CLS_TBARBTNTEXT);
        if (el.classList.contains('e-tbtn-align') || el.classList.contains(CLS_TBARTEXT)) {
            var btn = el.children[0];
            if (!sf.base.isNullOrUndefined(btnText) && el.classList.contains(CLS_TBARTEXT)) {
                btnText.style.display = 'none';
            }
            else if (!sf.base.isNullOrUndefined(btnText) && el.classList.contains(CLS_POPUPTEXT)) {
                btnText.style.display = 'block';
            }
            btn.style.minWidth = '0%';
            elWidth = parseFloat(!this.options.isVertical ? el.style.minWidth : el.style.minHeight);
            btn.style.minWidth = '';
            btn.style.minHeight = '';
            if (!sf.base.isNullOrUndefined(btnText)) {
                btnText.style.display = '';
            }
        }
        return elWidth;
    };
    SfToolbar.prototype.popupEleRefresh = function (width, popupEle, destroy) {
        var popPriority = this.popupPriCount > 0;
        var eleSplice = this.tbarEle;
        var priEleCnt;
        var index;
        var innerEle = this.element.querySelector('.' + CLS_ITEMS);
        var ignoreCount = 0;
        var _loop_1 = function (el) {
            if (el.classList.contains(CLS_POPPRI) && popPriority && !destroy) {
                return "continue";
            }
            var elWidth = this_1.popupEleWidth(el);
            if (el === this_1.tbarEle[0]) {
                elWidth += this_1.tbarEleMrgn;
            }
            el.style.position = '';
            if (elWidth < width || destroy) {
                sf.base.setStyleAttribute(el, { minWidth: '', height: '', minHeight: '' });
                if (!el.classList.contains(CLS_POPOVERFLOW)) {
                    el.classList.remove(CLS_POPUP);
                }
                index = this_1.tbarEle.indexOf(el);
                if (this_1.tbarAlign) {
                    var pos = this_1.options.items[index].align;
                    index = this_1.tbarAlgEle[(pos + 's').toLowerCase()].indexOf(el);
                    eleSplice = this_1.tbarAlgEle[(pos + 's').toLowerCase()];
                    innerEle = this_1.element.querySelector('.' + CLS_ITEMS + ' .' + 'e-toolbar-' + pos.toLowerCase());
                }
                var sepBeforePri_1 = 0;
                if (this_1.options.overflowMode !== 'Extended') {
                    eleSplice.slice(0, index).forEach(function (el) {
                        if (el.classList.contains(CLS_TBAROVERFLOW) || el.classList.contains(CLS_SEPARATOR)) {
                            if (el.classList.contains(CLS_SEPARATOR)) {
                                el.style.display = '';
                                width -= el.offsetWidth;
                            }
                            sepBeforePri_1++;
                        }
                    });
                }
                ignoreCount = this_1.ignoreEleFetch(index, innerEle);
                if (el.classList.contains(CLS_TBAROVERFLOW)) {
                    this_1.tbarPriRef(innerEle, index, sepBeforePri_1, el, destroy, elWidth, width, ignoreCount);
                    width -= el.offsetWidth;
                }
                else if (index === 0) {
                    innerEle.insertBefore(el, innerEle.firstChild);
                    width -= el.offsetWidth;
                }
                else {
                    priEleCnt = sf.base.selectAll('.' + CLS_TBAROVERFLOW, this_1.popObj.element).length;
                    innerEle.insertBefore(el, innerEle.children[(index + ignoreCount) - priEleCnt]);
                    width -= el.offsetWidth;
                }
                el.style.height = '';
            }
            else {
                return "break";
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = [].slice.call(popupEle.children); _i < _a.length; _i++) {
            var el = _a[_i];
            var state_1 = _loop_1(el);
            if (state_1 === "break")
                break;
        }
        var checkOverflow = this.checkOverflow(this.element, this.element.getElementsByClassName(CLS_ITEMS)[0]);
        if (checkOverflow && !destroy) {
            this.renderOverflowMode();
        }
    };
    SfToolbar.prototype.removePositioning = function () {
        var item = this.element.querySelector('.' + CLS_ITEMS);
        if (sf.base.isNullOrUndefined(item) || !item.classList.contains(CLS_TBARPOS)) {
            return;
        }
        sf.base.removeClass([item], CLS_TBARPOS);
        var innerItem = [].slice.call(item.childNodes);
        innerItem[1].removeAttribute('style');
        innerItem[2].removeAttribute('style');
    };
    SfToolbar.prototype.refreshPositioning = function () {
        var item = this.element.querySelector('.' + CLS_ITEMS);
        sf.base.addClass([item], CLS_TBARPOS);
        this.itemPositioning();
    };
    SfToolbar.prototype.itemPositioning = function () {
        var item = this.element.querySelector('.' + CLS_ITEMS);
        var margin;
        if (sf.base.isNullOrUndefined(item) || !item.classList.contains(CLS_TBARPOS)) {
            return;
        }
        var popupNav = this.element.querySelector('.' + CLS_TBARNAV);
        var innerItem;
        if (this.scrollModule) {
            var trgClass = (this.options.isVertical) ? CLS_VSCROLLCNT : CLS_HSCROLLCNT;
            innerItem = [].slice.call(item.querySelector('.' + trgClass).children);
        }
        else {
            innerItem = [].slice.call(item.childNodes);
        }
        if (this.options.isVertical) {
            margin = innerItem[0].offsetHeight + innerItem[2].offsetHeight;
        }
        else {
            margin = innerItem[0].offsetWidth + innerItem[2].offsetWidth;
        }
        var tbarWid = this.options.isVertical ? this.element.offsetHeight : this.element.offsetWidth;
        if (popupNav) {
            tbarWid -= (this.options.isVertical ? popupNav.offsetHeight : popupNav.offsetWidth);
            var popWid = (this.options.isVertical ? popupNav.offsetHeight : popupNav.offsetWidth) + 'px';
            innerItem[2].removeAttribute('style');
            if (this.options.isVertical) {
                if (this.options.enableRtl) {
                    innerItem[2].style.top = popWid;
                }
                else {
                    innerItem[2].style.bottom = popWid;
                }
            }
            else {
                if (this.options.enableRtl) {
                    innerItem[2].style.left = popWid;
                }
                else {
                    innerItem[2].style.right = popWid;
                }
            }
        }
        if (tbarWid <= margin) {
            return;
        }
        // eslint-disable-next-line max-len
        var value = (((tbarWid - margin)) - (!this.options.isVertical ? innerItem[1].offsetWidth : innerItem[1].offsetHeight)) / 2;
        innerItem[1].removeAttribute('style');
        var mrgn = ((!this.options.isVertical ? innerItem[0].offsetWidth : innerItem[0].offsetHeight) + value) + 'px';
        if (this.options.isVertical) {
            if (this.options.enableRtl) {
                innerItem[1].style.marginBottom = mrgn;
            }
            else {
                innerItem[1].style.marginTop = mrgn;
            }
        }
        else {
            if (this.options.enableRtl) {
                innerItem[1].style.marginRight = mrgn;
            }
            else {
                innerItem[1].style.marginLeft = mrgn;
            }
        }
    };
    SfToolbar.prototype.tbarItemAlign = function (item, itemEle, pos) {
        var _this = this;
        if (item.showAlwaysInPopup && item.overflow !== 'Show') {
            return;
        }
        var alignDiv = [];
        alignDiv.push(sf.base.createElement('div', { className: CLS_TBARLEFT }));
        alignDiv.push(sf.base.createElement('div', { className: CLS_TBARCENTER }));
        alignDiv.push(sf.base.createElement('div', { className: CLS_TBARRIGHT }));
        if (pos === 0 && item.align !== 'Left') {
            alignDiv.forEach(function (ele) {
                itemEle.appendChild(ele);
            });
            this.tbarAlign = true;
            sf.base.addClass([itemEle], CLS_TBARPOS);
        }
        else if (item.align !== 'Left') {
            var alignEle = itemEle.childNodes;
            var leftAlign_1 = alignDiv[0];
            [].slice.call(alignEle).forEach(function (el) {
                _this.tbarAlgEle.lefts.push(el);
                leftAlign_1.appendChild(el);
            });
            itemEle.appendChild(leftAlign_1);
            itemEle.appendChild(alignDiv[1]);
            itemEle.appendChild(alignDiv[2]);
            this.tbarAlign = true;
            sf.base.addClass([itemEle], CLS_TBARPOS);
        }
    };
    SfToolbar.prototype.renderItems = function () {
        var ele = this.element;
        var items = this.options.items;
        if (ele && items.length > 0) {
            var itemEleDom = ele.querySelector('.' + CLS_ITEMS);
            if (!itemEleDom) {
                itemEleDom = sf.base.createElement('div', { className: CLS_ITEMS });
            }
            this.itemsAlign(items, itemEleDom, true);
            if (!sf.base.isNullOrUndefined(ele.firstElementChild)) {
                ele.insertBefore(itemEleDom, ele.firstElementChild);
            }
            else {
                ele.appendChild(itemEleDom);
            }
        }
    };
    SfToolbar.prototype.setAttr = function (attr, element) {
        var key = Object.keys(attr);
        var keyVal;
        for (var i = 0; i < key.length; i++) {
            keyVal = key[i];
            if (keyVal === 'class') {
                sf.base.addClass([element], attr[keyVal]);
            }
            else {
                element.setAttribute(keyVal, attr[keyVal]);
            }
        }
    };
    SfToolbar.prototype.itemClick = function (e) {
        this.activeEleSwitch(e.currentTarget);
    };
    SfToolbar.prototype.activeEleSwitch = function (ele) {
        this.activeEleRemove(ele.firstElementChild);
        this.activeEle.focus();
    };
    SfToolbar.prototype.activeEleRemove = function (curEle) {
        if (!sf.base.isNullOrUndefined(this.activeEle)) {
            this.activeEle.setAttribute('tabindex', '-1');
        }
        this.activeEle = curEle;
        if (sf.base.isNullOrUndefined(this.trgtEle) && !curEle.parentElement.classList.contains(CLS_TEMPLATE)) {
            curEle.removeAttribute('tabindex');
        }
        else {
            this.activeEle.setAttribute('tabindex', '0');
        }
    };
    SfToolbar.prototype.resize = function () {
        var ele = this.element;
        this.tbResize = true;
        if (this.tbarAlign) {
            this.itemPositioning();
        }
        if (this.popObj && this.options.overflowMode === 'Popup') {
            this.popObj.hide();
        }
        var checkOverflow = this.checkOverflow(ele, ele.getElementsByClassName(CLS_ITEMS)[0]);
        if (!checkOverflow) {
            this.destroyScroll();
            var multirowele = ele.querySelector('.' + CLS_ITEMS);
            if (!sf.base.isNullOrUndefined(multirowele)) {
                sf.base.removeClass([multirowele], CLS_MULTIROWPOS);
                if (this.tbarAlign) {
                    sf.base.addClass([multirowele], CLS_TBARPOS);
                }
            }
        }
        if (checkOverflow && this.scrollModule && (this.offsetWid === ele.offsetWidth)) {
            return;
        }
        if (this.offsetWid > ele.offsetWidth || checkOverflow) {
            this.renderOverflowMode();
        }
        if (this.popObj) {
            if (this.options.overflowMode === 'Extended') {
                var eleStyles = window.getComputedStyle(this.element);
                this.popObj.width = parseFloat(eleStyles.width) + ((parseFloat(eleStyles.borderRightWidth)) * 2);
            }
            if (this.tbarAlign) {
                this.removePositioning();
            }
            this.popupRefresh(this.popObj.element, false);
            if (this.tbarAlign) {
                this.refreshPositioning();
            }
        }
        this.offsetWid = ele.offsetWidth;
        this.tbResize = false;
        this.separator();
    };
    SfToolbar.prototype.extendedOpen = function () {
        var sib = this.element.querySelector('.' + CLS_EXTENDABLECLASS);
        if (this.options.overflowMode === 'Extended' && sib) {
            this.isExtendedOpen = sib.classList.contains(CLS_POPUPOPEN);
        }
    };
    SfToolbar.prototype.disable = function (value) {
        var rootEle = this.element;
        if (value) {
            rootEle.classList.add(CLS_DISABLE);
        }
        else {
            rootEle.classList.remove(CLS_DISABLE);
        }
        rootEle.setAttribute('tabindex', !value ? '0' : '-1');
        if (this.activeEle) {
            this.activeEle.setAttribute('tabindex', !value ? '0' : '-1');
        }
        if (this.scrollModule) {
            this.scrollModule.disable(value);
        }
        if (this.popObj) {
            if (sf.base.isVisible(this.popObj.element) && this.options.overflowMode !== 'Extended') {
                this.popObj.hide();
            }
            rootEle.querySelector('#' + rootEle.id + '_nav').setAttribute('tabindex', !value ? '0' : '-1');
        }
    };
    SfToolbar.prototype.setCssClass = function (cssClass) {
        this.extendedOpen();
        if (this.options.cssClass) {
            sf.base.removeClass([this.element], this.options.cssClass.split(' '));
        }
        if (cssClass) {
            sf.base.addClass([this.element], cssClass.split(' '));
        }
        this.options.cssClass = cssClass;
    };
    return SfToolbar;
}());
// tslint:disable
var Toolbar = {
    initialize: function (element, options, dotnetRef) {
        if (options.scrollStep === 0) {
            options.scrollStep = null;
        }
        var instance = new SfToolbar(element, options, dotnetRef);
        instance.render();
    },
    hidePopup: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance) && !sf.base.isNullOrUndefined(element.blazor__instance.popObj)) {
            element.blazor__instance.popObj.hide({ name: 'FadeOut', duration: 100 });
        }
    },
    setCssClass: function (element, cssClass) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.setCssClass(cssClass);
        }
    },
    setWidth: function (element, width) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.width = width;
            element.blazor__instance.extendedOpen();
            var wid = element.offsetWidth;
            sf.base.setStyleAttribute(element, { 'width': sf.base.formatUnit(width) });
            element.blazor__instance.renderOverflowMode();
            if (element.blazor__instance.popObj && wid < element.offsetWidth) {
                element.blazor__instance.popupRefresh(element.blazor__instance.popObj.element, false);
            }
        }
    },
    setHeight: function (element, height) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.height = height;
            element.blazor__instance.extendedOpen();
            sf.base.setStyleAttribute(element, { 'height': sf.base.formatUnit(height) });
        }
    },
    setOverflowMode: function (element, overflowMode) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.overflowMode = overflowMode;
            element.blazor__instance.extendedOpen();
            element.blazor__instance.destroyMode();
            element.blazor__instance.renderOverflowMode();
            if (element.blazor__instance.options.enableRtl) {
                sf.base.addClass([element], CLS_RTL);
            }
            element.blazor__instance.refreshOverflow();
        }
    },
    setEnableRTL: function (element, enableRtl) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.enableRtl = enableRtl;
            element.blazor__instance.extendedOpen();
            if (enableRtl) {
                sf.base.addClass([element], CLS_RTL);
            }
            else {
                sf.base.removeClass([element], CLS_RTL);
            }
            if (!sf.base.isNullOrUndefined(element.blazor__instance.scrollModule)) {
                if (enableRtl) {
                    sf.base.addClass([element.blazor__instance.scrollModule.element], CLS_RTL);
                }
                else {
                    sf.base.removeClass([element.blazor__instance.scrollModule.element], CLS_RTL);
                }
            }
            if (!sf.base.isNullOrUndefined(element.blazor__instance.popObj)) {
                if (enableRtl) {
                    sf.base.addClass([element.blazor__instance.popObj.element], CLS_RTL);
                }
                else {
                    sf.base.removeClass([element.blazor__instance.popObj.element], CLS_RTL);
                }
            }
            if (element.blazor__instance.tbarAlign) {
                element.blazor__instance.itemPositioning();
            }
        }
    },
    setScrollStep: function (element, scrollStep) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.scrollStep = scrollStep;
            element.blazor__instance.extendedOpen();
            if (element.blazor__instance.scrollModule) {
                element.blazor__instance.scrollModule.scrollStep = scrollStep;
            }
        }
    },
    setEnableCollision: function (element, enableCollision) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.enableCollision = enableCollision;
            element.blazor__instance.extendedOpen();
            if (element.blazor__instance.popObj) {
                element.blazor__instance.popObj.collision = { Y: enableCollision ? 'flip' : 'none' };
            }
        }
    },
    setAllowKeyboard: function (element, allowKeyboard) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.allowKeyboard = allowKeyboard;
            element.blazor__instance.extendedOpen();
            element.blazor__instance.unwireKeyboardEvent();
            if (allowKeyboard) {
                element.blazor__instance.wireKeyboardEvent();
            }
        }
    },
    serverItemsRerender: function (element, items, firstRender) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.items = items;
            element.blazor__instance.extendedOpen();
            element.blazor__instance.destroyMode();
            element.blazor__instance.resetServerItems(firstRender);
            element.blazor__instance.serverItemsRefresh(firstRender);
        }
    },
    hideItem: function (element, items) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options.items = items;
            element.blazor__instance.refreshOverflow();
        }
    },
    disable: function (element, value) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.disable(value);
        }
    },
    refreshOverflow: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.refreshOverflow();
        }
    },
    destroy: function (element) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.destroy();
        }
    },
    refresh: function (element, options) {
        if (options.scrollStep === 0) {
            options.scrollStep = null;
        }
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(element.blazor__instance)) {
            element.blazor__instance.options = options;
            element.blazor__instance.destroyMode();
            element.blazor__instance.resetServerItems(false);
            element.blazor__instance.serverItemsRefresh(false);
        }
    }
};

return Toolbar;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-tooltip.js":
/*!*************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-tooltip.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Tooltip = (function () {
'use strict';

var TAPHOLD_THRESHOLD = 500;
var SHOW_POINTER_TIP_GAP = 0;
var HIDE_POINTER_TIP_GAP = 8;
var MOUSE_TRAIL_GAP = 2;
var POINTER_ADJUST = 2;
var ROOT = 'e-tooltip';
var ELEMENT_HIDDNE = 'e-blazor-hidden';
var TOOLTIP_WRAP = 'e-tooltip-wrap';
var ARROW_TIP = 'e-arrow-tip';
var ARROW_TIP_OUTER = 'e-arrow-tip-outer';
var ARROW_TIP_INNER = 'e-arrow-tip-inner';
var TIP_BOTTOM = 'e-tip-bottom';
var TIP_TOP = 'e-tip-top';
var TIP_LEFT = 'e-tip-left';
var TIP_RIGHT = 'e-tip-right';
var POPUP_ROOT = 'e-popup';
var POPUP_OPEN = 'e-popup-open';
var POPUP_CLOSE = 'e-popup-close';
var POPUP_LIB = 'e-lib';
var HIDDDEN = 'e-hidden';
var BIGGER = 'e-bigger';
var RIGHT = 'Right';
var BOTTOM = 'Bottom';
var TOP = 'Top';
var LEFT = 'Left';
var CENTER = 'Center';
var END = 'End';
var START = 'Start';
var TOPLEFT = 'TopLeft';
var TOPRIGHT = 'TopRight';
var BOTTOMLEFT = 'BottomLeft';
var BOTTOMCENTER = 'BottomCenter';
var BOTTOMRIGHT = 'BottomRight';
var LEFTTOP = 'LeftTop';
var LEFTCENTER = 'LeftCenter';
var LEFTBOTTOM = 'LeftBottom';
var RIGHTTOP = 'RightTop';
var RIGHTCENTER = 'RightCenter';
var RIGHTBOTTOM = 'RightBottom';
var PLACEHOLDER = '_content_placeholder';
var CONTENT = '_content';
var TIPCONTENT = 'e-tip-content';
var SfTooltip = /** @class */ (function () {
    function SfTooltip(element, ref, properties, eventList) {
        this.popupObj = null;
        this.isPositionUpdate = false;
        this.isOffsetXUpdate = false;
        this.isOffsetYUpdate = false;
        this.tipClass = TIP_BOTTOM;
        this.tooltipPositionX = 'Center';
        this.tooltipPositionY = 'Top';
        this.isContiniousOpen = false;
        this.isRestrictUpdate = false;
        this.showTimer = 0;
        this.hideTimer = 0;
        this.contentTargetValue = null;
        this.contentEvent = null;
        this.contentAnimation = null;
        this.beforeCloseAnimation = null;
        this.isPopupHidden = true;
        this.isMultiTarget = false;
        this.mouseAction = false;
        this.mouseMoveEvent = null;
        this.mouseMoveTarget = null;
        this.element = element;
        this.properties = properties;
        this.dotnetRef = ref;
        if (!sf.base.isNullOrUndefined(this.element)) {
            this.ctrlId = this.element.id;
            this.element.blazor__instance = this;
            this.element.eventList = eventList;
        }
    }
    SfTooltip.prototype.getTriggerList = function (trigger) {
        if (trigger === 'Auto') {
            trigger = (sf.base.Browser.isDevice) ? 'Hover' : 'Hover Focus';
        }
        return trigger.split(' ');
    };
    SfTooltip.prototype.formatPosition = function () {
        var _a, _b;
        if (this.properties.position.indexOf('Top') === 0 || this.properties.position.indexOf('Bottom') === 0) {
            _a = this.properties.position.split(/(?=[A-Z])/), this.tooltipPositionY = _a[0], this.tooltipPositionX = _a[1];
        }
        else {
            _b = this.properties.position.split(/(?=[A-Z])/), this.tooltipPositionX = _b[0], this.tooltipPositionY = _b[1];
        }
    };
    SfTooltip.prototype.getTargetList = function (target) {
        var targetElements = [];
        if (target === null || target === '') {
            targetElements.push(this.element);
        }
        else {
            targetElements = [].slice.call(sf.base.selectAll(target, this.element));
            if (targetElements && targetElements.length === 0) {
                targetElements = [].slice.call(sf.base.selectAll(target, document));
            }
        }
        return targetElements;
    };
    SfTooltip.prototype.wireEvents = function (trigger) {
        var triggerList = this.getTriggerList(trigger);
        var targetList = this.getTargetList(this.properties.target);
        for (var _i = 0, triggerList_1 = triggerList; _i < triggerList_1.length; _i++) {
            var opensOn = triggerList_1[_i];
            for (var _a = 0, targetList_1 = targetList; _a < targetList_1.length; _a++) {
                var target = targetList_1[_a];
                if (opensOn === 'Custom') {
                    return;
                }
                if (opensOn === 'Focus') {
                    sf.base.EventHandler.add(target, 'focus', this.targetHover, this);
                }
                if (opensOn === 'Click') {
                    sf.base.EventHandler.add(target, sf.base.Browser.touchStartEvent, this.targetClick, this);
                }
                if (opensOn === 'Hover') {
                    if (sf.base.Browser.isDevice) {
                        this.touchModule = new sf.base.Touch(target, {
                            tapHoldThreshold: TAPHOLD_THRESHOLD,
                            tapHold: this.tapHoldHandler.bind(this)
                        });
                        sf.base.EventHandler.add(target, sf.base.Browser.touchEndEvent, this.touchEndHandler, this);
                    }
                    else {
                        sf.base.EventHandler.add(target, 'mouseover', this.targetHover, this);
                        if (!this.properties.isSticky) {
                            sf.base.EventHandler.add(target, 'mouseleave', this.onMouseOut, this);
                        }
                    }
                }
            }
        }
        sf.base.EventHandler.add(document, 'touchend', this.touchEnd, this);
        sf.base.EventHandler.add(document, 'scroll wheel', this.scrollHandler, this);
        sf.base.EventHandler.add(document, 'keydown', this.keyDown, this);
        window.addEventListener('resize', this.onWindowResize.bind(this));
    };
    SfTooltip.prototype.onWindowResize = function () {
        if (!this.isHidden()) {
            this.reposition(this.findTarget());
        }
    };
    SfTooltip.prototype.wireMouseEvents = function (e, target) {
        if (this.tooltipEle) {
            if (!this.properties.isSticky) {
                if (e.type === 'focus') {
                    sf.base.EventHandler.add(target, 'blur', this.onMouseOut, this);
                }
                if (this.properties.closeDelay) {
                    sf.base.EventHandler.add(this.tooltipEle, 'mouseenter', this.tooltipHover, this);
                    sf.base.EventHandler.add(this.tooltipEle, 'mouseleave', this.tooltipMouseOut, this);
                }
            }
            if (this.properties.mouseTrail) {
                sf.base.EventHandler.add(target, 'mousemove touchstart mouseenter', this.onMouseMove, this);
            }
        }
    };
    SfTooltip.prototype.unwireEvents = function (trigger) {
        var triggerList = this.getTriggerList(trigger);
        var targetList = this.getTargetList(this.properties.target);
        for (var _i = 0, triggerList_2 = triggerList; _i < triggerList_2.length; _i++) {
            var opensOn = triggerList_2[_i];
            for (var _a = 0, targetList_2 = targetList; _a < targetList_2.length; _a++) {
                var target = targetList_2[_a];
                if (opensOn === 'Custom') {
                    return;
                }
                if (opensOn === 'Focus') {
                    sf.base.EventHandler.remove(target, 'focus', this.targetHover);
                }
                if (opensOn === 'Click') {
                    sf.base.EventHandler.remove(target, sf.base.Browser.touchStartEvent, this.targetClick);
                }
                if (opensOn === 'Hover') {
                    if (sf.base.Browser.isDevice) {
                        if (this.touchModule) {
                            this.touchModule.destroy();
                        }
                        sf.base.EventHandler.remove(target, sf.base.Browser.touchEndEvent, this.touchEndHandler);
                    }
                    else {
                        sf.base.EventHandler.remove(target, 'mouseover', this.targetHover);
                        if (!this.properties.isSticky) {
                            sf.base.EventHandler.remove(target, 'mouseleave', this.onMouseOut);
                        }
                    }
                }
            }
        }
        sf.base.EventHandler.remove(document, 'touchend', this.touchEnd);
        sf.base.EventHandler.remove(document, 'scroll wheel', this.scrollHandler);
        sf.base.EventHandler.remove(document, 'keydown', this.keyDown);
        window.removeEventListener('resize', this.onWindowResize.bind(this));
    };
    SfTooltip.prototype.unwireMouseEvents = function (target) {
        if (!this.properties.isSticky) {
            var triggerList = this.getTriggerList(this.properties.opensOn);
            for (var _i = 0, triggerList_3 = triggerList; _i < triggerList_3.length; _i++) {
                var opensOn = triggerList_3[_i];
                if (opensOn === 'Focus') {
                    sf.base.EventHandler.remove(target, 'blur', this.onMouseOut);
                }
            }
            if (this.properties.closeDelay) {
                sf.base.EventHandler.remove(target, 'mouseenter', this.tooltipHover);
                sf.base.EventHandler.remove(target, 'mouseleave', this.tooltipMouseOut);
            }
        }
        if (this.properties.mouseTrail) {
            sf.base.EventHandler.remove(target, 'mousemove touchstart mouseenter', this.onMouseMove);
        }
    };
    SfTooltip.prototype.findTarget = function () {
        return sf.base.select('[data-tooltip-id= "' + this.ctrlId + '_content"]', document);
    };
    SfTooltip.prototype.addDescribedBy = function (target, id) {
        var describedby = (sf.base.getAttributeOrDefault(target, 'aria-describedby', null) || '').split(/\s+/);
        if (describedby.indexOf(id) < 0) {
            describedby.push(id);
        }
        sf.base.attributes(target, { 'aria-describedby': describedby.join(' ').trim(), 'data-tooltip-id': id });
    };
    SfTooltip.prototype.removeDescribedBy = function (target) {
        var id = sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null);
        var describedby = (sf.base.getAttributeOrDefault(target, 'aria-describedby', null) || '').split(/\s+/);
        var index = describedby.indexOf(id);
        if (index !== -1) {
            describedby.splice(index, 1);
        }
        target.removeAttribute('data-tooltip-id');
        var orgdescribedby = describedby.join(' ').trim();
        orgdescribedby ? sf.base.attributes(target, { 'aria-describedby': orgdescribedby }) : target.removeAttribute('aria-describedby');
    };
    SfTooltip.prototype.clear = function () {
        if (this.tooltipEle && this.isPopupHidden) {
            sf.base.removeClass([this.tooltipEle], POPUP_CLOSE);
            sf.base.addClass([this.tooltipEle], POPUP_OPEN);
        }
        if (this.isPopupHidden) {
            if (this.popupObj) {
                this.popupObj.destroy();
            }
            if (this.tooltipEle) {
                sf.base.setStyleAttribute(this.tooltipEle, { 'display': 'none' });
                var contentElement = document.getElementById(this.ctrlId + PLACEHOLDER);
                if (contentElement) {
                    contentElement.appendChild(this.tooltipEle);
                }
                if (document.body.contains(this.element)) {
                    // tslint:disable
                    this.dotnetRef.invokeMethodAsync('CreateTooltip', false).catch(function () { });
                }
            }
            this.tooltipEle = null;
            this.popupObj = null;
        }
    };
    SfTooltip.prototype.tapHoldHandler = function (evt) {
        this.targetHover(evt.originalEvent);
    };
    SfTooltip.prototype.touchEndHandler = function (e) {
        if (!this.properties.isSticky) {
            this.hideTooltip(this.properties.animation.close);
        }
    };
    SfTooltip.prototype.targetClick = function (e) {
        var target = this.properties.target ? sf.base.closest(e.target, this.properties.target) :
            this.element;
        if (!sf.base.isNullOrUndefined(target)) {
            if (sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null) === null) {
                this.targetHover(e);
            }
            else if (!this.properties.isSticky) {
                this.hideTooltip(this.properties.animation.close, e, target);
            }
        }
    };
    SfTooltip.prototype.restoreElement = function (target) {
        this.unwireMouseEvents(target);
        if (!sf.base.isNullOrUndefined(sf.base.getAttributeOrDefault(target, 'data-content', null))) {
            if (this.hasTitle) {
                sf.base.attributes(target, { 'title': sf.base.getAttributeOrDefault(target, 'data-content', null) });
            }
            target.removeAttribute('data-content');
        }
        this.removeDescribedBy(target);
    };
    SfTooltip.prototype.checkForOpen = function (opensOn, element, e) {
        if (element == null || sf.base.isNullOrUndefined(e)) {
            return false;
        }
        var target = this.properties.target ? sf.base.closest(e.target, this.properties.target) : this.element;
        if (target == null) {
            return false;
        }
        var isOpenable = true;
        if (opensOn === 'Hover') {
            isOpenable = sf.base.matches(target, ':hover');
        }
        else if (opensOn === 'Auto') {
            isOpenable = (sf.base.matches(target, ':hover') || sf.base.matches(target, ':focus'));
        }
        else if (opensOn === 'Focus') {
            isOpenable = sf.base.matches(target, ':focus');
        }
        else if (opensOn === 'Click') {
            if (element === sf.base.closest(e.target, '.' + ROOT) &&
                sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null) === null) {
                isOpenable = true;
            }
            else {
                isOpenable = false;
            }
        }
        else if (opensOn === 'Custom') {
            if (sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null) === null) {
                isOpenable = true;
            }
            else {
                isOpenable = false;
            }
        }
        return isOpenable;
    };
    SfTooltip.prototype.targetHover = function (e) {
        if (!this.checkForOpen(this.properties.opensOn, this.element, e)) {
            return;
        }
        var target = this.properties.target ? sf.base.closest(e.target, this.properties.target) :
            this.element;
        if (sf.base.isNullOrUndefined(target) || sf.base.getAttributeOrDefault(target, 'data-tooltip-id', null) !== null) {
            return;
        }
        this.isMultiTarget = this.getTargetList(this.properties.target).length > 1 ? true : false;
        if (this.properties.target && this.isMultiTarget && e && !sf.base.isNullOrUndefined(e.target) && !sf.base.isNullOrUndefined((e.relatedTarget))) {
            var currTarget = sf.base.closest(e.target, this.properties.target);
            var relatedTarget = sf.base.closest(e.relatedTarget, this.properties.target);
            if (currTarget == relatedTarget) {
                return;
            }
        }
        var targetList = [].slice.call(sf.base.selectAll('[data-tooltip-id= "' + this.ctrlId + '_content"]', document));
        for (var _i = 0, targetList_3 = targetList; _i < targetList_3.length; _i++) {
            var target_1 = targetList_3[_i];
            this.restoreElement(target_1);
        }
        this.mouseAction = false;
        this.showTooltip(target, this.properties.animation.open, e);
    };
    SfTooltip.prototype.isHidden = function () {
        return this.tooltipEle ? !this.tooltipEle.classList.contains(POPUP_OPEN) : true;
    };
    SfTooltip.prototype.mouseMoveBeforeOpen = function (e) {
        this.mouseMoveEvent = e;
    };
    SfTooltip.prototype.mouseMoveBeforeRemove = function () {
        if (this.mouseMoveTarget) {
            sf.base.EventHandler.remove(this.mouseMoveTarget, "mousemove touchstart", this.mouseMoveBeforeOpen);
        }
    };
    SfTooltip.prototype.showTooltip = function (target, showAnimation, e) {
        var _this = this;
        this.clear();
        clearTimeout(this.showTimer);
        clearTimeout(this.hideTimer);
        if (this.properties.mouseTrail && this.properties.openDelay) {
            this.mouseMoveBeforeRemove();
            this.mouseMoveTarget = target;
            sf.base.EventHandler.add(this.mouseMoveTarget, "mousemove touchstart", this.mouseMoveBeforeOpen, this);
        }
        var show = function () {
            _this.isContiniousOpen = !sf.base.isNullOrUndefined(_this.tooltipEle);
            _this.tooltipEventArgs = {
                type: e ? e.type.toString() : null, cancel: false, target: _this.getDomObject('target', target), event: e ? e : null,
                hasText: _this.hasText(), element: _this.getDomObject('tooltipElement', _this.tooltipEle),
                isInteracted: !sf.base.isNullOrUndefined(e), name: 'beforeRender',
                left: e ? _this.getXYValue(e, 'x') : null,
                top: e ? _this.getXYValue(e, 'y') : null
            };
            _this.contentTargetValue = target;
            _this.contentEvent = e;
            _this.contentAnimation = showAnimation;
            _this.isRestrictUpdate = _this.element.eventList.beforeRender && !_this.isHidden();
            _this.element.eventList.beforeRender ? _this.triggerEvent('TriggerBeforeRenderEvent', _this.tooltipEventArgs) :
                _this.beforeRenderCallBack(false);
        };
        this.showTimer = setTimeout(show, this.properties.openDelay);
    };
    SfTooltip.prototype.triggerEvent = function (eventName, args) {
        if (document.body.contains(this.element)) {
            // tslint:disable
            this.dotnetRef.invokeMethodAsync(eventName, JSON.stringify(args)).catch(function () { });
        }
    };
    SfTooltip.prototype.beforeRenderCallBack = function (cancel) {
        if (cancel) {
            this.isPopupHidden = true;
            this.clear();
            this.mouseMoveBeforeRemove();
        }
        else {
            this.isPopupHidden = false;
            if (sf.base.isNullOrUndefined(this.tooltipEle)) {
                if (document.body.contains(this.element)) {
                    // tslint:disable
                    this.dotnetRef.invokeMethodAsync('CreateTooltip', true).catch(function () { });
                }
            }
            else if (this.isContiniousOpen && !this.isRestrictUpdate) {
                this.contentUpdated();
            }
            else {
                this.isRestrictUpdate = false;
            }
        }
    };
    SfTooltip.prototype.checkCollision = function (target, x, y) {
        var elePos = {
            left: x, top: y, position: this.properties.position,
            horizontal: this.tooltipPositionX, vertical: this.tooltipPositionY
        };
        var affectedPos = sf.popups.isCollide(this.tooltipEle, this.checkCollideTarget(), x, y);
        if (affectedPos.length > 0) {
            elePos.horizontal = affectedPos.indexOf('left') >= 0 ? RIGHT : affectedPos.indexOf('right') >= 0 ? LEFT :
                this.tooltipPositionX;
            elePos.vertical = affectedPos.indexOf('top') >= 0 ? BOTTOM : affectedPos.indexOf('bottom') >= 0 ? TOP :
                this.tooltipPositionY;
        }
        return elePos;
    };
    SfTooltip.prototype.checkCollideTarget = function () {
        return !this.properties.windowCollision && this.properties.target ? this.element : null;
    };
    SfTooltip.prototype.collisionFlipFit = function (target, x, y) {
        var elePos = this.checkCollision(target, x, y);
        var newpos = elePos.position;
        if (this.tooltipPositionY !== elePos.vertical) {
            newpos = ((this.properties.position.indexOf(BOTTOM) === 0 || this.properties.position.indexOf('Top') === 0) ?
                elePos.vertical + this.tooltipPositionX : this.tooltipPositionX + elePos.vertical);
        }
        if (this.tooltipPositionX !== elePos.horizontal) {
            if (newpos.indexOf(LEFT) === 0) {
                elePos.vertical = (newpos === LEFTTOP || newpos === LEFTCENTER) ? TOP : BOTTOM;
                newpos = (elePos.vertical + LEFT);
            }
            if (newpos.indexOf(RIGHT) === 0) {
                elePos.vertical = (newpos === RIGHTTOP || newpos === RIGHTCENTER) ? TOP : BOTTOM;
                newpos = (elePos.vertical + RIGHT);
            }
            elePos.horizontal = this.tooltipPositionX;
        }
        this.tooltipEventArgs = {
            type: null, cancel: false, target: this.getDomObject('target', target), event: null, isInteracted: false,
            hasText: this.hasText(), element: this.getDomObject('tooltipElement', this.tooltipEle),
            collidedPosition: newpos, name: 'beforeCollision', left: null, top: null
        };
        this.isRestrictUpdate = this.element.eventList.beforeCollision && !this.isHidden();
        if (this.element.eventList.beforeCollision) {
            this.triggerEvent('TriggerBeforeCollisionEvent', this.tooltipEventArgs);
        }
        if (elePos.position !== newpos) {
            var pos = sf.popups.calculatePosition(target, elePos.horizontal, elePos.vertical);
            this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);
            var offsetPos = this.calculateTooltipOffset(newpos);
            offsetPos.top -= (('TopBottom'.indexOf(this.properties.position.split(/(?=[A-Z])/)[0]) !== -1) &&
                ('TopBottom'.indexOf(newpos.split(/(?=[A-Z])/)[0]) !== -1)) ? (2 * this.properties.offsetY) : 0;
            offsetPos.left -= (('RightLeft'.indexOf(this.properties.position.split(/(?=[A-Z])/)[0]) !== -1) &&
                ('RightLeft'.indexOf(newpos.split(/(?=[A-Z])/)[0]) !== -1)) ? (2 * this.properties.offsetX) : 0;
            elePos.position = newpos;
            elePos.left = pos.left + offsetPos.left;
            elePos.top = pos.top + offsetPos.top;
        }
        else {
            this.adjustArrow(target, newpos, elePos.horizontal, elePos.vertical);
        }
        var eleOffset = { left: elePos.left, top: elePos.top };
        var left = sf.popups.fit(this.tooltipEle, this.checkCollideTarget(), { X: true, Y: false }, eleOffset).left;
        sf.base.setStyleAttribute(this.tooltipEle, { 'display': 'block' });
        if (this.properties.showTipPointer && (newpos.indexOf('Bottom') === 0 || newpos.indexOf('Top') === 0)) {
            var arrowEle = sf.base.select('.' + ARROW_TIP, this.tooltipEle);
            var arrowleft = parseInt(arrowEle.style.left, 10) - (left - elePos.left);
            if (arrowleft < 0) {
                arrowleft = 0;
            }
            else if ((arrowleft + arrowEle.offsetWidth) > this.tooltipEle.clientWidth) {
                arrowleft = this.tooltipEle.clientWidth - arrowEle.offsetWidth;
            }
            sf.base.setStyleAttribute(arrowEle, { 'left': (arrowleft.toString() + 'px') });
        }
        sf.base.setStyleAttribute(this.tooltipEle, { 'display': '' });
        eleOffset.left = left;
        return eleOffset;
    };
    SfTooltip.prototype.hideTooltip = function (hideAnimation, e, targetElement) {
        var _this = this;
        clearTimeout(this.hideTimer);
        clearTimeout(this.showTimer);
        var hide = function () {
            if (_this.checkForOpen(_this.properties.opensOn, _this.element, e)) {
                return;
            }
            if (_this.properties.closeDelay && _this.tooltipEle && _this.isTooltipOpen) {
                return;
            }
            var target;
            if (e) {
                target = _this.properties.target ? (targetElement || e.target) : _this.element;
            }
            else {
                target = sf.base.select('[data-tooltip-id= "' + _this.ctrlId + '_content"]', document);
            }
            _this.tooltipEventArgs = {
                type: e ? e.type.toString() : null, cancel: false, target: _this.getDomObject('target', target), event: e ? e : null,
                element: _this.getDomObject('tooltipElement', _this.tooltipEle), hasText: _this.hasText(),
                isInteracted: !sf.base.isNullOrUndefined(e), name: 'beforeClose', collidedPosition: null,
                left: e ? _this.getXYValue(e, 'x') : null,
                top: e ? _this.getXYValue(e, 'y') : null
            };
            _this.beforeCloseTarget = target;
            _this.beforeCloseAnimation = hideAnimation;
            _this.isRestrictUpdate = _this.element.eventList.beforeClose && !_this.isHidden();
            _this.element.eventList.beforeClose ? _this.triggerEvent('TriggerBeforeCloseEvent', _this.tooltipEventArgs) :
                _this.beforeCloseCallBack(false);
        };
        this.hideTimer = setTimeout(hide, this.properties.closeDelay);
    };
    SfTooltip.prototype.beforeCloseCallBack = function (cancel) {
        if (!cancel) {
            var proxy_1 = this;
            proxy_1.mouseMoveBeforeRemove();
            var hide = function () {
                if (!proxy_1.isMultiTarget) {
                    proxy_1.popupHide(proxy_1.beforeCloseAnimation, proxy_1.beforeCloseTarget);
                }
            };
            if (this.popupObj) {
                this.popupHide(this.beforeCloseAnimation, this.beforeCloseTarget);
            }
            else {
                setTimeout(hide, 200);
            }
        }
        else {
            this.isPopupHidden = false;
        }
    };
    SfTooltip.prototype.popupHide = function (hideAnimation, target) {
        if (target) {
            this.restoreElement(target);
        }
        this.isPopupHidden = true;
        var closeAnimation = {
            name: hideAnimation.effect,
            duration: hideAnimation.duration,
            delay: hideAnimation.delay,
            timingFunction: 'easeIn'
        };
        if (hideAnimation.effect === 'None') {
            closeAnimation = undefined;
        }
        if (this.popupObj) {
            this.popupObj.hide(closeAnimation);
        }
    };
    SfTooltip.prototype.calculateTooltipOffset = function (position) {
        var pos = { top: 0, left: 0 };
        var tooltipEleWidth = this.tooltipEle.offsetWidth;
        var tooltipEleHeight = this.tooltipEle.offsetHeight;
        var arrowEle = sf.base.select('.' + ARROW_TIP, this.tooltipEle);
        var tipWidth = arrowEle ? arrowEle.offsetWidth : 0;
        var tipHeight = arrowEle ? arrowEle.offsetHeight : 0;
        var tipAdjust = (this.properties.showTipPointer ? SHOW_POINTER_TIP_GAP : HIDE_POINTER_TIP_GAP);
        var tipHeightAdjust = (tipHeight / 2) + POINTER_ADJUST + (this.tooltipEle.offsetHeight - this.tooltipEle.clientHeight);
        var tipWidthAdjust = (tipWidth / 2) + POINTER_ADJUST + (this.tooltipEle.offsetWidth - this.tooltipEle.clientWidth);
        if (this.properties.mouseTrail) {
            tipAdjust += MOUSE_TRAIL_GAP;
        }
        switch (position) {
            case RIGHTTOP:
                pos.left += tipWidth + tipAdjust;
                pos.top -= tooltipEleHeight - tipHeightAdjust;
                break;
            case RIGHTCENTER:
                pos.left += tipWidth + tipAdjust;
                pos.top -= (tooltipEleHeight / 2);
                break;
            case RIGHTBOTTOM:
                pos.left += tipWidth + tipAdjust;
                pos.top -= (tipHeightAdjust);
                break;
            case BOTTOMRIGHT:
                pos.top += (tipHeight + tipAdjust);
                pos.left -= (tipWidthAdjust);
                break;
            case BOTTOMCENTER:
                pos.top += (tipHeight + tipAdjust);
                pos.left -= (tooltipEleWidth / 2);
                break;
            case BOTTOMLEFT:
                pos.top += (tipHeight + tipAdjust);
                pos.left -= (tooltipEleWidth - tipWidthAdjust);
                break;
            case LEFTBOTTOM:
                pos.left -= (tipWidth + tooltipEleWidth + tipAdjust);
                pos.top -= (tipHeightAdjust);
                break;
            case LEFTCENTER:
                pos.left -= (tipWidth + tooltipEleWidth + tipAdjust);
                pos.top -= (tooltipEleHeight / 2);
                break;
            case LEFTTOP:
                pos.left -= (tipWidth + tooltipEleWidth + tipAdjust);
                pos.top -= (tooltipEleHeight - tipHeightAdjust);
                break;
            case TOPLEFT:
                pos.top -= (tooltipEleHeight + tipHeight + tipAdjust);
                pos.left -= (tooltipEleWidth - tipWidthAdjust);
                break;
            case TOPRIGHT:
                pos.top -= (tooltipEleHeight + tipHeight + tipAdjust);
                pos.left -= (tipWidthAdjust);
                break;
            default:
                pos.top -= (tooltipEleHeight + tipHeight + tipAdjust);
                pos.left -= (tooltipEleWidth / 2);
                break;
        }
        pos.left += this.properties.offsetX;
        pos.top += this.properties.offsetY;
        return pos;
    };
    SfTooltip.prototype.setTipClass = function (position) {
        if (position.indexOf(RIGHT) === 0) {
            this.tipClass = TIP_LEFT;
        }
        else if (position.indexOf(BOTTOM) === 0) {
            this.tipClass = TIP_TOP;
        }
        else if (position.indexOf(LEFT) === 0) {
            this.tipClass = TIP_RIGHT;
        }
        else {
            this.tipClass = TIP_BOTTOM;
        }
    };
    SfTooltip.prototype.updateTipPosition = function (position) {
        var selEle = sf.base.selectAll('.' + ARROW_TIP + ',.' + ARROW_TIP_OUTER + ',.' + ARROW_TIP_INNER, this.tooltipEle);
        var removeList = [TIP_BOTTOM, TIP_TOP, TIP_LEFT, TIP_RIGHT];
        sf.base.removeClass(selEle, removeList);
        this.setTipClass(position);
        sf.base.addClass(selEle, this.tipClass);
    };
    SfTooltip.prototype.adjustArrow = function (target, position, tooltipPositionX, tooltipPositionY) {
        if (this.properties.showTipPointer === false) {
            return;
        }
        this.updateTipPosition(position);
        var leftValue;
        var topValue;
        sf.base.setStyleAttribute(this.tooltipEle, { 'display': 'block' });
        var tooltipWidth = this.tooltipEle.clientWidth;
        var tooltipHeight = this.tooltipEle.clientHeight;
        var arrowEle = sf.base.select('.' + ARROW_TIP, this.tooltipEle);
        var arrowInnerELe = sf.base.select('.' + ARROW_TIP_INNER, this.tooltipEle);
        var tipWidth = arrowEle.offsetWidth;
        var tipHeight = arrowEle.offsetHeight;
        sf.base.setStyleAttribute(this.tooltipEle, { 'display': '' });
        if (this.tipClass === TIP_BOTTOM || this.tipClass === TIP_TOP) {
            if (this.tipClass === TIP_BOTTOM) {
                topValue = '99.9%';
                sf.base.setStyleAttribute(arrowInnerELe, { 'top': ('-' + (tipHeight - 2) + 'px') });
            }
            else {
                topValue = -(tipHeight - 1) + 'px';
                sf.base.setStyleAttribute(arrowInnerELe, { 'top': ('-' + (tipHeight - 6) + 'px') });
            }
            if (target) {
                var tipPosExclude = tooltipPositionX !== 'Center' || (tooltipWidth > target.offsetWidth) ||
                    this.properties.mouseTrail;
                if ((tipPosExclude && tooltipPositionX === 'Left') || (!tipPosExclude && this.properties.tipPointerPosition === END)) {
                    leftValue = (tooltipWidth - tipWidth - POINTER_ADJUST) + 'px';
                }
                else if ((tipPosExclude && tooltipPositionX === 'Right') ||
                    (!tipPosExclude && this.properties.tipPointerPosition === START)) {
                    leftValue = POINTER_ADJUST + 'px';
                }
                else {
                    leftValue = ((tooltipWidth / 2) - (tipWidth / 2)) + 'px';
                }
            }
        }
        else {
            if (this.tipClass === TIP_RIGHT) {
                leftValue = '99.9%';
                sf.base.setStyleAttribute(arrowInnerELe, { 'left': ('-' + (tipWidth - 2) + 'px') });
            }
            else {
                leftValue = -(tipWidth - 1) + 'px';
                sf.base.setStyleAttribute(arrowInnerELe, { 'left': ((-(tipWidth) + (tipWidth - 2)) + 'px') });
            }
            var tipPosExclude = tooltipPositionY !== CENTER || (tooltipHeight > target.offsetHeight) || this.properties.mouseTrail;
            if ((tipPosExclude && tooltipPositionY === TOP) || (!tipPosExclude && this.properties.tipPointerPosition === END)) {
                topValue = (tooltipHeight - tipHeight - POINTER_ADJUST) + 'px';
            }
            else if ((tipPosExclude && tooltipPositionY === BOTTOM) || (!tipPosExclude && this.properties.tipPointerPosition === START)) {
                topValue = POINTER_ADJUST + 'px';
            }
            else {
                topValue = ((tooltipHeight / 2) - (tipHeight / 2)) + 'px';
            }
        }
        sf.base.setStyleAttribute(arrowEle, { 'top': topValue, 'left': leftValue });
    };
    SfTooltip.prototype.tooltipHover = function (e) {
        if (this.tooltipEle) {
            this.isTooltipOpen = true;
        }
    };
    SfTooltip.prototype.tooltipMouseOut = function (e) {
        this.isTooltipOpen = false;
        this.hideTooltip(this.properties.animation.close, e, this.findTarget());
    };
    SfTooltip.prototype.onMouseOut = function (e) {
        var enteredElement = e.relatedTarget;
        this.mouseAction = true;
        if (enteredElement && !this.properties.mouseTrail) {
            var checkForTooltipElement = sf.base.closest(enteredElement, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT);
            if (checkForTooltipElement) {
                sf.base.EventHandler.add(checkForTooltipElement, 'mouseleave', this.tooltipElementMouseOut, this);
            }
            else {
                this.hideTooltip(this.properties.animation.close, e, this.findTarget());
                if (this.properties.closeDelay === 0) {
                    this.clear();
                }
            }
        }
        else {
            this.hideTooltip(this.properties.animation.close, e, this.findTarget());
            this.clear();
        }
    };
    SfTooltip.prototype.tooltipElementMouseOut = function (e) {
        this.hideTooltip(this.properties.animation.close, e, this.findTarget());
        sf.base.EventHandler.remove(this.element, 'mouseleave', this.tooltipElementMouseOut);
        this.clear();
    };
    SfTooltip.prototype.onMouseMove = function (event) {
        if (!this.tooltipEle) {
            return;
        }
        var eventPageX = 0;
        var eventPageY = 0;
        if (event.type.indexOf('touch') > -1) {
            event.preventDefault();
            eventPageX = event.touches[0].pageX;
            eventPageY = event.touches[0].pageY;
        }
        else {
            eventPageX = event.pageX;
            eventPageY = event.pageY;
        }
        sf.base.Animation.stop(this.tooltipEle);
        sf.base.removeClass([this.tooltipEle], POPUP_CLOSE);
        sf.base.addClass([this.tooltipEle], POPUP_OPEN);
        this.adjustArrow(event.target, this.properties.position, this.tooltipPositionX, this.tooltipPositionY);
        var pos = this.calculateTooltipOffset(this.properties.position);
        var x = eventPageX + pos.left + this.properties.offsetX;
        var y = eventPageY + pos.top + this.properties.offsetY;
        var elePos = this.checkCollision(event.target, x, y);
        if (this.tooltipPositionX !== elePos.horizontal || this.tooltipPositionY !== elePos.vertical) {
            var newpos = (this.properties.position.indexOf(BOTTOM) === 0 || this.properties.position.indexOf(TOP) === 0) ?
                elePos.vertical + elePos.horizontal : elePos.horizontal + elePos.vertical;
            elePos.position = newpos;
            this.adjustArrow(event.target, elePos.position, elePos.horizontal, elePos.vertical);
            var colpos = this.calculateTooltipOffset(elePos.position);
            elePos.left = eventPageX + colpos.left - this.properties.offsetX;
            elePos.top = eventPageY + colpos.top - this.properties.offsetY;
        }
        sf.base.setStyleAttribute(this.tooltipEle, { 'left': (elePos.left + 'px'), 'top': (elePos.top + 'px') });
    };
    SfTooltip.prototype.keyDown = function (event) {
        if (this.tooltipEle && event.keyCode === 27) {
            this.hideTooltip(this.properties.animation.close);
        }
    };
    SfTooltip.prototype.touchEnd = function (e) {
        if (this.tooltipEle && sf.base.closest(e.target, '.' + ROOT) === null && !this.properties.isSticky) {
            this.hideTooltip(this.properties.animation.close);
        }
    };
    SfTooltip.prototype.scrollHandler = function (e) {
        if (this.tooltipEle) {
            if (!(sf.base.closest(e.target, "." + TOOLTIP_WRAP + "." + POPUP_LIB + "." + POPUP_ROOT))) {
                this.hideTooltip(this.properties.animation.close);
            }
        }
    };
    SfTooltip.prototype.renderContent = function (target) {
        var title = sf.base.getAttributeOrDefault(target, 'title', null);
        var dataTitle = sf.base.getAttributeOrDefault(target, 'data-title', null);
        if (!sf.base.isNullOrUndefined(title) && target) {
            sf.base.attributes(target, { 'data-content': title });
            this.hasTitle = true;
            this.isMultiTarget = true;
            target.removeAttribute('title');
        }
        else if (!sf.base.isNullOrUndefined(dataTitle) && target) {
            sf.base.attributes(target, { 'data-content': dataTitle });
            this.isMultiTarget = true;
        }
        if (!this.properties.content) {
            var tooltipContent = sf.base.select('.' + TIPCONTENT, this.tooltipEle);
            tooltipContent.innerText = target.getAttribute('data-content');
        }
    };
    SfTooltip.prototype.setHeigthWidth = function (widthValue, heightValue, target) {
        if (this.tooltipEle) {
            sf.base.setStyleAttribute(this.tooltipEle, { 'height': heightValue, 'width': widthValue });
        }
        if (target && this.tooltipEle.style.width !== 'auto') {
            this.tooltipEle.style.maxWidth = widthValue;
        }
    };
    SfTooltip.prototype.contentUpdated = function () {
        if (sf.base.isNullOrUndefined(this.tooltipEle)) {
            this.ctrlId = this.element.id;
            this.tooltipEle = sf.base.select('#' + this.ctrlId + CONTENT, document);
            if (this.tooltipEle) {
                sf.base.setStyleAttribute(this.tooltipEle, { 'position': 'absolute' });
                this.setHeigthWidth(sf.base.formatUnit(this.properties.width), sf.base.formatUnit(this.properties.height), this.contentTargetValue);
                if (this.contentTargetValue) {
                    if (sf.base.Browser.isDevice) {
                        sf.base.addClass([this.tooltipEle], BIGGER);
                    }
                    document.body.appendChild(this.tooltipEle);
                    sf.base.removeClass([this.tooltipEle], HIDDDEN);
                    this.addDescribedBy(this.contentTargetValue, this.ctrlId + CONTENT);
                    this.renderContent(this.contentTargetValue);
                    sf.base.addClass([this.tooltipEle], POPUP_OPEN);
                    this.renderPopup(this.contentTargetValue);
                    var pos = this.properties.position;
                    this.adjustArrow(this.contentTargetValue, pos, this.tooltipPositionX, this.tooltipPositionY);
                    sf.base.Animation.stop(this.tooltipEle);
                    this.reposition(this.contentTargetValue);
                    this.afterContentRender();
                }
            }
        }
        else {
            if (!this.isContiniousOpen || this.isRestrictUpdate) {
                return;
            }
            sf.base.addClass([this.tooltipEle], POPUP_OPEN);
            document.body.appendChild(this.tooltipEle);
            if (this.contentTargetValue) {
                this.renderPopup(this.contentTargetValue);
                var pos = this.properties.position;
                this.adjustArrow(this.contentTargetValue, pos, this.tooltipPositionX, this.tooltipPositionY);
                this.addDescribedBy(this.contentTargetValue, this.ctrlId + '_content');
                this.renderContent(this.contentTargetValue);
                sf.base.Animation.stop(this.tooltipEle);
                this.reposition(this.contentTargetValue);
                this.afterContentRender();
            }
        }
    };
    SfTooltip.prototype.afterContentRender = function () {
        sf.base.removeClass([this.tooltipEle], POPUP_OPEN);
        sf.base.addClass([this.tooltipEle], POPUP_CLOSE);
        this.tooltipEventArgs = {
            type: this.contentEvent ? this.contentEvent.type.toString() : null, isInteracted: !sf.base.isNullOrUndefined(this.contentEvent),
            hasText: this.hasText(), target: this.getDomObject('target', this.contentTargetValue), name: 'beforeOpen', cancel: false,
            event: this.contentEvent ? this.contentEvent : null, element: this.getDomObject('tooltipElement', this.tooltipEle),
            left: this.contentEvent ? this.getXYValue(this.contentEvent, 'x') : null, top: this.contentEvent ?
                this.getXYValue(this.contentEvent, 'y') : null
        };
        this.isRestrictUpdate = this.element.eventList.beforeOpen && !this.isHidden();
        this.element.eventList.beforeOpen ? this.triggerEvent('TriggerBeforeOpenEvent', this.tooltipEventArgs) :
            this.beforeOpenCallBack(false);
    };
    SfTooltip.prototype.beforeOpenCallBack = function (cancel) {
        if (cancel) {
            this.isPopupHidden = true;
            if (this.contentTargetValue) {
                this.popupHide(this.properties.animation.close, this.contentTargetValue);
            }
            this.mouseMoveBeforeRemove();
        }
        else {
            if (sf.base.isNullOrUndefined(this.contentAnimation)) {
                return;
            }
            var openAnimation = {
                name: this.contentAnimation.effect,
                duration: this.contentAnimation.duration,
                delay: this.contentAnimation.delay,
                timingFunction: 'easeOut'
            };
            if (this.contentAnimation.effect === 'None') {
                openAnimation = undefined;
            }
            if (this.popupObj) {
                this.popupObj.show(openAnimation, this.contentTargetValue);
                if (this.properties.openDelay && this.properties.mouseTrail && this.mouseMoveEvent) {
                    this.onMouseMove(this.mouseMoveEvent);
                }
            }
        }
        if (this.contentEvent) {
            this.wireMouseEvents(this.contentEvent, this.contentTargetValue);
        }
        this.contentTargetValue = this.contentEvent = this.contentAnimation = null;
    };
    SfTooltip.prototype.reposition = function (target) {
        if (target === null || !this.tooltipEle) {
            return;
        }
        var elePos = this.getTooltipPosition(target);
        if (this.popupObj) {
            this.popupObj.position = { X: elePos.left, Y: elePos.top };
            this.popupObj.dataBind();
        }
    };
    SfTooltip.prototype.renderPopup = function (target) {
        var elePos = this.properties.mouseTrail ? { top: 0, left: 0 } : this.getTooltipPosition(target);
        this.tooltipEle.classList.remove(POPUP_LIB);
        this.popupObj = new sf.popups.Popup(this.tooltipEle, {
            height: this.properties.height,
            width: this.properties.width,
            position: { X: elePos.left, Y: elePos.top },
            enableRtl: this.properties.enableRtl,
            open: this.openPopupHandler.bind(this),
            close: this.closePopupHandler.bind(this)
        });
    };
    SfTooltip.prototype.openPopupHandler = function () {
        if (this.tooltipEle && this.tooltipEle.classList.contains(POPUP_CLOSE) && this.isMultiTarget) {
            sf.base.removeClass([this.tooltipEle], POPUP_CLOSE);
            sf.base.addClass([this.tooltipEle], POPUP_OPEN);
        }
        if (!this.properties.mouseTrail) {
            this.reposition(this.findTarget());
        }
        this.tooltipEventArgs.name = 'Opened';
        this.isRestrictUpdate = this.element.eventList.opened && !this.isHidden();
        if (this.element.eventList.opened) {
            this.triggerEvent('TriggerOpenedEvent', this.tooltipEventArgs);
        }
        if (this.mouseAction && !sf.base.isNullOrUndefined(this.tooltipEle)) {
            this.hideTooltip(this.properties.animation.close);
        }
    };
    SfTooltip.prototype.closePopupHandler = function () {
        this.clear();
        this.tooltipEventArgs.name = 'Closed';
        this.isRestrictUpdate = this.element.eventList.closed && !this.isHidden();
        if (this.element.eventList.closed) {
            this.triggerEvent('TriggerClosedEvent', this.tooltipEventArgs);
        }
    };
    SfTooltip.prototype.getTooltipPosition = function (target) {
        sf.base.setStyleAttribute(this.tooltipEle, { 'display': 'block' });
        var pos = sf.popups.calculatePosition(target, this.tooltipPositionX, this.tooltipPositionY);
        var offsetPos = this.calculateTooltipOffset(this.properties.position);
        var elePos = this.collisionFlipFit(target, pos.left + offsetPos.left, pos.top + offsetPos.top);
        sf.base.setStyleAttribute(this.tooltipEle, { 'display': '' });
        return elePos;
    };
    SfTooltip.prototype.getDomObject = function (value, element) {
        // eslint-disable-next-line
        return element ? window.sfBlazor.getDomObject(value, element) : null;
    };
    SfTooltip.prototype.hasText = function () {
        return this.tooltipEle ? (this.tooltipEle.innerText.trim() === '' ? false : true) : false;
    };
    SfTooltip.prototype.getXYValue = function (e, direction) {
        var touchList = e.changedTouches;
        var value;
        if (direction === 'x') {
            value = touchList ? touchList[0].clientX : e.clientX;
        }
        else {
            value = touchList ? touchList[0].clientY : e.clientY;
        }
        if (!value && e.type === 'focus' && e.target) {
            var rect = e.target.getBoundingClientRect();
            value = rect ? (direction === 'x' ? rect.left : rect.top) : null;
        }
        return Math.ceil(value);
    };
    SfTooltip.prototype.destroy = function () {
        if (this.tooltipEle) {
            var placeholder = sf.base.select('#' + this.ctrlId + PLACEHOLDER, document);
            if (placeholder) {
                placeholder.appendChild(this.tooltipEle);
            }
        }
        if (this.popupObj) {
            this.popupObj.destroy();
        }
        sf.base.removeClass([this.element], ROOT);
        this.unwireEvents(this.properties.opensOn);
        this.unwireMouseEvents(this.element);
        this.tooltipEle = null;
        this.popupObj = null;
    };
    return SfTooltip;
}());
// eslint-disable-next-line
var Tooltip = {
    wireEvents: function (element, dotnetRef, properties, eventList) {
        this.updateAnimation(properties.animation);
        new SfTooltip(element, dotnetRef, properties, eventList);
        if (this.isValid(element)) {
            element.blazor__instance.formatPosition();
            element.blazor__instance.wireEvents(properties.opensOn);
            sf.base.removeClass([element], [ELEMENT_HIDDNE]);
        }
    },
    contentUpdated: function (element) {
        if (this.isValid(element)) {
            element.blazor__instance.contentUpdated();
        }
    },
    updateAnimation: function (animation) {
        animation.open.duration = animation.open.duration ? animation.open.duration : undefined;
        animation.close.duration = animation.close.duration ? animation.close.duration : undefined;
    },
    beforeRenderCallBack: function (element, cancel) {
        if (this.isValid(element)) {
            element.blazor__instance.beforeRenderCallBack(cancel);
        }
    },
    beforeOpenCallBack: function (element, cancel) {
        if (this.isValid(element)) {
            element.blazor__instance.beforeOpenCallBack(cancel);
        }
    },
    beforeCloseCallBack: function (element, cancel) {
        if (this.isValid(element)) {
            element.blazor__instance.beforeCloseCallBack(cancel);
        }
    },
    showTooltip: function (element, target, animation, targetProp) {
        if (!this.isValid(element)) {
            return;
        }
        if (targetProp !== null && targetProp !== '' && sf.base.select(targetProp, element.blazor__instance.element)) {
            target = sf.base.select(targetProp, element.blazor__instance.element);
        }
        element.blazor__instance.showTooltip(target, animation, null);
    },
    hideTooltip: function (element, animation) {
        if (this.isValid(element)) {
            element.blazor__instance.hideTooltip(animation);
        }
    },
    destroy: function (element) {
        if (this.isValid(element)) {
            element.blazor__instance.destroy();
        }
    },
    refresh: function (element) {
        if (!this.isValid(element)) {
            return;
        }
        var blazInstance = element.blazor__instance;
        if (!blazInstance.isPopupHidden) {
            blazInstance.hideTooltip(blazInstance.properties.animation.close);
        }
        blazInstance.unwireEvents(blazInstance.properties.opensOn);
        blazInstance.wireEvents(blazInstance.properties.opensOn);
    },
    refreshPosition: function (element, targetEle, targetProp) {
        if (!this.isValid(element)) {
            return;
        }
        var instance = element.blazor__instance;
        if (targetEle === null) {
            targetEle = targetProp !== null && targetProp !== '' ? sf.base.select(targetProp, instance.element) : instance.element;
        }
        instance.reposition(targetEle);
    },
    updateProperties: function (element, completeProps, props) {
        if (!this.isValid(element)) {
            return;
        }
        var blazInstance = element.blazor__instance;
        var prevBlazProp = element.blazor__instance.properties;
        blazInstance.isRestrictUpdate = true;
        if (props.animation) {
            this.updateAnimation(props.animation);
        }
        this.updateAnimation(completeProps.animation);
        if (props.opensOn || !sf.base.isNullOrUndefined(props.isSticky)) {
            blazInstance.unwireEvents(blazInstance.properties.opensOn);
            blazInstance.properties = completeProps;
            blazInstance.wireEvents(blazInstance.properties.opensOn);
        }
        else {
            var target = blazInstance.findTarget();
            if (props.height || props.width) {
                blazInstance.setHeigthWidth(sf.base.formatUnit(props.width), sf.base.formatUnit(props.height), target);
            }
            else if (props.position) {
                blazInstance.isPositionUpdate = true;
            }
            else if (props.offsetX) {
                blazInstance.isOffsetXUpdate = true;
            }
            else if (props.offsetX) {
                blazInstance.isOffsetYUpdate = true;
            }
            if (blazInstance.tooltipEle) {
                if (blazInstance.isPositionUpdate) {
                    var arrowInnerELe = sf.base.select('.' + ARROW_TIP_INNER, blazInstance.tooltipEle);
                    var arrowEle = sf.base.select('.' + ARROW_TIP, blazInstance.tooltipEle);
                    sf.base.removeClass([arrowEle], [blazInstance.tipClass]);
                    blazInstance.properties = completeProps;
                    blazInstance.formatPosition();
                    blazInstance.setTipClass(props.position);
                    sf.base.addClass([arrowEle], [blazInstance.tipClass]);
                    sf.base.setStyleAttribute(arrowInnerELe, { 'top': null, 'left': null });
                }
                if (blazInstance.isOffsetXUpdate) {
                    var value = ((parseInt(blazInstance.tooltipEle.style.left, 10) + (props.offsetX - prevBlazProp.offsetX)));
                    sf.base.setStyleAttribute(blazInstance.tooltipEle, { 'left': value.toString() + 'px' });
                }
                if (blazInstance.isOffsetYUpdate) {
                    var value = ((parseInt(blazInstance.tooltipEle.style.top, 10) + (props.offsetY - prevBlazProp.offsetY)));
                    sf.base.setStyleAttribute(blazInstance.tooltipEle, { 'top': value.toString() + 'px' });
                }
                blazInstance.properties = completeProps;
                blazInstance.reposition(target);
            }
            else {
                blazInstance.properties = completeProps;
                if (blazInstance.isPositionUpdate) {
                    blazInstance.formatPosition();
                }
            }
            blazInstance.isOffsetYUpdate = false;
            blazInstance.isOffsetXUpdate = false;
            blazInstance.isPositionUpdate = false;
            blazInstance.isRestrictUpdate = false;
        }
    },
    isValid: function (element) {
        return (element && element.blazor__instance) ? true : false;
    }
};

return Tooltip;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-treeview.js":
/*!**************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-treeview.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.TreeView = (function () {
'use strict';

var LISTITEM = 'e-list-item';
var LISTWRAP = 'e-text-wrap';
var PARENTITEM = 'e-list-parent';
var HOVER = 'e-hover';
var COLLAPSIBLE = 'e-icon-collapsible';
var EXPANDABLE = 'e-icon-expandable';
var MOUSEOVER = 'mouseover';
var CLICK = 'Click';
var DBLCLICK = 'DoubleClick';
var FOCUSING = 'focus';
var BLUR = 'blur';
var MOUSEDOWN = 'mousedown';
var MOUSEOUT = 'mouseout';
var EXPANDONNONE = 'None';
var EXPANDONAUTO = 'DoubleClick';
var ICON = 'e-icons';
var CHECK = 'e-check';
var BLOCK = 'block';
var HIDDEN = 'hidden';
var NONE = 'none';
var EMPTY = '';
var DISPLAYNONE = 'e-display-none';
var ACTIVE = 'e-active';
var CONTROL = 'e-control';
var ROOT = 'e-treeview';
var FOCUS = 'e-node-focus';
var PROCESS = 'e-process';
var CHECKBOXFRAME = 'e-frame';
var CHECKBOXWRAP = 'e-checkbox-wrapper';
var CHECKBOXRIPPLE = 'e-ripple-container';
var EDITING = 'e-editing';
var INPUT = 'e-input';
var INPUTGROUP = 'e-input-group';
var DISABLED = 'e-disabled';
var TEXTWRAP = 'e-text-content';
var FULLROW = 'e-fullrow';
var DRAGITEM = 'e-drag-item';
var DROPPABLE = 'e-droppable';
var DRAGGING = 'e-dragging';
var SIBLING = 'e-sibling';
var DROPIN = 'e-drop-in';
var DROPNEXT = 'e-drop-next';
var DROPOUT = 'e-drop-out';
var NODROP = 'e-no-drop';
var RTL = 'e-rtl';
var DROPCOUNT = 'e-drop-count';
var ITEM_ANIMATION_ACTIVE = 'e-animation-active';
var ALLOWDRAGANDDROP = 'allowDragAndDrop';
var ALLOWEDITING = 'allowEditing';
var SHOWCHECKBOX = 'showCheckBox';
var ALLOWTEXTWRAP = 'allowTextWrap';
var SETDISABLED = 'disabled';
var DRAGAREA = 'dragArea';
var CSSCLASS = 'cssClass';
var ANIMATION = 'animation';
var EXPANDONTYPE = 'expandOnType';
var ENABLERTL = 'enableRtl';
var DISABLE = 'e-disable';
var RIPPLE = 'e-ripple';
var RIPPLEELMENT = 'e-ripple-element';
var FULLROWSELECT = 'fullRowSelect';
var FULLROWWRAP = 'e-fullrow-wrap';
var INTERACTION = 'e-interaction';
var SfTreeView = /** @class */ (function () {
    function SfTreeView(element, options, dotnetRef) {
        this.isHelperElement = true;
        this.mouseDownStatus = false;
        this.preventExpand = false;
        this.keyBoardAction = false;
        this.isNodeRendered = false;
        this.isEdited = false;
        this.element = element;
        // eslint-disable-next-line
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
        this.options = options;
    }
    SfTreeView.prototype.render = function () {
        this.dragStartAction = false;
        this.listBaseOption = {
            expandCollapse: true,
            showIcon: true,
            expandIconClass: EXPANDABLE,
            expandIconPosition: 'Left'
        };
        this.keyConfigs = {
            escape: 'escape',
            end: 'end',
            enter: 'enter',
            f2: 'f2',
            home: 'home',
            moveDown: 'downarrow',
            moveLeft: 'leftarrow',
            moveRight: 'rightarrow',
            moveUp: 'uparrow',
            ctrlDown: 'ctrl+downarrow',
            ctrlUp: 'ctrl+uparrow',
            ctrlEnter: 'ctrl+enter',
            ctrlHome: 'ctrl+home',
            ctrlEnd: 'ctrl+end',
            ctrlA: 'ctrl+A',
            shiftDown: 'shift+downarrow',
            shiftUp: 'shift+uparrow',
            shiftEnter: 'shift+enter',
            shiftHome: 'shift+home',
            shiftEnd: 'shift+end',
            csDown: 'ctrl+shift+downarrow',
            csUp: 'ctrl+shift+uparrow',
            csEnter: 'ctrl+shift+enter',
            csHome: 'ctrl+shift+home',
            csEnd: 'ctrl+shift+end',
            space: 'space'
        };
        this.animationObj = new sf.base.Animation({});
        this.setDisabledMode(this.options.disabled);
        this.setMultiSelect(this.options.allowMultiSelection);
        if (this.options.hasTemplate) {
            this.element.classList.add(INTERACTION);
        }
    };
    SfTreeView.prototype.setDisabledMode = function (isEnabled) {
        this.setDragAndDrop(this.options.allowDragAndDrop);
        this.wireEditingEvents(this.options.allowEditing);
        this.checkAllDisabled(isEnabled);
        if (isEnabled) {
            this.unWireEvents();
        }
        else {
            this.wireEvents();
        }
    };
    SfTreeView.prototype.checkAllDisabled = function (isDisabled) {
        isDisabled ? this.element.classList.add(DISABLED) : this.element.classList.remove(DISABLED);
    };
    SfTreeView.prototype.setEnableRtl = function () {
        (this.options.enableRtl ? sf.base.addClass : sf.base.removeClass)([this.element], RTL);
    };
    SfTreeView.prototype.updateWrap = function (ulEle) {
        if (!this.options.fullRowSelect) {
            return;
        }
        var liEle = sf.base.selectAll('li', ulEle ? ulEle : this.element);
        var length = liEle.length;
        for (var i = 0; i < length; i++) {
            var element = sf.base.select('.' + FULLROW, liEle[i]);
            if (element && element.nextElementSibling) {
                element.style.height = this.options.allowTextWrap ? element.nextElementSibling.offsetHeight + 'px' : '';
            }
        }
    };
    SfTreeView.prototype.setTextWrap = function () {
        if (this.options.allowTextWrap && !this.element.classList.contains(LISTWRAP)) {
            sf.base.addClass([this.element], LISTWRAP);
        }
        else if (!this.options.allowTextWrap && this.element.classList.contains(LISTWRAP)) {
            sf.base.removeClass([this.element], LISTWRAP);
        }
        this.updateWrap();
    };
    SfTreeView.prototype.mouseDownHandler = function (e) {
        this.mouseDownStatus = true;
        if (e.shiftKey || e.ctrlKey) {
            e.preventDefault();
        }
        if (e.ctrlKey && this.options.allowMultiSelection) {
            sf.base.EventHandler.add(this.element, 'contextmenu', this.preventContextMenu, this);
        }
    };
    SfTreeView.prototype.onMouseLeave = function (e) {
        this.removeHover();
    };
    SfTreeView.prototype.unWireEvents = function () {
        this.wireClickEvent(false);
        this.wireExpandOnEvent(false);
        sf.base.EventHandler.remove(this.element, MOUSEDOWN, this.mouseDownHandler);
        sf.base.EventHandler.remove(this.element, FOCUSING, this.focusIn);
        sf.base.EventHandler.remove(this.element, BLUR, this.focusOut);
        sf.base.EventHandler.remove(this.element, MOUSEOVER, this.onMouseOver);
        sf.base.EventHandler.remove(this.element, MOUSEOUT, this.onMouseLeave);
        if (!this.options.disabled && this.keyboardModule) {
            this.keyboardModule.destroy();
        }
    };
    SfTreeView.prototype.keyboardActionHandler = function (e) {
        this.keyAction = e;
        var target = e.target;
        var focusedNode = this.getFocusedNode();
        if (target && target.classList.contains(INPUT)) {
            var inpEle = target;
            if (e.action === 'enter') {
                inpEle.blur();
                this.element.focus();
                sf.base.addClass([focusedNode], HOVER);
            }
            else if (e.action === 'escape') {
                inpEle.value = this.oldText;
                inpEle.blur();
                this.element.focus();
                sf.base.addClass([focusedNode], HOVER);
            }
            return;
        }
        e.preventDefault();
        var eventArgs = {
            cancel: false,
            event: e
        };
        var id = focusedNode.getAttribute('data-uid');
        this.dotNetRef.invokeMethodAsync('TriggerKeyboardEvent', eventArgs, id, e.action, e.key);
    };
    SfTreeView.prototype.setMultiSelect = function (isEnabled) {
        this.options.allowMultiSelection = isEnabled;
        if (isEnabled) {
            this.element.setAttribute('aria-multiselectable', 'true');
        }
        else {
            this.element.removeAttribute('aria-multiselectable');
        }
    };
    SfTreeView.prototype.setCssClass = function (cssClass) {
        if (this.options.cssClass) {
            sf.base.removeClass([this.element], this.options.cssClass.split(' '));
        }
        if (cssClass) {
            sf.base.addClass([this.element], cssClass.split(' '));
        }
        this.options.cssClass = cssClass;
    };
    SfTreeView.prototype.wireEditingEvents = function (toBind) {
        var _this_1 = this;
        if (toBind && !this.options.disabled) {
            // eslint-disable-next-line
            var proxy_1 = this;
            this.touchEditObj = new sf.base.Touch(this.element, {
                tap: function (e) {
                    if (_this_1.isDoubleTapped(e) && e.tapCount === 2) {
                        e.originalEvent.preventDefault();
                        proxy_1.editingHandler(e.originalEvent);
                    }
                }
            });
        }
        else if (this.touchEditObj) {
            this.touchEditObj.destroy();
        }
    };
    SfTreeView.prototype.setDragAndDrop = function (toBind) {
        if (toBind && !this.options.disabled) {
            this.initializeDrag();
        }
        else {
            this.destroyDrag();
        }
    };
    SfTreeView.prototype.setDragArea = function (dragArea) {
        if (this.options.allowDragAndDrop) {
            this.dragObj.dragArea = dragArea;
        }
    };
    SfTreeView.prototype.destroyDrag = function () {
        if (this.dragObj && this.dropObj) {
            this.dragObj.destroy();
            this.dropObj.destroy();
        }
    };
    SfTreeView.prototype.initializeDrag = function () {
        var _this_1 = this;
        var virtualEle;
        this.dragObj = new sf.base.Draggable(this.element, {
            enableTailMode: true, enableAutoScroll: true,
            dragArea: this.options.dropArea,
            dragTarget: '.' + TEXTWRAP,
            helper: function (e) {
                _this_1.dragTarget = e.sender.target;
                var dragRoot = sf.base.closest(_this_1.dragTarget, '.' + ROOT);
                var dragWrap = sf.base.closest(_this_1.dragTarget, '.' + TEXTWRAP);
                _this_1.dragLi = sf.base.closest(_this_1.dragTarget, '.' + LISTITEM);
                if (_this_1.options.fullRowSelect && !dragWrap && _this_1.dragTarget.classList.contains(FULLROW)) {
                    dragWrap = _this_1.dragTarget.nextElementSibling;
                }
                if (!_this_1.dragTarget || !e.element.isSameNode(dragRoot) || !dragWrap ||
                    _this_1.dragTarget.classList.contains(ROOT) || _this_1.dragTarget.classList.contains(PARENTITEM) ||
                    _this_1.dragTarget.classList.contains(LISTITEM) || _this_1.dragLi.classList.contains(DISABLE)) {
                    return false;
                }
                var cloneEle = (dragWrap.cloneNode(true));
                if (sf.base.isNullOrUndefined(sf.base.select('div.' + ICON, cloneEle))) {
                    var icon = sf.base.createElement('div', { className: ICON + ' ' + EXPANDABLE });
                    cloneEle.insertBefore(icon, cloneEle.children[0]);
                }
                var cssClass = DRAGITEM + ' ' + ROOT + ' ' + _this_1.options.cssClass + ' ' + (_this_1.options.enableRtl ? RTL : EMPTY);
                virtualEle = sf.base.createElement('div', { className: cssClass });
                virtualEle.appendChild(cloneEle);
                var selectedLI = _this_1.element.querySelectorAll('.' + ACTIVE);
                var length = selectedLI.length;
                if (length > 1 && _this_1.options.allowMultiSelection && _this_1.dragLi.classList.contains(ACTIVE)) {
                    var cNode = sf.base.createElement('span', { className: DROPCOUNT, innerHTML: EMPTY + length });
                    virtualEle.appendChild(cNode);
                }
                document.body.appendChild(virtualEle);
                document.body.style.cursor = EMPTY;
                _this_1.dragData = _this_1.getNodeData(_this_1.dragLi);
                _this_1.virtualEle = virtualEle;
                return virtualEle;
            },
            drag: function (e) {
                _this_1.dragObj.setProperties({ cursorAt: { top: (!sf.base.isNullOrUndefined(e.event.targetTouches) || sf.base.Browser.isDevice) ? 60 : -20 } });
                _this_1.dragAction(e, virtualEle);
            },
            dragStart: function (e) {
                sf.base.addClass([_this_1.element], DRAGGING);
                var listItem = sf.base.closest(e.target, LISTITEM);
                var level;
                if (listItem) {
                    level = parseInt(listItem.getAttribute('aria-level'), 10);
                }
                var eventArgs = _this_1.getDragEvent(e.event, _this_1, null, e.target, null, virtualEle, level);
                if (eventArgs.draggedNode.classList.contains(EDITING)) {
                    _this_1.dragObj.intDestroy(e.event);
                    _this_1.dragCancelAction(virtualEle);
                }
                else {
                    _this_1.dragStartEventArgs = e;
                    var left = _this_1.getXYValue(e.event, 'X');
                    var top_1 = _this_1.getXYValue(e.event, 'Y');
                    virtualEle.style.display = NONE;
                    _this_1.dotNetRef.invokeMethodAsync('TriggerDragStartEvent', _this_1.updateObjectValues(eventArgs), left, top_1);
                }
            },
            dragStop: function (e) {
                sf.base.removeClass([_this_1.element], DRAGGING);
                _this_1.removeVirtualEle();
                var dropTarget = e.target;
                var preventTargetExpand = false;
                _this_1.dropRoot = (sf.base.closest(dropTarget, '.' + DROPPABLE));
                _this_1.isHelperElement = true;
                if (!dropTarget || !_this_1.dropRoot) {
                    sf.base.remove(e.helper);
                    document.body.style.cursor = EMPTY;
                    _this_1.isHelperElement = false;
                }
                var listItem = sf.base.closest(dropTarget, LISTITEM);
                var level;
                if (listItem) {
                    level = parseInt(listItem.getAttribute('aria-level'), 10);
                }
                var dropEle = dropTarget;
                var eventArgs = _this_1.getDragEvent(e.event, _this_1, dropTarget, dropEle, null, e.helper, level);
                _this_1.dragStopEventArgs = e;
                eventArgs.preventTargetExpand = preventTargetExpand;
                var left = _this_1.getXYValue(e.event, 'X');
                var top = _this_1.getXYValue(e.event, 'Y');
                if (sf.base.isNullOrUndefined(eventArgs.dropIndicator)) {
                    eventArgs.dropIndicator = NODROP;
                    document.body.style.cursor = 'not-allowed';
                }
                _this_1.dotNetRef.invokeMethodAsync('TriggerDragStopEvent', _this_1.updateObjectValues(eventArgs), left, top);
            }
        });
        this.dropObj = new sf.base.Droppable(this.element, {
            out: function (e) {
                if (!sf.base.isNullOrUndefined(e) && !e.target.classList.contains(SIBLING)) {
                    document.body.style.cursor = 'not-allowed';
                }
            },
            over: function (e) {
                document.body.style.cursor = EMPTY;
            }
        });
    };
    SfTreeView.prototype.updateObjectValues = function (evtArgs) {
        /* tslint:disable:no-string-literal */
        evtArgs['clonedNode'] = null;
        evtArgs['draggedNode'] = null;
        evtArgs['draggedParentNode'] = null;
        evtArgs['dropTarget'] = null;
        evtArgs['droppedNode'] = null;
        evtArgs['target'] = null;
        /* tslint:enable:no-string-literal */
        return evtArgs;
    };
    SfTreeView.prototype.dragNodeStop = function (eventArgs) {
        this.dragParent = eventArgs.draggedParentNode;
        this.preventExpand = eventArgs.preventTargetExpand;
        if (eventArgs.cancel || eventArgs.dropIndicator == NODROP) {
            if (this.dragStopEventArgs.helper.parentNode) {
                sf.base.remove(this.dragStopEventArgs.helper);
            }
            document.body.style.cursor = '';
            this.isHelperElement = false;
        }
        this.dragStartAction = false;
        if (this.isHelperElement) {
            this.dropAction(this.dragStopEventArgs, true);
        }
    };
    SfTreeView.prototype.dragStartActionContinue = function (cancel) {
        if (cancel) {
            this.dragObj.intDestroy(this.dragStartEventArgs.event);
            this.dragCancelAction(this.virtualEle);
        }
        else {
            this.virtualEle.style.display = BLOCK;
            this.dragStartAction = true;
            this.dragStartEventArgs.bindEvents(sf.base.getElement(this.dragStartEventArgs.dragElement));
        }
    };
    SfTreeView.prototype.getId = function (ele) {
        if (sf.base.isNullOrUndefined(ele)) {
            return null;
        }
        else if (typeof ele === 'string') {
            return ele;
        }
        else if (typeof ele === 'object') {
            return (sf.base.getElement(ele)).getAttribute('data-uid');
        }
        else {
            return null;
        }
    };
    // eslint-disable-next-line
    SfTreeView.prototype.getOffsetValue = function (e, direction) {
        var value;
        var classList = e.target.classList;
        if (sf.base.Browser.info.name === 'mozilla' && !sf.base.isNullOrUndefined(classList)) {
            var rect = e.target.getBoundingClientRect();
            value = Math.ceil((direction === 'Y') ? (e.event.clientY - rect.top) : (e.event.clientX - rect.left));
        }
        else {
            value = (direction === 'Y') ? e.event.offsetY : e.event.offsetX;
        }
        return value;
    };
    // eslint-disable-next-line
    SfTreeView.prototype.dropAction = function (e, isBlazorDrop) {
        var offsetY = this.getOffsetValue(e, 'Y');
        var dropTarget = e.target;
        var dragObj;
        var level;
        var drop = false;
        if (!isBlazorDrop) {
            dragObj = e.dragData.draggable.blazor__instance;
        }
        else {
            dragObj = e.element.blazor__instance;
        }
        if (dragObj && dragObj.dragTarget) {
            var dragTarget = dragObj.dragTarget;
            var dragLi = (sf.base.closest(dragTarget, '.' + LISTITEM));
            var dropLi = (sf.base.closest(dropTarget, '.' + LISTITEM));
            if (dropLi == null && dropTarget.classList.contains(ROOT)) {
                dropLi = dropTarget.firstElementChild;
            }
            if (!isBlazorDrop) {
                sf.base.remove(e.droppedElement);
            }
            else {
                sf.base.remove(e.helper);
            }
            document.body.style.cursor = EMPTY;
            if (!dropLi || dropLi.isSameNode(dragLi) || this.isDescendant(dragLi, dropLi)) {
                return;
            }
            if (dragObj.allowMultiSelection && dragLi.classList.contains(ACTIVE)) {
                var sNodes = sf.base.selectAll('.' + ACTIVE, dragObj.element);
                if (e.target.offsetHeight <= 33 && offsetY > e.target.offsetHeight - 10 && offsetY > 6) {
                    for (var i = sNodes.length - 1; i >= 0; i--) {
                        if (dropLi.isSameNode(sNodes[i]) || this.isDescendant(sNodes[i], dropLi)) {
                            continue;
                        }
                        this.appendNode(dropTarget, sNodes[i], dropLi, e, dragObj, offsetY);
                    }
                }
                else {
                    for (var i = 0; i < sNodes.length; i++) {
                        if (dropLi.isSameNode(sNodes[i]) || this.isDescendant(sNodes[i], dropLi)) {
                            continue;
                        }
                        this.appendNode(dropTarget, sNodes[i], dropLi, e, dragObj, offsetY);
                    }
                }
            }
            else {
                this.appendNode(dropTarget, dragLi, dropLi, e, dragObj, offsetY);
            }
            level = parseInt(dragLi.getAttribute('aria-level'), 10);
            drop = true;
        }
        var element = isBlazorDrop ? e.element : e.dragData.draggedElement;
        var eventArgs = this.getDragEvent(e.event, dragObj, dropTarget, e.target, element, null, level, drop);
        var left = this.getXYValue(e.event, 'X');
        var top = this.getXYValue(e.event, 'Y');
        this.dotNetRef.invokeMethodAsync('TriggerNodeDropped', this.updateObjectValues(eventArgs), left, top);
    };
    SfTreeView.prototype.isDoubleTapped = function (e) {
        var target = e.originalEvent.target;
        var secondTap;
        if (target && e.tapCount) {
            if (e.tapCount === 1) {
                this.firstTap = sf.base.closest(target, '.' + LISTITEM);
            }
            else if (e.tapCount === 2) {
                secondTap = sf.base.closest(target, '.' + LISTITEM);
            }
        }
        return (this.firstTap === secondTap);
    };
    SfTreeView.prototype.isDescendant = function (parent, child) {
        var node = child.parentNode;
        while (!sf.base.isNullOrUndefined(node)) {
            if (node === parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    SfTreeView.prototype.appendNode = function (dropTarget, dragLi, dropLi, e, dragObj, offsetY) {
        var checkContainer = sf.base.closest(dropTarget, '.' + CHECKBOXWRAP);
        var collapse = sf.base.closest(e.target, '.' + COLLAPSIBLE);
        var expand = sf.base.closest(e.target, '.' + EXPANDABLE);
        var offsetX = this.getOffsetValue(e, 'X');
        if (!dragLi.classList.contains(DISABLE) && !checkContainer && ((expand && offsetY < 5) || (collapse && offsetX < 3)
            || (expand && offsetY > 19) || (collapse && offsetX > 19) || (!expand && !collapse))) {
            if (dropTarget.nodeName === 'LI') {
                this.dropAsSiblingNode(dragLi, dropLi, e, dragObj);
            }
            else if (dropTarget.firstElementChild && dropTarget.classList.contains(ROOT)) {
                if (dropTarget.firstElementChild.nodeName === 'UL') {
                    this.dropAsSiblingNode(dragLi, dropLi, e, dragObj);
                }
            }
            else if ((dropTarget.classList.contains(COLLAPSIBLE)) || (dropTarget.classList.contains(EXPANDABLE))) {
                this.dropAsSiblingNode(dragLi, dropLi, e, dragObj);
            }
            else {
                this.dropAsChildNode(dragLi, dropLi, dragObj, null, e, offsetY);
            }
        }
        else {
            this.dropAsChildNode(dragLi, dropLi, dragObj, null, e, offsetY, true);
        }
    };
    SfTreeView.prototype.dropAsSiblingNode = function (dragLi, dropLi, e, dragObj) {
        var dropUl = sf.base.closest(dropLi, '.' + PARENTITEM);
        var dragParentUl = sf.base.closest(dragLi, '.' + PARENTITEM);
        var dragParentLi = sf.base.closest(dragParentUl, '.' + LISTITEM);
        var dropParentLi = sf.base.closest(dropUl, '.' + LISTITEM);
        var dropParentLiId = null;
        var dragParentLiId = null;
        var pre;
        // eslint-disable-next-line
        var offsetX = this.getOffsetValue(e, 'X');
        // eslint-disable-next-line
        var offsetY = this.getOffsetValue(e, 'Y');
        if (e.target.offsetHeight > 0 && offsetY > e.target.offsetHeight - 2) {
            pre = false;
        }
        else if (offsetY < 2) {
            pre = true;
        }
        else if (e.target.classList.contains(EXPANDABLE) || (e.target.classList.contains(COLLAPSIBLE))) {
            if ((offsetY < 5) || (offsetX < 3)) {
                pre = true;
            }
            else if ((offsetY > 15) || (offsetX > 17)) {
                pre = false;
            }
        }
        if (dropParentLi) {
            dropParentLiId = dropParentLi.getAttribute('data-uid');
        }
        if (dragParentLi) {
            dragParentLiId = dragParentLi.getAttribute('data-uid');
        }
        var outerDrag = this.isExternalDrop(dragLi);
        var targetControl = this.dropRoot ? this.dropRoot.blazor__instance : null;
        var droppedInstance = outerDrag ? targetControl : this;
        var eventArgs = this.getDropArgs(dragLi, dropLi, dragParentLiId, dragObj, dropParentLiId, pre);
        droppedInstance.dotNetRef.invokeMethodAsync('DropNodeAsSibling', eventArgs);
        this.updateAriaLevel(dragLi);
    };
    SfTreeView.prototype.updateAriaLevel = function (dragLi) {
        var level = this.parents(dragLi, '.' + PARENTITEM).length;
        dragLi.setAttribute('aria-level', EMPTY + level);
        this.updateChildAriaLevel(sf.base.select('.' + PARENTITEM, dragLi), level + 1);
    };
    SfTreeView.prototype.updateChildAriaLevel = function (element, level) {
        if (!sf.base.isNullOrUndefined(element)) {
            var cNodes = element.querySelectorAll('li');
            for (var i = 0, len = cNodes.length; i < len; i++) {
                var liEle = cNodes[i];
                liEle.setAttribute('aria-level', EMPTY + level);
                this.updateChildAriaLevel(sf.base.select('.' + PARENTITEM, liEle), level + 1);
            }
        }
    };
    SfTreeView.prototype.dropAsChildNode = function (dragLi, dropLi, dragObj, index, e, pos, isCheck) {
        var dragParentUl = sf.base.closest(dragLi, '.' + PARENTITEM);
        var dragParentLi = sf.base.closest(dragParentUl, '.' + LISTITEM);
        var dropParentUl = sf.base.closest(dropLi, '.' + PARENTITEM);
        var dropParentLi = sf.base.closest(dropParentUl, '.' + LISTITEM);
        var dropParentLiId = null;
        var dragParentLiId = null;
        if (dropParentLi) {
            dropParentLiId = dropParentLi.getAttribute('data-uid');
        }
        if (dragParentLi) {
            dragParentLiId = dragParentLi.getAttribute('data-uid');
        }
        var outerDrag = this.isExternalDrop(dragLi);
        var srcControl = sf.base.closest(dragLi, '.' + ROOT) ? sf.base.closest(dragLi, '.' + ROOT).blazor__instance :
            (this.element ? this.element.blazor__instance : null);
        var targetControl = this.dropRoot ? this.dropRoot.blazor__instance : null;
        var droppedInstance = outerDrag ? targetControl : this;
        var eventArgs;
        if (e && (pos < 7) && !isCheck) {
            eventArgs = this.getDropArgs(dragLi, dropLi, dragParentLiId, srcControl, dropParentLiId, true);
            droppedInstance.dotNetRef.invokeMethodAsync('DropNodeAsSibling', eventArgs);
        }
        else if (e && (e.target.offsetHeight > 0 && pos > (e.target.offsetHeight - 10)) && !isCheck) {
            eventArgs = this.getDropArgs(dragLi, dropLi, dragParentLiId, srcControl, dropParentLiId, false);
            droppedInstance.dotNetRef.invokeMethodAsync('DropNodeAsSibling', eventArgs);
        }
        else {
            eventArgs = this.getDropArgs(dragLi, dropLi, dragParentLiId, srcControl);
            droppedInstance.dotNetRef.invokeMethodAsync('DropNodeAsChild', eventArgs);
        }
        this.updateAriaLevel(dragLi);
    };
    SfTreeView.prototype.isExternalDrop = function (dragLi) {
        var isExternalDrop = false;
        var srcElement = sf.base.closest(dragLi, '.' + ROOT) ? sf.base.closest(dragLi, '.' + ROOT) : this.element;
        var targetElement = this.dropRoot;
        if ((srcElement != null && targetElement != null && !srcElement.isSameNode(targetElement))) {
            isExternalDrop = true;
        }
        return isExternalDrop;
    };
    SfTreeView.prototype.getDropArgs = function (dragLi, dropLi, dragParentLiId, treeObj, dropParentLi, pre) {
        return {
            dragLi: dragLi.getAttribute('data-uid'),
            dropLi: dropLi.getAttribute('data-uid'),
            dragParentLi: dragParentLiId,
            dropParentLi: dropParentLi,
            pre: pre,
            srcTree: treeObj.dotNetRef,
            isExternalDrag: this.isExternalDrop(dragLi)
        };
    };
    SfTreeView.prototype.dragCancelAction = function (virtualEle) {
        sf.base.detach(virtualEle);
        sf.base.removeClass([this.element], DRAGGING);
        this.dragStartAction = false;
    };
    SfTreeView.prototype.removeVirtualEle = function () {
        var sibEle = sf.base.select('.' + SIBLING);
        if (sibEle) {
            sf.base.detach(sibEle);
        }
    };
    SfTreeView.prototype.dragAction = function (e, virtualEle) {
        var dropRoot = sf.base.closest(e.target, '.' + DROPPABLE);
        var dropWrap = sf.base.closest(e.target, '.' + TEXTWRAP);
        var icon = sf.base.select('div.' + ICON, virtualEle);
        var offsetX = this.getOffsetValue(e, 'X');
        var offsetY = this.getOffsetValue(e, 'Y');
        sf.base.removeClass([icon], [DROPIN, DROPNEXT, DROPOUT, NODROP]);
        this.removeVirtualEle();
        document.body.style.cursor = EMPTY;
        var classList = e.target.classList;
        if (this.options.fullRowSelect && !dropWrap && !sf.base.isNullOrUndefined(classList) && classList.contains(FULLROW)) {
            dropWrap = e.target.nextElementSibling;
        }
        if (dropRoot) {
            var dropLi = sf.base.closest(e.target, '.' + LISTITEM);
            var checkContainer = sf.base.closest(e.target, '.' + CHECKBOXWRAP);
            var collapse = sf.base.closest(e.target, '.' + COLLAPSIBLE);
            var expand = sf.base.closest(e.target, '.' + EXPANDABLE);
            if (!dropRoot.classList.contains(ROOT) || (dropWrap &&
                (!dropLi.isSameNode(this.dragLi) && !this.isDescendant(this.dragLi, dropLi)))) {
                if ((dropLi && e && (!expand && !collapse) && (offsetY < 7) && !checkContainer) ||
                    (((expand && offsetY < 5) || (collapse && offsetX < 3)))) {
                    sf.base.addClass([icon], DROPNEXT);
                    var element = sf.base.createElement('div', { className: SIBLING });
                    var index = this.options.fullRowSelect ? (1) : (0);
                    dropLi.insertBefore(element, dropLi.children[index]);
                }
                else if ((dropLi && e && (!expand && !collapse) && (e.target.offsetHeight > 0 && offsetY >
                    (e.target.offsetHeight - 10)) && !checkContainer) || (((expand && offsetY > 19) ||
                    (collapse && offsetX > 19)))) {
                    sf.base.addClass([icon], DROPNEXT);
                    var element = sf.base.createElement('div', { className: SIBLING });
                    var index = this.options.fullRowSelect ? (2) : (1);
                    dropLi.insertBefore(element, dropLi.children[index]);
                }
                else {
                    sf.base.addClass([icon], DROPIN);
                }
            }
            else if (e.target.nodeName === 'LI' && (!dropLi.isSameNode(this.dragLi) && !this.isDescendant(this.dragLi, dropLi))) {
                sf.base.addClass([icon], DROPNEXT);
                this.renderVirtualEle(e);
            }
            else if (e.target.classList.contains(SIBLING)) {
                sf.base.addClass([icon], DROPNEXT);
            }
            else if (e.target.classList.contains(DROPPABLE)) {
                sf.base.addClass([icon], DROPIN);
            }
            else {
                sf.base.addClass([icon], DROPOUT);
            }
        }
        else {
            sf.base.addClass([icon], NODROP);
            document.body.style.cursor = 'not-allowed';
        }
        var listItem = sf.base.closest(e.target, LISTITEM);
        var level;
        if (listItem) {
            level = parseInt(listItem.getAttribute('aria-level'), 10);
        }
        var eventArgs = this.getDragEvent(e.event, this, e.target, e.target, null, virtualEle, level);
        if (eventArgs.dropIndicator) {
            sf.base.removeClass([icon], eventArgs.dropIndicator);
        }
        this.iconElement = icon;
        this.draggingEventArgs = eventArgs;
        var left = this.getXYValue(e.event, 'X');
        var top = this.getXYValue(e.event, 'Y');
        this.dotNetRef.invokeMethodAsync('TriggerNodeDraggingEvent', this.updateObjectValues(eventArgs), left, top);
    };
    SfTreeView.prototype.nodeDragging = function (eventArgs) {
        if (this.draggingEventArgs.dropIndicator) {
            sf.base.addClass([this.iconElement], this.draggingEventArgs.dropIndicator);
        }
    };
    SfTreeView.prototype.renderVirtualEle = function (e) {
        // eslint-disable-next-line
        var offsetY = this.getOffsetValue(e, 'Y');
        var previous;
        if (offsetY > e.target.offsetHeight - 2) {
            previous = false;
        }
        else if (offsetY < 2) {
            previous = true;
        }
        var element = sf.base.createElement('div', { className: SIBLING });
        var index = this.options.fullRowSelect ? (previous ? 1 : 2) : (previous ? 0 : 1);
        e.target.insertBefore(element, e.target.children[index]);
    };
    SfTreeView.prototype.parents = function (element, selector) {
        var matched = [];
        var node = element.parentNode;
        while (!sf.base.isNullOrUndefined(node)) {
            if (sf.base.matches(node, selector)) {
                matched.push(node);
            }
            node = node.parentNode;
        }
        return matched;
    };
    SfTreeView.prototype.getDragEvent = function (event, obj, dropTarget, target, dragNode, cloneEle, level, drop) {
        var dropLi = dropTarget ? sf.base.closest(dropTarget, '.' + LISTITEM) : null;
        // eslint-disable-next-line
        var dropData = dropLi ? this.getNodeData(dropLi) : null;
        var draggedNode = obj ? obj.dragLi : dragNode;
        // eslint-disable-next-line
        var draggedNodeData = obj ? obj.dragData : null;
        var newParent = dropTarget ? this.parents(dropTarget, '.' + LISTITEM) : null;
        var dragLiParent = obj.dragLi.parentElement;
        var dragParent = obj.dragLi ? sf.base.closest(dragLiParent, '.' + LISTITEM) : null;
        var targetParent = null;
        var indexValue = null;
        var iconCss = [DROPNEXT, DROPIN, DROPOUT, NODROP];
        var iconClass = null;
        var node = drop ? draggedNode : dropLi;
        var index = node ? sf.base.closest(node, '.e-list-parent') : null;
        var i = 0;
        dragParent = (obj.dragLi && dragParent === null) ? sf.base.closest(dragLiParent, '.' + ROOT) : dragParent;
        dragParent = drop ? this.dragParent : dragParent;
        if (cloneEle) {
            while (i < 4) {
                if (sf.base.select('.' + ICON, cloneEle).classList.contains(iconCss[i])) {
                    iconClass = iconCss[i];
                    break;
                }
                i++;
            }
        }
        if (index) {
            var dropTar = 0;
            for (i = 0; i < index.childElementCount; i++) {
                dropTar = (!drop && index.children[i] === draggedNode && dropLi !== draggedNode) ? ++dropTar : dropTar;
                if ((!drop && index.children[i].classList.contains('e-hover'))) {
                    indexValue = (event.offsetY >= 23) ? i + 1 : i;
                    break;
                }
                else if (index.children[i] === node) {
                    indexValue = (event.offsetY >= 23) ? i : i;
                    break;
                }
            }
            indexValue = (dropTar !== 0) ? --indexValue : indexValue;
        }
        if (dropTarget) {
            if (newParent.length === 0) {
                targetParent = null;
            }
            else if (dropTarget.classList.contains(LISTITEM)) {
                targetParent = newParent[0];
            }
            else {
                targetParent = newParent[1];
            }
        }
        if (dropLi === draggedNode) {
            targetParent = dropLi;
        }
        if (dropTarget && target.offsetHeight <= 33 && event.offsetY < target.offsetHeight - 10 && event.offsetY > 6) {
            targetParent = dropLi;
            if (!drop) {
                level = ++level;
                var parent_1 = targetParent ? sf.base.select('.e-list-parent', targetParent) : null;
                indexValue = (parent_1) ? parent_1.children.length : 0;
            }
        }
        return {
            cancel: false,
            clonedNode: cloneEle,
            event: event,
            draggedNode: draggedNode,
            draggedNodeData: draggedNodeData,
            droppedNode: dropLi,
            droppedNodeData: dropData,
            dropIndex: indexValue,
            dropLevel: level,
            draggedParentNode: dragParent,
            dropTarget: targetParent,
            dropIndicator: iconClass,
            target: target
        };
    };
    SfTreeView.prototype.editingHandler = function (e) {
        var target = e.target;
        if (!target || target.classList.contains(ROOT) || target.classList.contains(PARENTITEM) ||
            target.classList.contains(LISTITEM) || target.classList.contains(ICON) ||
            target.classList.contains(INPUT) || target.classList.contains(INPUTGROUP)) {
            return;
        }
        else {
            this.createTextbox(sf.base.closest(target, '.' + LISTITEM), e);
        }
    };
    SfTreeView.prototype.createTextbox = function (liEle, e) {
        this.editEventArgs = this.getEditEvent(liEle, null, null);
        this.isEdited = true;
        this.dotNetRef.invokeMethodAsync('TriggerNodeEditingEvent', this.editEventArgs);
    };
    SfTreeView.prototype.getEditEvent = function (liEle, newText, inputEle) {
        // eslint-disable-next-line
        var data = this.getNodeData(liEle);
        return { newText: newText, nodeData: data, oldText: this.oldText, innerHtml: inputEle };
    };
    SfTreeView.prototype.focusIn = function () {
        if (!this.mouseDownStatus) {
            sf.base.addClass([this.getFocusedNode()], HOVER);
        }
        this.mouseDownStatus = false;
    };
    SfTreeView.prototype.focusOut = function () {
        sf.base.removeClass([this.getFocusedNode()], HOVER);
    };
    SfTreeView.prototype.wireEvents = function () {
        if (!this.options.disabled) {
            this.setExpandOnType();
            sf.base.EventHandler.add(this.element, MOUSEDOWN, this.mouseDownHandler, this);
            sf.base.EventHandler.add(this.element, MOUSEOVER, this.onMouseOver, this);
            sf.base.EventHandler.add(this.element, FOCUSING, this.focusIn, this);
            sf.base.EventHandler.add(this.element, BLUR, this.focusOut, this);
            sf.base.EventHandler.add(this.element, MOUSEOUT, this.onMouseLeave, this);
            if (this.options.showCheckBox) {
                var frame = sf.base.select('.' + CHECKBOXFRAME, this.element);
                if (!sf.base.isNullOrUndefined(frame)) {
                    sf.base.EventHandler.add(frame, 'mousedown', this.frameMouseHandler, this);
                    sf.base.EventHandler.add(frame, 'mouseup', this.frameMouseHandler, this);
                }
            }
            this.wireClickEvent(true);
            if (this.options.expandOnType !== EXPANDONNONE) {
                this.wireExpandOnEvent(true);
            }
            this.keyboardModule = new sf.base.KeyboardEvents(this.element, {
                keyAction: this.keyboardActionHandler.bind(this),
                keyConfigs: this.keyConfigs,
                eventName: 'keydown'
            });
        }
    };
    SfTreeView.prototype.frameMouseHandler = function (e) {
        var rippleSpan = sf.base.select('.' + CHECKBOXRIPPLE, e.target.parentElement);
        this.rippleMouseHandler(e, rippleSpan);
    };
    SfTreeView.prototype.rippleMouseHandler = function (e, rippleSpan) {
        if (rippleSpan) {
            var event_1 = document.createEvent('MouseEvents');
            event_1.initEvent(e.type, false, true);
            rippleSpan.dispatchEvent(event_1);
        }
    };
    SfTreeView.prototype.setExpandOnType = function () {
        var expandOnType = this.options.expandOnType;
        this.options.expandOnType = (expandOnType === EXPANDONAUTO) ? (sf.base.Browser.isDevice ? CLICK : DBLCLICK) : expandOnType;
    };
    SfTreeView.prototype.expandHandler = function (e) {
        var target = e.originalEvent.target;
        if (!target || target.classList.contains(INPUT) || target.classList.contains(ROOT) ||
            target.classList.contains(PARENTITEM) || target.classList.contains(LISTITEM) ||
            target.classList.contains(ICON) || this.options.showCheckBox && sf.base.closest(target, '.' + CHECKBOXWRAP)) {
            return;
        }
        else {
            this.expandCollapseAction(sf.base.closest(target, '.' + LISTITEM), e);
        }
    };
    SfTreeView.prototype.expandCollapseAction = function (currLi, e) {
        var icon = sf.base.select('div.' + ICON, currLi);
        if (!icon || icon.classList.contains(PROCESS)) {
            return;
        }
        else {
            var classList = icon.classList;
            if (classList.contains(EXPANDABLE)) {
                this.expandAction(currLi, e);
            }
            else if (classList.contains(COLLAPSIBLE)) {
                this.collapseAction(currLi, e, false);
            }
        }
    };
    SfTreeView.prototype.animateHeight = function (args, start, end) {
        var remaining = (args.duration - args.timeStamp) / args.duration;
        var currentHeight = (end - start) * remaining + start;
        args.element.parentElement.style.height = currentHeight + 'px';
    };
    SfTreeView.prototype.expandAction = function (currLi, e) {
        this.expandArgs = this.getExpandEvent(currLi, e);
        if (this.options.allowTextWrap) {
            var ul = sf.base.select('.' + PARENTITEM, currLi);
            this.isNodeRendered = ul ? true : false;
        }
        if (currLi && currLi.classList.contains(PROCESS)) {
            sf.base.removeClass([currLi], PROCESS);
        }
        this.dotNetRef.invokeMethodAsync('TriggerNodeExpandingEvent', this.expandArgs);
    };
    SfTreeView.prototype.collapseAction = function (currLi, e, fromClickHandler) {
        this.expandArgs = this.getExpandEvent(currLi, e);
        var start = 0;
        var end = 0;
        // eslint-disable-next-line
        var proxy = this;
        var ul = sf.base.select('.' + PARENTITEM, currLi);
        var liEle = currLi;
        var activeElement = sf.base.select('.' + LISTITEM + '.' + ACTIVE, currLi);
        if (ul) {
            var icon = sf.base.select('div.' + ICON, liEle);
            sf.base.removeClass([icon], COLLAPSIBLE);
            sf.base.addClass([icon], EXPANDABLE);
        }
        if (!sf.base.isNullOrUndefined(currLi.getAttribute("aria-expanded"))) {
            currLi.setAttribute("aria-expanded", "false");
        }
        if (this.options.animation.collapse.duration === 0) {
            ul.style.display = NONE;
            proxy.dotNetRef.invokeMethodAsync('TriggerNodeCollapsingEvent', proxy.expandArgs);
            if (fromClickHandler) {
                proxy.triggerClickEvent(e.originalEvent, currLi);
            }
        }
        else {
            this.animationObj.animate(ul, {
                name: this.options.animation.collapse.effect,
                duration: this.options.animation.collapse.duration,
                timingFunction: this.options.animation.collapse.easing,
                begin: function (args) {
                    liEle.style.overflow = HIDDEN;
                    if (!sf.base.isNullOrUndefined(activeElement) && activeElement instanceof HTMLElement) {
                        activeElement.classList.add(ITEM_ANIMATION_ACTIVE);
                    }
                    start = sf.base.select('.' + TEXTWRAP, currLi).offsetHeight;
                    end = liEle.offsetHeight;
                },
                progress: function (args) {
                    proxy.animateHeight(args, start, end);
                },
                end: function (args) {
                    args.element.style.display = NONE;
                    if (!sf.base.isNullOrUndefined(activeElement) && activeElement instanceof HTMLElement) {
                        activeElement.classList.remove(ITEM_ANIMATION_ACTIVE);
                    }
                    proxy.dotNetRef.invokeMethodAsync('TriggerNodeCollapsingEvent', proxy.expandArgs);
                    if (fromClickHandler) {
                        proxy.triggerClickEvent(e.originalEvent, currLi);
                    }
                }
            });
        }
    };
    SfTreeView.prototype.wireExpandOnEvent = function (toBind) {
        var _this_1 = this;
        if (toBind) {
            // eslint-disable-next-line
            var proxy_2 = this;
            this.touchExpandObj = new sf.base.Touch(this.element, {
                tap: function (e) {
                    if ((_this_1.options.expandOnType === CLICK || (_this_1.options.expandOnType === DBLCLICK
                        && _this_1.isDoubleTapped(e) && e.tapCount === 2))
                        && e.originalEvent.which !== 3) {
                        proxy_2.expandHandler(e);
                    }
                }
            });
        }
        else {
            if (this.touchExpandObj) {
                this.touchExpandObj.destroy();
            }
        }
    };
    // eslint-disable-next-line
    SfTreeView.prototype.getNodeData = function (currLi, fromDS) {
        if (!sf.base.isNullOrUndefined(currLi) && currLi.classList.contains(LISTITEM) &&
            !sf.base.isNullOrUndefined(sf.base.closest(currLi, '.' + CONTROL)) && sf.base.closest(currLi, '.' + CONTROL).classList.contains(ROOT)) {
            var id = currLi.getAttribute('data-uid');
            var pNode = sf.base.closest(currLi.parentNode, '.' + LISTITEM);
            var pid = pNode ? pNode.getAttribute('data-uid') : null;
            var selected = currLi.classList.contains(ACTIVE);
            var expanded = (currLi.getAttribute('aria-expanded') === 'true');
            var hasChildren = (currLi.getAttribute('aria-expanded') === null);
            var checked = null;
            if (this.options.showCheckBox) {
                checked = sf.base.select('.' + CHECKBOXWRAP, currLi).getAttribute('aria-checked');
            }
            return {
                id: id, text: null, parentID: pid, selected: selected, expanded: expanded,
                isChecked: checked, hasChildren: hasChildren
            };
        }
        return { id: EMPTY, text: EMPTY, parentID: EMPTY, selected: false, expanded: false, isChecked: EMPTY, hasChildren: false };
    };
    SfTreeView.prototype.getExpandEvent = function (currLi, e) {
        // eslint-disable-next-line
        var nodedata = this.getNodeData(currLi);
        return { isInteracted: !sf.base.isNullOrUndefined(e), nodeData: nodedata, event: e, isLoaded: currLi.querySelector('ul') != null ? true : false, nodeLevel: parseInt(currLi.getAttribute('aria-level'), 10) };
    };
    SfTreeView.prototype.updateSpinnerClass = function () {
        var spinnerEle = this.element.querySelector('.e-icons-spinner');
        sf.base.removeClass([spinnerEle], "e-icons-spinner");
    };
    SfTreeView.prototype.expandedNode = function (expandArgs) {
        var _this_1 = this;
        var li = this.element.querySelector('[data-uid="' + expandArgs.nodeData.id + '"]');
        this.focussedElement = li;
        var ulele = sf.base.select('.' + PARENTITEM, li);
        if (ulele) {
            ulele.classList.remove(DISPLAYNONE);
            var icon_1 = sf.base.select('div.' + ICON, li);
            this.expandArgs = this.getExpandEvent(li, expandArgs.event);
            var liEle_1 = li;
            var activeElement_1 = sf.base.select('.' + LISTITEM + '.' + ACTIVE, li);
            var start_1 = 0;
            var end_1 = 0;
            // eslint-disable-next-line
            var proxy_3 = this;
            this.setHeight(liEle_1, ulele);
            if (this.options.animation.expand.duration === 0) {
                sf.base.removeClass([icon_1], EXPANDABLE);
                sf.base.addClass([icon_1], COLLAPSIBLE);
                proxy_3.dotNetRef.invokeMethodAsync('TriggerNodeExpandedEvent', proxy_3.expandArgs);
                ulele.style.display = BLOCK;
                liEle_1.style.display = BLOCK;
                liEle_1.style.overflow = EMPTY;
                liEle_1.style.height = EMPTY;
                sf.base.removeClass([icon_1], "e-icons-spinner");
                if (this.options.allowTextWrap && (!this.isNodeRendered || this.isEdited)) {
                    this.isEdited = false;
                    this.updateWrap(ulele);
                }
            }
            else {
                this.animationObj.animate(ulele, {
                    name: this.options.animation.expand.effect,
                    duration: this.options.animation.expand.duration,
                    timingFunction: this.options.animation.expand.easing,
                    begin: function (args) {
                        liEle_1.style.overflow = HIDDEN;
                        if (!sf.base.isNullOrUndefined(activeElement_1) && activeElement_1 instanceof HTMLElement) {
                            activeElement_1.classList.add(ITEM_ANIMATION_ACTIVE);
                        }
                        start_1 = liEle_1.offsetHeight;
                        end_1 = sf.base.select('.' + TEXTWRAP, li).offsetHeight;
                    },
                    progress: function (args) {
                        sf.base.removeClass([icon_1], EXPANDABLE);
                        sf.base.addClass([icon_1], COLLAPSIBLE);
                        args.element.style.display = BLOCK;
                        proxy_3.animateHeight(args, start_1, end_1);
                    },
                    end: function (args) {
                        args.element.style.display = BLOCK;
                        if (!sf.base.isNullOrUndefined(activeElement_1) && activeElement_1 instanceof HTMLElement) {
                            activeElement_1.classList.remove(ITEM_ANIMATION_ACTIVE);
                        }
                        proxy_3.dotNetRef.invokeMethodAsync('TriggerNodeExpandedEvent', proxy_3.expandArgs);
                        ulele.style.display = BLOCK;
                        liEle_1.style.display = BLOCK;
                        liEle_1.style.overflow = EMPTY;
                        liEle_1.style.height = EMPTY;
                        sf.base.removeClass([icon_1], "e-icons-spinner");
                        if (_this_1.options.allowTextWrap && (!_this_1.isNodeRendered || _this_1.isEdited)) {
                            _this_1.isEdited = false;
                            _this_1.updateWrap(ulele);
                        }
                    }
                });
            }
        }
        this.setHover(this.getFocusedNode());
    };
    SfTreeView.prototype.setHeight = function (currli, ul) {
        ul.style.display = BLOCK;
        ul.style.visibility = HIDDEN;
        currli.style.height = currli.offsetHeight + 'px';
        ul.style.display = NONE;
        ul.style.visibility = EMPTY;
    };
    SfTreeView.prototype.collapsedNode = function (collapseArgs) {
        var li = this.element.querySelector('[data-uid="' + collapseArgs.nodeData.id + '"]');
        this.focussedElement = li;
        var ulelement = li.querySelector('ul');
        if (ulelement) {
            ulelement.style.display = NONE;
            ulelement.classList.add(DISPLAYNONE);
        }
        li.style.overflow = EMPTY;
        li.style.height = EMPTY;
        this.expandArgs = this.getExpandEvent(li, null);
        var icon = sf.base.select('div.' + ICON, li);
        sf.base.removeClass([icon], COLLAPSIBLE);
        sf.base.addClass([icon], EXPANDABLE);
        this.dotNetRef.invokeMethodAsync('TriggerNodeCollapsedEvent', this.expandArgs);
    };
    SfTreeView.prototype.preventContextMenu = function (e) {
        e.preventDefault();
    };
    SfTreeView.prototype.clickHandler = function (event) {
        var target = event.originalEvent.target;
        var isCollapsAction = false;
        sf.base.EventHandler.remove(this.element, 'contextmenu', this.preventContextMenu);
        if (!target) {
            return;
        }
        else {
            var classList = target.classList;
            var li = sf.base.closest(target, '.' + LISTITEM);
            if (!li) {
                return;
            }
            else if (event.originalEvent.which !== 3) {
                var rippleElement = sf.base.select('.' + RIPPLEELMENT, li);
                var rippleIcons = sf.base.select('.' + ICON, li);
                this.removeHover();
                this.focussedElement = li;
                this.setFocusElement(li);
                if (this.options.showCheckBox && !li.classList.contains(DISABLE)) {
                    var checkContainer = sf.base.closest(target, '.' + CHECKBOXWRAP);
                    if (!sf.base.isNullOrUndefined(checkContainer)) {
                        var checkElement = sf.base.select('.' + CHECKBOXFRAME, checkContainer);
                        this.validateCheckNode(checkContainer, checkElement.classList.contains(CHECK), li, event.originalEvent);
                        this.triggerClickEvent(event.originalEvent, li);
                        return;
                    }
                }
                if (classList.contains(EXPANDABLE)) {
                    this.expandAction(li, event);
                }
                else if (classList.contains(COLLAPSIBLE)) {
                    this.collapseAction(li, event, true);
                    isCollapsAction = true;
                }
                else if (rippleElement && rippleIcons) {
                    if (rippleIcons.classList.contains(RIPPLE) && rippleIcons.classList.contains(EXPANDABLE)) {
                        this.expandAction(li, event);
                    }
                    else if (rippleIcons.classList.contains(RIPPLE) && rippleIcons.classList.contains(COLLAPSIBLE)) {
                        this.collapseAction(li, event, true);
                        isCollapsAction = true;
                    }
                    else if (!classList.contains(PARENTITEM) && !classList.contains(LISTITEM)) {
                        this.toggleSelect(li, event.originalEvent, false);
                    }
                }
                else {
                    if (!classList.contains(PARENTITEM) && !classList.contains(LISTITEM)) {
                        this.toggleSelect(li, event.originalEvent, false);
                    }
                }
            }
            if (!isCollapsAction) {
                this.triggerClickEvent(event.originalEvent, li);
            }
        }
    };
    SfTreeView.prototype.getXYValue = function (e, direction) {
        var touchList = e.changedTouches;
        var value;
        if (direction === 'X') {
            value = touchList ? touchList[0].clientX : e.clientX;
        }
        else {
            value = touchList ? touchList[0].clientY : e.clientY;
        }
        if (!value && e.type === 'focus' && e.target) {
            var rect = e.target.getBoundingClientRect();
            value = rect ? (direction === 'X' ? rect.left : rect.top) : null;
        }
        return Math.ceil(value);
    };
    SfTreeView.prototype.triggerClickEvent = function (e, li) {
        var eventArgs = {
            event: e,
            node: null
        };
        this.dotNetRef.invokeMethodAsync('TriggerNodeClickingEvent', eventArgs, li.getAttribute('data-uid'), this.getXYValue(e, 'X'), this.getXYValue(e, 'Y'));
    };
    SfTreeView.prototype.getCheckEvent = function (currLi, action, e) {
        return { action: action, isInteracted: !sf.base.isNullOrUndefined(e), nodeData: this.getNodeData(currLi) };
    };
    SfTreeView.prototype.validateCheckNode = function (checkWrap, isCheck, li, e) {
        var currLi = sf.base.closest(checkWrap, '.' + LISTITEM);
        var ariaState = !isCheck ? 'true' : 'false';
        if (!sf.base.isNullOrUndefined(ariaState)) {
            checkWrap.setAttribute('aria-checked', ariaState);
        }
        var eventArgs = this.getCheckEvent(currLi, isCheck ? 'uncheck' : 'check', e);
        this.dotNetRef.invokeMethodAsync('TriggerNodeCheckingEvent', eventArgs);
    };
    SfTreeView.prototype.toggleSelect = function (li, e, multiSelect) {
        if (!li.classList.contains(DISABLE)) {
            if (this.options.allowMultiSelection && ((e && e.ctrlKey) || multiSelect) && this.isActive(li)) {
                this.unselectNode(li, e, multiSelect);
            }
            else {
                this.selectNode(li, e, multiSelect);
                if (this.options.allowMultiSelection && e && (e.ctrlKey || e.shiftKey)) {
                    this.setFocusElement(li);
                    this.focussedElement = li;
                }
            }
        }
    };
    SfTreeView.prototype.unselectNode = function (li, e, multiSelect) {
        var eventArgs = this.getSelectEvent(li, 'un-select', e, multiSelect, []);
        this.dotNetRef.invokeMethodAsync('TriggerNodeSelectingEvent', eventArgs);
    };
    SfTreeView.prototype.getSelectEvent = function (currLi, action, e, multiSelect, nodes) {
        // eslint-disable-next-line
        var detail = this.getNodeData(currLi);
        return { action: action, isInteracted: !sf.base.isNullOrUndefined(e), nodeData: detail,
            isMultiSelect: multiSelect, isCtrKey: !sf.base.isNullOrUndefined(e) && e.ctrlKey ? true : false, isShiftKey: !sf.base.isNullOrUndefined(e) && e.shiftKey ? true : false, nodes: nodes };
    };
    SfTreeView.prototype.selectNode = function (li, e, multiSelect) {
        if (sf.base.isNullOrUndefined(li) || (!this.options.allowMultiSelection && this.isActive(li) && !sf.base.isNullOrUndefined(e))) {
            this.setFocusElement(li);
            this.focussedElement = li;
            return;
        }
        var array = [];
        if (this.options.allowMultiSelection && e && e.shiftKey) {
            if (!this.startNode) {
                this.startNode = li;
            }
            var liList = Array.prototype.slice.call(sf.base.selectAll('.' + LISTITEM, this.element));
            var startIndex = liList.indexOf(this.startNode);
            var endIndex = liList.indexOf(li);
            if (startIndex > endIndex) {
                var temp = startIndex;
                startIndex = endIndex;
                endIndex = temp;
            }
            for (var i = startIndex; i <= endIndex; i++) {
                var currNode = liList[i];
                if (sf.base.isVisible(currNode) && !currNode.classList.contains(DISABLE)) {
                    array.push(currNode.getAttribute('data-uid'));
                }
            }
        }
        else {
            this.startNode = li;
        }
        var eventArgs = this.getSelectEvent(li, 'select', e, multiSelect, array);
        this.dotNetRef.invokeMethodAsync('TriggerNodeSelectingEvent', eventArgs);
    };
    SfTreeView.prototype.setFocusElement = function (li) {
        if (!sf.base.isNullOrUndefined(li)) {
            var focusedNode = this.getFocusedNode();
            if (focusedNode) {
                sf.base.removeClass([focusedNode], FOCUS);
            }
            sf.base.addClass([li], FOCUS);
            this.focussedElement = li;
            this.updateIdAttr(focusedNode, li);
        }
    };
    SfTreeView.prototype.updateIdAttr = function (preNode, nextNode) {
        this.element.removeAttribute('aria-activedescendant');
        if (preNode) {
            preNode.removeAttribute('id');
        }
        nextNode.setAttribute('id', this.element.id + '_active');
        this.element.setAttribute('aria-activedescendant', this.element.id + '_active');
    };
    SfTreeView.prototype.getFocusedNode = function () {
        var selectedItem;
        var fNode = this.focussedElement ? this.focussedElement :
            sf.base.select('.' + LISTITEM + '.' + FOCUS, this.element);
        if (sf.base.isNullOrUndefined(fNode)) {
            selectedItem = sf.base.select('.' + LISTITEM, this.element);
        }
        return sf.base.isNullOrUndefined(fNode) ? (sf.base.isNullOrUndefined(selectedItem) ? this.element.firstElementChild : selectedItem) : fNode;
    };
    SfTreeView.prototype.setFullRow = function (isEnabled) {
        (isEnabled ? sf.base.addClass : sf.base.removeClass)([this.element], FULLROWWRAP);
        this.options.fullRowSelect = isEnabled;
    };
    SfTreeView.prototype.isActive = function (li) {
        return li.classList.contains(ACTIVE);
    };
    SfTreeView.prototype.wireClickEvent = function (toBind) {
        if (toBind) {
            // eslint-disable-next-line
            var proxy_4 = this;
            this.touchClickObj = new sf.base.Touch(this.element, {
                tap: function (e) {
                    proxy_4.clickHandler(e);
                }
            });
        }
        else {
            if (this.touchClickObj) {
                this.touchClickObj.destroy();
            }
        }
    };
    SfTreeView.prototype.onMouseOver = function (e) {
        var target = e.target;
        var classList = target.classList;
        var currentLi = sf.base.closest(target, '.' + LISTITEM);
        if (!currentLi || classList.contains(PARENTITEM) || classList.contains(LISTITEM)) {
            this.removeHover();
            return;
        }
        else {
            if (currentLi && !currentLi.classList.contains(DISABLE)) {
                this.setHover(currentLi);
            }
        }
    };
    SfTreeView.prototype.setHover = function (li) {
        if (!li.classList.contains(HOVER)) {
            this.removeHover();
            sf.base.addClass([li], HOVER);
        }
    };
    SfTreeView.prototype.removeHover = function () {
        var hoveredNode = sf.base.selectAll('.' + HOVER, this.element);
        if (hoveredNode && hoveredNode.length) {
            sf.base.removeClass(hoveredNode, HOVER);
        }
    };
    SfTreeView.prototype.checkNode = function (e) {
        var focusedNode = this.getFocusedNode();
        var checkWrap = sf.base.select('.' + CHECKBOXWRAP, focusedNode);
        var isChecked = sf.base.select(' .' + CHECKBOXFRAME, checkWrap).classList.contains(CHECK);
        if (!focusedNode.classList.contains(DISABLE)) {
            if (focusedNode.getElementsByClassName('e-checkbox-disabled').length === 0) {
                this.validateCheckNode(checkWrap, isChecked, focusedNode, e);
            }
        }
    };
    SfTreeView.prototype.openNode = function (toBeOpened, e) {
        var focusedNode = this.getFocusedNode();
        var icon = sf.base.select('div.' + ICON, focusedNode);
        if (toBeOpened) {
            if (!icon) {
                return;
            }
            else if (icon.classList.contains(EXPANDABLE)) {
                this.expandAction(focusedNode, e);
            }
            else {
                this.focusNextNode(focusedNode, true);
            }
        }
        else {
            if (icon && icon.classList.contains(COLLAPSIBLE)) {
                this.collapseAction(focusedNode, e, false);
            }
            else {
                var parentLi = sf.base.closest(sf.base.closest(focusedNode, '.' + PARENTITEM), '.' + LISTITEM);
                if (!parentLi) {
                    return;
                }
                else {
                    if (!parentLi.classList.contains(DISABLE)) {
                        this.setNodeFocus(focusedNode, parentLi);
                        this.navigateToFocus(true);
                    }
                }
            }
        }
    };
    SfTreeView.prototype.getScrollParent = function (node) {
        if (sf.base.isNullOrUndefined(node)) {
            return null;
        }
        return (node.scrollHeight > node.clientHeight) ? node : this.getScrollParent(node.parentElement);
    };
    SfTreeView.prototype.navigateToFocus = function (isUp) {
        var focusNode = this.getFocusedNode().querySelector('.' + TEXTWRAP);
        var pos = focusNode.getBoundingClientRect();
        var parent = this.getScrollParent(this.element);
        if (!sf.base.isNullOrUndefined(parent)) {
            var parentPos = parent.getBoundingClientRect();
            if (pos.bottom > parentPos.bottom) {
                parent.scrollTop += pos.bottom - parentPos.bottom;
            }
            else if (pos.top < parentPos.top) {
                parent.scrollTop -= parentPos.top - pos.top;
            }
        }
        var isVisible$$1 = this.isVisibleInViewport(focusNode);
        if (!isVisible$$1) {
            focusNode.scrollIntoView(isUp);
        }
    };
    SfTreeView.prototype.isVisibleInViewport = function (txtWrap) {
        var pos = txtWrap.getBoundingClientRect();
        return (pos.top >= 0 && pos.left >= 0 && pos.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            pos.right <= (window.innerWidth || document.documentElement.clientWidth));
    };
    SfTreeView.prototype.setNodeFocus = function (preNode, nextNode) {
        sf.base.removeClass([preNode], [HOVER, FOCUS]);
        if (!nextNode.classList.contains(DISABLE)) {
            this.focussedElement = nextNode;
            sf.base.addClass([nextNode], [HOVER, FOCUS]);
            this.updateIdAttr(preNode, nextNode);
        }
    };
    SfTreeView.prototype.focusNextNode = function (li, isTowards) {
        var nextNode = isTowards ? this.getNextNode(li) : this.getPrevNode(li);
        this.setNodeFocus(li, nextNode);
        this.navigateToFocus(!isTowards);
        if (nextNode.classList.contains(DISABLE)) {
            var lastChild = nextNode.lastChild;
            if (nextNode.previousSibling == null && nextNode.classList.contains('e-level-1')) {
                this.focusNextNode(nextNode, true);
            }
            else if (nextNode.nextSibling == null && nextNode.classList.contains('e-node-collapsed')) {
                this.focusNextNode(nextNode, false);
            }
            else if (nextNode.nextSibling == null && lastChild.classList.contains(TEXTWRAP)) {
                this.focusNextNode(nextNode, false);
            }
            else {
                this.focusNextNode(nextNode, isTowards);
            }
        }
    };
    SfTreeView.prototype.shiftKeySelect = function (isTowards, e) {
        if (this.options.allowMultiSelection) {
            var focusedNode = this.getFocusedNode();
            var nextNode = isTowards ? this.getNextNode(focusedNode) : this.getPrevNode(focusedNode);
            this.removeHover();
            this.setFocusElement(nextNode);
            this.focussedElement = nextNode;
            this.toggleSelect(nextNode, e, false);
            this.navigateToFocus(!isTowards);
        }
        else {
            this.navigateNode(isTowards);
        }
    };
    SfTreeView.prototype.updateList = function () {
        this.liList = Array.prototype.slice.call(sf.base.selectAll('.' + LISTITEM, this.element));
    };
    SfTreeView.prototype.getNextNode = function (li) {
        var index = this.liList.indexOf(li);
        var nextNode;
        do {
            index++;
            nextNode = this.liList[index];
            if (sf.base.isNullOrUndefined(nextNode)) {
                return li;
            }
        } while (!sf.base.isVisible(nextNode));
        return nextNode;
    };
    SfTreeView.prototype.getPrevNode = function (li) {
        var index = this.liList.indexOf(li);
        var prevNode;
        do {
            index--;
            prevNode = this.liList[index];
            if (sf.base.isNullOrUndefined(prevNode)) {
                return li;
            }
        } while (!sf.base.isVisible(prevNode));
        return prevNode;
    };
    SfTreeView.prototype.getRootNode = function () {
        var index = 0;
        var rootNode;
        do {
            rootNode = this.liList[index];
            index++;
        } while (!sf.base.isVisible(rootNode));
        return rootNode;
    };
    SfTreeView.prototype.getEndNode = function () {
        var index = this.liList.length - 1;
        var endNode;
        do {
            endNode = this.liList[index];
            index--;
        } while (!sf.base.isVisible(endNode));
        return endNode;
    };
    SfTreeView.prototype.navigateNode = function (isTowards) {
        this.focusNextNode(this.getFocusedNode(), isTowards);
    };
    SfTreeView.prototype.updateOldText = function (oldText) {
        this.oldText = oldText;
    };
    SfTreeView.prototype.onPropertyChanged = function (newProp) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case SHOWCHECKBOX:
                    this.options.showCheckBox = newProp.showCheckBox;
                    break;
                case ALLOWDRAGANDDROP:
                    this.setDragAndDrop(newProp.allowDragAndDrop);
                    break;
                case ALLOWTEXTWRAP:
                    this.options.allowTextWrap = newProp.allowTextWrap;
                    this.setTextWrap();
                    break;
                case ALLOWEDITING:
                    this.wireEditingEvents(newProp.allowEditing);
                    break;
                case SETDISABLED:
                    this.options.disabled = newProp.disabled;
                    this.checkAllDisabled(newProp.disabled);
                    break;
                case DRAGAREA:
                    this.setDragArea(newProp.dropArea);
                    break;
                case CSSCLASS:
                    this.setCssClass(newProp.cssClass);
                    break;
                case FULLROWSELECT:
                    this.setFullRow(newProp.fullRowSelect);
                    break;
                case EXPANDONTYPE:
                    this.options.expandOnType = newProp.expandOnType;
                    break;
                case ENABLERTL:
                    this.options.enableRtl = newProp.enableRtl;
                    this.setEnableRtl();
                    break;
                case ANIMATION:
                    this.options.animation = newProp.animation;
            }
        }
    };
    SfTreeView.prototype.navigateRootNode = function (isBackwards) {
        var focusedNode = this.getFocusedNode();
        var rootNode = isBackwards ? this.getRootNode() : this.getEndNode();
        if (!rootNode.classList.contains(DISABLE)) {
            this.setNodeFocus(focusedNode, rootNode);
            this.navigateToFocus(isBackwards);
        }
    };
    SfTreeView.prototype.selectGivenNodes = function (sNodes) {
        for (var i = 0; i < sNodes.length; i++) {
            if (!sNodes[i].classList.contains(DISABLE)) {
                this.selectNode(sNodes[i], null, true);
            }
        }
    };
    SfTreeView.prototype.beginEdit = function (node) {
        var nodeElement = this.element.querySelector('[data-uid="' + node + '"]');
        if (sf.base.isNullOrUndefined(nodeElement) || this.options.disabled) {
            return;
        }
        this.createTextbox(nodeElement, null);
    };
    SfTreeView.prototype.ensureVisible = function (node) {
        var liEle = this.element.querySelector('[data-uid="' + node + '"]');
        if (sf.base.isNullOrUndefined(liEle)) {
            return;
        }
        var parents = this.parents(liEle, '.' + LISTITEM);
        var parentNodeId = [];
        for (var i = 0; i < parents.length; i++) {
            parentNodeId.push(parents[i].getAttribute('data-uid'));
        }
        this.dotNetRef.invokeMethodAsync('UpdateExpandedNode', parentNodeId);
        setTimeout(function () { liEle.scrollIntoView(true); }, 450);
    };
    SfTreeView.prototype.nodeCollapse = function (id) {
        var liElement = this.element.querySelector('[data-uid="' + id + '"]');
        this.collapseAction(liElement, null, false);
    };
    SfTreeView.prototype.nodeExpand = function (id) {
        var liElement = this.element.querySelector('[data-uid="' + id + '"]');
        this.expandAction(liElement, null);
    };
    SfTreeView.prototype.KeyActionHandler = function (e, nodeId) {
        this.updateList();
        var nodeElement = this.element.querySelector('[data-uid="' + nodeId + '"]');
        var focusedNode = sf.base.isNullOrUndefined(nodeElement) ? this.getFocusedNode() : nodeElement;
        switch (e.action) {
            case 'space':
                if (this.options.showCheckBox) {
                    this.checkNode(this.keyAction);
                }
                break;
            case 'moveRight':
                this.keyBoardAction = true;
                this.openNode(!this.options.enableRtl, this.keyAction);
                break;
            case 'moveLeft':
                this.keyBoardAction = true;
                this.openNode(this.options.enableRtl, this.keyAction);
                break;
            case 'shiftDown':
                this.shiftKeySelect(true, this.keyAction);
                break;
            case 'moveDown':
            case 'ctrlDown':
            case 'csDown':
                this.navigateNode(true);
                break;
            case 'shiftUp':
                this.shiftKeySelect(false, this.keyAction);
                break;
            case 'moveUp':
            case 'ctrlUp':
            case 'csUp':
                this.navigateNode(false);
                break;
            case 'home':
            case 'shiftHome':
            case 'ctrlHome':
            case 'csHome':
                this.navigateRootNode(true);
                break;
            case 'end':
            case 'shiftEnd':
            case 'ctrlEnd':
            case 'csEnd':
                this.navigateRootNode(false);
                break;
            case 'enter':
            case 'ctrlEnter':
            case 'shiftEnter':
            case 'csEnter':
                this.toggleSelect(focusedNode, this.keyAction, false);
                break;
            case 'f2':
                if (this.options.allowEditing && !focusedNode.classList.contains(DISABLE)) {
                    this.createTextbox(focusedNode, this.keyAction);
                }
                break;
            case 'ctrlA':
                if (this.options.allowMultiSelection) {
                    var sNodes = sf.base.selectAll('.' + LISTITEM + ':not(.' + ACTIVE + ')', this.element);
                    this.selectGivenNodes(sNodes);
                }
                break;
        }
        // eslint-disable-next-line
        var _this = this;
        // eslint-disable-next-line
        setTimeout(function () {
            if (_this.keyBoardAction) {
                _this.setHover(_this.getFocusedNode());
                _this.keyBoardAction = false;
            }
        }, 100);
    };
    return SfTreeView;
}());
// eslint-disable-next-line
var TreeView = {
    initialize: function (element, options, dotnetRef) {
        var instance = new SfTreeView(element, options, dotnetRef);
        instance.render();
        if (this.valid(element) && element.blazor__instance.options.allowTextWrap) {
            element.blazor__instance.updateWrap();
        }
        if (document.getElementById(element.id)) {
            instance.dotNetRef.invokeMethodAsync('CreatedEvent', null);
        }
    },
    updateTextWrap: function (element) {
        if (this.valid(element) && element.blazor__instance.options.allowTextWrap) {
            element.blazor__instance.updateWrap();
        }
    },
    dataSourceChanged: function (element) {
        element.blazor__instance.unWireEvents();
        element.blazor__instance.wireEvents();
    },
    collapseAction: function (element, nodeId) {
        if (this.valid(element)) {
            // eslint-disable-next-line
            var currentLi = element.querySelector('[data-uid="' + nodeId + '"]');
            element.blazor__instance.collapseAction(currentLi, null, false);
        }
    },
    expandAction: function (element, nodeId) {
        if (this.valid(element)) {
            // eslint-disable-next-line
            var currentLi = element.querySelector('[data-uid="' + nodeId + '"]');
            element.blazor__instance.expandAction(currentLi, null);
        }
    },
    expandedNode: function (element, args) {
        if (this.valid(element)) {
            element.blazor__instance.expandedNode(args);
        }
    },
    collapsedNode: function (element, args) {
        if (this.valid(element)) {
            element.blazor__instance.collapsedNode(args);
        }
    },
    KeyActionHandler: function (element, args, nodeId) {
        if (this.valid(element)) {
            element.blazor__instance.KeyActionHandler(args, nodeId);
        }
    },
    setMultiSelect: function (element, args) {
        if (this.valid(element)) {
            element.blazor__instance.setMultiSelect(args);
        }
    },
    dragStartActionContinue: function dragStartActionContinue(element, cancel) {
        if (this.valid(element)) {
            element.blazor__instance.dragStartActionContinue(cancel);
        }
    },
    dragNodeStop: function dragNodeStop(element, args) {
        if (this.valid(element)) {
            element.blazor__instance.dragNodeStop(args);
        }
    },
    nodeDragging: function nodeDragging(element, args) {
        if (this.valid(element)) {
            element.blazor__instance.nodeDragging(args);
        }
    },
    setFocus: function setFocus(element, liElement) {
        if (!sf.base.isNullOrUndefined(element) && !sf.base.isNullOrUndefined(liElement)) {
            var inputEle = (document.getElementById(element.id));
            inputEle.focus();
            inputEle.setSelectionRange(0, inputEle.value.length);
        }
    },
    updateOldText: function updateOldText(element, text) {
        if (this.valid(element)) {
            element.blazor__instance.updateOldText(text);
        }
    },
    updateSpinnerClass: function updateSpinnerClass(element) {
        if (this.valid(element)) {
            element.blazor__instance.updateSpinnerClass();
        }
    },
    onPropertyChanged: function onPropertyChanged(element, properties) {
        if (this.valid(element)) {
            element.blazor__instance.onPropertyChanged(properties);
        }
    },
    // eslint-disable-next-line
    valid: function (element) {
        return (element && element.blazor__instance);
    },
    beginEdit: function beginEdit(element, node) {
        if (this.valid(element)) {
            element.blazor__instance.beginEdit(node);
        }
    },
    ensureVisible: function ensureVisible(element, node) {
        if (this.valid(element)) {
            element.blazor__instance.ensureVisible(node);
        }
    },
    nodeCollapse: function nodeCollapse(element, id) {
        if (this.valid(element)) {
            element.blazor__instance.nodeCollapse(id);
        }
    },
    nodeExpand: function nodeCollapse(element, id) {
        if (this.valid(element)) {
            element.blazor__instance.nodeExpand(id);
        }
    }
};

return TreeView;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/sf-uploader.js":
/*!**************************************************!*\
  !*** ./resources/19.3.44/Scripts/sf-uploader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sfBlazor = window.sfBlazor || {};
window.sfBlazor.Uploader = (function () {
'use strict';

var globalTimeOut = {};
var DEFT_MAT_WIDTH = 30;
var DEFT_FAB_WIDTH = 30;
var DEFT_BOOT_WIDTH = 30;
var DEFT_BOOT4_WIDTH = 36;
var CLS_SHOWSPIN = 'e-spin-show';
var CLS_HIDESPIN = 'e-spin-hide';
var CLS_MATERIALSPIN = 'e-spin-material';
var CLS_FABRICSPIN = 'e-spin-fabric';
var CLS_TAILWINDSPIN = 'e-spin-tailwind';
var CLS_BOOTSPIN = 'e-spin-bootstrap';
var CLS_BOOT4SPIN = 'e-spin-bootstrap4';
var CLS_HIGHCONTRASTSPIN = 'e-spin-high-contrast';
var CLS_SPINWRAP = 'e-spinner-pane';
var CLS_SPININWRAP = 'e-spinner-inner';
var CLS_SPINCIRCLE = 'e-path-circle';
var CLS_SPINARC = 'e-path-arc';
var CLS_SPINLABEL = 'e-spin-label';
var CLS_SPINTEMPLATE = 'e-spin-template';
var spinTemplate = null;
var spinCSSClass = null;
// eslint-disable-next-line
/**
  * Function to change the Spinners in a page globally from application end.
  * ```
  * E.g : blazorSpinner({ action: "Create", options: {target: targetElement}, type: "" });
  * ```
  *
  * @param {string} action - specifies the string
  * @param {CreateArgs} options - specifies the args
  * @param {string} target - specifies the target
  * @param {string} type - specifes the type
  * @returns {void}
  * @private
  */

/**
 * Create a spinner for the specified target element.
 * ```
 * E.g : renderSpinner({ target: targetElement, width: '34px', label: 'Loading..' });
 * ```
 *
 * @param {SpinnerArgs} args - specifies the args
 * @param {CreateElementArgs} internalCreateElement - specifis the element args
 * @returns {void}
 * @private
 */
function renderSpinner(args, internalCreateElement) {
    if (!args.target) {
        return;
    }
    var radius;
    var makeElement = !sf.base.isNullOrUndefined(internalCreateElement) ? internalCreateElement : sf.base.createElement;
    // eslint-disable-next-line
    var container = create_spinner_container(args.target, makeElement);
    if (!sf.base.isNullOrUndefined(args.cssClass)) {
        container.wrap.classList.add(args.cssClass);
    }
    if (!sf.base.isNullOrUndefined(args.template) || !sf.base.isNullOrUndefined(spinTemplate)) {
        var template = !sf.base.isNullOrUndefined(args.template) ? args.template : spinTemplate;
        container.wrap.classList.add(CLS_SPINTEMPLATE);
        replaceContent(container.wrap, template, spinCSSClass);
    }
    else {
        var theme = !sf.base.isNullOrUndefined(args.type) ? args.type : getTheme(container.wrap);
        var width = !sf.base.isNullOrUndefined(args.width) ? args.width : undefined;
        radius = calculateRadius(width, theme);
        setTheme(theme, container.wrap, radius, makeElement);
        if (!sf.base.isNullOrUndefined(args.label)) {
            createLabel(container.inner_wrap, args.label, makeElement);
        }
    }
    container.wrap.classList.add(CLS_HIDESPIN);
    container = null;
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {string} label - specifies the string
 * @param {createElementParams} makeElement - specifies the element
 * @returns {HTMLElement} - returns the element
 */
function createLabel(container, label, makeElement) {
    var labelEle = makeElement('div', {});
    labelEle.classList.add(CLS_SPINLABEL);
    labelEle.innerHTML = label;
    container.appendChild(labelEle);
    return labelEle;
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createMaterialSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Material', radius: radius };
    create_material_element(container, uniqueID, makeElement, CLS_MATERIALSPIN);
    mat_calculate_attributes(radius, container, 'Material', CLS_MATERIALSPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createBootstrap4Spinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Bootstrap4', radius: radius };
    create_material_element(container, uniqueID, makeElement, CLS_BOOT4SPIN);
    mat_calculate_attributes(radius, container, 'Bootstrap4', CLS_BOOT4SPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {string} uniqueID - specifies the id.
 * @param {number} radius - specifies the radius
 * @returns {void}
 */
function startMatAnimate(container, uniqueID, radius) {
    var globalObject = {};
    var timeOutVar = 0;
    globalTimeOut[uniqueID].timeOut = 0;
    globalObject[uniqueID] = globalVariables(uniqueID, radius, 0, 0);
    // eslint-disable-next-line
    var spinnerInfo = { uniqueID: uniqueID, container: container, globalInfo: globalObject, timeOutVar: timeOutVar };
    animateMaterial(spinnerInfo);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createFabricSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Fabric', radius: radius };
    create_fabric_element(container, uniqueID, CLS_FABRICSPIN, makeElement);
    fb_calculate_attributes(radius, container, CLS_FABRICSPIN);
}
function createTailwindSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Tailwind', radius: radius };
    create_fabric_element(container, uniqueID, CLS_TAILWINDSPIN, makeElement);
    fb_calculate_attributes(radius, container, CLS_TAILWINDSPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createHighContrastSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'HighContrast', radius: radius };
    create_fabric_element(container, uniqueID, CLS_HIGHCONTRASTSPIN, makeElement);
    fb_calculate_attributes(radius, container, CLS_HIGHCONTRASTSPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @returns {string} - returns the string
 */
function getTheme(container) {
    var theme = window.getComputedStyle(container, ':after').getPropertyValue('content');
    return theme.replace(/['"]+/g, '');
}
/**
 *
 * @param {string} theme - specifies the theme
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function setTheme(theme, container, radius, makeElement) {
    var innerContainer = container.querySelector('.' + CLS_SPININWRAP);
    var svg = innerContainer.querySelector('svg');
    if (!sf.base.isNullOrUndefined(svg)) {
        innerContainer.removeChild(svg);
    }
    switch (theme) {
        case 'Material':
            createMaterialSpinner(innerContainer, radius, makeElement);
            break;
        case 'Fabric':
            createFabricSpinner(innerContainer, radius, makeElement);
            break;
        case 'Bootstrap':
            createBootstrapSpinner(innerContainer, radius, makeElement);
            break;
        case 'HighContrast':
            createHighContrastSpinner(innerContainer, radius, makeElement);
            break;
        case 'Bootstrap4':
            createBootstrap4Spinner(innerContainer, radius, makeElement);
            break;
        case 'Tailwind':
        case 'Tailwind-dark':
            createTailwindSpinner(innerContainer, radius, makeElement);
            break;
    }
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createBootstrapSpinner(innerContainer, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Bootstrap', radius: radius };
    create_bootstrap_element(innerContainer, uniqueID, makeElement);
    boot_calculate_attributes(innerContainer, radius);
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {string} uniqueID - specifies the id
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
// eslint-disable-next-line
function create_bootstrap_element(innerContainer, uniqueID, makeElement) {
    var svgBoot = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    var viewBoxValue = 64;
    var trans = 32;
    var defaultRadius = 2;
    svgBoot.setAttribute('id', uniqueID);
    svgBoot.setAttribute('class', CLS_BOOTSPIN);
    svgBoot.setAttribute('viewBox', '0 0 ' + viewBoxValue + ' ' + viewBoxValue);
    innerContainer.insertBefore(svgBoot, innerContainer.firstChild);
    for (var item = 0; item <= 7; item++) {
        var bootCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        bootCircle.setAttribute('class', CLS_SPINCIRCLE + '_' + item);
        bootCircle.setAttribute('r', defaultRadius + '');
        bootCircle.setAttribute('transform', 'translate(' + trans + ',' + trans + ')');
        svgBoot.appendChild(bootCircle);
    }
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {number} radius - specifies the radius
 * @returns {void}
 */
// eslint-disable-next-line
function boot_calculate_attributes(innerContainer, radius) {
    var svg = innerContainer.querySelector('svg.e-spin-bootstrap');
    var x = 0;
    var y = 0;
    var rad = 24;
    svg.style.width = svg.style.height = radius + 'px';
    var startArc = 90;
    for (var item = 0; item <= 7; item++) {
        var start = defineArcPoints(x, y, rad, startArc);
        var circleEle = svg.querySelector('.' + CLS_SPINCIRCLE + '_' + item);
        circleEle.setAttribute('cx', start.x + '');
        circleEle.setAttribute('cy', start.y + '');
        startArc = startArc >= 360 ? 0 : startArc;
        startArc = startArc + 45;
    }
}
/**
 *
 * @param {number} begin - specifies the number
 * @param {number} stop  - specifirs the number
 * @returns {number[]} - returns the array of number
 */
function generateSeries(begin, stop) {
    var series = [];
    var start = begin;
    var end = stop;
    // eslint-disable-next-line
    var increment = false, count = 1;
    formSeries(start);
    /**
     *
     * @param {number} i - specifies the number
     * @returns {void}
     */
    function formSeries(i) {
        series.push(i);
        if (i !== end || count === 1) {
            if (i <= start && i > 1 && !increment) {
                i = parseFloat((i - 0.2).toFixed(2));
            }
            else if (i === 1) {
                i = 7;
                i = parseFloat((i + 0.2).toFixed(2));
                increment = true;
            }
            else if (i < 8 && increment) {
                i = parseFloat((i + 0.2).toFixed(2));
                if (i === 8) {
                    increment = false;
                }
            }
            else if (i <= 8 && !increment) {
                i = parseFloat((i - 0.2).toFixed(2));
            }
            ++count;
            formSeries(i);
        }
    }
    return series;
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @returns {void}
 */
function animateBootstrap(innerContainer) {
    var svg = innerContainer.querySelector('svg.e-spin-bootstrap');
    var id = svg.getAttribute('id');
    for (var i = 1; i <= 8; i++) {
        var circleEle = (innerContainer.getElementsByClassName('e-path-circle_' +
            (i === 8 ? 0 : i))[0]);
        rotation(circleEle, i, i, generateSeries(i, i), id);
    }
    /**
     *
     * @param {SVGCircleElement} circle - specifies the circl element
     * @param {number} start - specifies the number
     * @param {number} end - specifies the end number
     * @param {number} series - specifies the series
     * @param {string} id - specifies the id
     * @returns {void}
     */
    function rotation(circle, start, end, series, id) {
        var count = 0;
        boot_animate(start);
        // eslint-disable-next-line
        function boot_animate(radius) {
            if (globalTimeOut[id].isAnimate) {
                ++count;
                circle.setAttribute('r', radius + '');
                if (count >= series.length) {
                    count = 0;
                }
                // eslint-disable-next-line
                globalTimeOut[id].timeOut = setTimeout(boot_animate.bind(null, series[count]), 18);
            }
        }
    }
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {string} template - specifies the template
 * @param {string} cssClass - specifies the css class.
 * @returns {void}
 */
function replaceContent(container, template, cssClass) {
    if (!sf.base.isNullOrUndefined(cssClass)) {
        container.classList.add(cssClass);
    }
    var inner = container.querySelector('.e-spinner-inner');
    inner.innerHTML = template;
}
/**
 *
 * @param {string} width - specifies the width
 * @param {string} theme - specifies the string
 * @returns {number} - returns the number
 */
function calculateRadius(width, theme) {
    var defaultSize;
    switch (theme) {
        case 'Material':
            defaultSize = DEFT_MAT_WIDTH;
            break;
        case 'Fabric':
            defaultSize = DEFT_FAB_WIDTH;
            break;
        case 'Tailwind':
        case 'Tailwind-dark':
            defaultSize = DEFT_FAB_WIDTH;
            break;
        case 'Bootstrap4':
            defaultSize = DEFT_BOOT4_WIDTH;
            break;
        default:
            defaultSize = DEFT_BOOT_WIDTH;
    }
    width = width ? parseFloat(width + '') : defaultSize;
    return theme === 'Bootstrap' ? width : width / 2;
}
/**
 *
 * @param {string} id - specifies the id
 * @param {number} radius - specifies the radius
 * @param {number} count - specifies the number count
 * @param {number} previousId - specifies the previous id
 * @returns {GlobalVariables} - returns the variables
 */
function globalVariables(id, radius, count, previousId) {
    return {
        radius: radius,
        count: count,
        previousId: previousId
    };
}
/**
 * @returns {string} - returns the string
 */
// eslint-disable-next-line
function random_generator() {
    var random = '';
    var combine = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (var i = 0; i < 5; i++) {
        random += combine.charAt(Math.floor(Math.random() * combine.length));
    }
    return random;
}
/**
 *
 * @param {HTMLElement} innerCon - specifies the element
 * @param {string} uniqueID - specifies the unique id
 * @param {string} themeClass - specifies the string
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
// eslint-disable-next-line
function create_fabric_element(innerCon, uniqueID, themeClass, makeElement) {
    var svgFabric = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgFabric.setAttribute('id', uniqueID);
    svgFabric.setAttribute('class', themeClass);
    var fabricCirclePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    fabricCirclePath.setAttribute('class', CLS_SPINCIRCLE);
    var fabricCircleArc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    fabricCircleArc.setAttribute('class', CLS_SPINARC);
    innerCon.insertBefore(svgFabric, innerCon.firstChild);
    svgFabric.appendChild(fabricCirclePath);
    svgFabric.appendChild(fabricCircleArc);
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {string} uniqueID - specifies the unique id
 * @param {createElementParams} makeElement - specifies the element
 * @param {string} cls - specifies the string
 * @returns {void}
 */
// eslint-disable-next-line
function create_material_element(innerContainer, uniqueID, makeElement, cls) {
    var svgMaterial = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    var matCirclePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    svgMaterial.setAttribute('class', cls);
    svgMaterial.setAttribute('id', uniqueID);
    matCirclePath.setAttribute('class', CLS_SPINCIRCLE);
    innerContainer.insertBefore(svgMaterial, innerContainer.firstChild);
    svgMaterial.appendChild(matCirclePath);
}
/**
 *
 * @param {HTMLElement} target - specifies the element
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
// eslint-disable-next-line
function create_spinner_container(target, makeElement) {
    var spinnerContainer = makeElement('div', {});
    var spinnerInnerContainer = makeElement('div', {});
    spinnerContainer.classList.add(CLS_SPINWRAP);
    spinnerInnerContainer.classList.add(CLS_SPININWRAP);
    target.appendChild(spinnerContainer);
    spinnerContainer.appendChild(spinnerInnerContainer);
    // eslint-disable-next-line
    return { wrap: spinnerContainer, inner_wrap: spinnerInnerContainer };
}
/**
 *
 * @param {SpinnerInfo} spinnerInfo - specifies the spinner
 * @returns {void}
 */
function animateMaterial(spinnerInfo) {
    var start = 1;
    var end = 149;
    var duration = 1333;
    var max = 75;
    createCircle(start, end, easeAnimation, duration, spinnerInfo.globalInfo[spinnerInfo.uniqueID].count, max, spinnerInfo);
    spinnerInfo.globalInfo[spinnerInfo.uniqueID].count = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].count % 4;
}
/**
 *
 * @param {number} start - specifies the number
 * @param {number} end - specifies the end number
 * @param {Function} easing - specifies the function
 * @param {number} duration - specifies the duration
 * @param {number} count - specifies the count
 * @param {number} max - specifies the max number
 * @param {SpinnerInfo} spinnerInfo - specifies the spinner info
 * @returns {void}
 */
// eslint-disable-next-line
function createCircle(start, end, easing, duration, count, max, spinnerInfo) {
    var id = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].previousId;
    var startTime = new Date().getTime();
    var change = end - start;
    var diameter = getSize((spinnerInfo.globalInfo[spinnerInfo.uniqueID].radius * 2) + '');
    var strokeSize = getStrokeSize(diameter);
    var rotate = -90 * (spinnerInfo.globalInfo[spinnerInfo.uniqueID].count || 0);
    mat_animation(spinnerInfo);
    // eslint-disable-next-line
    function mat_animation(spinnerInfo) {
        var currentTime = Math.max(0, Math.min(new Date().getTime() - startTime, duration));
        updatePath(easing(currentTime, start, change, duration), spinnerInfo.container);
        if (id === spinnerInfo.globalInfo[spinnerInfo.uniqueID].previousId && currentTime < duration) {
            // eslint-disable-next-line
            globalTimeOut[spinnerInfo.uniqueID].timeOut = setTimeout(mat_animation.bind(null, spinnerInfo), 1);
        }
        else {
            animateMaterial(spinnerInfo);
        }
    }
    /**
     *
     * @param {number} value - specifies the number value
     * @param {HTMLElement} container - specifies the container
     * @returns {void}
     */
    function updatePath(value, container) {
        if ((!sf.base.isNullOrUndefined(container.querySelector('svg.e-spin-material')))
            && (!sf.base.isNullOrUndefined(container.querySelector('svg.e-spin-material').querySelector('path.e-path-circle')))) {
            var svg = container.querySelector('svg.e-spin-material');
            var path = svg.querySelector('path.e-path-circle');
            path.setAttribute('stroke-dashoffset', getDashOffset(diameter, strokeSize, value, max) + '');
            path.setAttribute('transform', 'rotate(' + (rotate) + ' ' + diameter / 2 + ' ' + diameter / 2 + ')');
        }
    }
}
/**
 *
 * @param {number} radius - specifies the number
 * @param {HTMLElement} container - specifies the element
 * @param {string} type - specifies the string type
 * @param {string} cls - specifies the string
 * @returns {void}
 */
// eslint-disable-next-line
function mat_calculate_attributes(radius, container, type, cls) {
    var diameter = radius * 2;
    var svg = container.querySelector('svg.' + cls);
    var path = svg.querySelector('path.e-path-circle');
    var strokeSize = getStrokeSize(diameter);
    var transformOrigin = (diameter / 2) + 'px';
    svg.setAttribute('viewBox', '0 0 ' + diameter + ' ' + diameter);
    svg.style.width = svg.style.height = diameter + 'px';
    svg.style.transformOrigin = transformOrigin + ' ' + transformOrigin + ' ' + transformOrigin;
    path.setAttribute('d', drawArc(diameter, strokeSize));
    if (type === 'Material') {
        path.setAttribute('stroke-width', strokeSize + '');
        path.setAttribute('stroke-dasharray', ((diameter - strokeSize) * Math.PI * 0.75) + '');
        path.setAttribute('stroke-dashoffset', getDashOffset(diameter, strokeSize, 1, 75) + '');
    }
}
/**
 *
 * @param {string} value - specifies the value
 * @returns {number} - returns the number
 */
function getSize(value) {
    var parsed = parseFloat(value);
    return parsed;
}
/**
 *
 * @param {number} diameter - specifies the diameter
 * @param {number} strokeSize - specifies the size
 * @returns {string} - returns the string
 */
function drawArc(diameter, strokeSize) {
    var radius = diameter / 2;
    var offset = strokeSize / 2;
    return 'M' + radius + ',' + offset
        + 'A' + (radius - offset) + ',' + (radius - offset) + ' 0 1 1 ' + offset + ',' + radius;
}
/**
 *
 * @param {number} diameter - specifies the number
 * @returns {number} - returns the number
 */
function getStrokeSize(diameter) {
    return 10 / 100 * diameter;
}
/**
 *
 * @param {number} diameter - specifies the number
 * @param {number} strokeSize - specifies the stroke size
 * @param {number} value - specifies the value
 * @param {number} max - specifies the max number
 * @returns {number} - returns the number
 */
function getDashOffset(diameter, strokeSize, value, max) {
    return (diameter - strokeSize) * Math.PI * ((3 * (max) / 100) - (value / 100));
}
/**
 *
 * @param {number} current - specifies the number
 * @param {number} start - specifies the stroke size
 * @param {number} change - specifies the value
 * @param {number} duration - specifies the max number
 * @returns {number} - returns the number
 */
function easeAnimation(current, start, change, duration) {
    var timestamp = (current /= duration) * current;
    var timecount = timestamp * current;
    return start + change * (6 * timecount * timestamp + -15 * timestamp * timestamp + 10 * timecount);
}
/**
 *
 * @param {number} radius - specifies the number
 * @param {HTMLElement} innerConainer - specifies the element
 * @param {string} trgClass - specifies the class
 * @returns {void}
 */
// eslint-disable-next-line
function fb_calculate_attributes(radius, innerConainer, trgClass) {
    var centerX = radius;
    var centerY = radius;
    var diameter = radius * 2;
    // eslint-disable-next-line
    var startArc = 315, endArc = 45;
    var svg = innerConainer.querySelector('.' + trgClass);
    var circle = svg.querySelector('.e-path-circle');
    var path = svg.querySelector('.e-path-arc');
    var transformOrigin = (diameter / 2) + 'px';
    circle.setAttribute('d', defineCircle(centerX, centerY, radius));
    path.setAttribute('d', defineArc(centerX, centerY, radius, startArc, endArc));
    svg.setAttribute('viewBox', '0 0 ' + diameter + ' ' + diameter);
    svg.style.transformOrigin = transformOrigin + ' ' + transformOrigin + ' ' + transformOrigin;
    svg.style.width = svg.style.height = diameter + 'px';
}
/**
 *
 * @param {number} centerX - specifies the number
 * @param {number} centerY - specifies the stroke size
 * @param {number} radius - specifies the value
 * @param {number} angle - specifies the max number
 * @returns {number} - returns the number
 */
function defineArcPoints(centerX, centerY, radius, angle) {
    var radians = (angle - 90) * Math.PI / 180.0;
    return {
        x: centerX + (radius * Math.cos(radians)),
        y: centerY + (radius * Math.sin(radians))
    };
}
/**
 *
 * @param {number} x - specifies the number
 * @param {number} y - specifies the stroke size
 * @param {number} radius - specifies the radius
 * @param {number} startArc - specifies the value
 * @param {number} endArc - specifies the max number
 * @returns {number} - returns the number
 */
function defineArc(x, y, radius, startArc, endArc) {
    var start = defineArcPoints(x, y, radius, endArc);
    var end = defineArcPoints(x, y, radius, startArc);
    var d = [
        'M', start.x, start.y,
        'A', radius, radius, 0, 0, 0, end.x, end.y
    ].join(' ');
    return d;
}
/**
 *
 * @param {number} x - specifies the number
 * @param {number} y - specifies the stroke size
 * @param {number} radius - specifies the value
 * @returns {string} - returns the string
 */
function defineCircle(x, y, radius) {
    var d = [
        'M', x, y,
        'm', -radius, 0,
        'a', radius, radius, 0, 1, 0, radius * 2, 0,
        'a', radius, radius, 0, 1, 0, -radius * 2, 0
    ].join(' ');
    return d;
}
// eslint-disable-next-line
/**
 * Function to show the Spinner.
 *
 * @param {HTMLElement} container - Specify the target of the Spinner.
 * @returns {void}
 * @private
 */
function enableSpinner(container) {
    showHideSpinner(container, false);
    container = null;
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {boolean} isHide - specifies the boolean
 * @returns {void}
 */
function showHideSpinner(container, isHide) {
    var spinnerWrap;
    if (container) {
        spinnerWrap = container.classList.contains(CLS_SPINWRAP) ? container :
            container.querySelector('.' + CLS_SPINWRAP);
    }
    if (container && spinnerWrap) {
        var inner = spinnerWrap.querySelector('.' + CLS_SPININWRAP);
        var spinCheck = void 0;
        // eslint-disable-next-line
        spinCheck = isHide ? !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_HIDESPIN) :
            !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_SHOWSPIN);
        if (spinCheck) {
            var svgEle = spinnerWrap.querySelector('svg');
            if (sf.base.isNullOrUndefined(svgEle)) {
                return;
            }
            var id = svgEle.getAttribute('id');
            globalTimeOut[id].isAnimate = !isHide;
            switch (globalTimeOut[id].type) {
                case 'Material':
                    // eslint-disable-next-line
                    isHide ? clearTimeout(globalTimeOut[id].timeOut) : startMatAnimate(inner, id, globalTimeOut[id].radius);
                    break;
                case 'Bootstrap':
                    // eslint-disable-next-line
                    isHide ? clearTimeout(globalTimeOut[id].timeOut) : animateBootstrap(inner);
                    break;
            }
        }
        // eslint-disable-next-line
        isHide ? sf.base.classList(spinnerWrap, [CLS_HIDESPIN], [CLS_SHOWSPIN]) : sf.base.classList(spinnerWrap, [CLS_SHOWSPIN], [CLS_HIDESPIN]);
        container = null;
    }
}
/**
 * Function to hide the Spinner.
 *
 * @param {HTMLElement} container - Specify the target of the Spinner.
 * @returns {void}
 * @private
 */
function disableSpinner(container) {
    showHideSpinner(container, true);
    container = null;
}

/**
 * Blazor uploader interop handler
 */
var INPUT_WRAPPER = 'e-file-select';
var DROP_WRAPPER = 'e-file-select-wrap';
var LIST_PARENT = 'e-upload-files';
var FILE = 'e-upload-file-list';
var STATUS = 'e-file-status';
var ACTION_BUTTONS = 'e-upload-actions';
var UPLOAD_BUTTONS = 'e-file-upload-btn e-css e-btn e-flat e-primary';
var CLEAR_BUTTONS = 'e-file-clear-btn e-css e-btn e-flat';
var FILE_NAME = 'e-file-name';
var FILE_TYPE = 'e-file-type';
var FILE_SIZE = 'e-file-size';
var REMOVE_ICON = 'e-file-remove-btn';
var DELETE_ICON = 'e-file-delete-btn';
var SPINNER_PANE = 'e-spinner-pane';
var ABORT_ICON = 'e-file-abort-btn';
var RETRY_ICON = 'e-file-reload-btn';
var DRAG_HOVER = 'e-upload-drag-hover';
var PROGRESS_WRAPPER = 'e-upload-progress-wrap';
var PROGRESSBAR = 'e-upload-progress-bar';
var PROGRESSBAR_TEXT = 'e-progress-bar-text';
var UPLOAD_INPROGRESS = 'e-upload-progress';
var UPLOAD_SUCCESS = 'e-upload-success';
var UPLOAD_FAILED = 'e-upload-fails';
var TEXT_CONTAINER = 'e-file-container';
var VALIDATION_FAILS = 'e-validation-fails';
var RTL_CONTAINER = 'e-rtl-container';
var ICON_FOCUSED = 'e-clear-icon-focus';
var PROGRESS_INNER_WRAPPER = 'e-progress-inner-wrap';
var PAUSE_UPLOAD = 'e-file-pause-btn';
var RESUME_UPLOAD = 'e-file-play-btn';
var RESTRICT_RETRY = 'e-restrict-retry';
var FORM_UPLOAD = 'e-form-upload';
var HIDDEN_INPUT = 'e-hidden-file-input';
var INVALID_FILE = 'e-file-invalid';
var INFORMATION = 'e-file-information';
var SfUploader = /** @class */ (function () {
    function SfUploader(element, dotnetRef, options) {
        this.initialAttr = { accept: null, multiple: false, disabled: false };
        this.uploadedFilesData = [];
        this.base64String = [];
        this.isForm = false;
        this.allTypes = false;
        this.pausedData = [];
        this.uploadMetaData = [];
        this.btnTabIndex = '0';
        this.disableKeyboardNavigation = false;
        this.count = -1;
        this.actionCompleteCount = 0;
        this.flag = true;
        this.selectedFiles = [];
        this.uploaderName = 'UploadFiles';
        this.fileStreams = [];
        this.newFileRef = 0;
        this.isFirstFileOnSelection = false;
        this.dragCounter = 0;
        this.fileList = [];
        this.filesData = [];
        this.element = element;
        this.updateProperty(options);
        this.element.blazor__instance = this;
        this.dotNetRef = dotnetRef;
    }
    SfUploader.prototype.initialize = function () {
        this.preRender();
        this.render();
    };
    //#region Internal methods
    SfUploader.prototype.updateProperty = function (uploadObj) {
        sf.base.extend(this, this, uploadObj);
    };
    SfUploader.prototype.reRenderFileList = function () {
        if (this.listParent) {
            sf.base.detach(this.listParent);
            this.listParent = null;
            this.fileList = [];
            this.createFileList(this.filesData);
            if (this.actionButtons) {
                this.removeActionButtons();
                this.renderActionButtons();
                this.checkActionButtonStatus();
            }
        }
    };
    SfUploader.prototype.updateDropArea = function () {
        if (this.dropArea) {
            this.setDropArea();
        }
        else {
            this.dropZoneElement = null;
            var dropTextArea = this.dropAreaWrapper.querySelector('.e-file-drop');
            if (dropTextArea) {
                sf.base.remove(dropTextArea);
            }
        }
    };
    SfUploader.prototype.propertyChanges = function (uploadObj, newProp) {
        this.updateProperty(uploadObj);
        this.isBlazorSaveUrl = (this.asyncSettings.saveUrl === '' || sf.base.isNullOrUndefined(this.asyncSettings.saveUrl));
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'AllowedExtensions':
                    this.clearAll();
                    break;
                case 'EnableRtl':
                    this.reRenderFileList();
                    break;
                case 'Buttons':
                    this.buttons.browse = sf.base.isNullOrUndefined(this.buttons.browse) ? '' : this.buttons.browse;
                    this.buttons.clear = sf.base.isNullOrUndefined(this.buttons.clear) ? '' : this.buttons.clear;
                    this.buttons.upload = sf.base.isNullOrUndefined(this.buttons.upload) ? '' : this.buttons.upload;
                    this.renderButtonTemplates();
                    break;
                case 'DropArea':
                    this.unBindDropEvents();
                    this.updateDropArea();
                    break;
                case 'Files':
                    this.renderPreLoadFiles();
                    break;
                case 'MinFileSize':
                case 'MaxFileSize':
                case 'AutoUpload':
                    this.clearAll();
                    break;
                case 'SequentialUpload':
                    this.clearAll();
                    break;
            }
        }
    };
    SfUploader.prototype.preRender = function () {
        this.isBlazorTemplate = this.template !== '' && !sf.base.isNullOrUndefined(this.template);
        this.isBlazorSaveUrl = (this.asyncSettings.saveUrl === '' || sf.base.isNullOrUndefined(this.asyncSettings.saveUrl));
        if (this.isBlazorSaveUrl && this.sequentialUpload) {
            this.sequentialUpload = false;
        }
        if (!this.isBlazorSaveUrl) {
            this.formRendered();
        }
        this.keyConfigs = {
            enter: 'enter'
        };
        this.browserName = sf.base.Browser.info.name;
        this.uploaderName = this.element.getAttribute('name');
    };
    SfUploader.prototype.formRendered = function () {
        var parentEle = sf.base.closest(this.element, 'form');
        if (!sf.base.isNullOrUndefined(parentEle)) {
            for (; parentEle && parentEle !== document.documentElement; parentEle = parentEle.parentElement) {
                if (parentEle.tagName === 'FORM') {
                    this.isForm = true;
                    this.formElement = parentEle;
                    parentEle.setAttribute('enctype', 'multipart/form-data');
                    parentEle.setAttribute('encoding', 'multipart/form-data');
                }
            }
        }
    };
    /**
     * To Initialize the control rendering
     * @private
     */
    SfUploader.prototype.render = function () {
        this.dropAreaWrapper = sf.base.closest(this.element, '.' + DROP_WRAPPER);
        this.uploadWrapper = sf.base.closest(this.element, '.e-upload.e-control-wrapper');
        this.browseButton = this.dropAreaWrapper.querySelector('button.e-upload-browse-btn');
        this.setDropArea();
        this.renderPreLoadFiles();
        this.wireEvents();
    };
    SfUploader.prototype.wireEvents = function () {
        sf.base.EventHandler.add(this.browseButton, 'click', this.browseButtonClick, this);
        sf.base.EventHandler.add(this.element, 'change', this.onSelectFiles, this);
        sf.base.EventHandler.add(document, 'click', this.removeFocus, this);
        this.keyboardModule = new sf.base.KeyboardEvents(this.uploadWrapper, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: this.keyConfigs,
            eventName: 'keydown',
        });
        if (this.isForm) {
            sf.base.EventHandler.add(this.formElement, 'reset', this.resetForm, this);
        }
    };
    SfUploader.prototype.renderPreLoadFiles = function () {
        if (this.files && this.files.length) {
            if (this.enablePersistence && this.filesData.length) {
                this.createFileList(this.filesData);
                return;
            }
            if (sf.base.isNullOrUndefined(this.files[0].size)) {
                return;
            }
            var files = [].slice.call(this.files);
            var filesData = [];
            if (!this.multiple) {
                this.clearData();
                files = [files[0]];
            }
            for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                var data = files_1[_i];
                var fileData = {
                    name: data.name + '.' + data.type.split('.')[data.type.split('.').length - 1],
                    rawFile: '',
                    size: data.size,
                    status: this.localizedTexts('uploadSuccessMessage'),
                    type: data.type,
                    validationMessages: { minSize: '', maxSize: '' },
                    statusCode: '2'
                };
                filesData.push(fileData);
                this.filesData.push(fileData);
            }
            if (this.isBlazorTemplate) {
                return;
            }
            this.createFileList(filesData);
            if (!this.autoUpload && this.listParent && !this.actionButtons && (!this.isForm || this.allowUpload()) && this.showFileList) {
                this.renderActionButtons();
            }
            this.checkActionButtonStatus();
            if (this.sequentialUpload) {
                this.count = this.filesData.length - 1;
            }
        }
    };
    SfUploader.prototype.renderActionButtons = function () {
        this.element.setAttribute('tabindex', '-1');
        if (!(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
            this.actionButtons = sf.base.createElement('div', { className: ACTION_BUTTONS });
            this.uploadButton = sf.base.createElement('button', {
                className: UPLOAD_BUTTONS,
                attrs: { 'type': 'button', 'tabindex': this.btnTabIndex }
            });
            this.clearButton = sf.base.createElement('button', {
                className: CLEAR_BUTTONS,
                attrs: { 'type': 'button', 'tabindex': this.btnTabIndex }
            });
            this.actionButtons.appendChild(this.clearButton);
            this.actionButtons.appendChild(this.uploadButton);
            this.renderButtonTemplates();
            this.uploadWrapper.appendChild(this.actionButtons);
            this.browseButton.blur();
            this.uploadButton.focus();
            this.wireActionButtonEvents();
        }
    };
    SfUploader.prototype.setDropArea = function () {
        var dropTextArea = this.dropAreaWrapper.querySelector('.e-file-drop');
        if (this.dropArea) {
            this.dropZoneElement = (typeof (this.dropArea) !== 'string') ? this.dropArea :
                document.querySelector(this.dropArea);
            var element = this.element;
            var enableDropText = false;
            while (element.parentNode) {
                element = element.parentNode;
                if (element === this.dropZoneElement) {
                    enableDropText = true;
                }
            }
            if (!enableDropText && dropTextArea) {
                sf.base.remove(dropTextArea);
            }
        }
        else if (sf.base.isNullOrUndefined(this.dropArea)) {
            this.dropZoneElement = this.uploadWrapper;
            //this.setProperties({dropArea: this.uploadWrapper }, true);
        }
        this.bindDropEvents();
    };
    SfUploader.prototype.serverActionButtonsEventBind = function (element) {
        if (element && !this.isForm) {
            this.browseButton.blur();
            this.actionButtons = element;
            this.uploadButton = this.actionButtons.querySelector('.e-file-upload-btn');
            this.clearButton = this.actionButtons.querySelector('.e-file-clear-btn');
            this.uploadButton.focus();
            this.unwireActionButtonEvents();
            this.wireActionButtonEvents();
            this.checkActionButtonStatus();
        }
    };
    SfUploader.prototype.serverUlElement = function (element) {
        if (element && (this.isBlazorSaveUrl || this.isBlazorTemplate)) {
            this.listParent = element;
            this.fileList = [].slice.call(this.listParent.querySelectorAll('li'));
            this.serverRemoveIconBindEvent();
            if (!this.isForm) {
                this.checkAutoUpload(this.filesData);
            }
        }
    };
    SfUploader.prototype.wireActionButtonEvents = function () {
        sf.base.EventHandler.add(this.uploadButton, 'click', this.uploadButtonClick, this);
        sf.base.EventHandler.add(this.clearButton, 'click', this.clearButtonClick, this);
    };
    SfUploader.prototype.unwireActionButtonEvents = function () {
        sf.base.EventHandler.remove(this.uploadButton, 'click', this.uploadButtonClick);
        sf.base.EventHandler.remove(this.clearButton, 'click', this.clearButtonClick);
    };
    SfUploader.prototype.checkActionButtonStatus = function () {
        if (this.actionButtons && !this.isBlazorTemplate) {
            var length_1 = this.uploadWrapper.querySelectorAll('.' + VALIDATION_FAILS).length +
                this.uploadWrapper.querySelectorAll('.e-upload-fails:not(.e-upload-progress)').length +
                this.uploadWrapper.querySelectorAll('span.' + UPLOAD_SUCCESS).length +
                this.uploadWrapper.querySelectorAll('span.' + UPLOAD_INPROGRESS).length;
            if (length_1 > 0 && length_1 === this.uploadWrapper.querySelectorAll('li').length) {
                this.uploadButton.setAttribute('disabled', 'disabled');
            }
            else {
                this.uploadButton.removeAttribute('disabled');
            }
        }
    };
    SfUploader.prototype.renderButtonTemplates = function () {
        if (typeof (this.buttons.browse) === 'string') {
            this.browseButton.textContent = (this.buttons.browse === 'Browse...') ?
                this.localizedTexts('browse') : this.buttons.browse;
            this.browseButton.setAttribute('title', this.browseButton.textContent);
        }
        else {
            this.browseButton.innerHTML = '';
            this.browseButton.appendChild(this.buttons.browse);
        }
        if (this.uploadButton) {
            var uploadText = void 0;
            uploadText = sf.base.isNullOrUndefined(this.buttons.upload) ? 'Upload' : this.buttons.upload;
            this.buttons.upload = uploadText;
            if (typeof (this.buttons.upload) === 'string') {
                this.uploadButton.textContent = (this.buttons.upload === 'Upload') ?
                    this.localizedTexts('upload') : this.buttons.upload;
                this.uploadButton.setAttribute('title', this.uploadButton.textContent);
            }
            else {
                this.uploadButton.innerHTML = '';
                this.uploadButton.appendChild(this.buttons.upload);
            }
        }
        if (this.clearButton) {
            var clearText = void 0;
            clearText = sf.base.isNullOrUndefined(this.buttons.clear) ? 'Clear' : this.buttons.clear;
            this.buttons.clear = clearText;
            if (typeof (this.buttons.clear) === 'string') {
                this.clearButton.textContent = (this.buttons.clear === 'Clear') ?
                    this.localizedTexts('clear') : this.buttons.clear;
                this.clearButton.setAttribute('title', this.clearButton.textContent);
            }
            else {
                this.clearButton.innerHTML = '';
                this.clearButton.appendChild(this.buttons.clear);
            }
        }
    };
    SfUploader.prototype.checkAutoUpload = function (fileData) {
        if (this.autoUpload) {
            if (this.sequentialUpload) {
                this.sequenceUpload(fileData);
            }
            else {
                this.upload(fileData);
            }
            this.removeActionButtons();
        }
        else if (!this.actionButtons) {
            this.renderActionButtons();
        }
        this.checkActionButtonStatus();
    };
    SfUploader.prototype.removeActionButtons = function () {
        if (this.actionButtons) {
            this.unwireActionButtonEvents();
            if (!(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
                sf.base.detach(this.actionButtons);
            }
            this.actionButtons = null;
        }
    };
    SfUploader.prototype.sequenceUpload = function (fileData) {
        if (this.filesData.length - fileData.length === 0 ||
            this.filesData[(this.filesData.length - fileData.length - 1)].statusCode !== '1') {
            ++this.count;
            var isFileListCreated = this.showFileList ? false : true;
            if (typeof this.filesData[this.count] === 'object') {
                this.isFirstFileOnSelection = false;
                this.upload(this.filesData[this.count], isFileListCreated);
                if (this.filesData[this.count].statusCode === '0') {
                    this.sequenceUpload(fileData);
                }
            }
            else {
                --this.count;
            }
        }
    };
    SfUploader.prototype.unWireEvents = function () {
        sf.base.EventHandler.remove(this.browseButton, 'click', this.browseButtonClick);
        sf.base.EventHandler.remove(this.element, 'change', this.onSelectFiles);
        sf.base.EventHandler.remove(document, 'click', this.removeFocus);
        if (this.isForm) {
            sf.base.EventHandler.remove(this.formElement, 'reset', this.resetForm);
        }
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
    };
    SfUploader.prototype.resetForm = function () {
        this.clearAll();
    };
    SfUploader.prototype.keyActionHandler = function (e) {
        var targetElement = e.target;
        switch (e.action) {
            case 'enter':
                if (e.target === this.clearButton) {
                    this.clearButtonClick();
                }
                else if (e.target === this.uploadButton) {
                    this.uploadButtonClick();
                }
                else if (e.target === this.browseButton) {
                    this.browseButtonClick();
                }
                else if (targetElement.classList.contains(PAUSE_UPLOAD)) {
                    var metaData = this.getCurrentMetaData(null, e);
                    metaData.file.statusCode = '4';
                    metaData.file.status = this.localizedTexts('pauseUpload');
                    this.abortUpload(metaData, false);
                }
                else if (targetElement.classList.contains(RESUME_UPLOAD)) {
                    this.resumeUpload(this.getCurrentMetaData(null, e), e);
                }
                else if (targetElement.classList.contains(RETRY_ICON)) {
                    var metaData = this.getCurrentMetaData(null, e);
                    if (!sf.base.isNullOrUndefined(metaData)) {
                        metaData.file.statusCode = '1';
                        metaData.file.status = this.localizedTexts('readyToUploadMessage');
                        this.chunkUpload(metaData.file);
                    }
                    else {
                        var target = e.target.parentElement;
                        var fileData = this.filesData[this.fileList.indexOf(target)];
                        this.retry(fileData);
                    }
                }
                else {
                    this.removeFiles(e);
                    if (!targetElement.classList.contains(ABORT_ICON)) {
                        this.browseButton.focus();
                    }
                }
                e.preventDefault();
                e.stopPropagation();
                break;
        }
    };
    SfUploader.prototype.getCurrentMetaData = function (fileInfo, e) {
        var fileData;
        var targetMetaData;
        if (sf.base.isNullOrUndefined(fileInfo)) {
            var target = e.target.parentElement;
            fileData = this.filesData[this.fileList.indexOf(target)];
        }
        else {
            fileData = fileInfo;
        }
        for (var i = 0; i < this.uploadMetaData.length; i++) {
            if (this.uploadMetaData[i].file.name === fileData.name) {
                targetMetaData = this.uploadMetaData[i];
            }
        }
        return targetMetaData;
    };
    SfUploader.prototype.removeFocus = function () {
        if (this.uploadWrapper && this.listParent && this.listParent.querySelector('.' + ICON_FOCUSED)) {
            document.activeElement.blur();
            this.listParent.querySelector('.' + ICON_FOCUSED).classList.remove(ICON_FOCUSED);
        }
    };
    SfUploader.prototype.browseButtonClick = function () {
        this.element.click();
    };
    SfUploader.prototype.uploadButtonClick = function () {
        if (this.sequentialUpload) {
            this.sequenceUpload(this.filesData);
        }
        else {
            this.upload(this.filesData);
        }
    };
    SfUploader.prototype.clearButtonClick = function () {
        this.clearAll();
        if (this.sequentialUpload) {
            this.count = -1;
        }
        this.actionCompleteCount = 0;
    };
    SfUploader.prototype.bindDropEvents = function () {
        if (this.dropZoneElement) {
            sf.base.EventHandler.add(this.dropZoneElement, 'drop', this.dropElement, this);
            sf.base.EventHandler.add(this.dropZoneElement, 'dragover', this.dragHover, this);
            sf.base.EventHandler.add(this.dropZoneElement, 'dragleave', this.onDragLeave, this);
            sf.base.EventHandler.add(this.dropZoneElement, 'paste', this.onPasteFile, this);
            sf.base.EventHandler.add(this.dropZoneElement, 'dragenter', this.onDragEnter, this);
        }
    };
    SfUploader.prototype.unBindDropEvents = function () {
        if (this.dropZoneElement) {
            sf.base.EventHandler.remove(this.dropZoneElement, 'drop', this.dropElement);
            sf.base.EventHandler.remove(this.dropZoneElement, 'dragover', this.dragHover);
            sf.base.EventHandler.remove(this.dropZoneElement, 'dragleave', this.onDragLeave);
            sf.base.EventHandler.remove(this.dropZoneElement, 'dragenter', this.onDragEnter);
        }
    };
    SfUploader.prototype.onDragEnter = function (e) {
        if (!this.enabled) {
            return;
        }
        this.dropZoneElement.classList.add(DRAG_HOVER);
        this.dragCounter = this.dragCounter + 1;
        e.preventDefault();
        e.stopPropagation();
    };
    SfUploader.prototype.onDragLeave = function (e) {
        if (!this.enabled) {
            return;
        }
        this.dragCounter = this.dragCounter - 1;
        if (!this.dragCounter) {
            this.dropZoneElement.classList.remove(DRAG_HOVER);
        }
    };
    SfUploader.prototype.dragHover = function (e) {
        if (!this.enabled) {
            return;
        }
        if (this.dropEffect !== 'Default') {
            e.dataTransfer.dropEffect = this.dropEffect.toLowerCase();
        }
        e.preventDefault();
        e.stopPropagation();
    };
    SfUploader.prototype.dropElement = function (e) {
        this.dragCounter = 0;
        this.dropZoneElement.classList.remove(DRAG_HOVER);
        this.onSelectFiles(e);
        e.preventDefault();
        e.stopPropagation();
    };
    SfUploader.prototype.onPasteFile = function (event) {
        var item = event.clipboardData.items;
        if (item.length !== 1) {
            return;
        }
        var pasteFile = [].slice.call(item)[0];
        if ((pasteFile.kind === 'file') && pasteFile.type.match('^image/')) {
            this.renderSelectedFiles(event, [pasteFile.getAsFile()], false, true);
        }
    };
    SfUploader.prototype.getSelectedFiles = function (index) {
        var data = [];
        var liElement = this.fileList[index];
        var allFiles = this.getFilesData();
        var nameElements = +liElement.getAttribute('data-files-count');
        var startIndex = 0;
        for (var i = 0; i < index; i++) {
            startIndex += (+this.fileList[i].getAttribute('data-files-count'));
        }
        for (var j = startIndex; j < (startIndex + nameElements); j++) {
            data.push(allFiles[j]);
        }
        return data;
    };
    SfUploader.prototype.removeFiles = function (args) {
        if (!this.enabled) {
            return;
        }
        var selectedElement = args.target.parentElement;
        if (this.isBlazorSaveUrl) {
            this.fileList = [].slice.call(this.uploadWrapper.querySelectorAll('li'));
        }
        var index = this.fileList.indexOf(selectedElement);
        var liElement = this.fileList[index];
        var formUpload = this.isFormUpload();
        var fileData = formUpload ? this.getSelectedFiles(index) : this.getFilesInArray(this.filesData[index]);
        if (sf.base.isNullOrUndefined(fileData)) {
            return;
        }
        if (args.target.classList.contains(ABORT_ICON) && !formUpload) {
            fileData[0].statusCode = '5';
            if (!sf.base.isNullOrUndefined(liElement)) {
                var spinnerTarget = liElement.querySelector('.' + ABORT_ICON);
                renderSpinner({ target: spinnerTarget, width: '20px' });
                enableSpinner(spinnerTarget);
            }
            if (this.sequentialUpload) {
                this.uploadSequential();
            }
            if (!(liElement.classList.contains(RESTRICT_RETRY))) {
                this.checkActionComplete(true);
            }
        }
        else if (!sf.base.closest(args.target, '.' + SPINNER_PANE)) {
            this.remove(fileData, false, false, true, args);
        }
        this.element.value = '';
        this.checkActionButtonStatus();
    };
    SfUploader.prototype.removeFilesData = function (file, customTemplate) {
        var index;
        if (customTemplate) {
            if (!this.showFileList) {
                index = this.filesData.indexOf(file);
                this.filesData.splice(index, 1);
            }
            return;
        }
        var selectedElement = this.getLiElement(file);
        if (sf.base.isNullOrUndefined(selectedElement)) {
            return;
        }
        if (!this.isBlazorSaveUrl) {
            sf.base.detach(selectedElement);
        }
        index = this.fileList.indexOf(selectedElement);
        this.fileList.splice(index, 1);
        this.filesData.splice(index, 1);
        if (!this.isBlazorSaveUrl && (this.fileList.length === 0 && !sf.base.isNullOrUndefined(this.listParent))) {
            sf.base.detach(this.listParent);
            this.listParent = null;
            this.removeActionButtons();
            if (this.sequentialUpload) {
                if (index <= this.count) {
                    --this.count;
                }
            }
        }
        else {
            // tslint:disable-next-line
            this.dotNetRef.invokeMethodAsync('RemoveFileData', index);
        }
    };
    SfUploader.prototype.removeUploadedFile = function (file, eventArgs, removeDirectly, custom) {
        var _this = this;
        var selectedFiles = file;
        var ajax = new sf.base.Ajax(this.asyncSettings.removeUrl, 'POST', true, null);
        ajax.emitError = false;
        var formData = new FormData();
        ajax.beforeSend = function (e) {
            eventArgs.currentRequest = ajax.httpRequest;
            if (_this.currentRequestHeader) {
                _this.updateCustomheader(ajax.httpRequest, _this.currentRequestHeader);
            }
            if (_this.customFormDatas) {
                _this.updateFormData(formData, _this.customFormDatas);
            }
            if (!removeDirectly && _this.removingEnabled) {
                // @ts-ignore-start
                _this.dotNetRef.invokeMethodAsync('RemovingEvent', eventArgs).then(function (eventArgs) {
                    // @ts-ignore-end
                    if (eventArgs.cancel) {
                        e.cancel = true;
                    }
                    else {
                        _this.removingEventCallback(file);
                    }
                });
            }
            else {
                _this.removingEventCallback(file);
            }
        };
        var name = this.element.getAttribute('name');
        if (eventArgs.postRawFile && !sf.base.isNullOrUndefined(selectedFiles.rawFile) && selectedFiles.rawFile !== '') {
            formData.append(name, selectedFiles.rawFile, selectedFiles.name);
        }
        else {
            formData.append(name, selectedFiles.name);
        }
        ajax.onLoad = function (e) { _this.removeCompleted(e, selectedFiles, custom); return {}; };
        ajax.onError = function (e) { _this.removeFailed(e, selectedFiles, custom); return {}; };
        ajax.send(formData);
    };
    SfUploader.prototype.removeCompleted = function (e, files, customTemplate) {
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var status = e.target;
        if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
            var args = {
                e: e, response: response, operation: 'remove',
                file: this.updateStatus(files, this.localizedTexts('removedSuccessMessage'), '2')
            };
            if (this.successEnabled) {
                this.dotNetRef.invokeMethodAsync('SuccessEvent', args);
            }
            this.removeFilesData(files, customTemplate);
            var index = this.uploadedFilesData.indexOf(files);
            this.uploadedFilesData.splice(index, 1);
            if (this.changeEnabled) {
                this.dotNetRef.invokeMethodAsync('ChangeEvent', { files: this.uploadedFilesData });
            }
        }
        else {
            this.removeFailed(e, files, customTemplate);
        }
    };
    SfUploader.prototype.removeFailed = function (e, files, customTemplate) {
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var args = {
            e: e, response: response, operation: 'remove', file: this.updateStatus(files, this.localizedTexts('removedFailedMessage'), '0')
        };
        if (!customTemplate) {
            var index = this.filesData.indexOf(files);
            var rootElement = this.fileList[index];
            if (rootElement) {
                rootElement.classList.remove(UPLOAD_SUCCESS);
                rootElement.classList.add(UPLOAD_FAILED);
                var statusElement = rootElement.querySelector('.' + STATUS);
                if (statusElement) {
                    statusElement.classList.remove(UPLOAD_SUCCESS);
                    statusElement.classList.add(UPLOAD_FAILED);
                }
            }
            this.checkActionButtonStatus();
        }
        if (this.failuredEnabled) {
            this.dotNetRef.invokeMethodAsync('FailureEvent', args);
        }
        var liElement = this.getLiElement(files);
        if (!sf.base.isNullOrUndefined(liElement) && !sf.base.isNullOrUndefined(liElement.querySelector('.' + DELETE_ICON))) {
            var spinnerTarget = liElement.querySelector('.' + DELETE_ICON);
            disableSpinner(spinnerTarget);
            sf.base.detach(liElement.querySelector('.e-spinner-pane'));
        }
    };
    SfUploader.prototype.removingEventCallback = function (file) {
        var liElement = this.getLiElement(file);
        if (!sf.base.isNullOrUndefined(liElement) && (!sf.base.isNullOrUndefined(liElement.querySelector('.' + DELETE_ICON)) ||
            !sf.base.isNullOrUndefined(liElement.querySelector('.' + REMOVE_ICON)))) {
            var spinnerTarget = void 0;
            spinnerTarget = liElement.querySelector('.' + DELETE_ICON) ? liElement.querySelector('.' + DELETE_ICON) :
                liElement.querySelector('.' + REMOVE_ICON);
            renderSpinner({ target: spinnerTarget, width: '20px' });
            enableSpinner(spinnerTarget);
        }
    };
    SfUploader.prototype.updateFormData = function (formData, customData) {
        if (customData && customData.length > 0 && customData[0]) {
            var _loop_1 = function (i) {
                var data = customData[i];
                // tslint:disable-next-line
                var value = Object.keys(data).map(function (e) {
                    return data[e];
                });
                formData.append(Object.keys(data)[0], value);
            };
            for (var i = 0; i < customData.length; i++) {
                _loop_1(i);
            }
        }
    };
    SfUploader.prototype.updateCustomheader = function (request, currentRequest) {
        if (currentRequest.length > 0 && currentRequest[0]) {
            var _loop_2 = function (i) {
                var data = currentRequest[i];
                // tslint:disable-next-line
                var value = Object.keys(data).map(function (e) {
                    return data[e];
                });
                request.setRequestHeader(Object.keys(data)[0], value);
            };
            for (var i = 0; i < currentRequest.length; i++) {
                _loop_2(i);
            }
        }
    };
    SfUploader.prototype.getFilesFromFolder = function (event) {
        this.filesEntries = [];
        var items;
        items = this.multiple ? event.dataTransfer.items : [event.dataTransfer.items[0]];
        var validDirectoryUpload = this.checkDirectoryUpload(items);
        if (!validDirectoryUpload) {
            return;
        }
        var _loop_3 = function (i) {
            // tslint:disable-next-line
            var item = items[i].webkitGetAsEntry();
            if (item.isFile) {
                var files_2 = [];
                // tslint:disable-next-line
                (item).file(function (fileObj) {
                    var path = item.fullPath;
                    files_2.push({ 'path': path, 'file': fileObj });
                });
                this_1.renderSelectedFiles(event, files_2, true);
            }
            else if (item.isDirectory) {
                this_1.traverseFileTree(item, event);
            }
        };
        var this_1 = this;
        for (var i = 0; i < items.length; i++) {
            _loop_3(i);
        }
    };
    SfUploader.prototype.checkDirectoryUpload = function (items) {
        for (var i = 0; items && i < items.length; i++) {
            // tslint:disable-next-line
            var item = items[i].webkitGetAsEntry();
            if (item.isDirectory) {
                return true;
            }
        }
        return false;
    };
    // tslint:disable
    SfUploader.prototype.traverseFileTree = function (item, event) {
        if (item.isFile) {
            this.filesEntries.push(item);
        }
        else if (item.isDirectory) {
            // tslint:disable-next-line
            var directoryReader = item.createReader();
            // tslint:disable-next-line
            this.readFileFromDirectory(directoryReader, event);
        }
    };
    // tslint:disable
    SfUploader.prototype.readFileFromDirectory = function (directoryReader, event) {
        var _this = this;
        // tslint:disable-next-line
        directoryReader.readEntries(function (entries) {
            for (var i = 0; i < entries.length; i++) {
                _this.traverseFileTree(entries[i], event);
                // tslint:disable-next-line
            }
            
            _this.pushFilesEntries(event);
            if (entries.length) {
                _this.readFileFromDirectory(directoryReader);
            }
        });
    };
    SfUploader.prototype.pushFilesEntries = function (event) {
        var _this = this;
        var files = [];
        var _loop_4 = function (i) {
            // tslint:disable-next-line
            this_2.filesEntries[i].file(function (fileObj) {
                if (_this.filesEntries.length) {
                    var path = _this.filesEntries[i].fullPath;
                    files.push({ 'path': path, 'file': fileObj });
                    if (i === _this.filesEntries.length - 1) {
                        _this.filesEntries = [];
                        _this.renderSelectedFiles(event, files, true);
                    }
                }
            });
        };
        var this_2 = this;
        for (var i = 0; i < this.filesEntries.length; i++) {
            _loop_4(i);
        }
    };
    // tslint:enable
    SfUploader.prototype.onSelectFiles = function (args) {
        if (!this.enabled) {
            return;
        }
        var targetFiles;
        if (args.type === 'drop') {
            if (this.directoryUpload) {
                this.getFilesFromFolder(args);
            }
            else {
                var files = this.sortFilesList = args.dataTransfer.files;
                if (this.browserName !== 'msie' && this.browserName !== 'edge' && this.browserName !== 'safari') {
                    this.element.files = files;
                }
                if (files.length > 0) {
                    targetFiles = this.multiple ? this.sortFileList(files) : [files[0]];
                    this.renderSelectedFiles(args, targetFiles);
                }
            }
        }
        else {
            targetFiles = [].slice.call(args.target.files);
            this.renderSelectedFiles(args, targetFiles);
        }
    };
    SfUploader.prototype.getBase64 = function (file) {
        return new Promise(function (resolve, reject) {
            var fileReader = new FileReader();
            fileReader.readAsDataURL(file);
            fileReader.onload = function () { return resolve(fileReader.result); };
            fileReader.onerror = function (error) { return reject(error); };
        });
    };
    /* tslint:ignore */
    SfUploader.prototype.renderSelectedFiles = function (args, 
    // tslint:disable-next-line
    targetFiles, directory, paste) {
        var _this = this;
        this.base64String = [];
        // tslint:disable-next-line
        var eventArgs = {
            event: args,
            cancel: false,
            filesData: [],
            isModified: false,
            modifiedFilesData: [],
            progressInterval: '',
            isCanceled: false,
            currentRequest: null,
            customFormData: null,
            type: args && args.type
        };
        if (targetFiles.length < 1) {
            eventArgs.isCanceled = true;
            if (this.selectedEnabled) {
                this.dotNetRef.invokeMethodAsync('SelectedEvent', eventArgs);
            }
            return;
        }
        this.flag = true;
        var fileData = [];
        if (!this.multiple) {
            this.clearData(true);
            targetFiles = [targetFiles[0]];
        }
        for (var i = 0; i < targetFiles.length; i++) {
            var file = directory ? targetFiles[i].file : targetFiles[i];
            this.updateInitialFileDetails(args, targetFiles, file, i, fileData, directory, paste);
        }
        eventArgs.filesData = fileData;
        if (this.allowedExtensions.indexOf('*') > -1) {
            this.allTypes = true;
        }
        if (!this.allTypes) {
            fileData = this.checkExtension(fileData);
        }
        if (this.selectedEnabled) {
            // @ts-ignore-start
            this.dotNetRef.invokeMethodAsync('SelectedEvent', eventArgs).then(function (eventArgs) {
                // @ts-ignore-end
                _this._internalRenderSelect(eventArgs, fileData);
            });
        }
        else {
            this._internalRenderSelect(eventArgs, fileData);
        }
    };
    SfUploader.prototype.updateInitialFileDetails = function (args, 
    // tslint:disable-next-line
    targetFiles, file, i, fileData, directory, paste) {
        var fileName = directory ? targetFiles[i].path.substring(1, targetFiles[i].path.length) : paste ?
            sf.base.getUniqueID(file.name.substring(0, file.name.lastIndexOf('.'))) + '.' + this.getFileType(file.name) :
            this.directoryUpload ? targetFiles[i].webkitRelativePath : file.name;
        var fileDetails = {
            name: fileName,
            rawFile: file,
            size: file.size,
            status: this.localizedTexts('readyToUploadMessage'),
            type: this.getFileType(file.name),
            mimeContentType: file.type,
            lastModifiedDate: new Date(file.lastModified),
            validationMessages: this.validatedFileSize(file.size),
            statusCode: '1',
            id: sf.base.getUniqueID(file.name.substring(0, file.name.lastIndexOf('.'))) + '.' + this.getFileType(file.name)
        };
        if (paste) {
            fileDetails.fileSource = 'paste';
        }
        fileDetails.status = fileDetails.validationMessages.minSize !== '' ? this.localizedTexts('invalidMinFileSize') :
            fileDetails.validationMessages.maxSize !== '' ? this.localizedTexts('invalidMaxFileSize') : fileDetails.status;
        if (fileDetails.validationMessages.minSize !== '' || fileDetails.validationMessages.maxSize !== '') {
            fileDetails.statusCode = '0';
        }
        fileData.push(fileDetails);
    };
    SfUploader.prototype._internalRenderSelect = function (eventArgs, fileData) {
        if (!eventArgs.cancel) {
            this.currentRequestHeader = eventArgs.currentRequest;
            this.customFormDatas = eventArgs.customFormData;
            this.selectedFiles = this.selectedFiles.concat(fileData);
            this.btnTabIndex = this.disableKeyboardNavigation ? '-1' : '0';
            if (this.showFileList) {
                if (eventArgs.isModified && eventArgs.modifiedFilesData.length > 0) {
                    for (var j = 0; j < eventArgs.modifiedFilesData.length; j++) {
                        for (var k = 0; k < fileData.length; k++) {
                            if (eventArgs.modifiedFilesData[j].id === fileData[k].id) {
                                eventArgs.modifiedFilesData[j].rawFile = fileData[k].rawFile;
                            }
                        }
                    }
                    var dataFiles = this.allTypes ? eventArgs.modifiedFilesData :
                        this.checkExtension(eventArgs.modifiedFilesData);
                    this.updateSortedFileList(dataFiles);
                    this.filesData = dataFiles;
                    if ((!this.isForm || this.allowUpload()) && !(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
                        this.checkAutoUpload(dataFiles);
                    }
                }
                else {
                    this.createFileList(fileData, true);
                    if (!(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
                        this.filesData = this.filesData.concat(fileData);
                    }
                    if ((!this.isForm || this.allowUpload()) && !(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
                        this.checkAutoUpload(fileData);
                    }
                }
                if (!sf.base.isNullOrUndefined(eventArgs.progressInterval) && eventArgs.progressInterval !== '') {
                    this.progressInterval = eventArgs.progressInterval;
                }
            }
            else {
                this.filesData = this.filesData.concat(fileData);
                if (this.isBlazorSaveUrl) {
                    // tslint:disable-next-line
                    this.dotNetRef.invokeMethodAsync('UpdateServerFileData', this.filesData, this.isForm);
                }
                if (this.autoUpload) {
                    this.upload(this.filesData, true);
                }
            }
            this.raiseActionComplete();
            this.isFirstFileOnSelection = true;
        }
    };
    SfUploader.prototype.allowUpload = function () {
        var allowFormUpload = false;
        if (this.isForm && (!sf.base.isNullOrUndefined(this.asyncSettings.saveUrl) && this.asyncSettings.saveUrl !== '')) {
            allowFormUpload = true;
        }
        return allowFormUpload;
    };
    SfUploader.prototype.isFormUpload = function () {
        var isFormUpload = false;
        if (this.isForm && ((sf.base.isNullOrUndefined(this.asyncSettings.saveUrl) || this.asyncSettings.saveUrl === '')
            && (sf.base.isNullOrUndefined(this.asyncSettings.removeUrl) || this.asyncSettings.removeUrl === ''))) {
            isFormUpload = true;
        }
        return isFormUpload;
    };
    SfUploader.prototype.clearData = function (singleUpload) {
        if (!sf.base.isNullOrUndefined(this.listParent) && !(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
            sf.base.detach(this.listParent);
            this.listParent = null;
        }
        if (this.browserName !== 'msie' && !singleUpload) {
            this.element.value = '';
        }
        this.fileList = [];
        this.filesData = [];
        if (this.isBlazorSaveUrl || this.isBlazorTemplate) {
            // tslint:disable-next-line
            this.dotNetRef.invokeMethodAsync('ClearAllFile');
        }
        else {
            this.removeActionButtons();
        }
    };
    SfUploader.prototype.updateSortedFileList = function (filesData) {
        var previousListClone = sf.base.createElement('div', { id: 'clonewrapper' });
        var added = -1;
        var removedList;
        if (this.listParent) {
            for (var i = 0; i < this.listParent.querySelectorAll('li').length; i++) {
                var liElement = this.listParent.querySelectorAll('li')[i];
                previousListClone.appendChild(liElement.cloneNode(true));
            }
            removedList = this.listParent.querySelectorAll('li');
            for (var _i = 0, removedList_1 = removedList; _i < removedList_1.length; _i++) {
                var item = removedList_1[_i];
                sf.base.detach(item);
            }
            this.removeActionButtons();
            var oldList = [].slice.call(previousListClone.childNodes);
            sf.base.detach(this.listParent);
            this.listParent = null;
            this.fileList = [];
            this.createParentUL();
            for (var index = 0; index < filesData.length; index++) {
                for (var j = 0; j < this.filesData.length; j++) {
                    if (this.filesData[j].name === filesData[index].name) {
                        this.listParent.appendChild(oldList[j]);
                        sf.base.EventHandler.add(oldList[j].querySelector('.e-icons'), 'click', this.removeFiles, this);
                        this.fileList.push(oldList[j]);
                        added = index;
                    }
                }
                if (added !== index) {
                    this.createFileList([filesData[index]]);
                }
            }
        }
        else {
            this.createFileList(filesData);
        }
    };
    SfUploader.prototype.isBlank = function (str) {
        return (!str || /^\s*$/.test(str));
    };
    SfUploader.prototype.checkExtension = function (files) {
        var dropFiles = files;
        if (!this.isBlank(this.allowedExtensions)) {
            var allowedExtensions = [];
            var extensions = this.allowedExtensions.split(',');
            for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
                var extension = extensions_1[_i];
                allowedExtensions.push(extension.trim().toLocaleLowerCase());
            }
            for (var i = 0; i < files.length; i++) {
                if (allowedExtensions.indexOf(('.' + files[i].type).toLocaleLowerCase()) === -1) {
                    files[i].status = this.localizedTexts('invalidFileType');
                    files[i].statusCode = '0';
                }
            }
        }
        return dropFiles;
    };
    SfUploader.prototype.validatedFileSize = function (fileSize) {
        var minSizeError = '';
        var maxSizeError = '';
        if (fileSize < this.minFileSize) {
            minSizeError = this.localizedTexts('invalidMinFileSize');
        }
        else if (fileSize > this.maxFileSize) {
            maxSizeError = this.localizedTexts('invalidMaxFileSize');
        }
        else {
            minSizeError = '';
            maxSizeError = '';
        }
        var errorMessage = { minSize: minSizeError, maxSize: maxSizeError };
        return errorMessage;
    };
    SfUploader.prototype.isPreLoadFile = function (fileData) {
        var isPreload = false;
        if (this.files) {
            for (var i = 0; i < this.files.length; i++) {
                if (this.files[i].name === fileData.name.slice(0, fileData.name.lastIndexOf('.')) && this.files[i].type === fileData.type) {
                    isPreload = true;
                    break;
                }
            }
        }
        return isPreload;
    };
    SfUploader.prototype.createParentUL = function () {
        if (sf.base.isNullOrUndefined(this.listParent)) {
            this.listParent = sf.base.createElement('ul', { className: LIST_PARENT });
            this.uploadWrapper.appendChild(this.listParent);
        }
    };
    SfUploader.prototype.formFileList = function (fileData, files) {
        var fileList = sf.base.createElement('li', { className: FILE });
        fileList.setAttribute('data-files-count', fileData.length + '');
        var fileContainer = sf.base.createElement('span', { className: TEXT_CONTAINER });
        var statusMessage;
        for (var _i = 0, fileData_1 = fileData; _i < fileData_1.length; _i++) {
            var listItem = fileData_1[_i];
            var fileNameEle = sf.base.createElement('span', { className: FILE_NAME });
            fileNameEle.innerHTML = this.getFileNameOnly(listItem.name);
            var fileTypeEle = sf.base.createElement('span', { className: FILE_TYPE });
            var fileType = this.getFileType(listItem.name);
            fileTypeEle.innerHTML = '.' + fileType;
            if (!fileType) {
                fileTypeEle.classList.add('e-hidden');
            }
            if (!this.enableRtl) {
                fileContainer.appendChild(fileNameEle);
                fileContainer.appendChild(fileTypeEle);
            }
            else {
                var rtlContainer = sf.base.createElement('span', { className: RTL_CONTAINER });
                rtlContainer.appendChild(fileTypeEle);
                rtlContainer.appendChild(fileNameEle);
                fileContainer.appendChild(rtlContainer);
            }
            this.truncateName(fileNameEle);
            statusMessage = this.formValidateFileInfo(listItem, fileList);
        }
        fileList.appendChild(fileContainer);
        this.setListToFileInfo(fileData, fileList);
        var index = this.listParent.querySelectorAll('li').length;
        var infoEle = sf.base.createElement('span');
        if (fileList.classList.contains(INVALID_FILE)) {
            infoEle.classList.add(STATUS);
            infoEle.classList.add(INVALID_FILE);
            infoEle.innerText = fileData.length > 1 ? this.localizedTexts('invalidFileSelection') : statusMessage;
        }
        else {
            infoEle.classList.add(fileData.length > 1 ? INFORMATION : FILE_SIZE);
            infoEle.innerText = fileData.length > 1 ? this.localizedTexts('totalFiles') + ': ' + fileData.length + ' , '
                + this.localizedTexts('size') + ': ' +
                this.bytesToSize(this.getFileSize(fileData)) : this.bytesToSize(fileData[0].size);
            this.createFormInput(fileData);
        }
        fileContainer.appendChild(infoEle);
        if (sf.base.isNullOrUndefined(fileList.querySelector('.e-icons'))) {
            var iconElement = sf.base.createElement('span', { className: 'e-icons', attrs: { 'tabindex': this.btnTabIndex } });
            if (this.browserName === 'msie') {
                iconElement.classList.add('e-msie');
            }
            iconElement.setAttribute('title', this.localizedTexts('remove'));
            fileList.appendChild(fileContainer);
            fileList.appendChild(iconElement);
            sf.base.EventHandler.add(iconElement, 'click', this.removeFiles, this);
            iconElement.classList.add(REMOVE_ICON);
        }
        var eventsArgs = {
            element: fileList,
            fileInfo: this.mergeFileInfo(fileData, fileList),
            index: index,
            isPreload: this.isPreLoadFile(this.mergeFileInfo(fileData, fileList))
        };
        if (this.fileListRenderEnabled) {
            this.dotNetRef.invokeMethodAsync('FileListRenderingEvent', eventsArgs);
        }
        this.listParent.appendChild(fileList);
        this.fileList.push(fileList);
    };
    SfUploader.prototype.formValidateFileInfo = function (listItem, fileList) {
        var statusMessage = listItem.status;
        var validationMessages = this.validatedFileSize(listItem.size);
        if (validationMessages.minSize !== '' || validationMessages.maxSize !== '') {
            this.addInvalidClass(fileList);
            statusMessage = validationMessages.minSize !== '' ? this.localizedTexts('invalidMinFileSize') :
                validationMessages.maxSize !== '' ? this.localizedTexts('invalidMaxFileSize') : statusMessage;
        }
        var typeValidationMessage = this.checkExtension(this.getFilesInArray(listItem))[0].status;
        if (typeValidationMessage === this.localizedTexts('invalidFileType')) {
            this.addInvalidClass(fileList);
            statusMessage = typeValidationMessage;
        }
        return statusMessage;
    };
    SfUploader.prototype.addInvalidClass = function (fileList) {
        fileList.classList.add(INVALID_FILE);
    };
    SfUploader.prototype.createFormInput = function (fileData) {
        var inputElement = this.element.cloneNode(true);
        inputElement.classList.add(HIDDEN_INPUT);
        for (var _i = 0, fileData_2 = fileData; _i < fileData_2.length; _i++) {
            var listItem = fileData_2[_i];
            listItem.input = inputElement;
        }
        inputElement.setAttribute('name', this.uploaderName);
        this.uploadWrapper.querySelector('.' + INPUT_WRAPPER).appendChild(inputElement);
        if (this.browserName !== 'msie' && this.browserName !== 'edge') {
            this.element.value = '';
        }
    };
    SfUploader.prototype.getFileSize = function (fileData) {
        var fileSize = 0;
        for (var _i = 0, fileData_3 = fileData; _i < fileData_3.length; _i++) {
            var file = fileData_3[_i];
            fileSize += file.size;
        }
        return fileSize;
    };
    SfUploader.prototype.mergeFileInfo = function (fileData, fileList) {
        var result = {
            name: '',
            rawFile: '',
            size: 0,
            status: '',
            type: '',
            validationMessages: { minSize: '', maxSize: '' },
            statusCode: '1',
            list: fileList
        };
        var fileNames = [];
        var type = '';
        for (var _i = 0, fileData_4 = fileData; _i < fileData_4.length; _i++) {
            var listItem = fileData_4[_i];
            fileNames.push(listItem.name);
            type = listItem.type;
        }
        result.name = fileNames.join(', ');
        result.size = this.getFileSize(fileData);
        result.type = type;
        result.status = this.statusForFormUpload(fileData, fileList);
        return result;
    };
    SfUploader.prototype.statusForFormUpload = function (fileData, fileList) {
        var isValid = true;
        var statusMessage;
        for (var _i = 0, fileData_5 = fileData; _i < fileData_5.length; _i++) {
            var listItem = fileData_5[_i];
            statusMessage = listItem.status;
            var validationMessages = this.validatedFileSize(listItem.size);
            if (validationMessages.minSize !== '' || validationMessages.maxSize !== '') {
                isValid = false;
                statusMessage = validationMessages.minSize !== '' ? this.localizedTexts('invalidMinFileSize') :
                    validationMessages.maxSize !== '' ? this.localizedTexts('invalidMaxFileSize') : statusMessage;
            }
            var typeValidationMessage = this.checkExtension(this.getFilesInArray(listItem))[0].status;
            if (typeValidationMessage === this.localizedTexts('invalidFileType')) {
                isValid = false;
                statusMessage = typeValidationMessage;
            }
        }
        if (!isValid) {
            fileList.classList.add(INVALID_FILE);
            statusMessage = fileData.length > 1 ? this.localizedTexts('invalidFileSelection') : statusMessage;
        }
        else {
            statusMessage = this.localizedTexts('totalFiles') + ': ' + fileData.length + ' , '
                + this.localizedTexts('size') + ': ' +
                this.bytesToSize(this.getFileSize(fileData));
        }
        return statusMessage;
    };
    /**
     * Create the file list for specified files data.
     * @param { FileInfo[] } fileData - specifies the files data for file list creation.
     * @returns void
     */
    SfUploader.prototype.createFileList = function (fileData, isSelectedFile) {
        if (this.isBlazorSaveUrl || this.isBlazorTemplate) {
            var fileListData = (isSelectedFile) ? this.filesData = this.filesData.concat(fileData) : fileData;
            // tslint:disable-next-line
            this.dotNetRef.invokeMethodAsync('CreateFileList', fileListData, this.isForm);
        }
        else {
            this.createParentUL();
            if (this.isFormUpload()) {
                this.uploadWrapper.classList.add(FORM_UPLOAD);
                this.formFileList(fileData, this.element.files);
            }
            else {
                for (var _i = 0, fileData_6 = fileData; _i < fileData_6.length; _i++) {
                    var listItem = fileData_6[_i];
                    var liElement = sf.base.createElement('li', {
                        className: FILE,
                        attrs: { 'data-file-name': listItem.name, 'data-files-count': '1' }
                    });
                    var textContainer = sf.base.createElement('span', { className: TEXT_CONTAINER });
                    var textElement = sf.base.createElement('span', { className: FILE_NAME, attrs: { 'title': listItem.name } });
                    textElement.innerHTML = this.getFileNameOnly(listItem.name);
                    var fileExtension = sf.base.createElement('span', { className: FILE_TYPE });
                    var fileType = this.getFileType(listItem.name);
                    fileExtension.innerHTML = '.' + fileType;
                    if (!fileType) {
                        fileExtension.classList.add('e-hidden');
                    }
                    if (!this.enableRtl) {
                        textContainer.appendChild(textElement);
                        textContainer.appendChild(fileExtension);
                    }
                    else {
                        var rtlContainer = sf.base.createElement('span', { className: RTL_CONTAINER });
                        rtlContainer.appendChild(fileExtension);
                        rtlContainer.appendChild(textElement);
                        textContainer.appendChild(rtlContainer);
                    }
                    var fileSize = sf.base.createElement('span', { className: FILE_SIZE });
                    fileSize.innerHTML = this.bytesToSize(listItem.size);
                    textContainer.appendChild(fileSize);
                    var statusElement = sf.base.createElement('span', { className: STATUS });
                    textContainer.appendChild(statusElement);
                    statusElement.innerHTML = listItem.status;
                    liElement.appendChild(textContainer);
                    var iconElement = sf.base.createElement('span', {
                        className: ' e-icons',
                        attrs: { 'tabindex': this.btnTabIndex }
                    });
                    if (this.browserName === 'msie') {
                        iconElement.classList.add('e-msie');
                    }
                    iconElement.setAttribute('title', this.localizedTexts('remove'));
                    liElement.appendChild(iconElement);
                    sf.base.EventHandler.add(iconElement, 'click', this.removeFiles, this);
                    if (listItem.statusCode === '2') {
                        statusElement.classList.add(UPLOAD_SUCCESS);
                        iconElement.classList.add(DELETE_ICON);
                        iconElement.setAttribute('title', this.localizedTexts('delete'));
                    }
                    else if (listItem.statusCode !== '1') {
                        statusElement.classList.remove(UPLOAD_SUCCESS);
                        statusElement.classList.add(VALIDATION_FAILS);
                    }
                    if (this.autoUpload && listItem.statusCode === '1' && this.asyncSettings.saveUrl !== '') {
                        statusElement.innerHTML = '';
                    }
                    if (!iconElement.classList.contains(DELETE_ICON)) {
                        iconElement.classList.add(REMOVE_ICON);
                    }
                    var index = fileData.indexOf(listItem);
                    var eventsArgs = {
                        element: liElement,
                        fileInfo: listItem,
                        index: index,
                        isPreload: this.isPreLoadFile(listItem)
                    };
                    if (this.fileListRenderEnabled) {
                        this.dotNetRef.invokeMethodAsync('FileListRenderingEvent', eventsArgs);
                    }
                    this.listParent.appendChild(liElement);
                    this.fileList.push(liElement);
                    this.truncateName(textElement);
                    var preventActionComplete = this.flag;
                    if (this.isPreLoadFile(listItem)) {
                        this.flag = false;
                        this.checkActionComplete(true);
                        this.flag = preventActionComplete;
                    }
                }
            }
        }
    };
    SfUploader.prototype.getSlicedName = function (nameElement) {
        var text;
        text = nameElement.textContent;
        nameElement.dataset.tail = text.slice(text.length - 10);
    };
    SfUploader.prototype.setListToFileInfo = function (fileData, fileList) {
        for (var _i = 0, fileData_7 = fileData; _i < fileData_7.length; _i++) {
            var listItem = fileData_7[_i];
            listItem.list = fileList;
        }
    };
    SfUploader.prototype.truncateName = function (name) {
        var nameElement = name;
        if (this.browserName !== 'edge' && nameElement.offsetWidth < nameElement.scrollWidth) {
            this.getSlicedName(nameElement);
        }
        else if (nameElement.offsetWidth + 1 < nameElement.scrollWidth) {
            this.getSlicedName(nameElement);
        }
    };
    SfUploader.prototype.getFileType = function (name) {
        var extension;
        var index = name.lastIndexOf('.');
        if (index >= 0) {
            extension = name.substring(index + 1);
        }
        return extension ? extension : '';
    };
    SfUploader.prototype.getFileNameOnly = function (name) {
        var type = this.getFileType(name);
        var names = name.split('.' + type);
        return type = names[0];
    };
    SfUploader.prototype.setInitialAttributes = function () {
        if (this.initialAttr.accept) {
            this.element.setAttribute('accept', this.initialAttr.accept);
        }
        if (this.initialAttr.disabled) {
            this.element.setAttribute('disabled', 'disabled');
        }
        if (this.initialAttr.multiple) {
            var newAttr = document.createAttribute('multiple');
            this.element.setAttributeNode(newAttr);
        }
    };
    SfUploader.prototype.filterfileList = function (files) {
        var filterFiles = [];
        var li;
        for (var i = 0; i < files.length; i++) {
            li = this.getLiElement(files[i]);
            if (!li.classList.contains(UPLOAD_SUCCESS)) {
                filterFiles.push(files[i]);
            }
        }
        return filterFiles;
    };
    SfUploader.prototype.updateStatus = function (files, status, statusCode, updateLiStatus) {
        if (updateLiStatus === void 0) { updateLiStatus = true; }
        if (!(status === '' || sf.base.isNullOrUndefined(status)) && !(statusCode === '' || sf.base.isNullOrUndefined(statusCode))) {
            if (this.isBlazorSaveUrl) {
                for (var i = 0; i < this.filesData.length; i++) {
                    if (this.filesData[i].name === files.name) {
                        this.filesData[i].status = status;
                        this.filesData[i].statusCode = statusCode;
                    }
                }
            }
            else {
                files.status = status;
                files.statusCode = statusCode;
            }
        }
        if (updateLiStatus) {
            var li = this.getLiElement(files);
            if (!sf.base.isNullOrUndefined(li)) {
                if (!sf.base.isNullOrUndefined(li.querySelector('.' + STATUS)) && !((status === '' || sf.base.isNullOrUndefined(status)))) {
                    li.querySelector('.' + STATUS).textContent = status;
                }
            }
        }
        return files;
    };
    SfUploader.prototype.getLiElement = function (files) {
        var index;
        for (var i = 0; i < this.filesData.length; i++) {
            if ((!sf.base.isNullOrUndefined(this.filesData[i].id) && !sf.base.isNullOrUndefined(files.id)) ? (this.filesData[i].name === files.name &&
                this.filesData[i].id === files.id) : this.filesData[i].name === files.name) {
                index = i;
            }
        }
        return this.fileList[index];
    };
    SfUploader.prototype.createProgressBar = function (liElement) {
        var progressbarWrapper = sf.base.createElement('span', { className: PROGRESS_WRAPPER });
        var progressBar = sf.base.createElement('progressbar', { className: PROGRESSBAR, attrs: { value: '0', max: '100' } });
        var progressbarInnerWrapper = sf.base.createElement('span', { className: PROGRESS_INNER_WRAPPER });
        progressBar.setAttribute('style', 'width: 0%');
        var progressbarText = sf.base.createElement('span', { className: PROGRESSBAR_TEXT });
        progressbarText.textContent = '0%';
        progressbarInnerWrapper.appendChild(progressBar);
        progressbarWrapper.appendChild(progressbarInnerWrapper);
        progressbarWrapper.appendChild(progressbarText);
        liElement.querySelector('.' + TEXT_CONTAINER).appendChild(progressbarWrapper);
    };
    SfUploader.prototype.updateProgressbar = function (e, li) {
        if (!isNaN(Math.round((e.loaded / e.total) * 100)) && !sf.base.isNullOrUndefined(li.querySelector('.' + PROGRESSBAR))) {
            if (!sf.base.isNullOrUndefined(this.progressInterval) && this.progressInterval !== '') {
                var value = (Math.round((e.loaded / e.total) * 100)) % parseInt(this.progressInterval, 10);
                if (value === 0 || value === 100) {
                    this.changeProgressValue(li, Math.round((e.loaded / e.total) * 100).toString() + '%');
                }
            }
            else {
                this.changeProgressValue(li, Math.round((e.loaded / e.total) * 100).toString() + '%');
            }
        }
    };
    SfUploader.prototype.changeProgressValue = function (li, progressValue) {
        li.querySelector('.' + PROGRESSBAR).setAttribute('style', 'width:' + progressValue);
        li.querySelector('.' + PROGRESSBAR_TEXT).textContent = progressValue;
    };
    SfUploader.prototype.uploadInProgress = function (e, files, customUI, request) {
        var li = this.getLiElement(files);
        if (sf.base.isNullOrUndefined(li) && (!customUI)) {
            return;
        }
        if (!sf.base.isNullOrUndefined(li)) {
            if (files.statusCode === '5') {
                this.cancelUploadingFile(files, e, request, li);
            }
            if (!(li.querySelectorAll('.' + PROGRESS_WRAPPER).length > 0) && li.querySelector('.' + STATUS)) {
                li.querySelector('.' + STATUS).classList.add(UPLOAD_INPROGRESS);
                this.createProgressBar(li);
                this.updateProgressBarClasses(li, UPLOAD_INPROGRESS);
                li.querySelector('.' + STATUS).classList.remove(UPLOAD_FAILED);
            }
            this.updateProgressbar(e, li);
            var iconEle = li.querySelector('.' + REMOVE_ICON);
            if (!sf.base.isNullOrUndefined(iconEle)) {
                iconEle.classList.add(ABORT_ICON, UPLOAD_INPROGRESS);
                iconEle.setAttribute('title', this.localizedTexts('abort'));
                iconEle.classList.remove(REMOVE_ICON);
            }
        }
        else {
            this.cancelUploadingFile(files, e, request);
        }
        var args = {
            e: e,
            operation: 'upload',
            file: this.updateStatus(files, this.localizedTexts('inProgress'), '3'),
            lengthComputable: e.lengthComputable,
            loaded: e.loaded,
            total: e.total
        };
        if (this.progressingEnabled) {
            this.dotNetRef.invokeMethodAsync('ProgressEvent', args);
        }
    };
    SfUploader.prototype.cancelEventCallback = function (files, request, li, eventArgs) {
        var _this = this;
        if (eventArgs.cancel) {
            files.statusCode = '3';
            if (!sf.base.isNullOrUndefined(li)) {
                var spinnerTarget = li.querySelector('.' + ABORT_ICON);
                if (!sf.base.isNullOrUndefined(spinnerTarget)) {
                    disableSpinner(spinnerTarget);
                    sf.base.detach(li.querySelector('.e-spinner-pane'));
                }
            }
        }
        else {
            request.emitError = false;
            request.httpRequest.abort();
            var formData = new FormData();
            if (files.statusCode === '5') {
                var name_1 = this.element.getAttribute('name');
                formData.append(name_1, files.name);
                formData.append('cancel-uploading', files.name);
                var ajax = new sf.base.Ajax(this.asyncSettings.removeUrl, 'POST', true, null);
                ajax.emitError = false;
                ajax.onLoad = function (e) { _this.removecanceledFile(e, files); return {}; };
                ajax.send(formData);
            }
        }
    };
    SfUploader.prototype.cancelUploadingFile = function (files, e, request, li) {
        var _this = this;
        if (files.statusCode === '5') {
            var eventArgs = {
                event: e,
                fileData: files,
                cancel: false
            };
            if (this.cancelEnabled) {
                // @ts-ignore-start
                this.dotNetRef.invokeMethodAsync('CancelingEvent', eventArgs).then(function (eventArgs) {
                    // @ts-ignore-end
                    _this.cancelEventCallback(files, request, li, eventArgs);
                });
            }
            else {
                this.cancelEventCallback(files, request, li, eventArgs);
            }
        }
    };
    SfUploader.prototype.removecanceledFile = function (e, file) {
        var liElement = this.getLiElement(file);
        if (liElement.querySelector('.' + RETRY_ICON) || sf.base.isNullOrUndefined(liElement.querySelector('.' + ABORT_ICON))) {
            return;
        }
        this.updateStatus(file, this.localizedTexts('fileUploadCancel'), '5');
        this.renderFailureState(e, file, liElement);
        var spinnerTarget = liElement.querySelector('.' + REMOVE_ICON);
        if (!sf.base.isNullOrUndefined(liElement)) {
            disableSpinner(spinnerTarget);
            sf.base.detach(liElement.querySelector('.e-spinner-pane'));
        }
        var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
        var args = { event: e, response: requestResponse, operation: 'cancel', file: file };
        if (this.successEnabled) {
            this.dotNetRef.invokeMethodAsync('SuccessEvent', args);
        }
    };
    SfUploader.prototype.renderFailureState = function (e, file, liElement) {
        var _this = this;
        this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
        this.removeProgressbar(liElement, 'failure');
        if (!sf.base.isNullOrUndefined(liElement.querySelector('.e-file-status'))) {
            liElement.querySelector('.e-file-status').classList.add(UPLOAD_FAILED);
        }
        var deleteIcon = liElement.querySelector('.' + ABORT_ICON);
        if (sf.base.isNullOrUndefined(deleteIcon)) {
            return;
        }
        deleteIcon.classList.remove(ABORT_ICON, UPLOAD_INPROGRESS);
        deleteIcon.classList.add(REMOVE_ICON);
        deleteIcon.setAttribute('title', this.localizedTexts('remove'));
        this.pauseButton = sf.base.createElement('span', { className: 'e-icons e-file-reload-btn', attrs: { 'tabindex': this.btnTabIndex } });
        deleteIcon.parentElement.insertBefore(this.pauseButton, deleteIcon);
        this.pauseButton.setAttribute('title', this.localizedTexts('retry'));
        var retryElement = liElement.querySelector('.' + RETRY_ICON);
        retryElement.addEventListener('click', function (e) { _this.reloadcanceledFile(e, file, liElement, false); }, false);
    };
    SfUploader.prototype.reloadcanceledFile = function (e, file, liElement, custom) {
        file.statusCode = '1';
        file.status = this.localizedTexts('readyToUploadMessage');
        if (!custom) {
            liElement.querySelector('.' + STATUS).classList.remove(UPLOAD_FAILED);
            if (!sf.base.isNullOrUndefined(liElement.querySelector('.' + RETRY_ICON))) {
                sf.base.detach(liElement.querySelector('.' + RETRY_ICON));
            }
            this.pauseButton = null;
        }
        liElement.classList.add(RESTRICT_RETRY);
        this.upload([file]);
    };
    SfUploader.prototype.uploadComplete = function (e, file, customUI) {
        var status = e.target;
        if (status.readyState === 4 && status.status >= 200 && status.status <= 299) {
            var li = this.getLiElement(file);
            if (sf.base.isNullOrUndefined(li) && (!customUI || sf.base.isNullOrUndefined(customUI))) {
                return;
            }
            if (!sf.base.isNullOrUndefined(li)) {
                this.updateProgressBarClasses(li, UPLOAD_SUCCESS);
                this.removeProgressbar(li, 'success');
                var iconEle = li.querySelector('.' + ABORT_ICON);
                if (!sf.base.isNullOrUndefined(iconEle)) {
                    iconEle.classList.add(DELETE_ICON);
                    iconEle.setAttribute('title', this.localizedTexts('delete'));
                    iconEle.classList.remove(ABORT_ICON);
                    iconEle.classList.remove(UPLOAD_INPROGRESS);
                }
            }
            this.raiseSuccessEvent(e, file);
        }
        else {
            this.uploadFailed(e, file);
        }
    };
    SfUploader.prototype.getResponse = function (e) {
        // tslint:disable-next-line
        var target = e.currentTarget;
        var response = {
            readyState: target.readyState,
            statusCode: target.status,
            statusText: target.statusText,
            headers: target.getAllResponseHeaders(),
            withCredentials: target.withCredentials
        };
        return response;
    };
    SfUploader.prototype.serverRemoveIconBindEvent = function () {
        if (this.uploadWrapper && this.isBlazorSaveUrl) {
            var iconElement = [].slice.call(this.uploadWrapper.querySelectorAll('ul li'));
            for (var i = 0; i < iconElement.length; i++) {
                var removeIconEle = (iconElement[i]) ? iconElement[i].querySelector('.e-icons') : null;
                if (removeIconEle) {
                    sf.base.EventHandler.remove(removeIconEle, 'click', this.removeFiles);
                    sf.base.EventHandler.add(removeIconEle, 'click', this.removeFiles, this);
                }
            }
        }
    };
    SfUploader.prototype.raiseSuccessEvent = function (e, file) {
        var _this = this;
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var statusMessage = this.localizedTexts('uploadSuccessMessage');
        var args = {
            e: e, response: response, operation: 'upload', file: this.updateStatus(file, statusMessage, '2', false), statusText: statusMessage
        };
        if (!this.isBlazorSaveUrl) {
            var liElement = this.getLiElement(file);
            if (!sf.base.isNullOrUndefined(liElement)) {
                var spinnerEle = liElement.querySelector('.' + SPINNER_PANE);
                if (!sf.base.isNullOrUndefined(spinnerEle)) {
                    disableSpinner(liElement);
                    sf.base.detach(spinnerEle);
                }
            }
        }
        if (this.successEnabled) {
            // @ts-ignore-start
            this.dotNetRef.invokeMethodAsync('SuccessEvent', args).then(function (args) {
                // @ts-ignore-end
                _this.successEventCallback(file, args);
            });
        }
        else {
            this.successEventCallback(file, args);
        }
    };
    SfUploader.prototype.successEventCallback = function (file, args) {
        // tslint:disable-next-line
        this.updateStatus(file, args.statusText, '2');
        this.uploadedFilesData.push(file);
        if (!this.isBlazorSaveUrl && this.changeEnabled) {
            this.dotNetRef.invokeMethodAsync('ChangeEvent', { files: this.uploadedFilesData });
        }
        this.checkActionButtonStatus();
        if (this.fileList.length > 0) {
            if ((!(this.getLiElement(file)).classList.contains(RESTRICT_RETRY))) {
                this.uploadSequential();
                this.checkActionComplete(true);
            }
            else {
                (this.getLiElement(file)).classList.remove(RESTRICT_RETRY);
            }
        }
    };
    SfUploader.prototype.uploadFailed = function (e, file) {
        var _this = this;
        var li = this.getLiElement(file);
        var response = e && e.currentTarget ? this.getResponse(e) : null;
        var statusMessage = this.localizedTexts('uploadFailedMessage');
        var args = {
            e: e, response: response, operation: 'upload', file: this.updateStatus(file, statusMessage, '0', false), statusText: statusMessage,
            retryFiles: null
        };
        if (!sf.base.isNullOrUndefined(li)) {
            this.renderFailureState(e, file, li);
        }
        if (this.failuredEnabled) {
            // @ts-ignore-start
            this.dotNetRef.invokeMethodAsync('FailureEvent', args).then(function (args) {
                // @ts-ignore-end
                _this.failureEventCallback(file, args);
            });
        }
        else {
            this.failureEventCallback(file, args);
        }
    };
    SfUploader.prototype.failureEventCallback = function (file, args) {
        // tslint:disable-next-line
        this.updateStatus(file, args.statusText, '0');
        this.checkActionButtonStatus();
        this.uploadSequential();
        this.checkActionComplete(true);
        // tslint:disable-next-line
        var retryFile = args.retryFiles;
        if (retryFile != null) {
            this.retry(retryFile);
        }
    };
    SfUploader.prototype.uploadSequential = function () {
        if (this.sequentialUpload) {
            if (this.autoUpload) {
                this.checkAutoUpload(this.filesData);
            }
            else {
                this.uploadButtonClick();
            }
        }
    };
    SfUploader.prototype.checkActionComplete = function (increment) {
        increment ? ++this.actionCompleteCount : --this.actionCompleteCount;
        this.raiseActionComplete();
    };
    SfUploader.prototype.raiseActionComplete = function () {
        if ((this.filesData.length === this.actionCompleteCount) && this.flag) {
            this.flag = false;
            // tslint:disable-next-line
            var eventArgs = {
                fileData: []
            };
            eventArgs.fileData = this.getSelectedFileStatus(this.selectedFiles);
            if (this.actionCompleteEnabled) {
                this.dotNetRef.invokeMethodAsync('ActionCompleteEvent', eventArgs);
            }
        }
    };
    SfUploader.prototype.getSelectedFileStatus = function (selectedFiles) {
        var matchFiles = [];
        var matchFilesIndex = 0;
        for (var selectFileIndex = 0; selectFileIndex < selectedFiles.length; selectFileIndex++) {
            var selectedFileData = selectedFiles[selectFileIndex];
            for (var fileDataIndex = 0; fileDataIndex < this.filesData.length; fileDataIndex++) {
                if (this.filesData[fileDataIndex].name === selectedFileData.name) {
                    matchFiles[matchFilesIndex] = this.filesData[fileDataIndex];
                    ++matchFilesIndex;
                }
            }
        }
        return matchFiles;
    };
    SfUploader.prototype.updateProgressBarClasses = function (li, className) {
        var progressBar = li.querySelector('.' + PROGRESSBAR);
        if (!sf.base.isNullOrUndefined(progressBar)) {
            progressBar.classList.add(className);
        }
    };
    SfUploader.prototype.removeProgressbar = function (li, callType) {
        var _this = this;
        if (!sf.base.isNullOrUndefined(li.querySelector('.' + PROGRESS_WRAPPER))) {
            this.progressAnimation = new sf.base.Animation({ duration: 1250 });
            this.progressAnimation.animate(li.querySelector('.' + PROGRESS_WRAPPER), { name: 'FadeOut' });
            this.progressAnimation.animate(li.querySelector('.' + PROGRESSBAR_TEXT), { name: 'FadeOut' });
            setTimeout(function () { _this.animateProgressBar(li, callType); }, 750);
        }
    };
    SfUploader.prototype.animateProgressBar = function (li, callType) {
        if (callType === 'success') {
            li.classList.add(UPLOAD_SUCCESS);
            if (!sf.base.isNullOrUndefined(li.querySelector('.' + STATUS))) {
                li.querySelector('.' + STATUS).classList.remove(UPLOAD_INPROGRESS);
                this.progressAnimation.animate(li.querySelector('.' + STATUS), { name: 'FadeIn' });
                li.querySelector('.' + STATUS).classList.add(UPLOAD_SUCCESS);
                li.querySelector('.' + STATUS).classList.remove(UPLOAD_FAILED);
            }
        }
        else {
            if (!sf.base.isNullOrUndefined(li.querySelector('.' + STATUS))) {
                li.querySelector('.' + STATUS).classList.remove(UPLOAD_INPROGRESS);
                this.progressAnimation.animate(li.querySelector('.' + STATUS), { name: 'FadeIn' });
                li.querySelector('.' + STATUS).classList.add(UPLOAD_FAILED);
            }
        }
        if (li.querySelector('.' + PROGRESS_WRAPPER)) {
            sf.base.detach(li.querySelector('.' + PROGRESS_WRAPPER));
        }
    };
    SfUploader.prototype.localizedTexts = function (localeText) {
        return this.localeText[localeText];
    };
    SfUploader.prototype.chunkUpload = function (file, custom, fileIndex) {
        var start = 0;
        var end = Math.min(this.asyncSettings.chunkSize, file.size);
        var index = 0;
        var blob = file.rawFile.slice(start, end);
        var metaData = { chunkIndex: index, blob: blob, file: file, start: start, end: end, retryCount: 0, request: null };
        this.sendRequest(file, metaData, custom, fileIndex);
    };
    SfUploader.prototype.sendRequest = function (file, metaData, custom, fileIndex) {
        var _this = this;
        var formData = new FormData();
        if (!file.rawFile) {
            for (var k = 0; k < this.selectedFiles.length; k++) {
                if (file.id === this.selectedFiles[k].id) {
                    file.rawFile = this.selectedFiles[k].rawFile;
                }
            }
        }
        var blob = file.rawFile.slice(metaData.start, metaData.end);
        formData.append('chunkFile', blob, file.name);
        formData.append(this.uploaderName, blob, file.name);
        formData.append('chunk-index', metaData.chunkIndex.toString());
        formData.append('chunkIndex', metaData.chunkIndex.toString());
        var totalChunk = Math.max(Math.ceil(file.size / this.asyncSettings.chunkSize), 1);
        formData.append('total-chunk', totalChunk.toString());
        formData.append('totalChunk', totalChunk.toString());
        var ajax = new sf.base.Ajax({ url: this.asyncSettings.saveUrl, type: 'POST', async: true, contentType: null });
        ajax.emitError = false;
        ajax.onLoad = function (e) { _this.chunkUploadComplete(e, metaData, custom); return {}; };
        ajax.onUploadProgress = function (e) {
            _this.chunkUploadInProgress(e, metaData, custom);
            return {};
        };
        var eventArgs = {
            fileData: file,
            customFormData: [],
            cancel: false,
            chunkSize: this.asyncSettings.chunkSize === 0 ? null : this.asyncSettings.chunkSize
        };
        ajax.beforeSend = function (e) {
            eventArgs.currentRequest = ajax.httpRequest;
            eventArgs.currentChunkIndex = metaData.chunkIndex;
            if (_this.currentRequestHeader) {
                _this.updateCustomheader(ajax.httpRequest, _this.currentRequestHeader);
            }
            if (_this.customFormDatas) {
                _this.updateFormData(formData, _this.customFormDatas);
            }
            if (eventArgs.currentChunkIndex === 0) {
                // This event is currently not required but to avoid breaking changes for previous customer, we have included.
                if (_this.uploadingEnabled) {
                    // @ts-ignore-start
                    _this.dotNetRef.invokeMethodAsync('UploadingEvent', eventArgs).then(function (eventArgs) {
                        // @ts-ignore-end
                        _this.uploadingEventCallback(formData, eventArgs, e, file);
                    });
                }
                else {
                    _this.uploadingEventCallback(formData, eventArgs, e, file);
                }
            }
            else {
                if (_this.chunkUploadingEnabled) {
                    // @ts-ignore-start
                    _this.dotNetRef.invokeMethodAsync('ChunkUploadingEvent', eventArgs).then(function (eventArgs) {
                        // @ts-ignore-end
                        _this.uploadingEventCallback(formData, eventArgs, e, file);
                    });
                }
                else {
                    _this.uploadingEventCallback(formData, eventArgs, e, file);
                }
            }
        };
        ajax.onError = function (e) { _this.chunkUploadFailed(e, metaData, custom); return {}; };
        ajax.send(formData);
        metaData.request = ajax;
    };
    SfUploader.prototype.uploadingEventCallback = function (formData, eventArgs, e, file) {
        if (eventArgs.cancel) {
            this.eventCancelByArgs(e, eventArgs, file);
        }
        else {
            this.updateFormData(formData, eventArgs.customFormData);
        }
    };
    SfUploader.prototype.eventCancelByArgs = function (e, eventArgs, file) {
        var _this = this;
        e.cancel = true;
        if (eventArgs.fileData.statusCode === '5') {
            return;
        }
        var liElement = this.getLiElement(eventArgs.fileData);
        liElement.querySelector('.' + STATUS).innerHTML = this.localizedTexts('fileUploadCancel');
        liElement.querySelector('.' + STATUS).classList.add(UPLOAD_FAILED);
        eventArgs.fileData.statusCode = '5';
        eventArgs.fileData.status = this.localizedTexts('fileUploadCancel');
        this.pauseButton = sf.base.createElement('span', { className: 'e-icons e-file-reload-btn', attrs: { 'tabindex': this.btnTabIndex } });
        var removeIcon = liElement.querySelector('.' + REMOVE_ICON);
        removeIcon.parentElement.insertBefore(this.pauseButton, removeIcon);
        this.pauseButton.setAttribute('title', this.localizedTexts('retry'));
        this.pauseButton.addEventListener('click', function (e) { _this.reloadcanceledFile(e, file, liElement); }, false);
        this.checkActionButtonStatus();
    };
    SfUploader.prototype.checkChunkUpload = function () {
        return (this.asyncSettings.chunkSize <= 0 || sf.base.isNullOrUndefined(this.asyncSettings.chunkSize)) ? false : true;
    };
    SfUploader.prototype.chunkUploadComplete = function (e, metaData, custom) {
        var _this = this;
        var response = e.target;
        var liElement;
        if (response.readyState === 4 && response.status >= 200 && response.status < 300) {
            var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
            var totalChunk = Math.max(Math.ceil(metaData.file.size / this.asyncSettings.chunkSize), 1);
            var eventArgs = {
                event: e,
                file: metaData.file,
                chunkIndex: metaData.chunkIndex,
                totalChunk: totalChunk,
                chunkSize: this.asyncSettings.chunkSize,
                response: requestResponse
            };
            if (this.chunkSuccessEnabled) {
                this.dotNetRef.invokeMethodAsync('ChunkSuccessEvent', eventArgs);
            }
            if (sf.base.isNullOrUndefined(custom) || !custom) {
                liElement = this.getLiElement(metaData.file);
            }
            this.updateMetaData(metaData);
            if (metaData.end === metaData.file.size) {
                metaData.file.statusCode = '3';
            }
            if (metaData.file.statusCode === '5') {
                var eventArgs_1 = { event: e, fileData: metaData.file, cancel: false };
                if (this.cancelEnabled) {
                    // @ts-ignore-start
                    this.dotNetRef.invokeMethodAsync('CancelingEvent', eventArgs_1).then(function (eventArgs) {
                        // @ts-ignore-end
                        _this.cancelingEventCallback(metaData, liElement, response, custom, eventArgs);
                    });
                }
                else {
                    this.cancelingEventCallback(metaData, liElement, response, custom, eventArgs_1);
                }
            }
            else {
                if ((totalChunk - 1) === metaData.chunkIndex && totalChunk > metaData.chunkIndex) {
                    var index = this.pausedData.indexOf(metaData);
                    if (index >= 0) {
                        this.pausedData.splice(index, 1);
                    }
                    if (sf.base.isNullOrUndefined(this.template) && (sf.base.isNullOrUndefined(custom) || !custom) && liElement) {
                        if (liElement && !sf.base.isNullOrUndefined(liElement.querySelector('.' + PAUSE_UPLOAD))) {
                            sf.base.detach(liElement.querySelector('.' + PAUSE_UPLOAD));
                        }
                        this.removeChunkProgressBar(metaData);
                    }
                    this.raiseSuccessEvent(e, metaData.file);
                    return;
                }
                if (metaData.file.statusCode !== '4') {
                    this.sendNextRequest(metaData);
                }
            }
        }
        else {
            this.chunkUploadFailed(e, metaData);
        }
    };
    SfUploader.prototype.cancelingEventCallback = function (metaData, liElement, response, custom, eventArgs) {
        var _this = this;
        if (eventArgs.cancel) {
            metaData.file.statusCode = '3';
            var spinnerTarget = liElement.querySelector('.' + ABORT_ICON);
            if (!sf.base.isNullOrUndefined(liElement) && !sf.base.isNullOrUndefined(spinnerTarget)) {
                disableSpinner(spinnerTarget);
                sf.base.detach(liElement.querySelector('.e-spinner-pane'));
            }
            this.sendNextRequest(metaData);
        }
        else {
            metaData.request.emitError = false;
            response.abort();
            var formData = new FormData();
            var name_2 = this.element.getAttribute('name');
            formData.append(name_2, metaData.file.name);
            formData.append('cancel-uploading', metaData.file.name);
            formData.append('cancelUploading', metaData.file.name);
            var ajax = new sf.base.Ajax(this.asyncSettings.removeUrl, 'POST', true, null);
            ajax.emitError = false;
            ajax.onLoad = function (e) { _this.removeChunkFile(e, metaData, custom); return {}; };
            ajax.send(formData);
        }
    };
    SfUploader.prototype.sendNextRequest = function (metaData) {
        metaData.start = metaData.end;
        metaData.end += this.asyncSettings.chunkSize;
        metaData.end = Math.min(metaData.end, metaData.file.size);
        metaData.chunkIndex += 1;
        this.sendRequest(metaData.file, metaData);
    };
    SfUploader.prototype.removeChunkFile = function (e, metaData, custom) {
        if (sf.base.isNullOrUndefined(this.template) && (sf.base.isNullOrUndefined(custom) && !custom)) {
            var liElement = this.getLiElement(metaData.file);
            var deleteIcon = liElement.querySelector('.' + ABORT_ICON);
            var spinnerTarget = deleteIcon;
            this.updateStatus(metaData.file, this.localizedTexts('fileUploadCancel'), '5');
            this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
            this.removeProgressbar(liElement, 'failure');
            deleteIcon && deleteIcon.classList.remove(ABORT_ICON);
            deleteIcon && deleteIcon.classList.add(REMOVE_ICON);
            deleteIcon && deleteIcon.setAttribute('title', this.localizedTexts('remove'));
            var pauseIcon = liElement.querySelector('.' + PAUSE_UPLOAD);
            pauseIcon && pauseIcon.classList.add(RETRY_ICON);
            pauseIcon && pauseIcon.classList.remove(PAUSE_UPLOAD);
            pauseIcon && pauseIcon.setAttribute('title', this.localizedTexts('retry'));
            if (!sf.base.isNullOrUndefined(liElement) && !sf.base.isNullOrUndefined(deleteIcon)
                && !sf.base.isNullOrUndefined(liElement.querySelector('.e-spinner-pane'))) {
                disableSpinner(spinnerTarget);
                sf.base.detach(liElement.querySelector('.e-spinner-pane'));
            }
        }
    };
    SfUploader.prototype.pauseUpload = function (metaData, e, custom) {
        metaData.file.statusCode = '4';
        metaData.file.status = this.localizedTexts('pause');
        this.updateMetaData(metaData);
        var eventArgs = {
            event: e ? e : null,
            file: metaData.file,
            chunkIndex: metaData.chunkIndex,
            chunkCount: Math.round(metaData.file.size / this.asyncSettings.chunkSize),
            chunkSize: this.asyncSettings.chunkSize
        };
        this.abortUpload(metaData, custom, eventArgs);
    };
    SfUploader.prototype.abortUpload = function (metaData, custom, eventArgs) {
        if (metaData.file.statusCode !== '4') {
            metaData.request.emitError = false;
            metaData.request.httpRequest.abort();
        }
        var liElement = this.getLiElement(metaData.file);
        if (sf.base.isNullOrUndefined(this.template) && (sf.base.isNullOrUndefined(custom) || !custom)) {
            var targetElement = liElement.querySelector('.' + PAUSE_UPLOAD);
            targetElement.classList.remove(PAUSE_UPLOAD);
            targetElement.classList.add(RESUME_UPLOAD);
            targetElement.setAttribute('title', this.localizedTexts('resume'));
            targetElement.nextElementSibling.classList.add(REMOVE_ICON);
            targetElement.nextElementSibling.classList.remove(ABORT_ICON);
            targetElement.nextElementSibling.setAttribute('title', this.localizedTexts('remove'));
        }
        for (var i = 0; i < this.pausedData.length; i++) {
            if (this.pausedData[i].file.name === metaData.file.name) {
                this.pausedData.splice(i, 1);
            }
        }
        this.pausedData.push(metaData);
        if (this.pausedEnabled) {
            this.dotNetRef.invokeMethodAsync('PausingEvent', eventArgs);
        }
    };
    SfUploader.prototype.resumeUpload = function (metaData, e, custom) {
        var liElement = this.getLiElement(metaData.file);
        var targetElement;
        if (!sf.base.isNullOrUndefined(liElement)) {
            targetElement = liElement.querySelector('.' + RESUME_UPLOAD);
        }
        if (!sf.base.isNullOrUndefined(targetElement) && (sf.base.isNullOrUndefined(custom) || !custom)) {
            targetElement.classList.remove(RESUME_UPLOAD);
            targetElement.classList.add(PAUSE_UPLOAD);
            targetElement.setAttribute('title', this.localizedTexts('pause'));
            targetElement.nextElementSibling.classList.remove(REMOVE_ICON);
            targetElement.nextElementSibling.classList.add(ABORT_ICON);
            targetElement.nextElementSibling.setAttribute('title', this.localizedTexts('abort'));
        }
        metaData.file.status = this.localizedTexts('inProgress');
        metaData.file.statusCode = '3';
        this.updateMetaData(metaData);
        var eventArgs = {
            event: e ? e : null,
            file: metaData.file,
            chunkIndex: metaData.chunkIndex,
            chunkCount: Math.round(metaData.file.size / this.asyncSettings.chunkSize),
            chunkSize: this.asyncSettings.chunkSize
        };
        if (this.resumeEnabled) {
            this.dotNetRef.invokeMethodAsync('ResumingEvent', eventArgs);
        }
        for (var i = 0; i < this.pausedData.length; i++) {
            if (this.pausedData[i].end === this.pausedData[i].file.size) {
                this.chunkUploadComplete(e, metaData, custom);
            }
            else {
                if (this.pausedData[i].file.name === metaData.file.name) {
                    this.pausedData[i].start = this.pausedData[i].end;
                    this.pausedData[i].end = this.pausedData[i].end + this.asyncSettings.chunkSize;
                    this.pausedData[i].end = Math.min(this.pausedData[i].end, this.pausedData[i].file.size);
                    this.pausedData[i].chunkIndex = this.pausedData[i].chunkIndex + 1;
                    this.sendRequest(this.pausedData[i].file, this.pausedData[i], custom);
                }
            }
        }
    };
    SfUploader.prototype.updateMetaData = function (metaData) {
        if (this.uploadMetaData.indexOf(metaData) === -1) {
            this.uploadMetaData.push(metaData);
        }
        else {
            this.uploadMetaData.splice(this.uploadMetaData.indexOf(metaData), 1);
            this.uploadMetaData.push(metaData);
        }
    };
    SfUploader.prototype.removeChunkProgressBar = function (metaData) {
        var liElement = this.getLiElement(metaData.file);
        if (!sf.base.isNullOrUndefined(liElement)) {
            this.updateProgressBarClasses(liElement, UPLOAD_SUCCESS);
            this.removeProgressbar(liElement, 'success');
            var cancelButton = liElement.querySelector('.' + ABORT_ICON);
            if (!sf.base.isNullOrUndefined(cancelButton)) {
                cancelButton.classList.add(DELETE_ICON);
                cancelButton.setAttribute('title', this.localizedTexts('delete'));
                cancelButton.classList.remove(ABORT_ICON, UPLOAD_INPROGRESS);
            }
        }
    };
    SfUploader.prototype.chunkUploadFailed = function (e, metaData, custom) {
        var _this = this;
        var chunkCount = Math.max(Math.ceil(metaData.file.size / this.asyncSettings.chunkSize), 1);
        var liElement;
        if (sf.base.isNullOrUndefined(this.template) && (sf.base.isNullOrUndefined(custom) || !custom)) {
            liElement = this.getLiElement(metaData.file);
        }
        var requestResponse = e && e.currentTarget ? this.getResponse(e) : null;
        var eventArgs = {
            event: e,
            file: metaData.file,
            chunkIndex: metaData.chunkIndex,
            totalChunk: chunkCount,
            chunkSize: this.asyncSettings.chunkSize,
            cancel: false,
            response: requestResponse
        };
        if (this.chunkFailuredEnabled) {
            // @ts-ignore-start
            this.dotNetRef.invokeMethodAsync('ChunkFailureEvent', eventArgs).then(function (eventArgs) {
                // @ts-ignore-end
                _this.chunkFailureCallback(e, metaData, liElement, requestResponse, custom, eventArgs);
            });
        }
        else {
            this.chunkFailureCallback(e, metaData, liElement, requestResponse, custom, eventArgs);
        }
    };
    SfUploader.prototype.chunkFailureCallback = function (e, metaData, liElement, requestResponse, custom, eventArgs) {
        var _this = this;
        // To prevent triggering of failure event
        // tslint:disable-next-line
        if (!eventArgs.cancel) {
            if (metaData.retryCount < this.asyncSettings.retryCount) {
                setTimeout(function () { _this.retryRequest(liElement, metaData, custom); }, this.asyncSettings.retryAfterDelay);
            }
            else {
                if (!sf.base.isNullOrUndefined(liElement)) {
                    var pauseButton = liElement.querySelector('.' + PAUSE_UPLOAD) ?
                        liElement.querySelector('.' + PAUSE_UPLOAD) : liElement.querySelector('.' + RESUME_UPLOAD);
                    if (!sf.base.isNullOrUndefined(pauseButton)) {
                        pauseButton.classList.add(RETRY_ICON);
                        pauseButton.classList.remove(PAUSE_UPLOAD, RESUME_UPLOAD);
                    }
                    this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
                    this.removeProgressbar(liElement, 'failure');
                    liElement.querySelector('.e-icons').classList.remove(UPLOAD_INPROGRESS);
                    var iconElement = liElement.querySelector('.' + ABORT_ICON) ?
                        liElement.querySelector('.' + ABORT_ICON) : liElement.querySelector('.' + REMOVE_ICON);
                    iconElement.classList.remove(ABORT_ICON);
                    if (!sf.base.isNullOrUndefined(liElement.querySelector('.' + PAUSE_UPLOAD))) {
                        sf.base.detach(liElement.querySelector('.' + PAUSE_UPLOAD));
                    }
                    if (metaData.start > 0) {
                        iconElement.classList.add(DELETE_ICON);
                        iconElement.setAttribute('title', this.localizedTexts('delete'));
                    }
                    else {
                        iconElement.classList.add(REMOVE_ICON);
                        iconElement.setAttribute('title', this.localizedTexts('remove'));
                    }
                }
                metaData.retryCount = 0;
                var file_1 = metaData.file;
                var failureMessage = this.localizedTexts('uploadFailedMessage');
                var args = {
                    e: e, response: requestResponse,
                    operation: 'upload',
                    file: this.updateStatus(file_1, failureMessage, '0', false),
                    statusText: failureMessage,
                    retryFiles: null
                };
                if (this.failuredEnabled) {
                    // @ts-ignore-start
                    this.dotNetRef.invokeMethodAsync('FailureEvent', args).then(function (args) {
                        // @ts-ignore-end
                        _this.failureCallback(file_1, args);
                    });
                }
                else {
                    this.failureCallback(file_1, args);
                }
            }
        }
    };
    SfUploader.prototype.failureCallback = function (file, args) {
        // tslint:disable-next-line
        this.updateStatus(file, args.statusText, '0');
        this.uploadSequential();
        this.checkActionComplete(true);
        // tslint:disable-next-line
        var retryFile = args.retryFiles;
        if (retryFile != null) {
            this.retry(retryFile);
        }
    };
    SfUploader.prototype.retryRequest = function (liElement, metaData, custom) {
        if (sf.base.isNullOrUndefined(this.template) && (sf.base.isNullOrUndefined(custom) || !custom) && liElement) {
            this.updateProgressBarClasses(liElement, UPLOAD_FAILED);
        }
        metaData.retryCount += 1;
        this.sendRequest(metaData.file, metaData);
    };
    SfUploader.prototype.checkPausePlayAction = function (e) {
        var targetElement = e.target;
        var selectedElement = e.target.parentElement;
        var index = this.fileList.indexOf(selectedElement);
        var fileData = this.filesData[index];
        var metaData = this.getCurrentMetaData(fileData);
        if (targetElement.classList.contains(PAUSE_UPLOAD)) {
            this.pauseUpload(metaData, e);
        }
        else if (targetElement.classList.contains(RESUME_UPLOAD)) {
            this.resumeUpload(metaData, e);
        }
        else if (targetElement.classList.contains(RETRY_ICON)) {
            if (metaData.file.status === this.localizedTexts('fileUploadCancel')) {
                this.retryUpload(metaData, false);
            }
            else {
                this.retryUpload(metaData, true);
            }
        }
    };
    SfUploader.prototype.retryUpload = function (metaData, fromcanceledStage) {
        if (fromcanceledStage) {
            metaData.end = metaData.end + this.asyncSettings.chunkSize;
            metaData.start = metaData.start + this.asyncSettings.chunkSize;
            this.sendRequest(metaData.file, metaData);
        }
        else {
            metaData.file.statusCode = '1';
            metaData.file.status = this.localizedTexts('readyToUploadMessage');
            this.chunkUpload(metaData.file);
        }
        (this.getLiElement(metaData.file)).classList.add(RESTRICT_RETRY);
    };
    SfUploader.prototype.chunkUploadInProgress = function (e, metaData, custom) {
        var _this = this;
        if (metaData.file.statusCode === '4') {
            return;
        }
        if (metaData.file.statusCode !== '4' && metaData.file.statusCode !== '5') {
            metaData.file.statusCode = '3';
            metaData.file.status = this.localizedTexts('inProgress');
        }
        this.updateMetaData(metaData);
        var liElement = this.getLiElement(metaData.file);
        if (sf.base.isNullOrUndefined(liElement)) {
            return;
        }
        var retryElement = liElement.querySelector('.' + RETRY_ICON);
        if (!sf.base.isNullOrUndefined(retryElement)) {
            retryElement.classList.add(PAUSE_UPLOAD);
            retryElement.setAttribute('title', this.localizedTexts('pause'));
            retryElement.classList.remove(RETRY_ICON);
        }
        if (!sf.base.isNullOrUndefined(liElement)) {
            if (!(liElement.querySelectorAll('.' + PROGRESS_WRAPPER).length > 0)) {
                var statusElement = liElement.querySelector('.' + STATUS);
                if (sf.base.isNullOrUndefined(this.template)) {
                    statusElement.classList.add(UPLOAD_INPROGRESS);
                    statusElement.classList.remove(UPLOAD_FAILED);
                    this.createProgressBar(liElement);
                    this.updateProgressBarClasses(liElement, UPLOAD_INPROGRESS);
                }
                var clearIcon = liElement.querySelector('.' + REMOVE_ICON) ? liElement.querySelector('.' + REMOVE_ICON) :
                    liElement.querySelector('.' + DELETE_ICON);
                if (!sf.base.isNullOrUndefined(clearIcon)) {
                    clearIcon.classList.add(ABORT_ICON);
                    clearIcon.setAttribute('title', this.localizedTexts('abort'));
                    clearIcon.classList.remove(REMOVE_ICON);
                }
            }
            if (!isNaN(Math.round((e.loaded / e.total) * 100)) && sf.base.isNullOrUndefined(this.template) && metaData.file.statusCode !== '4') {
                var progressVal = void 0;
                var totalChunks = Math.ceil(metaData.file.size / this.asyncSettings.chunkSize) - 1;
                if (this.asyncSettings.chunkSize && totalChunks) {
                    progressVal = Math.round(metaData.chunkIndex / totalChunks * 100);
                    this.changeProgressValue(liElement, progressVal.toString() + '%');
                }
            }
            if (metaData.chunkIndex === 0) {
                this.checkActionButtonStatus();
            }
        }
        if (sf.base.isNullOrUndefined(liElement.querySelector('.' + PAUSE_UPLOAD)) && sf.base.isNullOrUndefined(this.template)
            && sf.base.isNullOrUndefined(liElement.querySelector('.' + DELETE_ICON))) {
            this.pauseButton = sf.base.createElement('span', { className: 'e-icons e-file-pause-btn', attrs: { 'tabindex': this.btnTabIndex } });
            if (this.browserName === 'msie') {
                this.pauseButton.classList.add('e-msie');
            }
            var abortIcon = liElement.querySelector('.' + ABORT_ICON);
            abortIcon.parentElement.insertBefore(this.pauseButton, abortIcon);
            this.pauseButton.setAttribute('title', this.localizedTexts('pause'));
            this.pauseButton.addEventListener('click', function (e) { _this.checkPausePlayAction(e); }, false);
        }
    };
    /**
     * It is used to convert bytes value into kilobytes or megabytes depending on the size based
     * on [binary prefix](https://en.wikipedia.org/wiki/Binary_prefix).
     * @param { number } bytes - specifies the file size in bytes.
     * @returns string
     */
    SfUploader.prototype.bytesToSize = function (bytes) {
        var i = -1;
        if (!bytes) {
            return '0.0 KB';
        }
        do {
            bytes = bytes / 1024;
            i++;
        } while (bytes > 99);
        if (i >= 2) {
            bytes = bytes * 1024;
            i = 1;
        }
        return Math.max(bytes, 0).toFixed(1) + ' ' + ['KB', 'MB'][i];
    };
    /**
     * Allows you to sort the file data alphabetically based on its file name clearly.
     * @param { FileList } filesData - specifies the files data for upload.
     * @returns File[]
     */
    SfUploader.prototype.sortFileList = function (filesData) {
        filesData = filesData ? filesData : this.sortFilesList;
        var files = filesData;
        var fileNames = [];
        for (var i = 0; i < files.length; i++) {
            fileNames.push(files[i].name);
        }
        var sortedFileNames = fileNames.sort();
        var sortedFilesData = [];
        for (var _i = 0, sortedFileNames_1 = sortedFileNames; _i < sortedFileNames_1.length; _i++) {
            var name_3 = sortedFileNames_1[_i];
            for (var i = 0; i < files.length; i++) {
                if (name_3 === files[i].name) {
                    sortedFilesData.push(files[i]);
                }
            }
        }
        return sortedFilesData;
    };
    /**
     * Removes the component from the DOM and detaches all its related event handlers. Also it removes the attributes and classes.
     * @method destroy
     * @return {void}.
     */
    SfUploader.prototype.destroy = function () {
        this.element.value = null;
        if (!(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
            this.clearAll();
        }
        this.unWireEvents();
        this.unBindDropEvents();
        this.element.removeAttribute('accept');
        this.setInitialAttributes();
        var attributes = ['aria-label', 'directory', 'webkitdirectory', 'tabindex'];
        for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
            var key = attributes_1[_i];
            this.element.removeAttribute(key);
        }
    };
    /**
     * Allows you to call the upload process manually by calling save URL action.
     * To process the selected files (added in upload queue), pass an empty argument otherwise
     * upload the specific file based on its argument.
     * @param { FileInfo | FileInfo[] } files - specifies the files data for upload.
     * @returns void
     */
    SfUploader.prototype.upload = function (files, custom) {
        var _this = this;
        files = files ? files : this.filesData;
        if (this.sequentialUpload && (this.isFirstFileOnSelection || custom)) {
            this.sequenceUpload(files);
        }
        else {
            var uploadFiles_1 = this.getFilesInArray(files);
            var eventArgs = {
                customFormData: [],
                currentRequest: null,
                cancel: false,
                filesData: uploadFiles_1
            };
            if (this.beforeUploadEnabled) {
                // @ts-ignore-start
                this.dotNetRef.invokeMethodAsync('BeforeUploadEvent', eventArgs).then(function (eventArgs) {
                    // @ts-ignore-end
                    _this.beforeUploadCallback(uploadFiles_1, custom, eventArgs);
                });
            }
            else {
                this.beforeUploadCallback(uploadFiles_1, custom, eventArgs);
            }
        }
    };
    SfUploader.prototype.beforeUploadCallback = function (uploadFiles, custom, eventArgs) {
        if (!eventArgs.cancel) {
            this.currentRequestHeader = eventArgs.currentRequest ? eventArgs.currentRequest : this.currentRequestHeader;
            this.customFormDatas = (eventArgs.customFormData && eventArgs.customFormData.length > 0) ?
                eventArgs.customFormData : this.customFormDatas;
            this.uploadFiles(uploadFiles, custom);
        }
    };
    SfUploader.prototype.getFilesInArray = function (files) {
        var uploadFiles = [];
        if (files instanceof Array) {
            uploadFiles = this.getFileListData(files);
        }
        else {
            uploadFiles.push(files);
        }
        return uploadFiles;
    };
    SfUploader.prototype.getFileListData = function (files) {
        var uploadFiles = [];
        if (!sf.base.isNullOrUndefined(this.filesData) && !sf.base.isNullOrUndefined(files)) {
            var _loop_5 = function (i) {
                uploadFiles.push(this_3.filesData.filter(function (e) { return e.name === files[i].name; })[0]);
            };
            var this_3 = this;
            for (var i = 0; i < files.length; i++) {
                _loop_5(i);
            }
        }
        return !sf.base.isNullOrUndefined(uploadFiles) ? uploadFiles : [];
    };
    SfUploader.prototype.serverReadFileBase64 = function (fileIndex, position, totalCount) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var file = _this.fileStreams[fileIndex].rawFile;
            try {
                var reader = new FileReader();
                // tslint:disable-next-line
                reader.onload = (function (args) {
                    return function () {
                        try {
                            var contents = args.result;
                            var data = contents ? contents.split(';base64,')[1] : null;
                            resolve(data);
                        }
                        catch (e) {
                            reject(e);
                        }
                    };
                })(reader);
                reader.readAsDataURL(file.slice(position, position + totalCount));
            }
            catch (e) {
                reject(e);
            }
        });
    };
    SfUploader.prototype.uploadFileCount = function (ele) {
        var files = this.filesData;
        if (!files || files.length === 0) {
            return -1;
        }
        var result = files.length;
        return result;
    };
    SfUploader.prototype.getFileRead = function (index, ele) {
        var files = this.filesData;
        if (!files || files.length === 0) {
            return -1;
        }
        var file = files[index];
        var fileCount = this.newFileRef++;
        this.fileStreams[fileCount] = file;
        return fileCount;
    };
    SfUploader.prototype.getFileInfo = function (index, ele) {
        var files = this.filesData;
        if (!files || files.length === 0) {
            return null;
        }
        var file = files[index];
        if (!file) {
            return null;
        }
        return this.filesData[index];
    };
    SfUploader.prototype.uploadFiles = function (files, custom) {
        var _this = this;
        var selectedFiles = [];
        if (this.asyncSettings.saveUrl === '' || sf.base.isNullOrUndefined(this.asyncSettings.saveUrl)) {
            // tslint:disable-next-line
            this.dotNetRef.invokeMethodAsync('GetFileDetails', files);
            return;
        }
        if (!custom || sf.base.isNullOrUndefined(custom)) {
            if (!this.multiple) {
                var file = [];
                file.push(files[0]);
                selectedFiles = this.filterfileList(file);
            }
            else {
                selectedFiles = this.filterfileList(files);
            }
        }
        else {
            selectedFiles = files;
        }
        var _loop_6 = function (i) {
            if (!this_4.checkChunkUpload()) {
                /* tslint:disable */
                if (selectedFiles[i] && selectedFiles[i].rawFile instanceof File) {
                    this_4.getBase64(selectedFiles[i].rawFile).then(function (data) {
                        _this.base64String.push(data);
                        _this.uploadFilesRequest(selectedFiles, i, custom);
                    });
                }
                /* tslint:disable */
            }
            else {
                this_4.uploadFilesRequest(selectedFiles, i, custom);
            }
        };
        var this_4 = this;
        for (var i = 0; i < selectedFiles.length; i++) {
            _loop_6(i);
        }
    };
    SfUploader.prototype.uploadFilesRequest = function (selectedFiles, i, custom) {
        var _this = this;
        var cloneFiles = [];
        var chunkEnabled = this.checkChunkUpload();
        var ajax = new sf.base.Ajax(this.asyncSettings.saveUrl, 'POST', true, null);
        ajax.emitError = false;
        var getFileData;
        getFileData = selectedFiles.slice(0);
        cloneFiles.push(getFileData[i].rawFile);
        var eventArgs = {
            fileData: getFileData[i],
            customFormData: [],
            cancel: false
        };
        var formData = new FormData();
        ajax.beforeSend = function (e) {
            eventArgs.currentRequest = ajax.httpRequest;
            eventArgs.fileData.rawFile = !chunkEnabled ? _this.base64String[i] : eventArgs.fileData.rawFile;
            if (_this.currentRequestHeader) {
                _this.updateCustomheader(ajax.httpRequest, _this.currentRequestHeader);
            }
            if (_this.customFormDatas) {
                _this.updateFormData(formData, _this.customFormDatas);
            }
            if (_this.uploadingEnabled) {
                // @ts-ignore-start
                _this.dotNetRef.invokeMethodAsync('UploadingEvent', eventArgs).then(function (args) {
                    // @ts-ignore-end
                    eventArgs = args;
                    _this.uploadCallback(e, chunkEnabled, selectedFiles, formData, i, cloneFiles, args);
                });
            }
            else {
                _this.uploadCallback(e, chunkEnabled, selectedFiles, formData, i, cloneFiles, eventArgs);
            }
        };
        if (selectedFiles[i].statusCode === '1') {
            var name_4 = this.element.getAttribute('name');
            formData.append(name_4, selectedFiles[i].rawFile, selectedFiles[i].name);
            if (chunkEnabled && selectedFiles[i].size > this.asyncSettings.chunkSize) {
                this.chunkUpload(selectedFiles[i], custom, i);
            }
            else {
                ajax.onLoad = function (e) {
                    if (eventArgs.cancel) {
                        return {};
                    }
                    else {
                        _this.uploadComplete(e, selectedFiles[i], custom);
                        return {};
                    }
                };
                ajax.onUploadProgress = function (e) {
                    if (eventArgs.cancel) {
                        return {};
                    }
                    else {
                        _this.uploadInProgress(e, selectedFiles[i], custom, ajax);
                        return {};
                    }
                };
                ajax.onError = function (e) { _this.uploadFailed(e, selectedFiles[i]); return {}; };
                ajax.send(formData);
            }
        }
    };
    SfUploader.prototype.uploadCallback = function (e, chunkEnabled, selectedFiles, formData, i, cloneFiles, args) {
        if (!chunkEnabled) {
            selectedFiles[i].rawFile = args.fileData.rawFile = cloneFiles[i];
        }
        if (args.cancel) {
            this.eventCancelByArgs(e, args, selectedFiles[i]);
        }
        this.updateFormData(formData, args.customFormData);
    };
    SfUploader.prototype.spliceFiles = function (liIndex) {
        var liElement = this.fileList[liIndex];
        var allFiles = this.getFilesData();
        var nameElements = +liElement.getAttribute('data-files-count');
        var startIndex = 0;
        for (var i = 0; i < liIndex; i++) {
            startIndex += (+this.fileList[i].getAttribute('data-files-count'));
        }
        var endIndex = (startIndex + nameElements) - 1;
        for (var j = endIndex; j >= startIndex; j--) {
            allFiles.splice(j, 1);
        }
    };
    /**
     * Remove the uploaded file from server manually by calling the remove URL action.
     * If you pass an empty argument to this method, the complete file list can be cleared,
     * otherwise remove the specific file based on its argument (“file_data”).
     * @param { FileInfo | FileInfo[] } fileData - specifies the files data to remove from file list/server.
     * @param { boolean } customTemplate - Set true if the component rendering with customize template.
     * @param { boolean } removeDirectly - Set true if files remove without removing event.
     * @param { boolean } postRawFile - Set false, to post file name only to the remove action.
     * @returns void
     */
    SfUploader.prototype.remove = function (fileData, customTemplate, removeDirectly, postRawFile, args) {
        var _this = this;
        if (sf.base.isNullOrUndefined(postRawFile)) {
            postRawFile = true;
        }
        var removeFiles = this.getFilesInArray(fileData);
        var beforeEventArgs = {
            cancel: false,
            customFormData: [],
            currentRequest: null,
            filesData: removeFiles,
            postRawFile: postRawFile
        };
        if (this.beforeRemoveEnabled) {
            // @ts-ignore-start
            this.dotNetRef.invokeMethodAsync('BeforeRemoveEvent', beforeEventArgs).then(function (beforeEventArgs) {
                // @ts-ignore-end
                _this.beforeRemoveCallback(fileData, customTemplate, removeDirectly, args, beforeEventArgs);
            });
        }
        else {
            this.beforeRemoveCallback(fileData, customTemplate, removeDirectly, args, beforeEventArgs);
        }
    };
    SfUploader.prototype.beforeRemoveCallback = function (fileData, customTemplate, removeDirectly, args, beforeEventArgs) {
        var _this = this;
        var eventArgs = {
            event: args,
            cancel: false,
            filesData: [],
            customFormData: [],
            postRawFile: beforeEventArgs.postRawFile,
            currentRequest: null
        };
        if (!beforeEventArgs.cancel) {
            this.currentRequestHeader = beforeEventArgs.currentRequest;
            this.customFormDatas = beforeEventArgs.customFormData;
            var index = void 0;
            if (this.isFormUpload() && !this.isBlazorSaveUrl) {
                eventArgs.filesData = fileData;
                // @ts-ignore-start
                this.dotNetRef.invokeMethodAsync('RemovingEvent', eventArgs).then(function (eventArgs) {
                    // @ts-ignore-end
                    _this.removeCallback(fileData, eventArgs);
                });
            }
            else if (this.isForm && (sf.base.isNullOrUndefined(this.asyncSettings.removeUrl) || this.asyncSettings.removeUrl === '')
                && !this.isBlazorSaveUrl) {
                eventArgs.filesData = this.getFilesData();
                if (this.removingEnabled) {
                    // @ts-ignore-start
                    this.dotNetRef.invokeMethodAsync('RemovingEvent', eventArgs).then(function (eventArgs) {
                        // @ts-ignore-end
                        if (!eventArgs.cancel) {
                            _this.clearAll();
                        }
                    });
                }
                else {
                    this.clearAll();
                }
            }
            else {
                var removeFiles = [];
                fileData = !sf.base.isNullOrUndefined(fileData) ? fileData : this.filesData;
                if (fileData instanceof Array) {
                    removeFiles = fileData;
                }
                else {
                    removeFiles.push(fileData);
                }
                eventArgs.filesData = removeFiles;
                var removeUrl = this.asyncSettings.removeUrl;
                var validUrl = (removeUrl === '' || sf.base.isNullOrUndefined(removeUrl)) ? false : true;
                var _loop_7 = function (files) {
                    index = this_5.filesData.indexOf(files);
                    var fileUploadedIndex = this_5.uploadedFilesData.indexOf(files);
                    if ((files.statusCode === '2' || files.statusCode === '4' || (files.statusCode === '0' &&
                        fileUploadedIndex !== -1)) && validUrl) {
                        this_5.removeUploadedFile(files, eventArgs, removeDirectly, customTemplate);
                    }
                    else {
                        if (!removeDirectly && this_5.removingEnabled) {
                            // @ts-ignore-start
                            this_5.dotNetRef.invokeMethodAsync('RemovingEvent', eventArgs).then(function (eventArgs) {
                                // @ts-ignore-end
                                if (!eventArgs.cancel) {
                                    _this.removeFilesData(files, customTemplate);
                                }
                            });
                        }
                        else {
                            this_5.removeFilesData(files, customTemplate);
                        }
                    }
                    if (args && !args.target.classList.contains(REMOVE_ICON)) {
                        this_5.checkActionComplete(false);
                    }
                };
                var this_5 = this;
                for (var _i = 0, removeFiles_1 = removeFiles; _i < removeFiles_1.length; _i++) {
                    var files = removeFiles_1[_i];
                    _loop_7(files);
                }
            }
        }
    };
    SfUploader.prototype.removeCallback = function (fileData, eventArgs) {
        if (!eventArgs.cancel) {
            var removingFiles = this.getFilesInArray(fileData);
            var isLiRemoved = false;
            var liIndex = void 0;
            for (var _i = 0, removingFiles_1 = removingFiles; _i < removingFiles_1.length; _i++) {
                var data = removingFiles_1[_i];
                if (!isLiRemoved) {
                    liIndex = this.fileList.indexOf(data.list);
                }
                if (liIndex > -1) {
                    var inputElement = !sf.base.isNullOrUndefined(data.input) ? data.input : null;
                    if (inputElement) {
                        sf.base.detach(inputElement);
                    }
                    this.spliceFiles(liIndex);
                    sf.base.detach(this.fileList[liIndex]);
                    this.fileList.splice(liIndex, 1);
                    isLiRemoved = true;
                    liIndex = -1;
                }
            }
        }
    };
    /**
     * Clear all the file entries from list that can be uploaded files or added in upload queue.
     * @returns void
     */
    SfUploader.prototype.clearAll = function () {
        var _this = this;
        if (sf.base.isNullOrUndefined(this.listParent) && !(this.isBlazorSaveUrl || this.isBlazorTemplate)) {
            if (this.browserName !== 'msie') {
                this.element.value = '';
            }
            this.filesData = [];
            return;
        }
        var eventArgs = {
            cancel: false,
            filesData: this.filesData
        };
        if (this.clearEnabled) {
            // @ts-ignore-start
            this.dotNetRef.invokeMethodAsync('ClearingEvent', eventArgs).then(function (eventArgs) {
                // @ts-ignore-end
                if (!eventArgs.cancel) {
                    _this.clearData();
                    _this.actionCompleteCount = 0;
                    _this.count = -1;
                }
            });
        }
        else {
            this.clearData();
            this.actionCompleteCount = 0;
            this.count = -1;
        }
    };
    /**
     * Get the data of files which are shown in file list.
     * @param { number } index - specifies the file list item(li) index.
     * @returns FileInfo[]
     */
    SfUploader.prototype.getFilesData = function (index) {
        if (sf.base.isNullOrUndefined(index)) {
            for (var i = 0; i < this.filesData.length; i++) {
                this.filesData[i].rawFile = this.base64String[i];
            }
            return this.filesData;
        }
        else {
            return this.getSelectedFiles(index);
        }
    };
    /**
     * Pauses the in-progress chunked upload based on the file data.
     * @param { FileInfo | FileInfo[] } fileData - specifies the files data to pause from uploading.
     * @param { boolean } custom - Set true if used custom UI.
     * @returns void
     */
    SfUploader.prototype.pause = function (fileData, custom) {
        fileData = fileData ? fileData : this.filesData;
        var fileDataFiles = this.getFilesInArray(fileData);
        this.pauseUploading(fileDataFiles, custom);
    };
    SfUploader.prototype.pauseUploading = function (fileData, custom) {
        var files = this.getFiles(fileData);
        for (var i = 0; i < files.length; i++) {
            if (files[i].statusCode === '3') {
                this.pauseUpload(this.getCurrentMetaData(files[i], null), null, custom);
            }
        }
    };
    SfUploader.prototype.getFiles = function (fileData) {
        var files = [];
        if (!sf.base.isNullOrUndefined(fileData) && !(fileData instanceof Array)) {
            files.push(fileData);
        }
        else {
            files = fileData;
        }
        return files;
    };
    /**
     * Resumes the chunked upload that is previously paused based on the file data.
     * @param { FileInfo | FileInfo[] } fileData - specifies the files data to resume the paused file.
     * @param { boolean } custom - Set true if used custom UI.
     * @returns void
     */
    SfUploader.prototype.resume = function (fileData, custom) {
        fileData = fileData ? fileData : this.filesData;
        var fileDataFiles = this.getFilesInArray(fileData);
        this.resumeFiles(fileDataFiles, custom);
    };
    SfUploader.prototype.resumeFiles = function (fileData, custom) {
        var files = this.getFiles(fileData);
        for (var i = 0; i < files.length; i++) {
            if (files[i].statusCode === '4') {
                this.resumeUpload(this.getCurrentMetaData(files[i], null), null, custom);
            }
        }
    };
    /**
     * Retries the canceled or failed file upload based on the file data.
     * @param { FileInfo | FileInfo[] } fileData - specifies the files data to retry the canceled or failed file.
     * @param { boolean } fromcanceledStage - Set true to retry from canceled stage and set false to retry from initial stage.
     * @returns void
     */
    SfUploader.prototype.retry = function (fileData, fromcanceledStage, custom) {
        fileData = fileData ? fileData : this.filesData;
        var fileDataFiles = this.getFilesInArray(fileData);
        this.retryFailedFiles(fileDataFiles, fromcanceledStage, custom);
    };
    SfUploader.prototype.retryFailedFiles = function (fileData, fromcanceledStage, custom) {
        var files = this.getFiles(fileData);
        for (var i = 0; i < files.length; i++) {
            if (files[i].statusCode === '5' || files[i].statusCode === '0') {
                if (this.asyncSettings.chunkSize > 0) {
                    this.retryUpload(this.getCurrentMetaData(files[i], null), fromcanceledStage);
                }
                else {
                    var liElement = void 0;
                    if (!custom) {
                        liElement = this.fileList[this.filesData.indexOf(files[i])];
                    }
                    this.reloadcanceledFile(null, files[i], liElement, custom);
                }
            }
        }
    };
    /**
     * Stops the in-progress chunked upload based on the file data.
     * When the file upload is canceled, the partially uploaded file is removed from server.
     * @param { FileInfo | FileInfo[] } fileData - specifies the files data to cancel the progressing file.
     * @returns void
     */
    SfUploader.prototype.cancel = function (fileData) {
        fileData = fileData ? fileData : this.filesData;
        var cancelingFiles = this.getFilesInArray(fileData);
        this.cancelUpload(cancelingFiles);
    };
    SfUploader.prototype.cancelUpload = function (fileData) {
        var files = this.getFiles(fileData);
        if (this.asyncSettings.chunkSize > 0) {
            for (var i = 0; i < files.length; i++) {
                if (files[i].statusCode === '3') {
                    var metaData = this.getCurrentMetaData(files[i], null);
                    metaData.file.statusCode = '5';
                    metaData.file.status = this.localizedTexts('fileUploadCancel');
                    this.updateMetaData(metaData);
                    this.showHideUploadSpinner(files[i]);
                }
            }
        }
        else {
            for (var i = 0; i < files.length; i++) {
                if (files[i].statusCode === '3') {
                    files[i].statusCode = '5';
                    files[i].status = this.localizedTexts('fileUploadCancel');
                    this.showHideUploadSpinner(files[i]);
                }
            }
        }
    };
    SfUploader.prototype.showHideUploadSpinner = function (files) {
        var liElement = this.getLiElement(files);
        if (!sf.base.isNullOrUndefined(liElement) && sf.base.isNullOrUndefined(this.template)) {
            var spinnerTarget = liElement.querySelector('.' + ABORT_ICON);
            renderSpinner({ target: spinnerTarget, width: '20px' });
            enableSpinner(spinnerTarget);
        }
    };
    return SfUploader;
}());
// tslint:disable
var Uploader = {
    initialize: function (element, dotnetRef, options) {
        if (element) {
            new SfUploader(element, dotnetRef, options);
        }
        if (element && element.blazor__instance) {
            element.blazor__instance.initialize();
        }
    },
    uploadFileCount: function (element) {
        if (element && element.blazor__instance) {
            return element.blazor__instance.uploadFileCount(element);
        }
        return 0;
    },
    getFileRead: function (element, index) {
        if (element && element.blazor__instance) {
            return element.blazor__instance.getFileRead(index, element);
        }
        return 0;
    },
    getFileInfo: function (element, index) {
        if (element && element.blazor__instance) {
            return element.blazor__instance.getFileInfo(index, element);
        }
        return null;
    },
    serverReadFileBase64: function (element, fileIndex, position, totalCount) {
        if (element && element.blazor__instance) {
            return element.blazor__instance.serverReadFileBase64(fileIndex, position, totalCount);
        }
        return null;
    },
    raiseSuccessEvent: function (element, file) {
        if (element && element.blazor__instance) {
            element.blazor__instance.raiseSuccessEvent(null, file);
        }
    },
    serverRemoveIconBindEvent: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.serverRemoveIconBindEvent();
        }
    },
    serverFileListElement: function (element, ulElement, btnElement, autoUpload) {
        if (element && element.blazor__instance) {
            element.blazor__instance.serverUlElement(ulElement);
            if (!autoUpload) {
                element.blazor__instance.serverActionButtonsEventBind(btnElement);
            }
        }
    },
    bytesToSize: function (element, bytes) {
        if (element && element.blazor__instance) {
            return element.blazor__instance.bytesToSize(bytes);
        }
        return '';
    },
    cancel: function (element, fileData) {
        if (element && element.blazor__instance) {
            element.blazor__instance.cancel(fileData);
        }
    },
    clearAll: function (element) {
        if (element && element.blazor__instance) {
            element.blazor__instance.clearAll();
        }
    },
    createFileList: function (element, fileData, isSelectedFile) {
        if (element && element.blazor__instance) {
            element.blazor__instance.createFileList(fileData, isSelectedFile);
        }
    },
    getFilesData: function (element, index) {
        if (element && element.blazor__instance) {
            return element.blazor__instance.getFilesData(index);
        }
        return null;
    },
    pause: function (element, fileData, custom) {
        if (element && element.blazor__instance) {
            element.blazor__instance.pause(fileData, custom);
        }
    },
    remove: function (element, fileData, customTemplate, removeDirectly, postRawFile, args) {
        if (element && element.blazor__instance) {
            element.blazor__instance.remove(fileData, customTemplate, removeDirectly, postRawFile, args);
        }
    },
    resume: function (element, fileData, custom) {
        if (element && element.blazor__instance) {
            element.blazor__instance.resume(fileData, custom);
        }
    },
    retry: function (element, fileData, fromcanceledStage, custom) {
        if (element && element.blazor__instance) {
            element.blazor__instance.retry(fileData, fromcanceledStage, custom);
        }
    },
    sortFileList: function (element, fileData) {
        if (element && element.blazor__instance) {
            return element.blazor__instance.sortFileList(fileData);
        }
        return null;
    },
    upload: function (element, fileData, custom) {
        if (element && element.blazor__instance) {
            element.blazor__instance.upload(fileData, custom);
        }
    },
    propertyChanges: function propertyChanges(element, options, newProps) {
        if (element && element.blazor__instance) {
            element.blazor__instance.propertyChanges(options, newProps);
        }
    }
};

return Uploader;

}());


/***/ }),

/***/ "./resources/19.3.44/Scripts/spinner.js":
/*!**********************************************!*\
  !*** ./resources/19.3.44/Scripts/spinner.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sf = window.sf || {};
var sfspinner = (function (exports) {
'use strict';

var globalTimeOut = {};
var DEFT_MAT_WIDTH = 30;
var DEFT_FAB_WIDTH = 30;
var DEFT_BOOT_WIDTH = 30;
var DEFT_BOOT4_WIDTH = 36;
var CLS_SHOWSPIN = 'e-spin-show';
var CLS_HIDESPIN = 'e-spin-hide';
var CLS_MATERIALSPIN = 'e-spin-material';
var CLS_FABRICSPIN = 'e-spin-fabric';
var CLS_TAILWINDSPIN = 'e-spin-tailwind';
var CLS_BOOTSPIN = 'e-spin-bootstrap';
var CLS_BOOT4SPIN = 'e-spin-bootstrap4';
var CLS_HIGHCONTRASTSPIN = 'e-spin-high-contrast';
var CLS_SPINWRAP = 'e-spinner-pane';
var CLS_SPININWRAP = 'e-spinner-inner';
var CLS_SPINCIRCLE = 'e-path-circle';
var CLS_SPINARC = 'e-path-arc';
var CLS_SPINLABEL = 'e-spin-label';
var CLS_SPINTEMPLATE = 'e-spin-template';
var spinTemplate = null;
var spinCSSClass = null;
// eslint-disable-next-line
/**
  * Function to change the Spinners in a page globally from application end.
  * ```
  * E.g : blazorSpinner({ action: "Create", options: {target: targetElement}, type: "" });
  * ```
  *
  * @param {string} action - specifies the string
  * @param {CreateArgs} options - specifies the args
  * @param {string} target - specifies the target
  * @param {string} type - specifes the type
  * @returns {void}
  * @private
  */
function Spinner(action, options, target, type) {
    switch (action) {
        case 'Create':
            /* eslint-disable */
            var element = document.querySelector(options.target);
            var args = { type: type, target: element, cssClass: options.cssClass,
                label: options.label, width: options.width };
            /* eslint-enable */
            createSpinner(args);
            break;
        case 'Show':
            showSpinner(document.querySelector(target));
            break;
        case 'Hide':
            hideSpinner(document.querySelector(target));
            break;
        case 'Set':
            // eslint-disable-next-line
            var setArgs = { cssClass: options.cssClass, type: type };
            setSpinner(setArgs);
            break;
    }
}
/**
 * Create a spinner for the specified target element.
 * ```
 * E.g : createSpinner({ target: targetElement, width: '34px', label: 'Loading..' });
 * ```
 *
 * @param {SpinnerArgs} args - specifies the args
 * @param {CreateElementArgs} internalCreateElement - specifis the element args
 * @returns {void}
 * @private
 */
function createSpinner(args, internalCreateElement) {
    if (!args.target) {
        return;
    }
    var radius;
    var makeElement = !sf.base.isNullOrUndefined(internalCreateElement) ? internalCreateElement : sf.base.createElement;
    // eslint-disable-next-line
    var container = create_spinner_container(args.target, makeElement);
    if (!sf.base.isNullOrUndefined(args.cssClass)) {
        container.wrap.classList.add(args.cssClass);
    }
    if (!sf.base.isNullOrUndefined(args.template) || !sf.base.isNullOrUndefined(spinTemplate)) {
        var template = !sf.base.isNullOrUndefined(args.template) ? args.template : spinTemplate;
        container.wrap.classList.add(CLS_SPINTEMPLATE);
        replaceContent(container.wrap, template, spinCSSClass);
    }
    else {
        var theme = !sf.base.isNullOrUndefined(args.type) ? args.type : getTheme(container.wrap);
        var width = !sf.base.isNullOrUndefined(args.width) ? args.width : undefined;
        radius = calculateRadius(width, theme);
        setTheme(theme, container.wrap, radius, makeElement);
        if (!sf.base.isNullOrUndefined(args.label)) {
            createLabel(container.inner_wrap, args.label, makeElement);
        }
    }
    container.wrap.classList.add(CLS_HIDESPIN);
    container = null;
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {string} label - specifies the string
 * @param {createElementParams} makeElement - specifies the element
 * @returns {HTMLElement} - returns the element
 */
function createLabel(container, label, makeElement) {
    var labelEle = makeElement('div', {});
    labelEle.classList.add(CLS_SPINLABEL);
    labelEle.innerHTML = label;
    container.appendChild(labelEle);
    return labelEle;
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createMaterialSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Material', radius: radius };
    create_material_element(container, uniqueID, makeElement, CLS_MATERIALSPIN);
    mat_calculate_attributes(radius, container, 'Material', CLS_MATERIALSPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createBootstrap4Spinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Bootstrap4', radius: radius };
    create_material_element(container, uniqueID, makeElement, CLS_BOOT4SPIN);
    mat_calculate_attributes(radius, container, 'Bootstrap4', CLS_BOOT4SPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {string} uniqueID - specifies the id.
 * @param {number} radius - specifies the radius
 * @returns {void}
 */
function startMatAnimate(container, uniqueID, radius) {
    var globalObject = {};
    var timeOutVar = 0;
    globalTimeOut[uniqueID].timeOut = 0;
    globalObject[uniqueID] = globalVariables(uniqueID, radius, 0, 0);
    // eslint-disable-next-line
    var spinnerInfo = { uniqueID: uniqueID, container: container, globalInfo: globalObject, timeOutVar: timeOutVar };
    animateMaterial(spinnerInfo);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createFabricSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Fabric', radius: radius };
    create_fabric_element(container, uniqueID, CLS_FABRICSPIN, makeElement);
    fb_calculate_attributes(radius, container, CLS_FABRICSPIN);
}
function createTailwindSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Tailwind', radius: radius };
    create_fabric_element(container, uniqueID, CLS_TAILWINDSPIN, makeElement);
    fb_calculate_attributes(radius, container, CLS_TAILWINDSPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createHighContrastSpinner(container, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'HighContrast', radius: radius };
    create_fabric_element(container, uniqueID, CLS_HIGHCONTRASTSPIN, makeElement);
    fb_calculate_attributes(radius, container, CLS_HIGHCONTRASTSPIN);
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @returns {string} - returns the string
 */
function getTheme(container) {
    var theme = window.getComputedStyle(container, ':after').getPropertyValue('content');
    return theme.replace(/['"]+/g, '');
}
/**
 *
 * @param {string} theme - specifies the theme
 * @param {HTMLElement} container - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function setTheme(theme, container, radius, makeElement) {
    var innerContainer = container.querySelector('.' + CLS_SPININWRAP);
    var svg = innerContainer.querySelector('svg');
    if (!sf.base.isNullOrUndefined(svg)) {
        innerContainer.removeChild(svg);
    }
    switch (theme) {
        case 'Material':
            createMaterialSpinner(innerContainer, radius, makeElement);
            break;
        case 'Fabric':
            createFabricSpinner(innerContainer, radius, makeElement);
            break;
        case 'Bootstrap':
            createBootstrapSpinner(innerContainer, radius, makeElement);
            break;
        case 'HighContrast':
            createHighContrastSpinner(innerContainer, radius, makeElement);
            break;
        case 'Bootstrap4':
            createBootstrap4Spinner(innerContainer, radius, makeElement);
            break;
        case 'Tailwind':
        case 'Tailwind-dark':
            createTailwindSpinner(innerContainer, radius, makeElement);
            break;
    }
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {number} radius - specifies the radius
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
function createBootstrapSpinner(innerContainer, radius, makeElement) {
    var uniqueID = random_generator();
    globalTimeOut[uniqueID] = { timeOut: 0, type: 'Bootstrap', radius: radius };
    create_bootstrap_element(innerContainer, uniqueID, makeElement);
    boot_calculate_attributes(innerContainer, radius);
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {string} uniqueID - specifies the id
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
// eslint-disable-next-line
function create_bootstrap_element(innerContainer, uniqueID, makeElement) {
    var svgBoot = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    var viewBoxValue = 64;
    var trans = 32;
    var defaultRadius = 2;
    svgBoot.setAttribute('id', uniqueID);
    svgBoot.setAttribute('class', CLS_BOOTSPIN);
    svgBoot.setAttribute('viewBox', '0 0 ' + viewBoxValue + ' ' + viewBoxValue);
    innerContainer.insertBefore(svgBoot, innerContainer.firstChild);
    for (var item = 0; item <= 7; item++) {
        var bootCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        bootCircle.setAttribute('class', CLS_SPINCIRCLE + '_' + item);
        bootCircle.setAttribute('r', defaultRadius + '');
        bootCircle.setAttribute('transform', 'translate(' + trans + ',' + trans + ')');
        svgBoot.appendChild(bootCircle);
    }
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {number} radius - specifies the radius
 * @returns {void}
 */
// eslint-disable-next-line
function boot_calculate_attributes(innerContainer, radius) {
    var svg = innerContainer.querySelector('svg.e-spin-bootstrap');
    var x = 0;
    var y = 0;
    var rad = 24;
    svg.style.width = svg.style.height = radius + 'px';
    var startArc = 90;
    for (var item = 0; item <= 7; item++) {
        var start = defineArcPoints(x, y, rad, startArc);
        var circleEle = svg.querySelector('.' + CLS_SPINCIRCLE + '_' + item);
        circleEle.setAttribute('cx', start.x + '');
        circleEle.setAttribute('cy', start.y + '');
        startArc = startArc >= 360 ? 0 : startArc;
        startArc = startArc + 45;
    }
}
/**
 *
 * @param {number} begin - specifies the number
 * @param {number} stop  - specifirs the number
 * @returns {number[]} - returns the array of number
 */
function generateSeries(begin, stop) {
    var series = [];
    var start = begin;
    var end = stop;
    // eslint-disable-next-line
    var increment = false, count = 1;
    formSeries(start);
    /**
     *
     * @param {number} i - specifies the number
     * @returns {void}
     */
    function formSeries(i) {
        series.push(i);
        if (i !== end || count === 1) {
            if (i <= start && i > 1 && !increment) {
                i = parseFloat((i - 0.2).toFixed(2));
            }
            else if (i === 1) {
                i = 7;
                i = parseFloat((i + 0.2).toFixed(2));
                increment = true;
            }
            else if (i < 8 && increment) {
                i = parseFloat((i + 0.2).toFixed(2));
                if (i === 8) {
                    increment = false;
                }
            }
            else if (i <= 8 && !increment) {
                i = parseFloat((i - 0.2).toFixed(2));
            }
            ++count;
            formSeries(i);
        }
    }
    return series;
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @returns {void}
 */
function animateBootstrap(innerContainer) {
    var svg = innerContainer.querySelector('svg.e-spin-bootstrap');
    var id = svg.getAttribute('id');
    for (var i = 1; i <= 8; i++) {
        var circleEle = (innerContainer.getElementsByClassName('e-path-circle_' +
            (i === 8 ? 0 : i))[0]);
        rotation(circleEle, i, i, generateSeries(i, i), id);
    }
    /**
     *
     * @param {SVGCircleElement} circle - specifies the circl element
     * @param {number} start - specifies the number
     * @param {number} end - specifies the end number
     * @param {number} series - specifies the series
     * @param {string} id - specifies the id
     * @returns {void}
     */
    function rotation(circle, start, end, series, id) {
        var count = 0;
        boot_animate(start);
        // eslint-disable-next-line
        function boot_animate(radius) {
            if (globalTimeOut[id].isAnimate) {
                ++count;
                circle.setAttribute('r', radius + '');
                if (count >= series.length) {
                    count = 0;
                }
                // eslint-disable-next-line
                globalTimeOut[id].timeOut = setTimeout(boot_animate.bind(null, series[count]), 18);
            }
        }
    }
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {string} template - specifies the template
 * @param {string} cssClass - specifies the css class.
 * @returns {void}
 */
function replaceContent(container, template, cssClass) {
    if (!sf.base.isNullOrUndefined(cssClass)) {
        container.classList.add(cssClass);
    }
    var inner = container.querySelector('.e-spinner-inner');
    inner.innerHTML = template;
}
/**
 *
 * @param {string} width - specifies the width
 * @param {string} theme - specifies the string
 * @returns {number} - returns the number
 */
function calculateRadius(width, theme) {
    var defaultSize;
    switch (theme) {
        case 'Material':
            defaultSize = DEFT_MAT_WIDTH;
            break;
        case 'Fabric':
            defaultSize = DEFT_FAB_WIDTH;
            break;
        case 'Tailwind':
        case 'Tailwind-dark':
            defaultSize = DEFT_FAB_WIDTH;
            break;
        case 'Bootstrap4':
            defaultSize = DEFT_BOOT4_WIDTH;
            break;
        default:
            defaultSize = DEFT_BOOT_WIDTH;
    }
    width = width ? parseFloat(width + '') : defaultSize;
    return theme === 'Bootstrap' ? width : width / 2;
}
/**
 *
 * @param {string} id - specifies the id
 * @param {number} radius - specifies the radius
 * @param {number} count - specifies the number count
 * @param {number} previousId - specifies the previous id
 * @returns {GlobalVariables} - returns the variables
 */
function globalVariables(id, radius, count, previousId) {
    return {
        radius: radius,
        count: count,
        previousId: previousId
    };
}
/**
 * @returns {string} - returns the string
 */
// eslint-disable-next-line
function random_generator() {
    var random = '';
    var combine = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (var i = 0; i < 5; i++) {
        random += combine.charAt(Math.floor(Math.random() * combine.length));
    }
    return random;
}
/**
 *
 * @param {HTMLElement} innerCon - specifies the element
 * @param {string} uniqueID - specifies the unique id
 * @param {string} themeClass - specifies the string
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
// eslint-disable-next-line
function create_fabric_element(innerCon, uniqueID, themeClass, makeElement) {
    var svgFabric = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgFabric.setAttribute('id', uniqueID);
    svgFabric.setAttribute('class', themeClass);
    var fabricCirclePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    fabricCirclePath.setAttribute('class', CLS_SPINCIRCLE);
    var fabricCircleArc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    fabricCircleArc.setAttribute('class', CLS_SPINARC);
    innerCon.insertBefore(svgFabric, innerCon.firstChild);
    svgFabric.appendChild(fabricCirclePath);
    svgFabric.appendChild(fabricCircleArc);
}
/**
 *
 * @param {HTMLElement} innerContainer - specifies the element
 * @param {string} uniqueID - specifies the unique id
 * @param {createElementParams} makeElement - specifies the element
 * @param {string} cls - specifies the string
 * @returns {void}
 */
// eslint-disable-next-line
function create_material_element(innerContainer, uniqueID, makeElement, cls) {
    var svgMaterial = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    var matCirclePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    svgMaterial.setAttribute('class', cls);
    svgMaterial.setAttribute('id', uniqueID);
    matCirclePath.setAttribute('class', CLS_SPINCIRCLE);
    innerContainer.insertBefore(svgMaterial, innerContainer.firstChild);
    svgMaterial.appendChild(matCirclePath);
}
/**
 *
 * @param {HTMLElement} target - specifies the element
 * @param {createElementParams} makeElement - specifies the element
 * @returns {void}
 */
// eslint-disable-next-line
function create_spinner_container(target, makeElement) {
    var spinnerContainer = makeElement('div', {});
    var spinnerInnerContainer = makeElement('div', {});
    spinnerContainer.classList.add(CLS_SPINWRAP);
    spinnerInnerContainer.classList.add(CLS_SPININWRAP);
    target.appendChild(spinnerContainer);
    spinnerContainer.appendChild(spinnerInnerContainer);
    // eslint-disable-next-line
    return { wrap: spinnerContainer, inner_wrap: spinnerInnerContainer };
}
/**
 *
 * @param {SpinnerInfo} spinnerInfo - specifies the spinner
 * @returns {void}
 */
function animateMaterial(spinnerInfo) {
    var start = 1;
    var end = 149;
    var duration = 1333;
    var max = 75;
    createCircle(start, end, easeAnimation, duration, spinnerInfo.globalInfo[spinnerInfo.uniqueID].count, max, spinnerInfo);
    spinnerInfo.globalInfo[spinnerInfo.uniqueID].count = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].count % 4;
}
/**
 *
 * @param {number} start - specifies the number
 * @param {number} end - specifies the end number
 * @param {Function} easing - specifies the function
 * @param {number} duration - specifies the duration
 * @param {number} count - specifies the count
 * @param {number} max - specifies the max number
 * @param {SpinnerInfo} spinnerInfo - specifies the spinner info
 * @returns {void}
 */
// eslint-disable-next-line
function createCircle(start, end, easing, duration, count, max, spinnerInfo) {
    var id = ++spinnerInfo.globalInfo[spinnerInfo.uniqueID].previousId;
    var startTime = new Date().getTime();
    var change = end - start;
    var diameter = getSize((spinnerInfo.globalInfo[spinnerInfo.uniqueID].radius * 2) + '');
    var strokeSize = getStrokeSize(diameter);
    var rotate = -90 * (spinnerInfo.globalInfo[spinnerInfo.uniqueID].count || 0);
    mat_animation(spinnerInfo);
    // eslint-disable-next-line
    function mat_animation(spinnerInfo) {
        var currentTime = Math.max(0, Math.min(new Date().getTime() - startTime, duration));
        updatePath(easing(currentTime, start, change, duration), spinnerInfo.container);
        if (id === spinnerInfo.globalInfo[spinnerInfo.uniqueID].previousId && currentTime < duration) {
            // eslint-disable-next-line
            globalTimeOut[spinnerInfo.uniqueID].timeOut = setTimeout(mat_animation.bind(null, spinnerInfo), 1);
        }
        else {
            animateMaterial(spinnerInfo);
        }
    }
    /**
     *
     * @param {number} value - specifies the number value
     * @param {HTMLElement} container - specifies the container
     * @returns {void}
     */
    function updatePath(value, container) {
        if ((!sf.base.isNullOrUndefined(container.querySelector('svg.e-spin-material')))
            && (!sf.base.isNullOrUndefined(container.querySelector('svg.e-spin-material').querySelector('path.e-path-circle')))) {
            var svg = container.querySelector('svg.e-spin-material');
            var path = svg.querySelector('path.e-path-circle');
            path.setAttribute('stroke-dashoffset', getDashOffset(diameter, strokeSize, value, max) + '');
            path.setAttribute('transform', 'rotate(' + (rotate) + ' ' + diameter / 2 + ' ' + diameter / 2 + ')');
        }
    }
}
/**
 *
 * @param {number} radius - specifies the number
 * @param {HTMLElement} container - specifies the element
 * @param {string} type - specifies the string type
 * @param {string} cls - specifies the string
 * @returns {void}
 */
// eslint-disable-next-line
function mat_calculate_attributes(radius, container, type, cls) {
    var diameter = radius * 2;
    var svg = container.querySelector('svg.' + cls);
    var path = svg.querySelector('path.e-path-circle');
    var strokeSize = getStrokeSize(diameter);
    var transformOrigin = (diameter / 2) + 'px';
    svg.setAttribute('viewBox', '0 0 ' + diameter + ' ' + diameter);
    svg.style.width = svg.style.height = diameter + 'px';
    svg.style.transformOrigin = transformOrigin + ' ' + transformOrigin + ' ' + transformOrigin;
    path.setAttribute('d', drawArc(diameter, strokeSize));
    if (type === 'Material') {
        path.setAttribute('stroke-width', strokeSize + '');
        path.setAttribute('stroke-dasharray', ((diameter - strokeSize) * Math.PI * 0.75) + '');
        path.setAttribute('stroke-dashoffset', getDashOffset(diameter, strokeSize, 1, 75) + '');
    }
}
/**
 *
 * @param {string} value - specifies the value
 * @returns {number} - returns the number
 */
function getSize(value) {
    var parsed = parseFloat(value);
    return parsed;
}
/**
 *
 * @param {number} diameter - specifies the diameter
 * @param {number} strokeSize - specifies the size
 * @returns {string} - returns the string
 */
function drawArc(diameter, strokeSize) {
    var radius = diameter / 2;
    var offset = strokeSize / 2;
    return 'M' + radius + ',' + offset
        + 'A' + (radius - offset) + ',' + (radius - offset) + ' 0 1 1 ' + offset + ',' + radius;
}
/**
 *
 * @param {number} diameter - specifies the number
 * @returns {number} - returns the number
 */
function getStrokeSize(diameter) {
    return 10 / 100 * diameter;
}
/**
 *
 * @param {number} diameter - specifies the number
 * @param {number} strokeSize - specifies the stroke size
 * @param {number} value - specifies the value
 * @param {number} max - specifies the max number
 * @returns {number} - returns the number
 */
function getDashOffset(diameter, strokeSize, value, max) {
    return (diameter - strokeSize) * Math.PI * ((3 * (max) / 100) - (value / 100));
}
/**
 *
 * @param {number} current - specifies the number
 * @param {number} start - specifies the stroke size
 * @param {number} change - specifies the value
 * @param {number} duration - specifies the max number
 * @returns {number} - returns the number
 */
function easeAnimation(current, start, change, duration) {
    var timestamp = (current /= duration) * current;
    var timecount = timestamp * current;
    return start + change * (6 * timecount * timestamp + -15 * timestamp * timestamp + 10 * timecount);
}
/**
 *
 * @param {number} radius - specifies the number
 * @param {HTMLElement} innerConainer - specifies the element
 * @param {string} trgClass - specifies the class
 * @returns {void}
 */
// eslint-disable-next-line
function fb_calculate_attributes(radius, innerConainer, trgClass) {
    var centerX = radius;
    var centerY = radius;
    var diameter = radius * 2;
    // eslint-disable-next-line
    var startArc = 315, endArc = 45;
    var svg = innerConainer.querySelector('.' + trgClass);
    var circle = svg.querySelector('.e-path-circle');
    var path = svg.querySelector('.e-path-arc');
    var transformOrigin = (diameter / 2) + 'px';
    circle.setAttribute('d', defineCircle(centerX, centerY, radius));
    path.setAttribute('d', defineArc(centerX, centerY, radius, startArc, endArc));
    svg.setAttribute('viewBox', '0 0 ' + diameter + ' ' + diameter);
    svg.style.transformOrigin = transformOrigin + ' ' + transformOrigin + ' ' + transformOrigin;
    svg.style.width = svg.style.height = diameter + 'px';
}
/**
 *
 * @param {number} centerX - specifies the number
 * @param {number} centerY - specifies the stroke size
 * @param {number} radius - specifies the value
 * @param {number} angle - specifies the max number
 * @returns {number} - returns the number
 */
function defineArcPoints(centerX, centerY, radius, angle) {
    var radians = (angle - 90) * Math.PI / 180.0;
    return {
        x: centerX + (radius * Math.cos(radians)),
        y: centerY + (radius * Math.sin(radians))
    };
}
/**
 *
 * @param {number} x - specifies the number
 * @param {number} y - specifies the stroke size
 * @param {number} radius - specifies the radius
 * @param {number} startArc - specifies the value
 * @param {number} endArc - specifies the max number
 * @returns {number} - returns the number
 */
function defineArc(x, y, radius, startArc, endArc) {
    var start = defineArcPoints(x, y, radius, endArc);
    var end = defineArcPoints(x, y, radius, startArc);
    var d = [
        'M', start.x, start.y,
        'A', radius, radius, 0, 0, 0, end.x, end.y
    ].join(' ');
    return d;
}
/**
 *
 * @param {number} x - specifies the number
 * @param {number} y - specifies the stroke size
 * @param {number} radius - specifies the value
 * @returns {string} - returns the string
 */
function defineCircle(x, y, radius) {
    var d = [
        'M', x, y,
        'm', -radius, 0,
        'a', radius, radius, 0, 1, 0, radius * 2, 0,
        'a', radius, radius, 0, 1, 0, -radius * 2, 0
    ].join(' ');
    return d;
}
// eslint-disable-next-line
/**
 * Function to show the Spinner.
 *
 * @param {HTMLElement} container - Specify the target of the Spinner.
 * @returns {void}
 * @private
 */
function showSpinner(container) {
    showHideSpinner(container, false);
    container = null;
}
/**
 *
 * @param {HTMLElement} container - specifies the element
 * @param {boolean} isHide - specifies the boolean
 * @returns {void}
 */
function showHideSpinner(container, isHide) {
    var spinnerWrap;
    if (container) {
        spinnerWrap = container.classList.contains(CLS_SPINWRAP) ? container :
            container.querySelector('.' + CLS_SPINWRAP);
    }
    if (container && spinnerWrap) {
        var inner = spinnerWrap.querySelector('.' + CLS_SPININWRAP);
        var spinCheck = void 0;
        // eslint-disable-next-line
        spinCheck = isHide ? !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_HIDESPIN) :
            !spinnerWrap.classList.contains(CLS_SPINTEMPLATE) && !spinnerWrap.classList.contains(CLS_SHOWSPIN);
        if (spinCheck) {
            var svgEle = spinnerWrap.querySelector('svg');
            if (sf.base.isNullOrUndefined(svgEle)) {
                return;
            }
            var id = svgEle.getAttribute('id');
            globalTimeOut[id].isAnimate = !isHide;
            switch (globalTimeOut[id].type) {
                case 'Material':
                    // eslint-disable-next-line
                    isHide ? clearTimeout(globalTimeOut[id].timeOut) : startMatAnimate(inner, id, globalTimeOut[id].radius);
                    break;
                case 'Bootstrap':
                    // eslint-disable-next-line
                    isHide ? clearTimeout(globalTimeOut[id].timeOut) : animateBootstrap(inner);
                    break;
            }
        }
        // eslint-disable-next-line
        isHide ? sf.base.classList(spinnerWrap, [CLS_HIDESPIN], [CLS_SHOWSPIN]) : sf.base.classList(spinnerWrap, [CLS_SHOWSPIN], [CLS_HIDESPIN]);
        container = null;
    }
}
/**
 * Function to hide the Spinner.
 *
 * @param {HTMLElement} container - Specify the target of the Spinner.
 * @returns {void}
 * @private
 */
function hideSpinner(container) {
    showHideSpinner(container, true);
    container = null;
}
// eslint-disable-next-line
/**
  * Function to change the Spinners in a page globally from application end.
  * ```
  * E.g : setSpinner({ cssClass: 'custom-css'; type: 'Material' });
  * ```
  *
  * @param {SetSpinnerArgs} args - specifies the args
  * @param {createElementParams} internalCreateElement - specifies the element params
  * @returns {void}
  * @private
  */
function setSpinner(args, internalCreateElement) {
    var makeElement = !sf.base.isNullOrUndefined(internalCreateElement) ? internalCreateElement : sf.base.createElement;
    if (args.template !== undefined) {
        spinTemplate = args.template;
        if (args.template !== undefined) {
            spinCSSClass = args.cssClass;
        }
    }
    var container = document.querySelectorAll('.' + CLS_SPINWRAP);
    for (var index = 0; index < container.length; index++) {
        ensureTemplate(args.template, container[index], args.type, args.cssClass, makeElement);
    }
}
/**
 *
 * @param {string} template - specifies the string
 * @param {HTMLElement} container - specifies the container
 * @param {string} theme - specifies the theme
 * @param {string} cssClass - specifies the string class
 * @param {createElementParams} makeEle - specifies the params
 * @returns {void}
 */
function ensureTemplate(template, container, theme, cssClass, makeEle) {
    if (sf.base.isNullOrUndefined(template) && !container.classList.contains(CLS_SPINTEMPLATE)) {
        replaceTheme(container, theme, cssClass, makeEle);
        if (container.classList.contains(CLS_SHOWSPIN)) {
            container.classList.remove(CLS_SHOWSPIN);
            showSpinner(container);
        }
        else {
            container.classList.remove(CLS_HIDESPIN);
            hideSpinner(container);
        }
    }
    else {
        spinTemplate = template;
        if (!sf.base.isNullOrUndefined(cssClass)) {
            spinCSSClass = cssClass;
        }
    }
}
/**
 *
 * @param {HTMLElement} container - specifies the container
 * @param {string} theme - specifies the theme
 * @param {string} cssClass - specifies the string class
 * @param {createElementParams} makeEle - specifies the params
 * @returns {void}
 */
function replaceTheme(container, theme, cssClass, makeEle) {
    if (!sf.base.isNullOrUndefined(cssClass)) {
        container.classList.add(cssClass);
    }
    var svgElement = container.querySelector('svg');
    var radius = theme === 'Bootstrap' ? parseFloat(svgElement.style.height) : parseFloat(svgElement.style.height) / 2;
    var classNames = svgElement.getAttribute('class');
    var svgClassList = classNames.split(/\s/);
    if (svgClassList.indexOf('e-spin-material') >= 0) {
        var id = svgElement.getAttribute('id');
        clearTimeout(globalTimeOut[id].timeOut);
    }
    setTheme(theme, container, radius, makeEle);
}

/**
 * spinner modules
 */

exports.Spinner = Spinner;
exports.createSpinner = createSpinner;
exports.showSpinner = showSpinner;
exports.hideSpinner = hideSpinner;
exports.setSpinner = setSpinner;

return exports;

});

    sf.popups = sf.base.extend({}, sf.popups, sfspinner({}));

/***/ }),

/***/ "./resources/19.3.44/Scripts/splitbuttonsbase.js":
/*!*******************************************************!*\
  !*** ./resources/19.3.44/Scripts/splitbuttonsbase.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sf = window.sf || {};
var splitbuttonsbase = (function (exports) {
'use strict';

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @param {Object} props - Specifies the properties
 * @param {string[]} model - Specifies the model
 * @returns {Object} Component Model
 */
function getModel(props, model) {
    var obj = sf.base.extend({}, props);
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var prop = _a[_i];
        if ((model).indexOf(prop) < 0) {
            sf.base.deleteObject(obj, prop);
        }
    }
    return obj;
}
/** @hidden
 * @param {HTMLElement} ul - Specifies the UL element
 * @param {number} keyCode - Specifies the keycode
 * @returns {void}
 */
function upDownKeyHandler(ul, keyCode) {
    var defaultIdx = keyCode === 40 ? 0 : ul.childElementCount - 1;
    var liIdx = defaultIdx;
    var li;
    var selectedLi = ul.querySelector('.e-selected');
    if (selectedLi) {
        selectedLi.classList.remove('e-selected');
    }
    for (var i = 0, len = ul.children.length; i < len; i++) {
        if (ul.children[i].classList.contains('e-focused')) {
            li = ul.children[i];
            liIdx = i;
            li.classList.remove('e-focused');
            if (keyCode === 40) {
                liIdx++;
            }
            else {
                liIdx--;
            }
            if (liIdx === (keyCode === 40 ? ul.childElementCount : -1)) {
                liIdx = defaultIdx;
            }
        }
    }
    li = ul.children[liIdx];
    liIdx = isValidLI(ul, li, liIdx, keyCode);
    if (liIdx !== -1) {
        sf.base.addClass([ul.children[liIdx]], 'e-focused');
        ul.children[liIdx].focus();
    }
}
/**
 * Get Valid LI element
 *
 * @param {HTMLElement} ul - Specifies the UL element
 * @param {Element} li - Specifies the LI element
 * @param {number} index - Specifies the index
 * @param {number} keyCode - Specifies the keycode
 * @param {number} count - Specifies the count
 * @returns {number} - Index
 */
function isValidLI(ul, li, index, keyCode, count) {
    if (count === void 0) { count = 0; }
    if (li.classList.contains('e-separator') || li.classList.contains('e-disabled')) {
        if (index === (keyCode === 40 ? ul.childElementCount - 1 : 0)) {
            index = keyCode === 40 ? 0 : ul.childElementCount - 1;
        }
        else {
            if (keyCode === 40) {
                index++;
            }
            else {
                index--;
            }
        }
    }
    li = ul.children[index];
    if (li.classList.contains('e-separator') || li.classList.contains('e-disabled')) {
        count++;
        if (count === ul.childElementCount) {
            return index = -1;
        }
        index = isValidLI(ul, li, index, keyCode, count);
    }
    return index;
}
/** @hidden
 * @param {HTMLElement} popup - Specifies the popup element.
 * @returns {void}
 */
function setBlankIconStyle(popup) {
    var blankIconList = [].slice.call(popup.getElementsByClassName('e-blank-icon'));
    if (!blankIconList.length) {
        return;
    }
    var iconLi = popup.querySelector('.e-item:not(.e-blank-icon):not(.e-separator)');
    if (iconLi.classList.contains('e-url')) {
        iconLi = iconLi.querySelector('.e-menu-url');
    }
    var icon = iconLi.querySelector('.e-menu-icon');
    var cssProp;
    var enableRtl = popup.classList.contains('e-rtl');
    if (enableRtl) {
        cssProp = { padding: 'paddingRight', margin: 'marginLeft' };
    }
    else {
        cssProp = { padding: 'paddingLeft', margin: 'marginRight' };
    }
    /* eslint-disable */
    var size = parseInt(getComputedStyle(icon).fontSize, 10) + parseInt((enableRtl ? getComputedStyle(icon)[cssProp.margin] : getComputedStyle(icon)[cssProp.margin]), 10)
        + parseInt(getComputedStyle(iconLi).paddingLeft, 10) + "px";
    blankIconList.forEach(function (li) {
        if (li.classList.contains('e-url')) {
            li.querySelector('.e-menu-url').style[cssProp.padding] = size;
        }
        else {
            li.style[cssProp.padding] = size;
        }
    });
    /* eslint-enable */
}
/**
 * Defines the items of Split Button/DropDownButton.
 */
var Item = /** @class */ (function (_super) {
    __extends(Item, _super);
    function Item() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sf.base.Property('')
    ], Item.prototype, "iconCss", void 0);
    __decorate([
        sf.base.Property('')
    ], Item.prototype, "id", void 0);
    __decorate([
        sf.base.Property(false)
    ], Item.prototype, "separator", void 0);
    __decorate([
        sf.base.Property('')
    ], Item.prototype, "text", void 0);
    __decorate([
        sf.base.Property('')
    ], Item.prototype, "url", void 0);
    __decorate([
        sf.base.Property(false)
    ], Item.prototype, "disabled", void 0);
    return Item;
}(sf.base.ChildProperty));

exports.getModel = getModel;
exports.upDownKeyHandler = upDownKeyHandler;
exports.setBlankIconStyle = setBlankIconStyle;
exports.Item = Item;

return exports;

});
window.sf.splitbuttons = window.sf.base.extend({}, window.sf.splitbuttons, splitbuttonsbase({}));


/***/ }),

/***/ "./resources/19.3.44/Scripts/svgbase.js":
/*!**********************************************!*\
  !*** ./resources/19.3.44/Scripts/svgbase.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

window.sf = window.sf || {};
window.sf.svgbase = (function (exports) {
'use strict';

/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * To import utils
 */
var SvgRenderer = /** @class */ (function () {
    /* End-Properties */
    function SvgRenderer(rootID) {
        //Internal Variables
        this.svgLink = 'http://www.w3.org/2000/svg';
        this.rootId = rootID;
    }
    // method to get the attributes value
    // tslint:disable-next-line:no-any
    SvgRenderer.prototype.getOptionValue = function (options, key) {
        return options[key];
    }; /* tslint:enable */
    /**
     * To create a Html5 SVG element
     *
     * @param {SVGAttributes} options - Options to create SVG
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createSvg = function (options) {
        if (sf.base.isNullOrUndefined(options.id)) {
            options.id = this.rootId + '_svg';
        }
        this.svgObj = document.getElementById(options.id);
        if (sf.base.isNullOrUndefined(document.getElementById(options.id))) {
            this.svgObj = document.createElementNS(this.svgLink, 'svg');
        }
        this.svgObj = this.setElementAttributes(options, this.svgObj);
        this.setSVGSize(options.width, options.height);
        return this.svgObj;
    };
    // method to set the height and width for the SVG element
    SvgRenderer.prototype.setSVGSize = function (width, height) {
        var element = document.getElementById(this.rootId);
        var size = !sf.base.isNullOrUndefined(element) ? element.getBoundingClientRect() : null;
        if (sf.base.isNullOrUndefined(this.width) || this.width <= 0) {
            this.svgObj.setAttribute('width', width ? width.toString() : size.width.toString());
        }
        else {
            this.svgObj.setAttribute('width', this.width.toString());
        }
        if (sf.base.isNullOrUndefined(this.height) || this.height <= 0) {
            this.svgObj.setAttribute('height', height ? height.toString() : '450');
        }
        else {
            this.svgObj.setAttribute('height', this.height.toString());
        }
    };
    /**
     * To draw a path
     *
     * @param {PathAttributes} options - Options to draw a path in SVG
     * @returns {Element} It returns a appropriate path
     */
    SvgRenderer.prototype.drawPath = function (options) {
        var path = document.getElementById(options.id);
        if (path === null) {
            path = document.createElementNS(this.svgLink, 'path');
        }
        path = this.setElementAttributes(options, path);
        return path;
    };
    /**
     * To draw a line
     *
     * @param {LineAttributes} options - Options to draw a line in SVG
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawLine = function (options) {
        var line = document.getElementById(options.id);
        if (line === null) {
            line = document.createElementNS(this.svgLink, 'line');
        }
        line = this.setElementAttributes(options, line);
        return line;
    };
    /**
     * To draw a rectangle
     *
     * @param {BaseAttibutes} options - Required options to draw a rectangle in SVG
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawRectangle = function (options) {
        var rectangle = document.getElementById(options.id);
        if (rectangle === null) {
            rectangle = document.createElementNS(this.svgLink, 'rect');
        }
        rectangle = this.setElementAttributes(options, rectangle);
        return rectangle;
    };
    /**
     * To draw a circle
     *
     * @param {CircleAttributes} options - Required options to draw a circle in SVG
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawCircle = function (options) {
        var circle = document.getElementById(options.id);
        if (circle === null) {
            circle = document.createElementNS(this.svgLink, 'circle');
        }
        circle = this.setElementAttributes(options, circle);
        return circle;
    };
    /**
     * To draw a polyline
     *
     * @param {PolylineAttributes} options - Options required to draw a polyline
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawPolyline = function (options) {
        var polyline = document.getElementById(options.id);
        if (polyline === null) {
            polyline = document.createElementNS(this.svgLink, 'polyline');
        }
        polyline = this.setElementAttributes(options, polyline);
        return polyline;
    };
    /**
     * To draw an ellipse
     *
     * @param {EllipseAttributes} options - Options required to draw an ellipse
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawEllipse = function (options) {
        var ellipse = document.getElementById(options.id);
        if (ellipse === null) {
            ellipse = document.createElementNS(this.svgLink, 'ellipse');
        }
        ellipse = this.setElementAttributes(options, ellipse);
        return ellipse;
    };
    /**
     * To draw a polygon
     *
     * @param {PolylineAttributes} options - Options needed to draw a polygon in SVG
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawPolygon = function (options) {
        var polygon = document.getElementById(options.id);
        if (polygon === null) {
            polygon = document.createElementNS(this.svgLink, 'polygon');
        }
        polygon = this.setElementAttributes(options, polygon);
        return polygon;
    };
    /**
     * To draw an image
     *
     * @param {ImageAttributes} options - Required options to draw an image in SVG
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawImage = function (options) {
        var img = document.createElementNS(this.svgLink, 'image');
        img.setAttributeNS(null, 'height', options.height.toString());
        img.setAttributeNS(null, 'width', options.width.toString());
        img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', options.href);
        img.setAttributeNS(null, 'x', options.x.toString());
        img.setAttributeNS(null, 'y', options.y.toString());
        img.setAttributeNS(null, 'id', options.id);
        img.setAttributeNS(null, 'visibility', options.visibility);
        if (!sf.base.isNullOrUndefined(this.getOptionValue(options, 'clip-path'))) {
            img.setAttributeNS(null, 'clip-path', this.getOptionValue(options, 'clip-path'));
        }
        if (!sf.base.isNullOrUndefined(options.preserveAspectRatio)) {
            img.setAttributeNS(null, 'preserveAspectRatio', options.preserveAspectRatio);
        }
        return img;
    };
    /**
     * To draw a text
     *
     * @param {TextAttributes} options - Options needed to draw a text in SVG
     * @param {string} label - Label of the text
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createText = function (options, label) {
        var text = document.createElementNS(this.svgLink, 'text');
        text = this.setElementAttributes(options, text);
        if (!sf.base.isNullOrUndefined(label)) {
            text.textContent = label;
        }
        return text;
    };
    /**
     * To create a tSpan
     *
     * @param {TextAttributes} options - Options to create tSpan
     * @param {string} label - The text content which is to be rendered in the tSpan
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createTSpan = function (options, label) {
        var tSpan = document.createElementNS(this.svgLink, 'tspan');
        tSpan = this.setElementAttributes(options, tSpan);
        if (!sf.base.isNullOrUndefined(label)) {
            tSpan.textContent = label;
        }
        return tSpan;
    };
    /**
     * To create a title
     *
     * @param {string} text - The text content which is to be rendered in the title
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createTitle = function (text) {
        var title = document.createElementNS(this.svgLink, 'title');
        title.textContent = text;
        return title;
    };
    /**
     * To create defs element in SVG
     *
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createDefs = function () {
        var defs = document.createElementNS(this.svgLink, 'defs');
        return defs;
    };
    /**
     * To create clip path in SVG
     *
     * @param {BaseAttibutes} options - Options needed to create clip path
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createClipPath = function (options) {
        var clipPath = document.createElementNS(this.svgLink, 'clipPath');
        clipPath = this.setElementAttributes(options, clipPath);
        return clipPath;
    };
    /**
     * To create foreign object in SVG
     *
     * @param {BaseAttibutes} options - Options needed to create foreign object
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createForeignObject = function (options) {
        var foreignObject = document.createElementNS(this.svgLink, 'foreignObject');
        foreignObject = this.setElementAttributes(options, foreignObject);
        return foreignObject;
    };
    /**
     * To create group element in SVG
     *
     * @param {BaseAttibutes} options - Options needed to create group
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createGroup = function (options) {
        var group = document.createElementNS(this.svgLink, 'g');
        group = this.setElementAttributes(options, group);
        return group;
    };
    /**
     * To create pattern in SVG
     *
     * @param {PatternAttributes} options - Required options to create pattern in SVG
     * @param {string} element - Specifies the name of the pattern
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.createPattern = function (options, element) {
        var pattern = document.createElementNS(this.svgLink, element);
        pattern = this.setElementAttributes(options, pattern);
        return pattern;
    };
    /**
     * To create radial gradient in SVG
     *
     * @param {string[]} colors - Specifies the colors required to create radial gradient
     * @param {string} name - Specifies the name of the gradient
     * @param {RadialGradient} options - value for radial gradient
     * @returns {string} It returns color name
     */
    SvgRenderer.prototype.createRadialGradient = function (colors, name, options) {
        var colorName;
        if (!sf.base.isNullOrUndefined(colors[0].colorStop)) {
            var newOptions = {
                'id': this.rootId + '_' + name + 'radialGradient',
                'cx': options.cx + '%',
                'cy': options.cy + '%',
                'r': options.r + '%',
                'fx': options.fx + '%',
                'fy': options.fy + '%'
            };
            this.drawGradient('radialGradient', newOptions, colors);
            colorName = 'url(#' + this.rootId + '_' + name + 'radialGradient)';
        }
        else {
            colorName = colors[0].color.toString();
        }
        return colorName;
    };
    /**
     * To create linear gradient in SVG
     *
     * @param {GradientColor[]} colors - Array of string specifies the values for color
     * @param {string} name - Specifies the name of the gradient
     * @param {LinearGradient} options - Specifies the options for gradient
     * @returns {string} It returns color name
     */
    SvgRenderer.prototype.createLinearGradient = function (colors, name, options) {
        var colorName;
        if (!sf.base.isNullOrUndefined(colors[0].colorStop)) {
            var newOptions = {
                'id': this.rootId + '_' + name + 'linearGradient',
                'x1': options.x1 + '%',
                'y1': options.y1 + '%',
                'x2': options.x2 + '%',
                'y2': options.y2 + '%'
            };
            this.drawGradient('linearGradient', newOptions, colors);
            colorName = 'url(#' + this.rootId + '_' + name + 'linearGradient)';
        }
        else {
            colorName = colors[0].color.toString();
        }
        return colorName;
    };
    /**
     * To render the gradient element in SVG
     *
     * @param {string} gradientType - Specifies the type of the gradient
     * @param {RadialGradient | LinearGradient} options - Options required to render a gradient
     * @param {string[]} colors - Array of string specifies the values for color
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawGradient = function (gradientType, options, colors) {
        var defs = this.createDefs();
        var gradient = document.createElementNS(this.svgLink, gradientType);
        gradient = this.setElementAttributes(options, gradient);
        for (var i = 0; i < colors.length; i++) {
            var stop_1 = document.createElementNS(this.svgLink, 'stop');
            stop_1.setAttribute('offset', colors[i].colorStop);
            stop_1.setAttribute('stop-color', colors[i].color);
            stop_1.setAttribute('stop-opacity', colors[i].opacity ? (colors[i].opacity) : '1');
            if (!sf.base.isNullOrUndefined(colors[i].style)) {
                stop_1.setAttribute('style', colors[i].style);
            }
            gradient.appendChild(stop_1);
        }
        defs.appendChild(gradient);
        return defs;
    };
    /**
     * To render a clip path
     *
     * @param {BaseAttibutes} options - Options required to render a clip path
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawClipPath = function (options) {
        var defs = this.createDefs();
        var clipPath = this.createClipPath({ 'id': options.id });
        options.id = options.id + '_Rect';
        var rect = this.drawRectangle(options);
        clipPath.appendChild(rect);
        defs.appendChild(clipPath);
        return defs;
    };
    /**
     * To create circular clip path in SVG
     *
     * @param {CircleAttributes} options - Options required to create circular clip path
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.drawCircularClipPath = function (options) {
        var defs = this.createDefs();
        var clipPath = this.createClipPath({ 'id': options.id });
        options.id = options.id + '_Circle';
        var circle = this.drawCircle(options);
        clipPath.appendChild(circle);
        defs.appendChild(clipPath);
        return defs;
    };
    /**
     * To set the attributes to the element
     *
     * @param {SVGCanvasAttributes} options - Attributes to set for the element
     * @param {Element} element - The element to which the attributes need to be set
     * @returns {Element} It returns a appropriate element
     */
    SvgRenderer.prototype.setElementAttributes = function (options, element) {
        var keys = Object.keys(options);
        for (var i = 0; i < keys.length; i++) {
            element.setAttribute(keys[i], options[keys[i]]);
        }
        return element;
    };
    /**
     * To create a Html5 canvas element
     * Dummy method for using canvas/svg render in the same variable name in chart control
     */
    SvgRenderer.prototype.createCanvas = function () {
        return null;
    };
    return SvgRenderer;
}());

/* eslint-disable no-case-declarations */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * To import utils.
 */
/**
 * @private
 */
var CanvasRenderer = /** @class */ (function () {
    /* End-Properties */
    function CanvasRenderer(rootID) {
        this.rootId = rootID;
    }
    // method to get the attributes value
    // tslint:disable-next-line:no-any
    CanvasRenderer.prototype.getOptionValue = function (options, key) {
        return options[key];
    };
    /* tslint:enable */
    /**
     * To create a Html5 canvas element
     *
     * @param {BaseAttibutes} options - Options to create canvas
     * @returns {HTMLCanvasElement} Creating a canvas
     */
    CanvasRenderer.prototype.createCanvas = function (options) {
        var canvasObj = document.createElement('canvas');
        canvasObj.setAttribute('id', this.rootId + '_canvas');
        this.ctx = canvasObj.getContext('2d');
        this.canvasObj = canvasObj;
        this.setCanvasSize(options.width, options.height);
        return this.canvasObj;
    };
    /**
     * To set the width and height for the Html5 canvas element
     *
     * @param {number} width - width of the canvas
     * @param {number} height - height of the canvas
     * @returns {void} Setting canvas size
     */
    CanvasRenderer.prototype.setCanvasSize = function (width, height) {
        var element = document.getElementById(this.rootId);
        var size = !sf.base.isNullOrUndefined(element) ? element.getBoundingClientRect() : null;
        if (sf.base.isNullOrUndefined(this.width)) {
            this.canvasObj.setAttribute('width', width ? width.toString() : size.width.toString());
        }
        else {
            this.canvasObj.setAttribute('width', this.width.toString());
        }
        if (sf.base.isNullOrUndefined(this.height)) {
            this.canvasObj.setAttribute('height', height ? height.toString() : '450');
        }
        else {
            this.canvasObj.setAttribute('height', this.height.toString());
        }
    };
    // To set the values to the attributes
    CanvasRenderer.prototype.setAttributes = function (options) {
        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
        var dashArray = this.getOptionValue(options, 'stroke-dasharray');
        if (!sf.base.isNullOrUndefined(dashArray)) {
            var dashArrayString = dashArray.split(',');
            this.ctx.setLineDash([parseInt(dashArrayString[0], 10), parseInt(dashArrayString[1], 10)]);
        }
        this.ctx.strokeStyle = this.getOptionValue(options, 'stroke');
    };
    /**
     * To draw a line
     *
     * @param {LineAttributes} options - required options to draw a line on the canvas
     * @returns {void} To draw a line
     */
    CanvasRenderer.prototype.drawLine = function (options) {
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
        this.ctx.strokeStyle = options.stroke;
        this.ctx.moveTo(options.x1, options.y1);
        this.ctx.lineTo(options.x2, options.y2);
        this.ctx.stroke();
        this.ctx.restore();
    };
    /**
     * To draw a rectangle
     *
     * @param {RectAttributes} options - required options to draw a rectangle on the canvas.
     * @param {Int32Array} canvasTranslate TO get a translate value of canvas.
     * @returns {void} To draw rectangle.
     */
    CanvasRenderer.prototype.drawRectangle = function (options, canvasTranslate) {
        var canvasCtx = this.ctx;
        var cornerRadius = options.rx;
        this.ctx.save();
        this.ctx.beginPath();
        if (canvasTranslate) {
            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
        }
        this.ctx.globalAlpha = this.getOptionValue(options, 'opacity');
        this.setAttributes(options);
        this.ctx.rect(options.x, options.y, options.width, options.height);
        if (cornerRadius !== null && cornerRadius >= 0) {
            this.drawCornerRadius(options);
        }
        else {
            if (options.fill === 'none') {
                options.fill = 'transparent';
            }
            this.ctx.fillStyle = options.fill;
            this.ctx.fillRect(options.x, options.y, options.width, options.height);
            this.ctx.stroke();
        }
        this.ctx.restore();
        this.ctx = canvasCtx;
        return (this.canvasObj);
    };
    // To draw the corner of a rectangle
    CanvasRenderer.prototype.drawCornerRadius = function (options) {
        var cornerRadius = options.rx;
        var x = options.x;
        var y = options.y;
        var width = options.width;
        var height = options.height;
        if (options.fill === 'none') {
            options.fill = 'transparent';
        }
        this.ctx.fillStyle = options.fill;
        if (width < 2 * cornerRadius) {
            cornerRadius = width / 2;
        }
        if (height < 2 * cornerRadius) {
            cornerRadius = height / 2;
        }
        this.ctx.beginPath();
        this.ctx.moveTo(x + width - cornerRadius, y);
        this.ctx.arcTo(x + width, y, x + width, y + height, cornerRadius);
        this.ctx.arcTo(x + width, y + height, x, y + height, cornerRadius);
        this.ctx.arcTo(x, y + height, x, y, cornerRadius);
        this.ctx.arcTo(x, y, x + width, y, cornerRadius);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
    };
    /**
     * To draw a path on the canvas
     *
     * @param {PathAttributes} options - options needed to draw path.
     * @param {Int32Array} canvasTranslate - Array of numbers to translate the canvas.
     * @returns {Element} To draw a path.
     */
    CanvasRenderer.prototype.drawPath = function (options, canvasTranslate) {
        var path = options.d;
        var dataSplit = path.split(' ');
        var borderWidth = this.getOptionValue(options, 'stroke-width');
        var canvasCtx = this.ctx;
        var flag = true;
        this.ctx.save();
        this.ctx.beginPath();
        if (canvasTranslate) {
            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
        }
        this.ctx.globalAlpha = options.opacity ? options.opacity : this.getOptionValue(options, 'fill-opacity');
        this.setAttributes(options);
        for (var i = 0; i < dataSplit.length; i = i + 3) {
            var x1 = parseFloat(dataSplit[i + 1]);
            var y1 = parseFloat(dataSplit[i + 2]);
            switch (dataSplit[i]) {
                case 'M':
                    if (!options.innerR && !options.cx) {
                        this.ctx.moveTo(x1, y1);
                    }
                    break;
                case 'L':
                    if (!options.innerR) {
                        this.ctx.lineTo(x1, y1);
                    }
                    break;
                case 'Q':
                    var q1 = parseFloat(dataSplit[i + 3]);
                    var q2 = parseFloat(dataSplit[i + 4]);
                    this.ctx.quadraticCurveTo(x1, y1, q1, q2);
                    i = i + 2;
                    break;
                case 'C':
                    var c1 = parseFloat(dataSplit[i + 3]);
                    var c2 = parseFloat(dataSplit[i + 4]);
                    var c3 = parseFloat(dataSplit[i + 5]);
                    var c4 = parseFloat(dataSplit[i + 6]);
                    this.ctx.bezierCurveTo(x1, y1, c1, c2, c3, c4);
                    i = i + 4;
                    break;
                case 'A':
                    if (!options.innerR) {
                        if (options.cx) {
                            this.ctx.arc(options.cx, options.cy, options.radius, 0, 2 * Math.PI, options.counterClockWise);
                        }
                        else {
                            this.ctx.moveTo(options.x, options.y);
                            this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
                            this.ctx.lineTo(options.x, options.y);
                        }
                    }
                    else if (flag) {
                        this.ctx.arc(options.x, options.y, options.radius, options.start, options.end, options.counterClockWise);
                        this.ctx.arc(options.x, options.y, options.innerR, options.end, options.start, !options.counterClockWise);
                        flag = false;
                    }
                    i = i + 5;
                    break;
                case 'z':
                case 'Z':
                    this.ctx.closePath();
                    //since for loop is incremented by 3, to get next value after 'z' i is decremented for 2.
                    i = i - 2;
                    break;
            }
        }
        if (options.fill !== 'none' && options.fill !== undefined) {
            this.ctx.fillStyle = options.fill;
            this.ctx.fill();
        }
        if (borderWidth > 0) {
            this.ctx.stroke();
        }
        this.ctx.restore();
        this.ctx = canvasCtx;
        return this.canvasObj;
    };
    /**
     * To draw a text
     *
     * @param {TextAttributes} options - options required to draw text
     * @param {string} label - Specifies the text which has to be drawn on the canvas
     * @param {number} transX - Specifies the text of translate X
     * @param {number} transY - Specifies the text of translate Y
     * @param {number} dy - Specifies the text of translate dy
     * @param {boolean} isTSpan - Specifies the boolean value of span value
     * @returns {void}
     */
    CanvasRenderer.prototype.createText = function (options, label, transX, transY, dy, isTSpan) {
        var fontWeight = this.getOptionValue(options, 'font-weight');
        if (!sf.base.isNullOrUndefined(fontWeight) && fontWeight.toLowerCase() === 'regular') {
            fontWeight = 'normal';
        }
        var fontSize = this.getOptionValue(options, 'font-size');
        var fontFamily = this.getOptionValue(options, 'font-family');
        var fontStyle = this.getOptionValue(options, 'font-style').toLowerCase();
        var font = (fontStyle + ' ' + fontWeight + ' ' + fontSize + ' ' + fontFamily);
        var anchor = this.getOptionValue(options, 'text-anchor');
        var opacity = options.opacity !== undefined ? options.opacity : 1;
        if (anchor === 'middle') {
            anchor = 'center';
        }
        this.ctx.save();
        this.ctx.fillStyle = options.fill;
        this.ctx.font = font;
        this.ctx.textAlign = anchor;
        this.ctx.globalAlpha = opacity;
        if (options.baseline) {
            this.ctx.textBaseline = options.baseline;
        }
        if (!isTSpan) {
            var txtlngth = 0;
            this.ctx.translate(options.x + (txtlngth / 2) + (transX ? transX : 0), options.y + (transY ? transY : 0));
            this.ctx.rotate(options.labelRotation * Math.PI / 180);
        }
        this.ctx.fillText(label, isTSpan ? options.x : 0, isTSpan ? dy : 0);
        this.ctx.restore();
        return this.canvasObj;
    };
    /**
     * To draw circle on the canvas
     *
     * @param {CircleAttributes} options - required options to draw the circle
     * @param {Int32Array} canvasTranslate Translate value of canvas
     * @returns {void}
     */
    CanvasRenderer.prototype.drawCircle = function (options, canvasTranslate) {
        var canvasCtx = this.ctx;
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.arc(options.cx, options.cy, options.r, 0, 2 * Math.PI);
        this.ctx.fillStyle = options.fill;
        this.ctx.globalAlpha = options.opacity;
        this.ctx.fill();
        if (canvasTranslate) {
            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
        }
        this.setAttributes(options);
        this.ctx.stroke();
        this.ctx.restore();
        this.ctx = canvasCtx;
        return this.canvasObj;
    };
    /**
     * To draw polyline
     *
     * @param {PolylineAttributes} options - options needed to draw polyline
     * @returns {void}
     */
    CanvasRenderer.prototype.drawPolyline = function (options) {
        this.ctx.save();
        this.ctx.beginPath();
        var points = options.points.split(' ');
        for (var i = 0; i < points.length - 1; i++) {
            var point = points[i].split(',');
            var x = parseFloat(point[0]);
            var y = parseFloat(point[1]);
            if (i === 0) {
                this.ctx.moveTo(x, y);
            }
            else {
                this.ctx.lineTo(x, y);
            }
        }
        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
        this.ctx.strokeStyle = options.stroke;
        this.ctx.stroke();
        this.ctx.restore();
    };
    /**
     * To draw an ellipse on the canvas
     *
     * @param {EllipseAttributes} options - options needed to draw ellipse
     * @param {Int32Array} canvasTranslate Translate value of canvas
     * @returns {void}
     */
    CanvasRenderer.prototype.drawEllipse = function (options, canvasTranslate) {
        var canvasCtx = this.ctx;
        var circumference = Math.max(options.rx, options.ry);
        var scaleX = options.rx / circumference;
        var scaleY = options.ry / circumference;
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.translate(options.cx, options.cy);
        if (canvasTranslate) {
            this.ctx.translate(canvasTranslate[0], canvasTranslate[1]);
        }
        this.ctx.save();
        this.ctx.scale(scaleX, scaleY);
        this.ctx.arc(0, 0, circumference, 0, 2 * Math.PI, false);
        this.ctx.fillStyle = options.fill;
        this.ctx.fill();
        this.ctx.restore();
        this.ctx.lineWidth = this.getOptionValue(options, 'stroke-width');
        this.ctx.strokeStyle = options.stroke;
        this.ctx.stroke();
        this.ctx.restore();
        this.ctx = canvasCtx;
    };
    /**
     * To draw an image
     *
     * @param {ImageAttributes} options - options required to draw an image on the canvas
     * @returns {void}
     */
    CanvasRenderer.prototype.drawImage = function (options) {
        this.ctx.save();
        var imageObj = new Image();
        if (!sf.base.isNullOrUndefined(options.href)) {
            imageObj.src = options.href;
            this.ctx.drawImage(imageObj, options.x, options.y, options.width, options.height);
        }
        this.ctx.restore();
    };
    /**
     * To create a linear gradient
     *
     * @param {string[]} colors - Specifies the colors required to create linear gradient
     * @returns {string} It returns color
     */
    CanvasRenderer.prototype.createLinearGradient = function (colors) {
        var myGradient;
        if (!sf.base.isNullOrUndefined(colors[0].colorStop)) {
            myGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvasObj.height);
        }
        var color = this.setGradientValues(colors, myGradient);
        return color;
    };
    /**
     * To create a radial gradient
     *
     * @param {string[]} colors - Specifies the colors required to create linear gradient
     * @returns {string} It returns gradient color
     */
    CanvasRenderer.prototype.createRadialGradient = function (colors) {
        var myGradient;
        if (!sf.base.isNullOrUndefined(colors[0].colorStop)) {
            myGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, this.canvasObj.height);
        }
        var colorName = this.setGradientValues(colors, myGradient);
        return colorName;
    };
    // To set the gradient values
    CanvasRenderer.prototype.setGradientValues = function (colors, myGradient) {
        var colorName;
        if (!sf.base.isNullOrUndefined(colors[0].colorStop)) {
            for (var i = 0; i <= colors.length - 1; i++) {
                var color = colors[i].color;
                var newColorStop = (colors[i].colorStop).slice(0, -1);
                var stopColor = parseInt(newColorStop, 10) / 100;
                myGradient.addColorStop(stopColor, color);
            }
            colorName = myGradient.toString();
        }
        else {
            colorName = colors[0].color.toString();
        }
        return colorName;
    };
    /**
     * To set the attributes to the element
     *
     * @param {SVGCanvasAttributes} options - Attributes to set for the element
     * @param {HTMLElement} element - The element to which the attributes need to be set
     * @returns {HTMLElement} It returns null value
     */
    CanvasRenderer.prototype.setElementAttributes = function (options, element) {
        var keys = Object.keys(options);
        var values = Object.keys(options).map(function (key) { return options[key]; });
        for (var i = 0; i < keys.length; i++) {
            element.setAttribute(keys[i], values[i]);
        }
        return null;
    };
    /**
     * To update the values of the canvas element attributes
     *
     * @param {SVGCanvasAttributes} options - Specifies the colors required to create gradient
     * @returns {void}
     */
    CanvasRenderer.prototype.updateCanvasAttributes = function (options) {
        this.setElementAttributes(options, this.canvasObj);
        var ctx = this.ctx;
        if (!sf.base.isNullOrUndefined(this.dataUrl)) {
            var img_1 = new Image;
            img_1.onload = function () {
                ctx.drawImage(img_1, 0, 0);
            };
            img_1.src = this.dataUrl;
        }
    };
    /**
     * This method clears the given rectangle region
     *
     * @param {Rect} rect The rect parameter as passed
     */
    CanvasRenderer.prototype.clearRect = function (rect) {
        this.ctx.restore();
        this.ctx.clearRect(rect.x, rect.y, rect.width, rect.height);
    };
    /**
     * For canvas rendering in chart
     * Dummy method for using canvas/svg render in the same variable name in chart control
     */
    CanvasRenderer.prototype.createGroup = function () {
        return null;
    };
    /**
     * To render a clip path
     *
     * Dummy method for using canvas/svg render in the same variable name in chart control
     */
    CanvasRenderer.prototype.drawClipPath = function () {
        return null;
    };
    /**
     * Clip method to perform clip in canvas mode
     *
     * @param {BaseAttibutes} options The canvas clip of options
     */
    CanvasRenderer.prototype.canvasClip = function (options) {
        this.ctx.save();
        this.ctx.fillStyle = 'transparent';
        this.ctx.rect(options.x, options.y, options.width, options.height);
        this.ctx.fill();
        this.ctx.clip();
    };
    /**
     * Tp restore the canvas
     */
    CanvasRenderer.prototype.canvasRestore = function () {
        this.ctx.restore();
    };
    /**
     * To draw a polygon
     * Dummy method for using canvas/svg render in the same variable name in chart control
     */
    CanvasRenderer.prototype.drawPolygon = function () {
        return null;
    };
    /**
     * To create defs element in SVG
     * Dummy method for using canvas/svg render in the same variable name in chart control
     *
     * @returns {Element} It returns null
     */
    CanvasRenderer.prototype.createDefs = function () {
        return null;
    };
    /**
     * To create clip path in SVG
     * Dummy method for using canvas/svg render in the same variable name in chart control
     */
    CanvasRenderer.prototype.createClipPath = function () {
        return null;
    };
    /**
     * To create a Html5 SVG element
     * Dummy method for using canvas/svg render in the same variable name in chart control
     *
     * @returns {Element} It returns null
     */
    CanvasRenderer.prototype.createSvg = function () {
        return null;
    };
    return CanvasRenderer;
}());

/**
 * Base modules
 */

/** @private */
function getTooltipThemeColor(theme) {
    var style;
    switch (theme) {
        case 'Highcontrast':
        case 'HighContrast':
            style = {
                tooltipFill: '#ffffff',
                tooltipBoldLabel: '#000000',
                tooltipLightLabel: '#000000',
                tooltipHeaderLine: '#969696'
            };
            break;
        case 'MaterialDark':
        case 'FabricDark':
        case 'BootstrapDark':
            style = {
                tooltipFill: '#F4F4F4',
                tooltipBoldLabel: '#282727',
                tooltipLightLabel: '#333232',
                tooltipHeaderLine: '#9A9A9A'
            };
            break;
        case 'Bootstrap4':
            style = {
                tooltipFill: 'rgba(0, 0, 0, 0.9)',
                tooltipBoldLabel: 'rgba(255, 255, 255)',
                tooltipLightLabel: 'rgba(255, 255, 255, 0.9)',
                tooltipHeaderLine: 'rgba(255, 255, 255, 0.2)'
            };
            break;
        case 'Tailwind':
            style = {
                tooltipFill: '#111827',
                tooltipBoldLabel: '#D1D5DB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#6B7280',
            };
            break;
        case 'TailwindDark':
            style = {
                tooltipFill: '#F9FAFB',
                tooltipBoldLabel: '#6B7280',
                tooltipLightLabel: '#1F2937',
                tooltipHeaderLine: '#9CA3AF',
            };
            break;
        case 'Bootstrap5':
            style = {
                tooltipFill: '#212529',
                tooltipBoldLabel: '#F9FAFB',
                tooltipLightLabel: '#F9FAFB',
                tooltipHeaderLine: '#9CA3AF',
            };
            break;
        case 'Bootstrap5Dark':
            style = {
                tooltipFill: '#E9ECEF',
                tooltipBoldLabel: '#212529',
                tooltipLightLabel: '#212529',
                tooltipHeaderLine: '#ADB5BD',
            };
            break;
        default:
            style = {
                tooltipFill: 'rgba(0, 8, 22, 0.75)',
                tooltipBoldLabel: '#ffffff',
                tooltipLightLabel: '#dbdbdb',
                tooltipHeaderLine: '#ffffff'
            };
            break;
    }
    return style;
}

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * Function to measure the height and width of the text.
 *
 * @private
 * @param {string} text To get a text
 * @param {FontModel} font To get a font of the text
 * @returns {Size} measureText
 */
function measureText(text, font) {
    var breakText = text || ''; // For avoid NuLL value
    var htmlObject = document.getElementById('chartmeasuretext');
    if (htmlObject === null) {
        htmlObject = sf.base.createElement('text', { id: 'chartmeasuretext' });
        document.body.appendChild(htmlObject);
    }
    if (typeof (text) === 'string' && (text.indexOf('<') > -1 || text.indexOf('>') > -1)) {
        var textArray = text.split(' ');
        for (var i = 0; i < textArray.length; i++) {
            if (textArray[i].indexOf('<br/>') === -1) {
                textArray[i] = textArray[i].replace(/[<>]/g, '&');
            }
        }
        text = textArray.join(' ');
    }
    htmlObject.innerHTML = (breakText.indexOf('<br>') > -1 || breakText.indexOf('<br/>') > -1) ? breakText : text;
    htmlObject.style.position = 'fixed';
    htmlObject.style.fontSize = font.size;
    htmlObject.style.fontWeight = font.fontWeight;
    htmlObject.style.fontStyle = font.fontStyle;
    htmlObject.style.fontFamily = font.fontFamily;
    htmlObject.style.visibility = 'hidden';
    htmlObject.style.top = '-100';
    htmlObject.style.left = '0';
    htmlObject.style.whiteSpace = 'nowrap';
    // For bootstrap line height issue
    htmlObject.style.lineHeight = 'normal';
    return new Size(htmlObject.clientWidth, htmlObject.clientHeight);
}
/** @private */
function findDirection(rX, rY, rect, arrowLocation, arrowPadding, top, bottom, left, tipX, tipY, tipRadius) {
    var direction = '';
    var startX = rect.x;
    var startY = rect.y;
    var width = rect.x + rect.width;
    var height = rect.y + rect.height;
    tipRadius = tipRadius ? tipRadius : 0;
    if (top) {
        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
            + startY + ' ' + (startX + rX) + ' ' + startY + ' ' +
            ' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + width + ' '
            + startY + ' ' + (width) + ' ' + (startY + rY));
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' '
            + (height) + ' ' + (width - rX) + ' ' + (height));
        if (arrowPadding !== 0) {
            direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (height));
            direction = direction.concat(' L' + ' ' + (tipX + tipRadius) + ' ' + (height + arrowPadding - tipRadius));
            direction += ' Q' + ' ' + (tipX) + ' ' + (height + arrowPadding) + ' ' + (tipX - tipRadius) +
                ' ' + (height + arrowPadding - tipRadius);
        }
        if ((arrowLocation.x - arrowPadding / 2) > startX) {
            direction = direction.concat(' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + height +
                ' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
                + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
        }
        else {
            if (arrowPadding === 0) {
                direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + height + ' Q ' + startX + ' '
                    + height + ' ' + (startX) + ' ' + (height - rY) + ' z');
            }
            else {
                direction = direction.concat(' L' + ' ' + (startX) + ' ' + (height + rY) + ' z');
            }
        }
    }
    else if (bottom) {
        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
            + (startY) + ' ' + (startX + rX) + ' ' + (startY) + ' L' + ' ' + (arrowLocation.x - arrowPadding / 2) + ' ' + (startY));
        direction = direction.concat(' L' + ' ' + (tipX - tipRadius) + ' ' + (arrowLocation.y + tipRadius));
        direction += ' Q' + ' ' + (tipX) + ' ' + (arrowLocation.y) + ' ' + (tipX + tipRadius) + ' ' + (arrowLocation.y + tipRadius);
        direction = direction.concat(' L' + ' ' + (arrowLocation.x + arrowPadding / 2) + ' ' + (startY) + ' L' + ' '
            + (width - rX) + ' ' + (startY) + ' Q ' + (width) + ' ' + (startY) + ' ' + (width) + ' ' + (startY + rY));
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + (width) + ' '
            + (height) + ' ' + (width - rX) + ' ' + (height) +
            ' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + (startX) + ' '
            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
    }
    else if (left) {
        direction = direction.concat('M' + ' ' + (startX) + ' ' + (startY + rY) + ' Q ' + startX + ' '
            + (startY) + ' ' + (startX + rX) + ' ' + (startY));
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (startY) + ' Q ' + (width) + ' '
            + (startY) + ' ' + (width) + ' ' + (startY + rY) + ' L' + ' ' + (width) + ' ' + (arrowLocation.y - arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (width + arrowPadding - tipRadius) + ' ' + (tipY - tipRadius));
        direction += ' Q ' + (width + arrowPadding) + ' ' + (tipY) + ' ' + (width + arrowPadding - tipRadius) + ' ' + (tipY + tipRadius);
        direction = direction.concat(' L' + ' ' + (width) + ' ' + (arrowLocation.y + arrowPadding / 2) +
            ' L' + ' ' + (width) + ' ' + (height - rY) + ' Q ' + width + ' ' + (height) + ' ' + (width - rX) + ' ' + (height));
        direction = direction.concat(' L' + ' ' + (startX + rX) + ' ' + (height) + ' Q ' + startX + ' '
            + (height) + ' ' + (startX) + ' ' + (height - rY) + ' z');
    }
    else {
        direction = direction.concat('M' + ' ' + (startX + rX) + ' ' + (startY) + ' Q ' + (startX) + ' '
            + (startY) + ' ' + (startX) + ' ' + (startY + rY) + ' L' + ' ' + (startX) + ' ' + (arrowLocation.y - arrowPadding / 2));
        direction = direction.concat(' L' + ' ' + (startX - arrowPadding + tipRadius) + ' ' + (tipY - tipRadius));
        direction += ' Q ' + (startX - arrowPadding) + ' ' + (tipY) + ' ' + (startX - arrowPadding + tipRadius) + ' ' + (tipY + tipRadius);
        direction = direction.concat(' L' + ' ' + (startX) + ' ' + (arrowLocation.y + arrowPadding / 2) +
            ' L' + ' ' + (startX) + ' ' + (height - rY) + ' Q ' + startX + ' '
            + (height) + ' ' + (startX + rX) + ' ' + (height));
        direction = direction.concat(' L' + ' ' + (width - rX) + ' ' + (height) + ' Q ' + width + ' '
            + (height) + ' ' + (width) + ' ' + (height - rY) +
            ' L' + ' ' + (width) + ' ' + (startY + rY) + ' Q ' + width + ' '
            + (startY) + ' ' + (width - rX) + ' ' + (startY) + ' z');
    }
    return direction;
}
/** @private */
var Size = /** @class */ (function () {
    function Size(width, height) {
        this.width = width;
        this.height = height;
    }
    return Size;
}());
/** @private */
var Rect = /** @class */ (function () {
    function Rect(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    return Rect;
}());
var Side = /** @class */ (function () {
    function Side(bottom, right) {
        this.isRight = right;
        this.isBottom = bottom;
    }
    return Side;
}());
/** @private */
var CustomizeOption = /** @class */ (function () {
    function CustomizeOption(id) {
        this.id = id;
    }
    return CustomizeOption;
}());
/** @private */
var TextOption = /** @class */ (function (_super) {
    __extends$1(TextOption, _super);
    function TextOption(id, x, y, anchor, text, transform, baseLine, labelRotation) {
        if (transform === void 0) { transform = ''; }
        var _this = _super.call(this, id) || this;
        _this.transform = '';
        _this.baseLine = 'auto';
        _this.labelRotation = 0;
        _this.x = x;
        _this.y = y;
        _this.anchor = anchor;
        _this.text = text;
        _this.transform = transform;
        _this.baseLine = baseLine;
        _this.labelRotation = labelRotation;
        return _this;
    }
    return TextOption;
}(CustomizeOption));
/** @private */
function getElement(id) {
    return document.getElementById(id);
}
/** @private */
function removeElement(id) {
    var element = getElement(id);
    if (element) {
        sf.base.remove(element);
    }
}
/** @private */
function drawSymbol(location, shape, size, url, options, label) {
    var renderer = new SvgRenderer('');
    var temp = calculateShapes(location, size, shape, options, url);
    var htmlObject = renderer['draw' + temp.functionName](temp.renderOption);
    htmlObject.setAttribute('aria-label', label);
    return htmlObject;
}
/** @private */
function calculateShapes(location, size, shape, options, url) {
    var path;
    var functionName = 'Path';
    var width = size.width;
    var height = size.height;
    var locX = location.x;
    var locY = location.y;
    var x = location.x + (-width / 2);
    var y = location.y + (-height / 2);
    switch (shape) {
        case 'Circle':
        case 'Bubble':
            functionName = 'Ellipse';
            sf.base.merge(options, { 'rx': width / 2, 'ry': height / 2, 'cx': locX, 'cy': locY });
            break;
        case 'Cross':
            path = 'M' + ' ' + x + ' ' + locY + ' ' + 'L' + ' ' + (locX + (width / 2)) + ' ' + locY + ' ' +
                'M' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' + 'L' + ' ' + locX + ' ' +
                (locY + (-height / 2));
            sf.base.merge(options, { 'd': path });
            break;
        case 'HorizontalLine':
            path = 'M' + ' ' + x + ' ' + locY + ' ' + 'L' + ' ' + (locX + (width / 2)) + ' ' + locY;
            sf.base.merge(options, { 'd': path });
            break;
        case 'VerticalLine':
            path = 'M' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' + 'L' + ' ' + locX + ' ' + (locY + (-height / 2));
            sf.base.merge(options, { 'd': path });
            break;
        case 'Diamond':
            path = 'M' + ' ' + x + ' ' + locY + ' ' +
                'L' + ' ' + locX + ' ' + (locY + (-height / 2)) + ' ' +
                'L' + ' ' + (locX + (width / 2)) + ' ' + locY + ' ' +
                'L' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + locY + ' z';
            sf.base.merge(options, { 'd': path });
            break;
        case 'Rectangle':
            path = 'M' + ' ' + x + ' ' + (locY + (-height / 2)) + ' ' +
                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (-height / 2)) + ' ' +
                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + (locY + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + (locY + (-height / 2)) + ' z';
            sf.base.merge(options, { 'd': path });
            break;
        case 'Triangle':
            path = 'M' + ' ' + x + ' ' + (locY + (height / 2)) + ' ' +
                'L' + ' ' + locX + ' ' + (locY + (-height / 2)) + ' ' +
                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY + (height / 2)) + ' ' +
                'L' + ' ' + x + ' ' + (locY + (height / 2)) + ' z';
            sf.base.merge(options, { 'd': path });
            break;
        case 'InvertedTriangle':
            path = 'M' + ' ' + (locX + (width / 2)) + ' ' + (locY - (height / 2)) + ' ' +
                'L' + ' ' + locX + ' ' + (locY + (height / 2)) + ' ' +
                'L' + ' ' + (locX - (width / 2)) + ' ' + (locY - (height / 2)) + ' ' +
                'L' + ' ' + (locX + (width / 2)) + ' ' + (locY - (height / 2)) + ' z';
            sf.base.merge(options, { 'd': path });
            break;
        case 'Pentagon':
            var eq = 72;
            var xValue = void 0;
            var yValue = void 0;
            for (var i = 0; i <= 5; i++) {
                xValue = (width / 2) * Math.cos((Math.PI / 180) * (i * eq));
                yValue = (height / 2) * Math.sin((Math.PI / 180) * (i * eq));
                if (i === 0) {
                    path = 'M' + ' ' + (locX + xValue) + ' ' + (locY + yValue) + ' ';
                }
                else {
                    path = path.concat('L' + ' ' + (locX + xValue) + ' ' + (locY + yValue) + ' ');
                }
            }
            path = path.concat('Z');
            sf.base.merge(options, { 'd': path });
            break;
        case 'Image':
            functionName = 'Image';
            sf.base.merge(options, { 'href': url, 'height': height, 'width': width, x: x, y: y });
            break;
    }
    return { renderOption: options, functionName: functionName };
}
/** @private */
var PathOption = /** @class */ (function (_super) {
    __extends$1(PathOption, _super);
    function PathOption(id, fill, width, color, opacity, dashArray, d) {
        var _this = _super.call(this, id) || this;
        _this.opacity = opacity;
        _this.fill = fill;
        _this.stroke = color;
        _this['stroke-width'] = width;
        _this['stroke-dasharray'] = dashArray;
        _this.d = d;
        return _this;
    }
    return PathOption;
}(CustomizeOption));
/** @private */
function textElement(options, font, color, parent) {
    var renderOptions = {};
    var renderer = new SvgRenderer('');
    renderOptions = {
        'id': options.id,
        'x': options.x,
        'y': options.y,
        'fill': color,
        'font-size': font.size,
        'font-style': font.fontStyle,
        'font-family': font.fontFamily,
        'font-weight': font.fontWeight,
        'text-anchor': options.anchor,
        'transform': options.transform,
        'opacity': font.opacity,
        'dominant-baseline': options.baseLine
    };
    var text = typeof options.text === 'string' ? options.text : options.text[0];
    var htmlObject = renderer.createText(renderOptions, text);
    htmlObject.style.fontFamily = font.fontFamily;
    htmlObject.style.fontStyle = font.fontStyle;
    htmlObject.style.fontSize = font.size;
    htmlObject.style.fontWeight = font.fontWeight;
    htmlObject.style.color = font.color;
    parent.appendChild(htmlObject);
    return htmlObject;
}
var TooltipLocation = /** @class */ (function () {
    function TooltipLocation(x, y) {
        this.x = x;
        this.y = y;
    }
    return TooltipLocation;
}());

var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable jsdoc/require-param */
/* eslint-disable jsdoc/require-returns */
/* eslint-disable valid-jsdoc */
/**
 * Configures the fonts in charts.
 *
 * @private
 */
var TextStyle = /** @class */ (function (_super) {
    __extends(TextStyle, _super);
    function TextStyle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sf.base.Property(null)
    ], TextStyle.prototype, "size", void 0);
    __decorate([
        sf.base.Property('')
    ], TextStyle.prototype, "color", void 0);
    __decorate([
        sf.base.Property('Segoe UI')
    ], TextStyle.prototype, "fontFamily", void 0);
    __decorate([
        sf.base.Property('Normal')
    ], TextStyle.prototype, "fontWeight", void 0);
    __decorate([
        sf.base.Property('Normal')
    ], TextStyle.prototype, "fontStyle", void 0);
    __decorate([
        sf.base.Property(1)
    ], TextStyle.prototype, "opacity", void 0);
    return TextStyle;
}(sf.base.ChildProperty));
/**
 * Configures the borders in the chart.
 *
 * @private
 */
var TooltipBorder = /** @class */ (function (_super) {
    __extends(TooltipBorder, _super);
    function TooltipBorder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sf.base.Property('')
    ], TooltipBorder.prototype, "color", void 0);
    __decorate([
        sf.base.Property(1)
    ], TooltipBorder.prototype, "width", void 0);
    return TooltipBorder;
}(sf.base.ChildProperty));
/**
 * Configures the borders in the chart.
 *
 * @private
 */
var AreaBounds = /** @class */ (function (_super) {
    __extends(AreaBounds, _super);
    function AreaBounds() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sf.base.Property(0)
    ], AreaBounds.prototype, "x", void 0);
    __decorate([
        sf.base.Property(0)
    ], AreaBounds.prototype, "y", void 0);
    __decorate([
        sf.base.Property(0)
    ], AreaBounds.prototype, "width", void 0);
    __decorate([
        sf.base.Property(0)
    ], AreaBounds.prototype, "height", void 0);
    return AreaBounds;
}(sf.base.ChildProperty));
/**
 * Configures the borders in the chart.
 *
 * @private
 */
var ToolLocation = /** @class */ (function (_super) {
    __extends(ToolLocation, _super);
    function ToolLocation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        sf.base.Property(0)
    ], ToolLocation.prototype, "x", void 0);
    __decorate([
        sf.base.Property(0)
    ], ToolLocation.prototype, "y", void 0);
    return ToolLocation;
}(sf.base.ChildProperty));
/**
 * Represents the Tooltip control.
 * ```html
 * <div id="tooltip"/>
 * <script>
 *   var tooltipObj = new Tooltip({ isResponsive : true });
 *   tooltipObj.appendTo("#tooltip");
 * </script>
 * ```
 *
 * @private
 */
var Tooltip = /** @class */ (function (_super) {
    __extends(Tooltip, _super);
    /**
     * Constructor for creating the widget
     *
     * @hidden
     */
    function Tooltip(options, element) {
        return _super.call(this, options, element) || this;
    }
    /**
     * Initialize the event handler.
     *
     * @private
     */
    Tooltip.prototype.preRender = function () {
        this.allowServerDataBinding = false;
        this.initPrivateVariable();
        if (!this.isCanvas) {
            this.removeSVG();
        }
        this.createTooltipElement();
    };
    Tooltip.prototype.initPrivateVariable = function () {
        this.renderer = new SvgRenderer(this.element.id);
        this.themeStyle = getTooltipThemeColor(this.theme);
        this.formattedText = [];
        this.padding = 5;
        this.isFirst = true;
        this.markerPoint = [];
    };
    Tooltip.prototype.removeSVG = function () {
        var svgObject = document.getElementById(this.element.id + '_svg');
        var templateObject = document.getElementById(this.element.id + 'parent_template');
        if (this.blazorTemplate) {
            sf.base.resetBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate');
        }
        if (svgObject && svgObject.parentNode) {
            sf.base.remove(svgObject);
        }
        if (templateObject && templateObject.parentNode) {
            sf.base.remove(templateObject);
        }
    };
    /**
     * To Initialize the control rendering.
     */
    Tooltip.prototype.render = function () {
        this.fadeOuted = false;
        if (!this.template) {
            this.renderText(this.isFirst);
            var argsData = {
                cancel: false, name: 'tooltipRender', tooltip: this
            };
            this.trigger('tooltipRender', argsData);
            var markerSide = this.renderTooltipElement(this.areaBounds, this.location);
            this.drawMarker(markerSide.isBottom, markerSide.isRight, this.markerSize);
        }
        else {
            this.updateTemplateFn();
            this.createTemplate(this.areaBounds, this.location);
        }
        this.trigger('loaded', { tooltip: this });
        var element = document.getElementById('chartmeasuretext');
        if (element) {
            sf.base.remove(element);
        }
        this.allowServerDataBinding = true;
    };
    Tooltip.prototype.createTooltipElement = function () {
        this.textElements = [];
        if (!this.template || this.shared) {
            // SVG element for tooltip
            var svgObject = this.renderer.createSvg({ id: this.element.id + '_svg' });
            this.element.appendChild(svgObject);
            // Group to hold text and path.
            var groupElement = document.getElementById(this.element.id + '_group');
            if (!groupElement) {
                groupElement = this.renderer.createGroup({ id: this.element.id + '_group' });
                groupElement.setAttribute('transform', 'translate(0,0)');
            }
            svgObject.appendChild(groupElement);
            var pathElement = this.renderer.drawPath({
                'id': this.element.id + '_path', 'stroke-width': this.border.width,
                'fill': this.fill || this.themeStyle.tooltipFill, 'opacity': ((this.theme === 'TailwindDark' || this.theme === 'Tailwind' || this.theme === 'Bootstrap5' || this.theme === 'Bootstrap5Dark') && this.opacity === 0.75) ?
                    1 : this.opacity,
                'stroke': this.border.color
            });
            groupElement.appendChild(pathElement);
        }
    };
    Tooltip.prototype.drawMarker = function (isBottom, isRight, size) {
        if (this.shapes.length <= 0) {
            return null;
        }
        var shapeOption;
        var count = 0;
        var markerGroup = this.renderer.createGroup({ id: this.element.id + '_trackball_group' });
        var groupElement = getElement(this.element.id + '_group');
        var x = (this.marginX * 2) + (size / 2) + (isRight ? this.arrowPadding : 0);
        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {
            var shape = _a[_i];
            if (shape !== 'None') {
                shapeOption = new PathOption(this.element.id + '_Trackball_' + count, this.palette[count], 1, '#cccccc', 1, null);
                if (this.markerPoint[count]) {
                    markerGroup.appendChild(drawSymbol(new TooltipLocation(x, this.markerPoint[count] - this.padding + (isBottom ? this.arrowPadding : 0)), shape, new Size(size, size), '', shapeOption, null));
                }
                count++;
            }
        }
        groupElement.appendChild(markerGroup);
    };
    Tooltip.prototype.renderTooltipElement = function (areaBounds, location) {
        var tooltipDiv = getElement(this.element.id);
        var arrowLocation = new TooltipLocation(0, 0);
        var tipLocation = new TooltipLocation(0, 0);
        var svgObject = getElement(this.element.id + '_svg');
        var groupElement = getElement(this.element.id + '_group');
        var pathElement = getElement(this.element.id + '_path');
        var rect;
        var isTop = false;
        var isLeft = false;
        var isBottom = false;
        var x = 0;
        var y = 0;
        this.tipRadius = 1;
        if (this.header !== '') {
            this.elementSize.height += this.marginY;
        }
        if (this.content.length > 1) {
            rect = this.sharedTooltipLocation(areaBounds, this.location.x, this.location.y);
            isTop = true;
        }
        else {
            rect = this.tooltipLocation(areaBounds, location, arrowLocation, tipLocation);
            if (!this.inverted) {
                isTop = (rect.y < (location.y + this.clipBounds.y));
                isBottom = !isTop;
                y = (isTop ? 0 : this.arrowPadding);
            }
            else {
                isLeft = (rect.x < (location.x + this.clipBounds.x));
                x = (isLeft ? 0 : this.arrowPadding);
            }
        }
        if (this.header !== '') {
            var headerSize = measureText(this.isWrap ? this.wrappedText : this.header, this.textStyle).height +
                (this.marginY * 2) + (isBottom ? this.arrowPadding : 0) + (this.isWrap ? 5 : 0); //header padding;
            var xLength = (this.marginX * 3) + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0);
            var direction = 'M ' + xLength + ' ' + headerSize +
                'L ' + (rect.width + (!isLeft && !isTop && !isBottom ? this.arrowPadding : 0) - (this.marginX * 2)) +
                ' ' + headerSize;
            var pathElement_1 = this.renderer.drawPath({
                'id': this.element.id + '_header_path', 'stroke-width': 1,
                'fill': null, 'opacity': 0.8, 'stroke': this.themeStyle.tooltipHeaderLine, 'd': direction
            });
            groupElement.appendChild(pathElement_1);
        }
        var start = this.border.width / 2;
        var pointRect = new Rect(start + x, start + y, rect.width - start, rect.height - start);
        groupElement.setAttribute('opacity', '1');
        if (this.enableAnimation && !this.shared && !this.isFirst) {
            this.animateTooltipDiv(tooltipDiv, rect);
        }
        else {
            this.updateDiv(tooltipDiv, rect.x, rect.y);
        }
        // eslint-disable-next-line no-extra-boolean-cast
        svgObject.setAttribute('height', (rect.height + this.border.width + (!((!this.inverted)) ? 0 : this.arrowPadding) + 5).toString());
        svgObject.setAttribute('width', (rect.width + this.border.width + (((!this.inverted)) ? 0 : this.arrowPadding) + 5).toString());
        svgObject.setAttribute('opacity', '1');
        if (!sf.base.isNullOrUndefined(this.tooltipPlacement)) {
            isTop = this.tooltipPlacement.indexOf('Top') > -1;
            isBottom = this.tooltipPlacement.indexOf('Bottom') > -1;
            isLeft = this.tooltipPlacement.indexOf('Left') > -1;
        }
        pathElement.setAttribute('d', findDirection(this.rx, this.ry, pointRect, arrowLocation, this.arrowPadding, isTop, isBottom, isLeft, tipLocation.x, tipLocation.y, this.tipRadius));
        if (this.enableShadow && this.theme !== 'Bootstrap4') {
            // To fix next chart initial tooltip opacity issue in tab control
            var shadowId = this.element.id + '_shadow';
            if (this.theme === 'Tailwind' || this.theme === 'TailwindDark'
                || this.theme === 'Bootstrap5' || this.theme === 'Bootstrap5Dark') {
                pathElement.setAttribute('box-shadow', '0px 1px 2px rgba(0, 0, 0, 0.06), 0px 1px 3px rgba(0, 0, 0, 0.1)');
            }
            else {
                pathElement.setAttribute('filter', sf.base.Browser.isIE ? '' : 'url(#' + shadowId + ')');
            }
            var shadow = '<filter id="' + shadowId + '" height="130%"><feGaussianBlur in="SourceAlpha" stdDeviation="3"/>';
            shadow += '<feOffset dx="3" dy="3" result="offsetblur"/><feComponentTransfer><feFuncA type="linear" slope="0.5"/>';
            shadow += '</feComponentTransfer><feMerge><feMergeNode/><feMergeNode in="SourceGraphic"/></feMerge></filter>';
            var defElement = this.renderer.createDefs();
            defElement.setAttribute('id', this.element.id + 'SVG_tooltip_definition');
            groupElement.appendChild(defElement);
            defElement.innerHTML = shadow;
        }
        pathElement.setAttribute('stroke', this.border.color);
        this.changeText(new TooltipLocation(x, y), isBottom, !isLeft && !isTop && !isBottom);
        return new Side(isBottom, !isLeft && !isTop && !isBottom);
    };
    Tooltip.prototype.changeText = function (point, isBottom, isRight) {
        var element = document.getElementById(this.element.id + '_text');
        if (isBottom) {
            element.setAttribute('transform', 'translate(0,' + this.arrowPadding + ')');
        }
        if (isRight) {
            element.setAttribute('transform', 'translate(' + this.arrowPadding + ' 0)');
        }
    };
    Tooltip.prototype.findFormattedText = function () {
        this.formattedText = [];
        if (this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '') {
            this.formattedText = this.formattedText.concat(this.header);
        }
        this.formattedText = this.formattedText.concat(this.content);
    };
    // tslint:disable-next-line:max-func-body-length
    Tooltip.prototype.renderText = function (isRender) {
        var height = 0;
        var width = 0; // Padding for text;
        var subWidth = 0;
        var lines;
        var key = 'properties';
        var font = sf.base.extend({}, this.textStyle, null, true)[key];
        var groupElement = getElement(this.element.id + '_group');
        var tspanElement;
        var textCollection;
        var tspanStyle = '';
        var line;
        var tspanOption;
        this.findFormattedText();
        var isRtlEnabled = document.body.getAttribute('dir') === 'rtl';
        var anchor = isRtlEnabled ? 'end' : 'start';
        this.leftSpace = this.areaBounds.x + this.location.x;
        this.rightSpace = (this.areaBounds.x + this.areaBounds.width) - this.leftSpace;
        var headerContent = this.header.replace(/<b>/g, '').replace(/<\/b>/g, '').trim();
        var isBoldTag = this.header.indexOf('<b>') > -1 && this.header.indexOf('</b>') > -1;
        var headerWidth = measureText(this.formattedText[0], font).width + (2 * this.marginX) + this.arrowPadding;
        var isLeftSpace = (this.location.x - headerWidth) < this.location.x;
        var isRightSpace = (this.areaBounds.x + this.areaBounds.width) < (this.location.x + headerWidth);
        var header;
        var headerSpace = (headerContent !== '') ? this.marginY : 0;
        var isRow = true;
        var isColumn = true;
        this.markerPoint = [];
        var markerSize = (this.shapes.length > 0) ? 10 : 0;
        var markerPadding = (this.shapes.length > 0) ? 5 : 0;
        var spaceWidth = 4;
        var subStringLength;
        var fontSize = '13px';
        var fontWeight = 'Normal';
        var labelColor = this.themeStyle.tooltipLightLabel;
        var dy = (22 / parseFloat(fontSize)) * (parseFloat(font.size));
        if (!isRender || this.isCanvas) {
            removeElement(this.element.id + '_text');
            removeElement(this.element.id + '_header_path');
            removeElement(this.element.id + '_trackball_group');
            removeElement(this.element.id + 'SVG_tooltip_definition');
        }
        var options = new TextOption(this.element.id + '_text', this.marginX * 2, (this.marginY * 2 + this.padding * 2 + (this.marginY === 2 ? 3 : 0)), anchor, '');
        var parentElement = textElement(options, font, null, groupElement);
        var withoutHeader = this.formattedText.length === 1 && this.formattedText[0].indexOf(' : <b>') > -1;
        var isHeader = this.header !== '';
        var size = isHeader && isBoldTag ? 16 : 13;
        for (var k = 0, pointsLength = this.formattedText.length; k < pointsLength; k++) {
            textCollection = this.formattedText[k].replace(/<(b|strong)>/g, '<b>')
                .replace(/<\/(b|strong)>/g, '</b>')
                .split(/<br.*?>/g);
            if (k === 0 && !withoutHeader && this.isTextWrap &&
                (this.leftSpace < headerWidth || isLeftSpace) &&
                (this.rightSpace < headerWidth || isRightSpace)) {
                subStringLength = Math.round(this.leftSpace > this.rightSpace ? (this.leftSpace / size) : (this.rightSpace / size));
                header = headerContent !== '' ? headerContent : this.formattedText[k];
                textCollection = header.match(new RegExp('.{1,' + subStringLength + '}', 'g'));
                this.wrappedText = isBoldTag ? '<b>' + textCollection.join('<br>') + '</b>' : textCollection.join('<br>');
                this.isWrap = textCollection.length > 1;
            }
            if (textCollection[0] === '') {
                continue;
            }
            if ((k !== 0) || (headerContent === '')) {
                this.markerPoint.push((headerContent !== '' ? (this.marginY) : 0) + options.y + height);
            }
            for (var i = 0, len = textCollection.length; i < len; i++) { // string value of unicode for LTR is \u200E
                lines = textCollection[i].replace(/<b>/g, '<br><b>').replace(/<\/b>/g, '</b><br>').replace(/:/g, '<br>\u200E:<br>')
                    .split('<br>');
                subWidth = 0;
                isColumn = true;
                height += dy;
                for (var j = 0, len_1 = lines.length; j < len_1; j++) {
                    line = lines[j];
                    if (!/\S/.test(line) && line !== '') {
                        line = ' '; //to trim multiple white spaces to single white space
                    }
                    if ((!isColumn && line === ' ') || (line.replace(/<b>/g, '').replace(/<\/b>/g, '').trim() !== '')) {
                        subWidth += line !== ' ' ? spaceWidth : 0;
                        if (isColumn && !isRow) {
                            tspanOption = {
                                x: (this.marginX * 2) + (markerSize + markerPadding),
                                dy: dy + ((isColumn) ? headerSpace : 0), fill: ''
                            };
                            headerSpace = null;
                        }
                        else {
                            if (isRow && isColumn) {
                                tspanOption = {
                                    x: (headerContent === '') ? ((this.marginX * 2) + (markerSize + markerPadding))
                                        : (this.marginX * 2) + (this.isWrap ? (markerSize + markerPadding) : 0)
                                };
                            }
                            else {
                                tspanOption = {};
                            }
                        }
                        isColumn = false;
                        tspanElement = this.renderer.createTSpan(tspanOption, '');
                        parentElement.appendChild(tspanElement);
                        if (line.indexOf('<b>') > -1 || ((isBoldTag && j === 0 && k === 0) && (isHeader || this.isWrap))) {
                            fontWeight = 'bold';
                            labelColor = this.themeStyle.tooltipBoldLabel;
                            tspanStyle = 'font-weight:' + fontWeight;
                            font.fontWeight = fontWeight;
                            (tspanElement).setAttribute('fill', this.textStyle.color || labelColor);
                        }
                        else {
                            tspanStyle = fontWeight === 'bold' ? 'font-weight:' + fontWeight : '';
                            font.fontWeight = fontWeight;
                            (tspanElement).setAttribute('fill', this.textStyle.color || labelColor);
                        }
                        if (line.indexOf('</b>') > -1 || ((isBoldTag && j === len_1 - 1 && k === 0) && (isHeader || this.isWrap))) {
                            fontWeight = 'Normal';
                            labelColor = this.themeStyle.tooltipLightLabel;
                        }
                        // eslint-disable-next-line no-useless-escape
                        (tspanElement).textContent = line = this.getTooltipTextContent(line);
                        subWidth += measureText(line, font).width;
                        if (tspanStyle !== '') {
                            tspanElement.style.fontWeight = tspanStyle.split('font-weight:')[1];
                            tspanElement.style.color = tspanElement.getAttribute('fill');
                        }
                        // 'inherit' will apply css style from parent element.
                        tspanElement.style.fontFamily = 'inherit';
                        tspanElement.style.fontStyle = 'inherit';
                        tspanElement.style.fontSize = 'inherit';
                        isRow = false;
                    }
                }
                subWidth -= spaceWidth;
                width = Math.max(width, subWidth);
            }
        }
        this.elementSize = new Size(width + (width > 0 ? (2 * this.marginX) : 0), height);
        this.elementSize.width += (markerSize + markerPadding); // marker size + marker Spacing
        var element = (parentElement.childNodes[0]);
        if (headerContent !== '' && element && !this.isWrap) {
            font.fontWeight = 'bold';
            var width_1 = (this.elementSize.width + (2 * this.padding)) / 2 - measureText(headerContent, font).width / 2;
            element.setAttribute('x', width_1.toString());
        }
    };
    Tooltip.prototype.getTooltipTextContent = function (tooltipText) {
        var characterCollection = tooltipText.match(/<[a-zA-Z\/](.|\n)*?>/g);
        if (sf.base.isNullOrUndefined(characterCollection)) {
            return tooltipText;
        }
        var isRtlText = /[\u0590-\u07FF\u200F\u202B\u202E\uFB1D-\uFDFD\uFE70-\uFEFC]/.test(tooltipText);
        for (var i = 0; i < characterCollection.length; i++) {
            if (this.isValidHTMLElement(characterCollection[i].replace('<', '').replace('/', '').replace('>', '').trim())) {
                tooltipText = tooltipText.replace(characterCollection[i], isRtlText ? '\u200E' : '');
            }
        }
        return tooltipText;
    };
    Tooltip.prototype.isValidHTMLElement = function (element) {
        return document.createElement(element).toString() != "[object HTMLUnknownElement]";
    };
    Tooltip.prototype.createTemplate = function (areaBounds, location) {
        var argsData = { cancel: false, name: 'tooltipRender', tooltip: this };
        this.trigger('tooltipRender', argsData);
        var parent = document.getElementById(this.element.id);
        if (this.isCanvas) {
            this.removeSVG();
        }
        var firstElement = parent.firstElementChild;
        if (firstElement) {
            sf.base.remove(firstElement);
        }
        if (!argsData.cancel) {
            var elem = sf.base.createElement('div', { id: this.element.id + 'parent_template' });
            var templateElement = this.templateFn(this.data, this.controlInstance, elem.id, elem.id + '_blazorTemplate', '');
            while (templateElement && templateElement.length > 0) {
                if (sf.base.isBlazor() || templateElement.length === 1) {
                    elem.appendChild(templateElement[0]);
                    templateElement = null;
                }
                else {
                    elem.appendChild(templateElement[0]);
                }
            }
            parent.appendChild(elem);
            var element = this.isCanvas ? elem : this.element;
            var rect = element.getBoundingClientRect();
            this.padding = 0;
            this.elementSize = new Size(rect.width, rect.height);
            var tooltipRect = this.shared ? this.sharedTooltipLocation(areaBounds, this.location.x, this.location.y)
                : this.tooltipLocation(areaBounds, location, new TooltipLocation(0, 0), new TooltipLocation(0, 0));
            if (this.enableAnimation && !this.shared && !this.isFirst) {
                this.animateTooltipDiv(this.element, tooltipRect);
            }
            else {
                this.updateDiv(element, tooltipRect.x, tooltipRect.y);
            }
            if (this.blazorTemplate) {
                //Customer issue - F149037  Call back function to handle the blazor tooltip alignment issues
                var tooltipRendered = function () {
                    var rect1 = getElement(thisObject_1.element.id).getBoundingClientRect();
                    thisObject_1.elementSize = new Size(rect1.width, rect1.height);
                    var tooltipRect1 = thisObject_1.tooltipLocation(areaBounds, location, new TooltipLocation(0, 0), new TooltipLocation(0, 0));
                    thisObject_1.updateDiv(getElement(thisObject_1.element.id), tooltipRect1.x, tooltipRect1.y);
                };
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var thisObject_1 = this;
                tooltipRendered.bind(thisObject_1, areaBounds, location);
                sf.base.updateBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate', this.blazorTemplate.name, this.blazorTemplate.parent, undefined, tooltipRendered);
            }
        }
        else {
            sf.base.remove(getElement(this.element.id + '_tooltip'));
        }
    };
    Tooltip.prototype.sharedTooltipLocation = function (bounds, x, y) {
        var width = this.elementSize.width + (2 * this.marginX);
        var height = this.elementSize.height + (2 * this.marginY);
        var tooltipRect = new Rect(x + 2 * this.padding, y - height - this.padding, width, height);
        if (tooltipRect.y < bounds.y) {
            tooltipRect.y += (tooltipRect.height + 2 * this.padding);
        }
        if (tooltipRect.x + tooltipRect.width > bounds.x + bounds.width) {
            tooltipRect.x -= (tooltipRect.width + 4 * this.padding);
        }
        return tooltipRect;
    };
    Tooltip.prototype.getCurrentPosition = function (bounds, symbolLocation, arrowLocation, tipLocation) {
        var position = this.tooltipPlacement;
        var clipX = this.clipBounds.x;
        var clipY = this.clipBounds.y;
        var markerHeight = this.offset;
        var width = this.elementSize.width + (2 * this.marginX);
        var height = this.elementSize.height + (2 * this.marginY);
        var location = new TooltipLocation(symbolLocation.x, symbolLocation.y);
        if (position === 'Top' || position === 'Bottom') {
            location = new TooltipLocation(location.x + clipX - this.elementSize.width / 2 - this.padding, location.y + clipY - this.elementSize.height - (2 * this.padding) - this.arrowPadding - markerHeight);
            arrowLocation.x = tipLocation.x = width / 2;
            if (position === 'Bottom') {
                location.y = symbolLocation.y + clipY + markerHeight;
            }
            if (bounds.x + bounds.width < location.x + width) {
                location.x = (bounds.width > width) ? ((bounds.x + bounds.width) - width + 6) : bounds.x;
                arrowLocation.x = tipLocation.x = (bounds.width > width) ? (bounds.x + symbolLocation.x - location.x) : symbolLocation.x;
            }
            else if (bounds.x > location.x) {
                location.x = bounds.x;
                arrowLocation.x = tipLocation.x = symbolLocation.x;
            }
        }
        else {
            location = new TooltipLocation(location.x + clipX + markerHeight, location.y + clipY - this.elementSize.height / 2 - (this.padding));
            arrowLocation.y = tipLocation.y = height / 2;
            if (position === 'Left') {
                location.x = symbolLocation.x + clipX - markerHeight - (width + this.arrowPadding);
            }
            if (bounds.y + bounds.height < location.y + height) {
                location.y = (bounds.height > height) ? ((bounds.y + bounds.height) - height + 6) : bounds.y;
                arrowLocation.y = tipLocation.y = (bounds.height > height) ? (bounds.y + symbolLocation.y - location.y) : symbolLocation.y;
            }
            else if (bounds.y > location.y) {
                location.y = bounds.y;
                arrowLocation.y = tipLocation.y = symbolLocation.y;
            }
        }
        return new Rect(location.x, location.y, width, height);
    };
    // tslint:disable-next-line:max-func-body-length
    Tooltip.prototype.tooltipLocation = function (bounds, symbolLocation, arrowLocation, tipLocation) {
        if (!sf.base.isNullOrUndefined(this.tooltipPlacement)) {
            var tooltipRect = this.getCurrentPosition(bounds, symbolLocation, arrowLocation, tipLocation);
            return tooltipRect;
        }
        var location = new TooltipLocation(symbolLocation.x, symbolLocation.y);
        var width = this.elementSize.width + (2 * this.marginX);
        var height = this.elementSize.height + (2 * this.marginY);
        var markerHeight = this.offset;
        var clipX = this.clipBounds.x;
        var clipY = this.clipBounds.y;
        var boundsX = bounds.x;
        var boundsY = bounds.y;
        if (!this.inverted) {
            location = new TooltipLocation(location.x + clipX - this.elementSize.width / 2 - this.padding, location.y + clipY - this.elementSize.height - (2 * this.padding) - this.arrowPadding - markerHeight);
            arrowLocation.x = tipLocation.x = width / 2;
            if (location.y < boundsY || (this.isNegative)) {
                location.y = (symbolLocation.y < 0 ? 0 : symbolLocation.y) + clipY + markerHeight;
            }
            if (location.y + height + this.arrowPadding > boundsY + bounds.height) {
                location.y = Math.min(symbolLocation.y, boundsY + bounds.height) + clipY
                    - this.elementSize.height - (2 * this.padding) - this.arrowPadding - markerHeight;
            }
            tipLocation.x = width / 2;
            if (location.x < boundsX) {
                arrowLocation.x -= (boundsX - location.x);
                tipLocation.x -= (boundsX - location.x);
                location.x = boundsX;
            }
            if (location.x + width > boundsX + bounds.width) {
                arrowLocation.x += ((location.x + width) - (boundsX + bounds.width));
                tipLocation.x += ((location.x + width) - (boundsX + bounds.width));
                location.x -= ((location.x + width) - (boundsX + bounds.width));
            }
            if (arrowLocation.x + this.arrowPadding / 2 > width - this.rx) {
                arrowLocation.x = width - this.rx - this.arrowPadding / 2;
                tipLocation.x = width;
                this.tipRadius = 0;
            }
            if (arrowLocation.x - this.arrowPadding / 2 < this.rx) {
                arrowLocation.x = this.rx + this.arrowPadding / 2;
                tipLocation.x = 0;
                this.tipRadius = 0;
            }
        }
        else {
            location = new TooltipLocation(location.x + clipX + markerHeight, location.y + clipY - this.elementSize.height / 2 - (this.padding));
            arrowLocation.y = tipLocation.y = height / 2;
            if ((location.x + width + this.arrowPadding > boundsX + bounds.width) || (this.isNegative)) {
                location.x = (symbolLocation.x > bounds.width ? bounds.width : symbolLocation.x)
                    + clipX - markerHeight - (width + this.arrowPadding);
            }
            if (location.x < boundsX) {
                location.x = (symbolLocation.x < 0 ? 0 : symbolLocation.x) + clipX + markerHeight;
            }
            if (location.y <= boundsY) {
                arrowLocation.y -= (boundsY - location.y);
                tipLocation.y -= (boundsY - location.y);
                location.y = boundsY;
            }
            if (location.y + height >= boundsY + bounds.height) {
                arrowLocation.y += ((location.y + height) - (boundsY + bounds.height));
                tipLocation.y += ((location.y + height) - (boundsY + bounds.height));
                location.y -= ((location.y + height) - (boundsY + bounds.height));
            }
            if (arrowLocation.y + this.arrowPadding / 2 > height - this.ry) {
                arrowLocation.y = height - this.ry - this.arrowPadding / 2;
                tipLocation.y = height;
                this.tipRadius = 0;
            }
            if (arrowLocation.y - this.arrowPadding / 2 < this.ry) {
                arrowLocation.y = this.ry + this.arrowPadding / 2;
                tipLocation.y = 0;
                this.tipRadius = 0;
            }
        }
        return new Rect(location.x, location.y, width, height);
    };
    Tooltip.prototype.animateTooltipDiv = function (tooltipDiv, rect) {
        var _this = this;
        var x = parseFloat(tooltipDiv.style.left);
        var y = parseFloat(tooltipDiv.style.top);
        var currenDiff;
        new sf.base.Animation({}).animate(tooltipDiv, {
            duration: this.duration,
            progress: function (args) {
                currenDiff = (args.timeStamp / args.duration);
                tooltipDiv.style.animation = null;
                tooltipDiv.style.left = (x + currenDiff * (rect.x - x)) + 'px';
                tooltipDiv.style.top = (y + currenDiff * (rect.y - y)) + 'px';
            },
            end: function (model) {
                _this.updateDiv(tooltipDiv, rect.x, rect.y);
                _this.trigger('animationComplete', { tooltip: _this });
            }
        });
    };
    Tooltip.prototype.updateDiv = function (tooltipDiv, x, y) {
        tooltipDiv.style.left = x + 'px';
        tooltipDiv.style.top = y + 'px';
    };
    Tooltip.prototype.updateTemplateFn = function () {
        if (this.template) {
            try {
                if (document.querySelectorAll(this.template).length) {
                    this.templateFn = sf.base.compile(document.querySelector(this.template).innerHTML.trim());
                }
            }
            catch (e) {
                this.templateFn = sf.base.compile(this.template);
            }
        }
    };
    /** @private */
    Tooltip.prototype.fadeOut = function () {
        var _this = this;
        var tooltipElement = (this.isCanvas && !this.template) ? getElement(this.element.id + '_svg') :
            getElement(this.element.id);
        if (tooltipElement) {
            var tooltipGroup_1 = tooltipElement.firstChild;
            if (this.isCanvas && !this.template) {
                tooltipGroup_1 = document.getElementById(this.element.id + '_group') ? document.getElementById(this.element.id + '_group') :
                    tooltipGroup_1;
            }
            if (!tooltipGroup_1) {
                return null;
            }
            var opacity_1 = parseFloat(tooltipGroup_1.getAttribute('opacity'));
            opacity_1 = !sf.base.isNullOrUndefined(opacity_1) ? opacity_1 : 1;
            new sf.base.Animation({}).animate(tooltipGroup_1, {
                duration: 200,
                progress: function (args) {
                    //  tooltipGroup.removeAttribute('e-animate');
                    _this.progressAnimation(tooltipGroup_1, opacity_1, (args.timeStamp / args.duration));
                },
                end: function () {
                    _this.fadeOuted = true;
                    _this.endAnimation(tooltipGroup_1);
                }
            });
        }
    };
    Tooltip.prototype.progressAnimation = function (tooltipGroup, opacity, timeStamp) {
        tooltipGroup.style.animation = '';
        tooltipGroup.setAttribute('opacity', (opacity - timeStamp).toString());
    };
    /*
     * @hidden
     */
    Tooltip.prototype.endAnimation = function (tooltipGroup) {
        tooltipGroup.setAttribute('opacity', '0');
        if (this.template) {
            tooltipGroup.style.display = 'none';
        }
        this.trigger('animationComplete', { tooltip: this });
    };
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @private
     */
    Tooltip.prototype.getPersistData = function () {
        var keyEntity = [];
        return this.addOnPersist(keyEntity);
    };
    /**
     * Get component name
     *
     *  @private
     */
    Tooltip.prototype.getModuleName = function () {
        return 'tooltip';
    };
    /**
     * To destroy the accumulationcharts
     *
     * @private
     */
    Tooltip.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.element.classList.remove('e-tooltip');
    };
    /**
     * Called internally if any of the property value changed.
     *
     * @returns {void}
     * @private
     */
    Tooltip.prototype.onPropertyChanged = function (newProp, oldProp) {
        if (this.blazorTemplate) {
            sf.base.resetBlazorTemplate(this.element.id + 'parent_template' + '_blazorTemplate');
        }
        this.isFirst = false;
        this.render();
    };
    __decorate([
        sf.base.Property(false)
    ], Tooltip.prototype, "enable", void 0);
    __decorate([
        sf.base.Property(false)
    ], Tooltip.prototype, "shared", void 0);
    __decorate([
        sf.base.Property(true)
    ], Tooltip.prototype, "enableShadow", void 0);
    __decorate([
        sf.base.Property(null)
    ], Tooltip.prototype, "fill", void 0);
    __decorate([
        sf.base.Property('')
    ], Tooltip.prototype, "header", void 0);
    __decorate([
        sf.base.Property(0.75)
    ], Tooltip.prototype, "opacity", void 0);
    __decorate([
        sf.base.Complex({ size: '13px', fontWeight: 'Normal', color: null, fontStyle: 'Normal', fontFamily: 'Segoe UI' }, TextStyle)
    ], Tooltip.prototype, "textStyle", void 0);
    __decorate([
        sf.base.Property(null)
    ], Tooltip.prototype, "template", void 0);
    __decorate([
        sf.base.Property(true)
    ], Tooltip.prototype, "enableAnimation", void 0);
    __decorate([
        sf.base.Property(300)
    ], Tooltip.prototype, "duration", void 0);
    __decorate([
        sf.base.Property(false)
    ], Tooltip.prototype, "inverted", void 0);
    __decorate([
        sf.base.Property(false)
    ], Tooltip.prototype, "isNegative", void 0);
    __decorate([
        sf.base.Complex({ color: '#cccccc', width: 0.5 }, TooltipBorder)
    ], Tooltip.prototype, "border", void 0);
    __decorate([
        sf.base.Property([])
    ], Tooltip.prototype, "content", void 0);
    __decorate([
        sf.base.Property(10)
    ], Tooltip.prototype, "markerSize", void 0);
    __decorate([
        sf.base.Complex({ x: 0, y: 0 }, ToolLocation)
    ], Tooltip.prototype, "clipBounds", void 0);
    __decorate([
        sf.base.Property([])
    ], Tooltip.prototype, "palette", void 0);
    __decorate([
        sf.base.Property([])
    ], Tooltip.prototype, "shapes", void 0);
    __decorate([
        sf.base.Complex({ x: 0, y: 0 }, ToolLocation)
    ], Tooltip.prototype, "location", void 0);
    __decorate([
        sf.base.Property(0)
    ], Tooltip.prototype, "offset", void 0);
    __decorate([
        sf.base.Property(2)
    ], Tooltip.prototype, "rx", void 0);
    __decorate([
        sf.base.Property(2)
    ], Tooltip.prototype, "ry", void 0);
    __decorate([
        sf.base.Property(5)
    ], Tooltip.prototype, "marginX", void 0);
    __decorate([
        sf.base.Property(5)
    ], Tooltip.prototype, "marginY", void 0);
    __decorate([
        sf.base.Property(12)
    ], Tooltip.prototype, "arrowPadding", void 0);
    __decorate([
        sf.base.Property(null)
    ], Tooltip.prototype, "data", void 0);
    __decorate([
        sf.base.Property('Material')
    ], Tooltip.prototype, "theme", void 0);
    __decorate([
        sf.base.Complex({ x: 0, y: 0, width: 0, height: 0 }, AreaBounds)
    ], Tooltip.prototype, "areaBounds", void 0);
    __decorate([
        sf.base.Property(null)
    ], Tooltip.prototype, "availableSize", void 0);
    __decorate([
        sf.base.Property()
    ], Tooltip.prototype, "blazorTemplate", void 0);
    __decorate([
        sf.base.Property(false)
    ], Tooltip.prototype, "isCanvas", void 0);
    __decorate([
        sf.base.Property(false)
    ], Tooltip.prototype, "isTextWrap", void 0);
    __decorate([
        sf.base.Property(null)
    ], Tooltip.prototype, "tooltipPlacement", void 0);
    __decorate([
        sf.base.Property(null)
    ], Tooltip.prototype, "controlInstance", void 0);
    __decorate([
        sf.base.Event()
    ], Tooltip.prototype, "tooltipRender", void 0);
    __decorate([
        sf.base.Event()
    ], Tooltip.prototype, "loaded", void 0);
    __decorate([
        sf.base.Event()
    ], Tooltip.prototype, "animationComplete", void 0);
    Tooltip = __decorate([
        sf.base.NotifyPropertyChanges
    ], Tooltip);
    return Tooltip;
}(sf.base.Component));

/**
 * Chart component exported items
 */

/**
 * Chart components exported.
 */

exports.TextStyle = TextStyle;
exports.TooltipBorder = TooltipBorder;
exports.AreaBounds = AreaBounds;
exports.ToolLocation = ToolLocation;
exports.Tooltip = Tooltip;
exports.getTooltipThemeColor = getTooltipThemeColor;
exports.measureText = measureText;
exports.findDirection = findDirection;
exports.Size = Size;
exports.Rect = Rect;
exports.Side = Side;
exports.CustomizeOption = CustomizeOption;
exports.TextOption = TextOption;
exports.getElement = getElement;
exports.removeElement = removeElement;
exports.drawSymbol = drawSymbol;
exports.calculateShapes = calculateShapes;
exports.PathOption = PathOption;
exports.textElement = textElement;
exports.TooltipLocation = TooltipLocation;
exports.SvgRenderer = SvgRenderer;
exports.CanvasRenderer = CanvasRenderer;

return exports;

});

    sf.svgbase = sf.svgbase({});


/***/ })

/******/ });